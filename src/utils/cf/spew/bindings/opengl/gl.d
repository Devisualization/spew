/**
 * This is a set of OpenGL bindings.
 *
 * Generated by ./ogl_gen ....
 * Do not modify. Regenerate if changes are required.
 *
 * Macros:
 *    D_CODE = <pre><code class="D">$0</code></pre>
 */
module cf.spew.bindings.opengl.gl;
import std.traits : Unqual;

alias int64_t = long;
alias uint64_t = ulong;
alias int32_t = int;

///
alias GLboolean = bool;
///
alias GLbyte = byte;
///
alias GLubyte = ubyte;
///
alias GLshort = short;
///
alias GLushort = ushort;
///
alias GLhalf = ushort;
///
alias GLint = int;
///
alias GLuint = uint;
///
alias GLfixed = int;
///
alias GLint64 = long;
///
alias GLuint64 = ulong;
///
alias GLsizei = uint;
///
alias GLenum = uint;
///
alias GLintptr = ptrdiff_t;
///
alias GLsizeiptr = ptrdiff_t;
///
alias GLsync = void*;
///
alias GLbitfield = uint;
///
alias GLfloat = float;
///
alias GLclampf = float;
///
alias GLdouble = double;
///
alias GLclampd = double;
///
alias GLclampx = int;
///
alias GLchar = char;
///
alias GLuintptr = size_t;
///
alias GLvoid = void;
///
alias GLeglImageOES = void*;
///
alias GLcharARB = char;
///
alias GLhandleARB = uint;
///
alias GLhalfARB = ushort;
///
alias Glfixed = GLint;

///
struct _cl_context;
///
struct _cl_event;

///
alias GLDEBUGPROC = extern(System) void function(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const(GLchar)* message, void* userParam);
///
alias GLDEBUGPROCARB = extern(System) void function(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const(GLchar)* message, void* userParam);
///
alias GLDEBUGPROCKHR = extern(System) void function(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const(GLchar)* message, void* userParam);

///
alias GLintptrARB = ptrdiff_t;
///
alias GLsizeiptrARB = ptrdiff_t;
///
alias GLint64EXT = int64_t;
///
alias GLuint64EXT = uint64_t;

///
alias GLDEBUGPROCAMD = extern(System) void function(GLuint id, GLenum category, GLenum severity, GLsizei length, const(GLchar)* message, void* userParam);
///
alias GLhalfNV = ushort;
///
alias GLvdpauSurfaceNV = GLintptr;

///
struct GLUnurbs;
///
struct GLUquadric;
///
struct GLUtesselator;
///
alias _GLUfuncptr = extern(System) void function();

struct OpenGL_Version {
	OGLIntroducedIn from;
	alias from this;
}

struct OpenGL_Extension {
	string name;
	alias name this;
}

enum OGLIntroducedIn : ushort {
	Unknown,
	V1P0 = 10,
	V1P1 = 11,
	V1P2 = 12,
	V1P3 = 13,
	V1P4 = 14,
	V1P5 = 15,
	V2P0 = 25,
	V2P1 = 21,
	V2P2 = 22,
	V3P0 = 30,
	V3P1 = 31,
	V3P2 = 32,
	V3P3 = 33,
	V4P0 = 40,
	V4P1 = 41,
	V4P2 = 42,
	V4P3 = 43,
	V4P4 = 44,
	V4P5 = 45,
}

struct Bitmaskable {}
enum GL_1PASS_EXT = 0x80A1; ///
enum GL_1PASS_SGIS = 0x80A1; ///
enum GL_2D = 0x0600; ///
enum GL_2PASS_0_EXT = 0x80A2; ///
enum GL_2PASS_0_SGIS = 0x80A2; ///
enum GL_2PASS_1_EXT = 0x80A3; ///
enum GL_2PASS_1_SGIS = 0x80A3; ///
enum GL_2X_BIT_ATI = 0x00000001; ///
enum GL_2_BYTES = 0x1407; ///
enum GL_2_BYTES_NV = 0x1407; ///
enum GL_3D = 0x0601; ///
enum GL_3DC_XY_AMD = 0x87FA; ///
enum GL_3DC_X_AMD = 0x87F9; ///
enum GL_3D_COLOR = 0x0602; ///
enum GL_3D_COLOR_TEXTURE = 0x0603; ///
enum GL_3_BYTES = 0x1408; ///
enum GL_3_BYTES_NV = 0x1408; ///
enum GL_422_AVERAGE_EXT = 0x80CE; ///
enum GL_422_EXT = 0x80CC; ///
enum GL_422_REV_AVERAGE_EXT = 0x80CF; ///
enum GL_422_REV_EXT = 0x80CD; ///
enum GL_4D_COLOR_TEXTURE = 0x0604; ///
enum GL_4PASS_0_EXT = 0x80A4; ///
enum GL_4PASS_0_SGIS = 0x80A4; ///
enum GL_4PASS_1_EXT = 0x80A5; ///
enum GL_4PASS_1_SGIS = 0x80A5; ///
enum GL_4PASS_2_EXT = 0x80A6; ///
enum GL_4PASS_2_SGIS = 0x80A6; ///
enum GL_4PASS_3_EXT = 0x80A7; ///
enum GL_4PASS_3_SGIS = 0x80A7; ///
enum GL_4X_BIT_ATI = 0x00000002; ///
enum GL_4_BYTES = 0x1409; ///
enum GL_4_BYTES_NV = 0x1409; ///
enum GL_8X_BIT_ATI = 0x00000004; ///
enum GL_ABGR_EXT = 0x8000; ///
enum GL_ACCUM = 0x0100; ///
enum GL_ACCUM_ADJACENT_PAIRS_NV = 0x90AD; ///
enum GL_ACCUM_ALPHA_BITS = 0x0D5B; ///
enum GL_ACCUM_BLUE_BITS = 0x0D5A; ///
enum GL_ACCUM_BUFFER_BIT = 0x00000200; ///
enum GL_ACCUM_CLEAR_VALUE = 0x0B80; ///
enum GL_ACCUM_GREEN_BITS = 0x0D59; ///
enum GL_ACCUM_RED_BITS = 0x0D58; ///
enum GL_ACTIVE_ATOMIC_COUNTER_BUFFERS = 0x92D9; ///
enum GL_ACTIVE_ATTRIBUTES = 0x8B89; ///
enum GL_ACTIVE_ATTRIBUTE_MAX_LENGTH = 0x8B8A; ///
enum GL_ACTIVE_PROGRAM = 0x8259; ///
enum GL_ACTIVE_PROGRAM_EXT = 0x8B8D; ///
enum GL_ACTIVE_RESOURCES = 0x92F5; ///
enum GL_ACTIVE_STENCIL_FACE_EXT = 0x8911; ///
enum GL_ACTIVE_SUBROUTINES = 0x8DE5; ///
enum GL_ACTIVE_SUBROUTINE_MAX_LENGTH = 0x8E48; ///
enum GL_ACTIVE_SUBROUTINE_UNIFORMS = 0x8DE6; ///
enum GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS = 0x8E47; ///
enum GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH = 0x8E49; ///
enum GL_ACTIVE_TEXTURE = 0x84E0; ///
enum GL_ACTIVE_TEXTURE_ARB = 0x84E0; ///
enum GL_ACTIVE_UNIFORMS = 0x8B86; ///
enum GL_ACTIVE_UNIFORM_BLOCKS = 0x8A36; ///
enum GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH = 0x8A35; ///
enum GL_ACTIVE_UNIFORM_MAX_LENGTH = 0x8B87; ///
enum GL_ACTIVE_VARIABLES = 0x9305; ///
enum GL_ACTIVE_VARYINGS_NV = 0x8C81; ///
enum GL_ACTIVE_VARYING_MAX_LENGTH_NV = 0x8C82; ///
enum GL_ACTIVE_VERTEX_UNITS_ARB = 0x86A5; ///
enum GL_ADD = 0x0104; ///
enum GL_ADD_ATI = 0x8963; ///
enum GL_ADD_BLEND_IMG = 0x8C09; ///
enum GL_ADD_SIGNED = 0x8574; ///
enum GL_ADD_SIGNED_ARB = 0x8574; ///
enum GL_ADD_SIGNED_EXT = 0x8574; ///
enum GL_ADJACENT_PAIRS_NV = 0x90AE; ///
enum GL_AFFINE_2D_NV = 0x9092; ///
enum GL_AFFINE_3D_NV = 0x9094; ///
enum GL_ALIASED_LINE_WIDTH_RANGE = 0x846E; ///
enum GL_ALIASED_POINT_SIZE_RANGE = 0x846D; ///
enum GL_ALLOW_DRAW_FRG_HINT_PGI = 0x1A210; ///
enum GL_ALLOW_DRAW_MEM_HINT_PGI = 0x1A211; ///
enum GL_ALLOW_DRAW_OBJ_HINT_PGI = 0x1A20E; ///
enum GL_ALLOW_DRAW_WIN_HINT_PGI = 0x1A20F; ///
enum GL_ALL_ATTRIB_BITS = 0xFFFFFFFF; ///
enum GL_ALL_BARRIER_BITS = 0xFFFFFFFF; ///
enum GL_ALL_BARRIER_BITS_EXT = 0xFFFFFFFF; ///
enum GL_ALL_COMPLETED_NV = 0x84F2; ///
enum GL_ALL_SHADER_BITS = 0xFFFFFFFF; ///
enum GL_ALL_SHADER_BITS_EXT = 0xFFFFFFFF; ///
enum GL_ALL_STATIC_DATA_IBM = 0x103060; ///
enum GL_ALPHA = 0x1906; ///
enum GL_ALPHA12 = 0x803D; ///
enum GL_ALPHA12_EXT = 0x803D; ///
enum GL_ALPHA16 = 0x803E; ///
enum GL_ALPHA16F_ARB = 0x881C; ///
enum GL_ALPHA16F_EXT = 0x881C; ///
enum GL_ALPHA16I_EXT = 0x8D8A; ///
enum GL_ALPHA16UI_EXT = 0x8D78; ///
enum GL_ALPHA16_EXT = 0x803E; ///
enum GL_ALPHA16_SNORM = 0x9018; ///
enum GL_ALPHA32F_ARB = 0x8816; ///
enum GL_ALPHA32F_EXT = 0x8816; ///
enum GL_ALPHA32I_EXT = 0x8D84; ///
enum GL_ALPHA32UI_EXT = 0x8D72; ///
enum GL_ALPHA4 = 0x803B; ///
enum GL_ALPHA4_EXT = 0x803B; ///
enum GL_ALPHA8 = 0x803C; ///
enum GL_ALPHA8I_EXT = 0x8D90; ///
enum GL_ALPHA8UI_EXT = 0x8D7E; ///
enum GL_ALPHA8_EXT = 0x803C; ///
enum GL_ALPHA8_OES = 0x803C; ///
enum GL_ALPHA8_SNORM = 0x9014; ///
enum GL_ALPHA_BIAS = 0x0D1D; ///
enum GL_ALPHA_BITS = 0x0D55; ///
enum GL_ALPHA_FLOAT16_APPLE = 0x881C; ///
enum GL_ALPHA_FLOAT16_ATI = 0x881C; ///
enum GL_ALPHA_FLOAT32_APPLE = 0x8816; ///
enum GL_ALPHA_FLOAT32_ATI = 0x8816; ///
enum GL_ALPHA_INTEGER = 0x8D97; ///
enum GL_ALPHA_INTEGER_EXT = 0x8D97; ///
enum GL_ALPHA_MAX_CLAMP_INGR = 0x8567; ///
enum GL_ALPHA_MAX_SGIX = 0x8321; ///
enum GL_ALPHA_MIN_CLAMP_INGR = 0x8563; ///
enum GL_ALPHA_MIN_SGIX = 0x8320; ///
enum GL_ALPHA_REF_COMMAND_NV = 0x000F; ///
enum GL_ALPHA_SCALE = 0x0D1C; ///
enum GL_ALPHA_SNORM = 0x9010; ///
enum GL_ALPHA_TEST = 0x0BC0; ///
enum GL_ALPHA_TEST_FUNC = 0x0BC1; ///
enum GL_ALPHA_TEST_FUNC_QCOM = 0x0BC1; ///
enum GL_ALPHA_TEST_QCOM = 0x0BC0; ///
enum GL_ALPHA_TEST_REF = 0x0BC2; ///
enum GL_ALPHA_TEST_REF_QCOM = 0x0BC2; ///
enum GL_ALREADY_SIGNALED = 0x911A; ///
enum GL_ALREADY_SIGNALED_APPLE = 0x911A; ///
enum GL_ALWAYS = 0x0207; ///
enum GL_ALWAYS_FAST_HINT_PGI = 0x1A20C; ///
enum GL_ALWAYS_SOFT_HINT_PGI = 0x1A20D; ///
enum GL_AMBIENT = 0x1200; ///
enum GL_AMBIENT_AND_DIFFUSE = 0x1602; ///
enum GL_AND = 0x1501; ///
enum GL_AND_INVERTED = 0x1504; ///
enum GL_AND_REVERSE = 0x1502; ///
enum GL_ANY_SAMPLES_PASSED = 0x8C2F; ///
enum GL_ANY_SAMPLES_PASSED_CONSERVATIVE = 0x8D6A; ///
enum GL_ANY_SAMPLES_PASSED_CONSERVATIVE_EXT = 0x8D6A; ///
enum GL_ANY_SAMPLES_PASSED_EXT = 0x8C2F; ///
enum GL_ARC_TO_NV = 0xFE; ///
enum GL_ARRAY_BUFFER = 0x8892; ///
enum GL_ARRAY_BUFFER_ARB = 0x8892; ///
enum GL_ARRAY_BUFFER_BINDING = 0x8894; ///
enum GL_ARRAY_BUFFER_BINDING_ARB = 0x8894; ///
enum GL_ARRAY_ELEMENT_LOCK_COUNT_EXT = 0x81A9; ///
enum GL_ARRAY_ELEMENT_LOCK_FIRST_EXT = 0x81A8; ///
enum GL_ARRAY_OBJECT_BUFFER_ATI = 0x8766; ///
enum GL_ARRAY_OBJECT_OFFSET_ATI = 0x8767; ///
enum GL_ARRAY_SIZE = 0x92FB; ///
enum GL_ARRAY_STRIDE = 0x92FE; ///
enum GL_ASYNC_DRAW_PIXELS_SGIX = 0x835D; ///
enum GL_ASYNC_HISTOGRAM_SGIX = 0x832C; ///
enum GL_ASYNC_MARKER_SGIX = 0x8329; ///
enum GL_ASYNC_READ_PIXELS_SGIX = 0x835E; ///
enum GL_ASYNC_TEX_IMAGE_SGIX = 0x835C; ///
enum GL_ATC_RGBA_EXPLICIT_ALPHA_AMD = 0x8C93; ///
enum GL_ATC_RGBA_INTERPOLATED_ALPHA_AMD = 0x87EE; ///
enum GL_ATC_RGB_AMD = 0x8C92; ///
enum GL_ATOMIC_COUNTER_BARRIER_BIT = 0x00001000; ///
enum GL_ATOMIC_COUNTER_BARRIER_BIT_EXT = 0x00001000; ///
enum GL_ATOMIC_COUNTER_BUFFER = 0x92C0; ///
enum GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS = 0x92C5; ///
enum GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES = 0x92C6; ///
enum GL_ATOMIC_COUNTER_BUFFER_BINDING = 0x92C1; ///
enum GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE = 0x92C4; ///
enum GL_ATOMIC_COUNTER_BUFFER_INDEX = 0x9301; ///
enum GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER = 0x90ED; ///
enum GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER = 0x92CB; ///
enum GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER = 0x92CA; ///
enum GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER = 0x92C8; ///
enum GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER = 0x92C9; ///
enum GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER = 0x92C7; ///
enum GL_ATOMIC_COUNTER_BUFFER_SIZE = 0x92C3; ///
enum GL_ATOMIC_COUNTER_BUFFER_START = 0x92C2; ///
enum GL_ATTACHED_SHADERS = 0x8B85; ///
enum GL_ATTENUATION_EXT = 0x834D; ///
enum GL_ATTRIBUTE_ADDRESS_COMMAND_NV = 0x0009; ///
enum GL_ATTRIB_ARRAY_POINTER_NV = 0x8645; ///
enum GL_ATTRIB_ARRAY_SIZE_NV = 0x8623; ///
enum GL_ATTRIB_ARRAY_STRIDE_NV = 0x8624; ///
enum GL_ATTRIB_ARRAY_TYPE_NV = 0x8625; ///
enum GL_ATTRIB_STACK_DEPTH = 0x0BB0; ///
enum GL_AUTO_GENERATE_MIPMAP = 0x8295; ///
enum GL_AUTO_NORMAL = 0x0D80; ///
enum GL_AUX0 = 0x0409; ///
enum GL_AUX1 = 0x040A; ///
enum GL_AUX2 = 0x040B; ///
enum GL_AUX3 = 0x040C; ///
enum GL_AUX_BUFFERS = 0x0C00; ///
enum GL_AUX_DEPTH_STENCIL_APPLE = 0x8A14; ///
enum GL_AVERAGE_EXT = 0x8335; ///
enum GL_AVERAGE_HP = 0x8160; ///
enum GL_BACK = 0x0405; ///
enum GL_BACK_LEFT = 0x0402; ///
enum GL_BACK_NORMALS_HINT_PGI = 0x1A223; ///
enum GL_BACK_PRIMARY_COLOR_NV = 0x8C77; ///
enum GL_BACK_RIGHT = 0x0403; ///
enum GL_BACK_SECONDARY_COLOR_NV = 0x8C78; ///
enum GL_BEVEL_NV = 0x90A6; ///
enum GL_BGR = 0x80E0; ///
enum GL_BGRA = 0x80E1; ///
enum GL_BGRA8_EXT = 0x93A1; ///
enum GL_BGRA_EXT = 0x80E1; ///
enum GL_BGRA_IMG = 0x80E1; ///
enum GL_BGRA_INTEGER = 0x8D9B; ///
enum GL_BGRA_INTEGER_EXT = 0x8D9B; ///
enum GL_BGR_EXT = 0x80E0; ///
enum GL_BGR_INTEGER = 0x8D9A; ///
enum GL_BGR_INTEGER_EXT = 0x8D9A; ///
enum GL_BIAS_BIT_ATI = 0x00000008; ///
enum GL_BIAS_BY_NEGATIVE_ONE_HALF_NV = 0x8541; ///
enum GL_BINNING_CONTROL_HINT_QCOM = 0x8FB0; ///
enum GL_BINORMAL_ARRAY_EXT = 0x843A; ///
enum GL_BINORMAL_ARRAY_POINTER_EXT = 0x8443; ///
enum GL_BINORMAL_ARRAY_STRIDE_EXT = 0x8441; ///
enum GL_BINORMAL_ARRAY_TYPE_EXT = 0x8440; ///
enum GL_BITMAP = 0x1A00; ///
enum GL_BITMAP_TOKEN = 0x0704; ///
enum GL_BLEND = 0x0BE2; ///
enum GL_BLEND_ADVANCED_COHERENT_KHR = 0x9285; ///
enum GL_BLEND_ADVANCED_COHERENT_NV = 0x9285; ///
enum GL_BLEND_COLOR = 0x8005; ///
enum GL_BLEND_COLOR_COMMAND_NV = 0x000B; ///
enum GL_BLEND_COLOR_EXT = 0x8005; ///
enum GL_BLEND_DST = 0x0BE0; ///
enum GL_BLEND_DST_ALPHA = 0x80CA; ///
enum GL_BLEND_DST_ALPHA_EXT = 0x80CA; ///
enum GL_BLEND_DST_ALPHA_OES = 0x80CA; ///
enum GL_BLEND_DST_RGB = 0x80C8; ///
enum GL_BLEND_DST_RGB_EXT = 0x80C8; ///
enum GL_BLEND_DST_RGB_OES = 0x80C8; ///
enum GL_BLEND_EQUATION = 0x8009; ///
enum GL_BLEND_EQUATION_ALPHA = 0x883D; ///
enum GL_BLEND_EQUATION_ALPHA_EXT = 0x883D; ///
enum GL_BLEND_EQUATION_ALPHA_OES = 0x883D; ///
enum GL_BLEND_EQUATION_EXT = 0x8009; ///
enum GL_BLEND_EQUATION_OES = 0x8009; ///
enum GL_BLEND_EQUATION_RGB = 0x8009; ///
enum GL_BLEND_EQUATION_RGB_EXT = 0x8009; ///
enum GL_BLEND_EQUATION_RGB_OES = 0x8009; ///
enum GL_BLEND_OVERLAP_NV = 0x9281; ///
enum GL_BLEND_PREMULTIPLIED_SRC_NV = 0x9280; ///
enum GL_BLEND_SRC = 0x0BE1; ///
enum GL_BLEND_SRC_ALPHA = 0x80CB; ///
enum GL_BLEND_SRC_ALPHA_EXT = 0x80CB; ///
enum GL_BLEND_SRC_ALPHA_OES = 0x80CB; ///
enum GL_BLEND_SRC_RGB = 0x80C9; ///
enum GL_BLEND_SRC_RGB_EXT = 0x80C9; ///
enum GL_BLEND_SRC_RGB_OES = 0x80C9; ///
enum GL_BLOCK_INDEX = 0x92FD; ///
enum GL_BLUE = 0x1905; ///
enum GL_BLUE_BIAS = 0x0D1B; ///
enum GL_BLUE_BITS = 0x0D54; ///
enum GL_BLUE_BIT_ATI = 0x00000004; ///
enum GL_BLUE_INTEGER = 0x8D96; ///
enum GL_BLUE_INTEGER_EXT = 0x8D96; ///
enum GL_BLUE_MAX_CLAMP_INGR = 0x8566; ///
enum GL_BLUE_MIN_CLAMP_INGR = 0x8562; ///
enum GL_BLUE_NV = 0x1905; ///
enum GL_BLUE_SCALE = 0x0D1A; ///
enum GL_BOLD_BIT_NV = 0x01; ///
enum GL_BOOL = 0x8B56; ///
enum GL_BOOL_ARB = 0x8B56; ///
enum GL_BOOL_VEC2 = 0x8B57; ///
enum GL_BOOL_VEC2_ARB = 0x8B57; ///
enum GL_BOOL_VEC3 = 0x8B58; ///
enum GL_BOOL_VEC3_ARB = 0x8B58; ///
enum GL_BOOL_VEC4 = 0x8B59; ///
enum GL_BOOL_VEC4_ARB = 0x8B59; ///
enum GL_BOUNDING_BOX_NV = 0x908D; ///
enum GL_BOUNDING_BOX_OF_BOUNDING_BOXES_NV = 0x909C; ///
enum GL_BROWSER_DEFAULT_WEBGL = 0x9244; ///
enum GL_BUFFER = 0x82E0; ///
enum GL_BUFFER_ACCESS = 0x88BB; ///
enum GL_BUFFER_ACCESS_ARB = 0x88BB; ///
enum GL_BUFFER_ACCESS_FLAGS = 0x911F; ///
enum GL_BUFFER_ACCESS_OES = 0x88BB; ///
enum GL_BUFFER_BINDING = 0x9302; ///
enum GL_BUFFER_DATA_SIZE = 0x9303; ///
enum GL_BUFFER_FLUSHING_UNMAP_APPLE = 0x8A13; ///
enum GL_BUFFER_GPU_ADDRESS_NV = 0x8F1D; ///
enum GL_BUFFER_IMMUTABLE_STORAGE = 0x821F; ///
enum GL_BUFFER_IMMUTABLE_STORAGE_EXT = 0x821F; ///
enum GL_BUFFER_KHR = 0x82E0; ///
enum GL_BUFFER_MAPPED = 0x88BC; ///
enum GL_BUFFER_MAPPED_ARB = 0x88BC; ///
enum GL_BUFFER_MAPPED_OES = 0x88BC; ///
enum GL_BUFFER_MAP_LENGTH = 0x9120; ///
enum GL_BUFFER_MAP_OFFSET = 0x9121; ///
enum GL_BUFFER_MAP_POINTER = 0x88BD; ///
enum GL_BUFFER_MAP_POINTER_ARB = 0x88BD; ///
enum GL_BUFFER_MAP_POINTER_OES = 0x88BD; ///
enum GL_BUFFER_OBJECT_APPLE = 0x85B3; ///
enum GL_BUFFER_OBJECT_EXT = 0x9151; ///
enum GL_BUFFER_SERIALIZED_MODIFY_APPLE = 0x8A12; ///
enum GL_BUFFER_SIZE = 0x8764; ///
enum GL_BUFFER_SIZE_ARB = 0x8764; ///
enum GL_BUFFER_STORAGE_FLAGS = 0x8220; ///
enum GL_BUFFER_STORAGE_FLAGS_EXT = 0x8220; ///
enum GL_BUFFER_UPDATE_BARRIER_BIT = 0x00000200; ///
enum GL_BUFFER_UPDATE_BARRIER_BIT_EXT = 0x00000200; ///
enum GL_BUFFER_USAGE = 0x8765; ///
enum GL_BUFFER_USAGE_ARB = 0x8765; ///
enum GL_BUFFER_VARIABLE = 0x92E5; ///
enum GL_BUMP_ENVMAP_ATI = 0x877B; ///
enum GL_BUMP_NUM_TEX_UNITS_ATI = 0x8777; ///
enum GL_BUMP_ROT_MATRIX_ATI = 0x8775; ///
enum GL_BUMP_ROT_MATRIX_SIZE_ATI = 0x8776; ///
enum GL_BUMP_TARGET_ATI = 0x877C; ///
enum GL_BUMP_TEX_UNITS_ATI = 0x8778; ///
enum GL_BYTE = 0x1400; ///
enum GL_C3F_V3F = 0x2A24; ///
enum GL_C4F_N3F_V3F = 0x2A26; ///
enum GL_C4UB_V2F = 0x2A22; ///
enum GL_C4UB_V3F = 0x2A23; ///
enum GL_CALLIGRAPHIC_FRAGMENT_SGIX = 0x8183; ///
enum GL_CAVEAT_SUPPORT = 0x82B8; ///
enum GL_CCW = 0x0901; ///
enum GL_CIRCULAR_CCW_ARC_TO_NV = 0xF8; ///
enum GL_CIRCULAR_CW_ARC_TO_NV = 0xFA; ///
enum GL_CIRCULAR_TANGENT_ARC_TO_NV = 0xFC; ///
enum GL_CLAMP = 0x2900; ///
enum GL_CLAMP_FRAGMENT_COLOR = 0x891B; ///
enum GL_CLAMP_FRAGMENT_COLOR_ARB = 0x891B; ///
enum GL_CLAMP_READ_COLOR = 0x891C; ///
enum GL_CLAMP_READ_COLOR_ARB = 0x891C; ///
enum GL_CLAMP_TO_BORDER = 0x812D; ///
enum GL_CLAMP_TO_BORDER_ARB = 0x812D; ///
enum GL_CLAMP_TO_BORDER_EXT = 0x812D; ///
enum GL_CLAMP_TO_BORDER_NV = 0x812D; ///
enum GL_CLAMP_TO_BORDER_OES = 0x812D; ///
enum GL_CLAMP_TO_BORDER_SGIS = 0x812D; ///
enum GL_CLAMP_TO_EDGE = 0x812F; ///
enum GL_CLAMP_TO_EDGE_SGIS = 0x812F; ///
enum GL_CLAMP_VERTEX_COLOR = 0x891A; ///
enum GL_CLAMP_VERTEX_COLOR_ARB = 0x891A; ///
enum GL_CLEAR = 0x1500; ///
enum GL_CLEAR_BUFFER = 0x82B4; ///
enum GL_CLEAR_TEXTURE = 0x9365; ///
enum GL_CLIENT_ACTIVE_TEXTURE = 0x84E1; ///
enum GL_CLIENT_ACTIVE_TEXTURE_ARB = 0x84E1; ///
enum GL_CLIENT_ALL_ATTRIB_BITS = 0xFFFFFFFF; ///
enum GL_CLIENT_ATTRIB_STACK_DEPTH = 0x0BB1; ///
enum GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT = 0x00004000; ///
enum GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT_EXT = 0x00004000; ///
enum GL_CLIENT_PIXEL_STORE_BIT = 0x00000001; ///
enum GL_CLIENT_STORAGE_BIT = 0x0200; ///
enum GL_CLIENT_STORAGE_BIT_EXT = 0x0200; ///
enum GL_CLIENT_VERTEX_ARRAY_BIT = 0x00000002; ///
enum GL_CLIPPING_INPUT_PRIMITIVES_ARB = 0x82F6; ///
enum GL_CLIPPING_OUTPUT_PRIMITIVES_ARB = 0x82F7; ///
enum GL_CLIP_DEPTH_MODE = 0x935D; ///
enum GL_CLIP_DISTANCE0 = 0x3000; ///
enum GL_CLIP_DISTANCE0_APPLE = 0x3000; ///
enum GL_CLIP_DISTANCE0_EXT = 0x3000; ///
enum GL_CLIP_DISTANCE1 = 0x3001; ///
enum GL_CLIP_DISTANCE1_APPLE = 0x3001; ///
enum GL_CLIP_DISTANCE1_EXT = 0x3001; ///
enum GL_CLIP_DISTANCE2 = 0x3002; ///
enum GL_CLIP_DISTANCE2_APPLE = 0x3002; ///
enum GL_CLIP_DISTANCE2_EXT = 0x3002; ///
enum GL_CLIP_DISTANCE3 = 0x3003; ///
enum GL_CLIP_DISTANCE3_APPLE = 0x3003; ///
enum GL_CLIP_DISTANCE3_EXT = 0x3003; ///
enum GL_CLIP_DISTANCE4 = 0x3004; ///
enum GL_CLIP_DISTANCE4_APPLE = 0x3004; ///
enum GL_CLIP_DISTANCE4_EXT = 0x3004; ///
enum GL_CLIP_DISTANCE5 = 0x3005; ///
enum GL_CLIP_DISTANCE5_APPLE = 0x3005; ///
enum GL_CLIP_DISTANCE5_EXT = 0x3005; ///
enum GL_CLIP_DISTANCE6 = 0x3006; ///
enum GL_CLIP_DISTANCE6_APPLE = 0x3006; ///
enum GL_CLIP_DISTANCE6_EXT = 0x3006; ///
enum GL_CLIP_DISTANCE7 = 0x3007; ///
enum GL_CLIP_DISTANCE7_APPLE = 0x3007; ///
enum GL_CLIP_DISTANCE7_EXT = 0x3007; ///
enum GL_CLIP_DISTANCE_NV = 0x8C7A; ///
enum GL_CLIP_FAR_HINT_PGI = 0x1A221; ///
enum GL_CLIP_NEAR_HINT_PGI = 0x1A220; ///
enum GL_CLIP_ORIGIN = 0x935C; ///
enum GL_CLIP_PLANE0 = 0x3000; ///
enum GL_CLIP_PLANE0_IMG = 0x3000; ///
enum GL_CLIP_PLANE1 = 0x3001; ///
enum GL_CLIP_PLANE1_IMG = 0x3001; ///
enum GL_CLIP_PLANE2 = 0x3002; ///
enum GL_CLIP_PLANE2_IMG = 0x3002; ///
enum GL_CLIP_PLANE3 = 0x3003; ///
enum GL_CLIP_PLANE3_IMG = 0x3003; ///
enum GL_CLIP_PLANE4 = 0x3004; ///
enum GL_CLIP_PLANE4_IMG = 0x3004; ///
enum GL_CLIP_PLANE5 = 0x3005; ///
enum GL_CLIP_PLANE5_IMG = 0x3005; ///
enum GL_CLIP_VOLUME_CLIPPING_HINT_EXT = 0x80F0; ///
enum GL_CLOSE_PATH_NV = 0x00; ///
enum GL_CMYKA_EXT = 0x800D; ///
enum GL_CMYK_EXT = 0x800C; ///
enum GL_CND0_ATI = 0x896B; ///
enum GL_CND_ATI = 0x896A; ///
enum GL_COEFF = 0x0A00; ///
enum GL_COLOR = 0x1800; ///
enum GL_COLOR3_BIT_PGI = 0x00010000; ///
enum GL_COLOR4_BIT_PGI = 0x00020000; ///
enum GL_COLORBURN = 0x929A; ///
enum GL_COLORBURN_KHR = 0x929A; ///
enum GL_COLORBURN_NV = 0x929A; ///
enum GL_COLORDODGE = 0x9299; ///
enum GL_COLORDODGE_KHR = 0x9299; ///
enum GL_COLORDODGE_NV = 0x9299; ///
enum GL_COLOR_ALPHA_PAIRING_ATI = 0x8975; ///
enum GL_COLOR_ARRAY = 0x8076; ///
enum GL_COLOR_ARRAY_ADDRESS_NV = 0x8F23; ///
enum GL_COLOR_ARRAY_BUFFER_BINDING = 0x8898; ///
enum GL_COLOR_ARRAY_BUFFER_BINDING_ARB = 0x8898; ///
enum GL_COLOR_ARRAY_COUNT_EXT = 0x8084; ///
enum GL_COLOR_ARRAY_EXT = 0x8076; ///
enum GL_COLOR_ARRAY_LENGTH_NV = 0x8F2D; ///
enum GL_COLOR_ARRAY_LIST_IBM = 0x103072; ///
enum GL_COLOR_ARRAY_LIST_STRIDE_IBM = 0x103082; ///
enum GL_COLOR_ARRAY_PARALLEL_POINTERS_INTEL = 0x83F7; ///
enum GL_COLOR_ARRAY_POINTER = 0x8090; ///
enum GL_COLOR_ARRAY_POINTER_EXT = 0x8090; ///
enum GL_COLOR_ARRAY_SIZE = 0x8081; ///
enum GL_COLOR_ARRAY_SIZE_EXT = 0x8081; ///
enum GL_COLOR_ARRAY_STRIDE = 0x8083; ///
enum GL_COLOR_ARRAY_STRIDE_EXT = 0x8083; ///
enum GL_COLOR_ARRAY_TYPE = 0x8082; ///
enum GL_COLOR_ARRAY_TYPE_EXT = 0x8082; ///
enum GL_COLOR_ATTACHMENT0 = 0x8CE0; ///
enum GL_COLOR_ATTACHMENT0_EXT = 0x8CE0; ///
enum GL_COLOR_ATTACHMENT0_NV = 0x8CE0; ///
enum GL_COLOR_ATTACHMENT0_OES = 0x8CE0; ///
enum GL_COLOR_ATTACHMENT1 = 0x8CE1; ///
enum GL_COLOR_ATTACHMENT10 = 0x8CEA; ///
enum GL_COLOR_ATTACHMENT10_EXT = 0x8CEA; ///
enum GL_COLOR_ATTACHMENT10_NV = 0x8CEA; ///
enum GL_COLOR_ATTACHMENT11 = 0x8CEB; ///
enum GL_COLOR_ATTACHMENT11_EXT = 0x8CEB; ///
enum GL_COLOR_ATTACHMENT11_NV = 0x8CEB; ///
enum GL_COLOR_ATTACHMENT12 = 0x8CEC; ///
enum GL_COLOR_ATTACHMENT12_EXT = 0x8CEC; ///
enum GL_COLOR_ATTACHMENT12_NV = 0x8CEC; ///
enum GL_COLOR_ATTACHMENT13 = 0x8CED; ///
enum GL_COLOR_ATTACHMENT13_EXT = 0x8CED; ///
enum GL_COLOR_ATTACHMENT13_NV = 0x8CED; ///
enum GL_COLOR_ATTACHMENT14 = 0x8CEE; ///
enum GL_COLOR_ATTACHMENT14_EXT = 0x8CEE; ///
enum GL_COLOR_ATTACHMENT14_NV = 0x8CEE; ///
enum GL_COLOR_ATTACHMENT15 = 0x8CEF; ///
enum GL_COLOR_ATTACHMENT15_EXT = 0x8CEF; ///
enum GL_COLOR_ATTACHMENT15_NV = 0x8CEF; ///
enum GL_COLOR_ATTACHMENT16 = 0x8CF0; ///
enum GL_COLOR_ATTACHMENT17 = 0x8CF1; ///
enum GL_COLOR_ATTACHMENT18 = 0x8CF2; ///
enum GL_COLOR_ATTACHMENT19 = 0x8CF3; ///
enum GL_COLOR_ATTACHMENT1_EXT = 0x8CE1; ///
enum GL_COLOR_ATTACHMENT1_NV = 0x8CE1; ///
enum GL_COLOR_ATTACHMENT2 = 0x8CE2; ///
enum GL_COLOR_ATTACHMENT20 = 0x8CF4; ///
enum GL_COLOR_ATTACHMENT21 = 0x8CF5; ///
enum GL_COLOR_ATTACHMENT22 = 0x8CF6; ///
enum GL_COLOR_ATTACHMENT23 = 0x8CF7; ///
enum GL_COLOR_ATTACHMENT24 = 0x8CF8; ///
enum GL_COLOR_ATTACHMENT25 = 0x8CF9; ///
enum GL_COLOR_ATTACHMENT26 = 0x8CFA; ///
enum GL_COLOR_ATTACHMENT27 = 0x8CFB; ///
enum GL_COLOR_ATTACHMENT28 = 0x8CFC; ///
enum GL_COLOR_ATTACHMENT29 = 0x8CFD; ///
enum GL_COLOR_ATTACHMENT2_EXT = 0x8CE2; ///
enum GL_COLOR_ATTACHMENT2_NV = 0x8CE2; ///
enum GL_COLOR_ATTACHMENT3 = 0x8CE3; ///
enum GL_COLOR_ATTACHMENT30 = 0x8CFE; ///
enum GL_COLOR_ATTACHMENT31 = 0x8CFF; ///
enum GL_COLOR_ATTACHMENT3_EXT = 0x8CE3; ///
enum GL_COLOR_ATTACHMENT3_NV = 0x8CE3; ///
enum GL_COLOR_ATTACHMENT4 = 0x8CE4; ///
enum GL_COLOR_ATTACHMENT4_EXT = 0x8CE4; ///
enum GL_COLOR_ATTACHMENT4_NV = 0x8CE4; ///
enum GL_COLOR_ATTACHMENT5 = 0x8CE5; ///
enum GL_COLOR_ATTACHMENT5_EXT = 0x8CE5; ///
enum GL_COLOR_ATTACHMENT5_NV = 0x8CE5; ///
enum GL_COLOR_ATTACHMENT6 = 0x8CE6; ///
enum GL_COLOR_ATTACHMENT6_EXT = 0x8CE6; ///
enum GL_COLOR_ATTACHMENT6_NV = 0x8CE6; ///
enum GL_COLOR_ATTACHMENT7 = 0x8CE7; ///
enum GL_COLOR_ATTACHMENT7_EXT = 0x8CE7; ///
enum GL_COLOR_ATTACHMENT7_NV = 0x8CE7; ///
enum GL_COLOR_ATTACHMENT8 = 0x8CE8; ///
enum GL_COLOR_ATTACHMENT8_EXT = 0x8CE8; ///
enum GL_COLOR_ATTACHMENT8_NV = 0x8CE8; ///
enum GL_COLOR_ATTACHMENT9 = 0x8CE9; ///
enum GL_COLOR_ATTACHMENT9_EXT = 0x8CE9; ///
enum GL_COLOR_ATTACHMENT9_NV = 0x8CE9; ///
enum GL_COLOR_ATTACHMENT_EXT = 0x90F0; ///
enum GL_COLOR_BUFFER_BIT = 0x00004000; ///
enum GL_COLOR_BUFFER_BIT0_QCOM = 0x00000001; ///
enum GL_COLOR_BUFFER_BIT1_QCOM = 0x00000002; ///
enum GL_COLOR_BUFFER_BIT2_QCOM = 0x00000004; ///
enum GL_COLOR_BUFFER_BIT3_QCOM = 0x00000008; ///
enum GL_COLOR_BUFFER_BIT4_QCOM = 0x00000010; ///
enum GL_COLOR_BUFFER_BIT5_QCOM = 0x00000020; ///
enum GL_COLOR_BUFFER_BIT6_QCOM = 0x00000040; ///
enum GL_COLOR_BUFFER_BIT7_QCOM = 0x00000080; ///
enum GL_COLOR_CLEAR_UNCLAMPED_VALUE_ATI = 0x8835; ///
enum GL_COLOR_CLEAR_VALUE = 0x0C22; ///
enum GL_COLOR_COMPONENTS = 0x8283; ///
enum GL_COLOR_ENCODING = 0x8296; ///
enum GL_COLOR_EXT = 0x1800; ///
enum GL_COLOR_FLOAT_APPLE = 0x8A0F; ///
enum GL_COLOR_INDEX = 0x1900; ///
enum GL_COLOR_INDEX12_EXT = 0x80E6; ///
enum GL_COLOR_INDEX16_EXT = 0x80E7; ///
enum GL_COLOR_INDEX1_EXT = 0x80E2; ///
enum GL_COLOR_INDEX2_EXT = 0x80E3; ///
enum GL_COLOR_INDEX4_EXT = 0x80E4; ///
enum GL_COLOR_INDEX8_EXT = 0x80E5; ///
enum GL_COLOR_INDEXES = 0x1603; ///
enum GL_COLOR_LOGIC_OP = 0x0BF2; ///
enum GL_COLOR_MATERIAL = 0x0B57; ///
enum GL_COLOR_MATERIAL_FACE = 0x0B55; ///
enum GL_COLOR_MATERIAL_PARAMETER = 0x0B56; ///
enum GL_COLOR_MATRIX = 0x80B1; ///
enum GL_COLOR_MATRIX_SGI = 0x80B1; ///
enum GL_COLOR_MATRIX_STACK_DEPTH = 0x80B2; ///
enum GL_COLOR_MATRIX_STACK_DEPTH_SGI = 0x80B2; ///
enum GL_COLOR_RENDERABLE = 0x8286; ///
enum GL_COLOR_SAMPLES_NV = 0x8E20; ///
enum GL_COLOR_SUM = 0x8458; ///
enum GL_COLOR_SUM_ARB = 0x8458; ///
enum GL_COLOR_SUM_CLAMP_NV = 0x854F; ///
enum GL_COLOR_SUM_EXT = 0x8458; ///
enum GL_COLOR_TABLE = 0x80D0; ///
enum GL_COLOR_TABLE_ALPHA_SIZE = 0x80DD; ///
enum GL_COLOR_TABLE_ALPHA_SIZE_SGI = 0x80DD; ///
enum GL_COLOR_TABLE_BIAS = 0x80D7; ///
enum GL_COLOR_TABLE_BIAS_SGI = 0x80D7; ///
enum GL_COLOR_TABLE_BLUE_SIZE = 0x80DC; ///
enum GL_COLOR_TABLE_BLUE_SIZE_SGI = 0x80DC; ///
enum GL_COLOR_TABLE_FORMAT = 0x80D8; ///
enum GL_COLOR_TABLE_FORMAT_SGI = 0x80D8; ///
enum GL_COLOR_TABLE_GREEN_SIZE = 0x80DB; ///
enum GL_COLOR_TABLE_GREEN_SIZE_SGI = 0x80DB; ///
enum GL_COLOR_TABLE_INTENSITY_SIZE = 0x80DF; ///
enum GL_COLOR_TABLE_INTENSITY_SIZE_SGI = 0x80DF; ///
enum GL_COLOR_TABLE_LUMINANCE_SIZE = 0x80DE; ///
enum GL_COLOR_TABLE_LUMINANCE_SIZE_SGI = 0x80DE; ///
enum GL_COLOR_TABLE_RED_SIZE = 0x80DA; ///
enum GL_COLOR_TABLE_RED_SIZE_SGI = 0x80DA; ///
enum GL_COLOR_TABLE_SCALE = 0x80D6; ///
enum GL_COLOR_TABLE_SCALE_SGI = 0x80D6; ///
enum GL_COLOR_TABLE_SGI = 0x80D0; ///
enum GL_COLOR_TABLE_WIDTH = 0x80D9; ///
enum GL_COLOR_TABLE_WIDTH_SGI = 0x80D9; ///
enum GL_COLOR_WRITEMASK = 0x0C23; ///
enum GL_COMBINE = 0x8570; ///
enum GL_COMBINE4_NV = 0x8503; ///
enum GL_COMBINER0_NV = 0x8550; ///
enum GL_COMBINER1_NV = 0x8551; ///
enum GL_COMBINER2_NV = 0x8552; ///
enum GL_COMBINER3_NV = 0x8553; ///
enum GL_COMBINER4_NV = 0x8554; ///
enum GL_COMBINER5_NV = 0x8555; ///
enum GL_COMBINER6_NV = 0x8556; ///
enum GL_COMBINER7_NV = 0x8557; ///
enum GL_COMBINER_AB_DOT_PRODUCT_NV = 0x8545; ///
enum GL_COMBINER_AB_OUTPUT_NV = 0x854A; ///
enum GL_COMBINER_BIAS_NV = 0x8549; ///
enum GL_COMBINER_CD_DOT_PRODUCT_NV = 0x8546; ///
enum GL_COMBINER_CD_OUTPUT_NV = 0x854B; ///
enum GL_COMBINER_COMPONENT_USAGE_NV = 0x8544; ///
enum GL_COMBINER_INPUT_NV = 0x8542; ///
enum GL_COMBINER_MAPPING_NV = 0x8543; ///
enum GL_COMBINER_MUX_SUM_NV = 0x8547; ///
enum GL_COMBINER_SCALE_NV = 0x8548; ///
enum GL_COMBINER_SUM_OUTPUT_NV = 0x854C; ///
enum GL_COMBINE_ALPHA = 0x8572; ///
enum GL_COMBINE_ALPHA_ARB = 0x8572; ///
enum GL_COMBINE_ALPHA_EXT = 0x8572; ///
enum GL_COMBINE_ARB = 0x8570; ///
enum GL_COMBINE_EXT = 0x8570; ///
enum GL_COMBINE_RGB = 0x8571; ///
enum GL_COMBINE_RGB_ARB = 0x8571; ///
enum GL_COMBINE_RGB_EXT = 0x8571; ///
enum GL_COMMAND_BARRIER_BIT = 0x00000040; ///
enum GL_COMMAND_BARRIER_BIT_EXT = 0x00000040; ///
enum GL_COMPARE_REF_DEPTH_TO_TEXTURE_EXT = 0x884E; ///
enum GL_COMPARE_REF_TO_TEXTURE = 0x884E; ///
enum GL_COMPARE_REF_TO_TEXTURE_EXT = 0x884E; ///
enum GL_COMPARE_R_TO_TEXTURE = 0x884E; ///
enum GL_COMPARE_R_TO_TEXTURE_ARB = 0x884E; ///
enum GL_COMPATIBLE_SUBROUTINES = 0x8E4B; ///
enum GL_COMPILE = 0x1300; ///
enum GL_COMPILE_AND_EXECUTE = 0x1301; ///
enum GL_COMPILE_STATUS = 0x8B81; ///
enum GL_COMPLETION_STATUS_ARB = 0x91B1; ///
enum GL_COMPRESSED_ALPHA = 0x84E9; ///
enum GL_COMPRESSED_ALPHA_ARB = 0x84E9; ///
enum GL_COMPRESSED_INTENSITY = 0x84EC; ///
enum GL_COMPRESSED_INTENSITY_ARB = 0x84EC; ///
enum GL_COMPRESSED_LUMINANCE = 0x84EA; ///
enum GL_COMPRESSED_LUMINANCE_ALPHA = 0x84EB; ///
enum GL_COMPRESSED_LUMINANCE_ALPHA_3DC_ATI = 0x8837; ///
enum GL_COMPRESSED_LUMINANCE_ALPHA_ARB = 0x84EB; ///
enum GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT = 0x8C72; ///
enum GL_COMPRESSED_LUMINANCE_ARB = 0x84EA; ///
enum GL_COMPRESSED_LUMINANCE_LATC1_EXT = 0x8C70; ///
enum GL_COMPRESSED_R11_EAC = 0x9270; ///
enum GL_COMPRESSED_R11_EAC_OES = 0x9270; ///
enum GL_COMPRESSED_RED = 0x8225; ///
enum GL_COMPRESSED_RED_GREEN_RGTC2_EXT = 0x8DBD; ///
enum GL_COMPRESSED_RED_RGTC1 = 0x8DBB; ///
enum GL_COMPRESSED_RED_RGTC1_EXT = 0x8DBB; ///
enum GL_COMPRESSED_RG = 0x8226; ///
enum GL_COMPRESSED_RG11_EAC = 0x9272; ///
enum GL_COMPRESSED_RG11_EAC_OES = 0x9272; ///
enum GL_COMPRESSED_RGB = 0x84ED; ///
enum GL_COMPRESSED_RGB8_ETC2 = 0x9274; ///
enum GL_COMPRESSED_RGB8_ETC2_OES = 0x9274; ///
enum GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 0x9276; ///
enum GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2_OES = 0x9276; ///
enum GL_COMPRESSED_RGBA = 0x84EE; ///
enum GL_COMPRESSED_RGBA8_ETC2_EAC = 0x9278; ///
enum GL_COMPRESSED_RGBA8_ETC2_EAC_OES = 0x9278; ///
enum GL_COMPRESSED_RGBA_ARB = 0x84EE; ///
enum GL_COMPRESSED_RGBA_ASTC_10x10 = 0x93BB; ///
enum GL_COMPRESSED_RGBA_ASTC_10x10_KHR = 0x93BB; ///
enum GL_COMPRESSED_RGBA_ASTC_10x5 = 0x93B8; ///
enum GL_COMPRESSED_RGBA_ASTC_10x5_KHR = 0x93B8; ///
enum GL_COMPRESSED_RGBA_ASTC_10x6 = 0x93B9; ///
enum GL_COMPRESSED_RGBA_ASTC_10x6_KHR = 0x93B9; ///
enum GL_COMPRESSED_RGBA_ASTC_10x8 = 0x93BA; ///
enum GL_COMPRESSED_RGBA_ASTC_10x8_KHR = 0x93BA; ///
enum GL_COMPRESSED_RGBA_ASTC_12x10 = 0x93BC; ///
enum GL_COMPRESSED_RGBA_ASTC_12x10_KHR = 0x93BC; ///
enum GL_COMPRESSED_RGBA_ASTC_12x12 = 0x93BD; ///
enum GL_COMPRESSED_RGBA_ASTC_12x12_KHR = 0x93BD; ///
enum GL_COMPRESSED_RGBA_ASTC_3x3x3_OES = 0x93C0; ///
enum GL_COMPRESSED_RGBA_ASTC_4x3x3_OES = 0x93C1; ///
enum GL_COMPRESSED_RGBA_ASTC_4x4 = 0x93B0; ///
enum GL_COMPRESSED_RGBA_ASTC_4x4_KHR = 0x93B0; ///
enum GL_COMPRESSED_RGBA_ASTC_4x4x3_OES = 0x93C2; ///
enum GL_COMPRESSED_RGBA_ASTC_4x4x4_OES = 0x93C3; ///
enum GL_COMPRESSED_RGBA_ASTC_5x4 = 0x93B1; ///
enum GL_COMPRESSED_RGBA_ASTC_5x4_KHR = 0x93B1; ///
enum GL_COMPRESSED_RGBA_ASTC_5x4x4_OES = 0x93C4; ///
enum GL_COMPRESSED_RGBA_ASTC_5x5 = 0x93B2; ///
enum GL_COMPRESSED_RGBA_ASTC_5x5_KHR = 0x93B2; ///
enum GL_COMPRESSED_RGBA_ASTC_5x5x4_OES = 0x93C5; ///
enum GL_COMPRESSED_RGBA_ASTC_5x5x5_OES = 0x93C6; ///
enum GL_COMPRESSED_RGBA_ASTC_6x5 = 0x93B3; ///
enum GL_COMPRESSED_RGBA_ASTC_6x5_KHR = 0x93B3; ///
enum GL_COMPRESSED_RGBA_ASTC_6x5x5_OES = 0x93C7; ///
enum GL_COMPRESSED_RGBA_ASTC_6x6 = 0x93B4; ///
enum GL_COMPRESSED_RGBA_ASTC_6x6_KHR = 0x93B4; ///
enum GL_COMPRESSED_RGBA_ASTC_6x6x5_OES = 0x93C8; ///
enum GL_COMPRESSED_RGBA_ASTC_6x6x6_OES = 0x93C9; ///
enum GL_COMPRESSED_RGBA_ASTC_8x5 = 0x93B5; ///
enum GL_COMPRESSED_RGBA_ASTC_8x5_KHR = 0x93B5; ///
enum GL_COMPRESSED_RGBA_ASTC_8x6 = 0x93B6; ///
enum GL_COMPRESSED_RGBA_ASTC_8x6_KHR = 0x93B6; ///
enum GL_COMPRESSED_RGBA_ASTC_8x8 = 0x93B7; ///
enum GL_COMPRESSED_RGBA_ASTC_8x8_KHR = 0x93B7; ///
enum GL_COMPRESSED_RGBA_BPTC_UNORM = 0x8E8C; ///
enum GL_COMPRESSED_RGBA_BPTC_UNORM_ARB = 0x8E8C; ///
enum GL_COMPRESSED_RGBA_FXT1_3DFX = 0x86B1; ///
enum GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 0x8C03; ///
enum GL_COMPRESSED_RGBA_PVRTC_2BPPV2_IMG = 0x9137; ///
enum GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x8C02; ///
enum GL_COMPRESSED_RGBA_PVRTC_4BPPV2_IMG = 0x9138; ///
enum GL_COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x83F1; ///
enum GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE = 0x83F2; ///
enum GL_COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2; ///
enum GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE = 0x83F3; ///
enum GL_COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3; ///
enum GL_COMPRESSED_RGB_ARB = 0x84ED; ///
enum GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT = 0x8E8E; ///
enum GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB = 0x8E8E; ///
enum GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT = 0x8E8F; ///
enum GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB = 0x8E8F; ///
enum GL_COMPRESSED_RGB_FXT1_3DFX = 0x86B0; ///
enum GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 0x8C01; ///
enum GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 0x8C00; ///
enum GL_COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0; ///
enum GL_COMPRESSED_RG_RGTC2 = 0x8DBD; ///
enum GL_COMPRESSED_SIGNED_LUMINANCE_ALPHA_LATC2_EXT = 0x8C73; ///
enum GL_COMPRESSED_SIGNED_LUMINANCE_LATC1_EXT = 0x8C71; ///
enum GL_COMPRESSED_SIGNED_R11_EAC = 0x9271; ///
enum GL_COMPRESSED_SIGNED_R11_EAC_OES = 0x9271; ///
enum GL_COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT = 0x8DBE; ///
enum GL_COMPRESSED_SIGNED_RED_RGTC1 = 0x8DBC; ///
enum GL_COMPRESSED_SIGNED_RED_RGTC1_EXT = 0x8DBC; ///
enum GL_COMPRESSED_SIGNED_RG11_EAC = 0x9273; ///
enum GL_COMPRESSED_SIGNED_RG11_EAC_OES = 0x9273; ///
enum GL_COMPRESSED_SIGNED_RG_RGTC2 = 0x8DBE; ///
enum GL_COMPRESSED_SLUMINANCE = 0x8C4A; ///
enum GL_COMPRESSED_SLUMINANCE_ALPHA = 0x8C4B; ///
enum GL_COMPRESSED_SLUMINANCE_ALPHA_EXT = 0x8C4B; ///
enum GL_COMPRESSED_SLUMINANCE_EXT = 0x8C4A; ///
enum GL_COMPRESSED_SRGB = 0x8C48; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10 = 0x93DB; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 0x93DB; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5 = 0x93D8; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = 0x93D8; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6 = 0x93D9; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = 0x93D9; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8 = 0x93DA; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = 0x93DA; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10 = 0x93DC; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = 0x93DC; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12 = 0x93DD; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 0x93DD; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_3x3x3_OES = 0x93E0; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x3x3_OES = 0x93E1; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4 = 0x93D0; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 0x93D0; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x3_OES = 0x93E2; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x4_OES = 0x93E3; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4 = 0x93D1; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = 0x93D1; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4x4_OES = 0x93E4; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5 = 0x93D2; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = 0x93D2; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x4_OES = 0x93E5; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x5_OES = 0x93E6; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5 = 0x93D3; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = 0x93D3; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5x5_OES = 0x93E7; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6 = 0x93D4; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 0x93D4; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x5_OES = 0x93E8; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x6_OES = 0x93E9; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5 = 0x93D5; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = 0x93D5; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6 = 0x93D6; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = 0x93D6; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8 = 0x93D7; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 0x93D7; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 0x9279; ///
enum GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC_OES = 0x9279; ///
enum GL_COMPRESSED_SRGB8_ETC2 = 0x9275; ///
enum GL_COMPRESSED_SRGB8_ETC2_OES = 0x9275; ///
enum GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 0x9277; ///
enum GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2_OES = 0x9277; ///
enum GL_COMPRESSED_SRGB_ALPHA = 0x8C49; ///
enum GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM = 0x8E8D; ///
enum GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB = 0x8E8D; ///
enum GL_COMPRESSED_SRGB_ALPHA_EXT = 0x8C49; ///
enum GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV1_EXT = 0x8A56; ///
enum GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV2_IMG = 0x93F0; ///
enum GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV1_EXT = 0x8A57; ///
enum GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV2_IMG = 0x93F1; ///
enum GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 0x8C4D; ///
enum GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_NV = 0x8C4D; ///
enum GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 0x8C4E; ///
enum GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_NV = 0x8C4E; ///
enum GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 0x8C4F; ///
enum GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_NV = 0x8C4F; ///
enum GL_COMPRESSED_SRGB_EXT = 0x8C48; ///
enum GL_COMPRESSED_SRGB_PVRTC_2BPPV1_EXT = 0x8A54; ///
enum GL_COMPRESSED_SRGB_PVRTC_4BPPV1_EXT = 0x8A55; ///
enum GL_COMPRESSED_SRGB_S3TC_DXT1_EXT = 0x8C4C; ///
enum GL_COMPRESSED_SRGB_S3TC_DXT1_NV = 0x8C4C; ///
enum GL_COMPRESSED_TEXTURE_FORMATS = 0x86A3; ///
enum GL_COMPRESSED_TEXTURE_FORMATS_ARB = 0x86A3; ///
enum GL_COMPUTE_PROGRAM_NV = 0x90FB; ///
enum GL_COMPUTE_PROGRAM_PARAMETER_BUFFER_NV = 0x90FC; ///
enum GL_COMPUTE_SHADER = 0x91B9; ///
enum GL_COMPUTE_SHADER_BIT = 0x00000020; ///
enum GL_COMPUTE_SHADER_INVOCATIONS_ARB = 0x82F5; ///
enum GL_COMPUTE_SUBROUTINE = 0x92ED; ///
enum GL_COMPUTE_SUBROUTINE_UNIFORM = 0x92F3; ///
enum GL_COMPUTE_TEXTURE = 0x82A0; ///
enum GL_COMPUTE_WORK_GROUP_SIZE = 0x8267; ///
enum GL_COMP_BIT_ATI = 0x00000002; ///
enum GL_CONDITION_SATISFIED = 0x911C; ///
enum GL_CONDITION_SATISFIED_APPLE = 0x911C; ///
enum GL_CONFORMANT_NV = 0x9374; ///
enum GL_CONIC_CURVE_TO_NV = 0x1A; ///
enum GL_CONJOINT_NV = 0x9284; ///
enum GL_CONSERVATIVE_RASTERIZATION_INTEL = 0x83FE; ///
enum GL_CONSERVATIVE_RASTERIZATION_NV = 0x9346; ///
enum GL_CONSERVATIVE_RASTER_DILATE_GRANULARITY_NV = 0x937B; ///
enum GL_CONSERVATIVE_RASTER_DILATE_NV = 0x9379; ///
enum GL_CONSERVATIVE_RASTER_DILATE_RANGE_NV = 0x937A; ///
enum GL_CONSERVATIVE_RASTER_MODE_NV = 0x954D; ///
enum GL_CONSERVATIVE_RASTER_MODE_POST_SNAP_NV = 0x954E; ///
enum GL_CONSERVATIVE_RASTER_MODE_PRE_SNAP_TRIANGLES_NV = 0x954F; ///
enum GL_CONSERVE_MEMORY_HINT_PGI = 0x1A1FD; ///
enum GL_CONSTANT = 0x8576; ///
enum GL_CONSTANT_ALPHA = 0x8003; ///
enum GL_CONSTANT_ALPHA_EXT = 0x8003; ///
enum GL_CONSTANT_ARB = 0x8576; ///
enum GL_CONSTANT_ATTENUATION = 0x1207; ///
enum GL_CONSTANT_BORDER = 0x8151; ///
enum GL_CONSTANT_BORDER_HP = 0x8151; ///
enum GL_CONSTANT_COLOR = 0x8001; ///
enum GL_CONSTANT_COLOR0_NV = 0x852A; ///
enum GL_CONSTANT_COLOR1_NV = 0x852B; ///
enum GL_CONSTANT_COLOR_EXT = 0x8001; ///
enum GL_CONSTANT_EXT = 0x8576; ///
enum GL_CONSTANT_NV = 0x8576; ///
enum GL_CONST_EYE_NV = 0x86E5; ///
enum GL_CONTEXT_COMPATIBILITY_PROFILE_BIT = 0x00000002; ///
enum GL_CONTEXT_CORE_PROFILE_BIT = 0x00000001; ///
enum GL_CONTEXT_FLAGS = 0x821E; ///
enum GL_CONTEXT_FLAG_DEBUG_BIT = 0x00000002; ///
enum GL_CONTEXT_FLAG_DEBUG_BIT_KHR = 0x00000002; ///
enum GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT = 0x00000001; ///
enum GL_CONTEXT_FLAG_NO_ERROR_BIT_KHR = 0x00000008; ///
enum GL_CONTEXT_FLAG_PROTECTED_CONTENT_BIT_EXT = 0x00000010; ///
enum GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT = 0x00000004; ///
enum GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT_ARB = 0x00000004; ///
enum GL_CONTEXT_LOST = 0x0507; ///
enum GL_CONTEXT_LOST_KHR = 0x0507; ///
enum GL_CONTEXT_LOST_WEBGL = 0x9242; ///
enum GL_CONTEXT_PROFILE_MASK = 0x9126; ///
enum GL_CONTEXT_RELEASE_BEHAVIOR = 0x82FB; ///
enum GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH = 0x82FC; ///
enum GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH_KHR = 0x82FC; ///
enum GL_CONTEXT_RELEASE_BEHAVIOR_KHR = 0x82FB; ///
enum GL_CONTEXT_ROBUST_ACCESS = 0x90F3; ///
enum GL_CONTEXT_ROBUST_ACCESS_EXT = 0x90F3; ///
enum GL_CONTEXT_ROBUST_ACCESS_KHR = 0x90F3; ///
enum GL_CONTINUOUS_AMD = 0x9007; ///
enum GL_CONTRAST_NV = 0x92A1; ///
enum GL_CONVEX_HULL_NV = 0x908B; ///
enum GL_CONVOLUTION_1D = 0x8010; ///
enum GL_CONVOLUTION_1D_EXT = 0x8010; ///
enum GL_CONVOLUTION_2D = 0x8011; ///
enum GL_CONVOLUTION_2D_EXT = 0x8011; ///
enum GL_CONVOLUTION_BORDER_COLOR = 0x8154; ///
enum GL_CONVOLUTION_BORDER_COLOR_HP = 0x8154; ///
enum GL_CONVOLUTION_BORDER_MODE = 0x8013; ///
enum GL_CONVOLUTION_BORDER_MODE_EXT = 0x8013; ///
enum GL_CONVOLUTION_FILTER_BIAS = 0x8015; ///
enum GL_CONVOLUTION_FILTER_BIAS_EXT = 0x8015; ///
enum GL_CONVOLUTION_FILTER_SCALE = 0x8014; ///
enum GL_CONVOLUTION_FILTER_SCALE_EXT = 0x8014; ///
enum GL_CONVOLUTION_FORMAT = 0x8017; ///
enum GL_CONVOLUTION_FORMAT_EXT = 0x8017; ///
enum GL_CONVOLUTION_HEIGHT = 0x8019; ///
enum GL_CONVOLUTION_HEIGHT_EXT = 0x8019; ///
enum GL_CONVOLUTION_HINT_SGIX = 0x8316; ///
enum GL_CONVOLUTION_WIDTH = 0x8018; ///
enum GL_CONVOLUTION_WIDTH_EXT = 0x8018; ///
enum GL_CON_0_ATI = 0x8941; ///
enum GL_CON_10_ATI = 0x894B; ///
enum GL_CON_11_ATI = 0x894C; ///
enum GL_CON_12_ATI = 0x894D; ///
enum GL_CON_13_ATI = 0x894E; ///
enum GL_CON_14_ATI = 0x894F; ///
enum GL_CON_15_ATI = 0x8950; ///
enum GL_CON_16_ATI = 0x8951; ///
enum GL_CON_17_ATI = 0x8952; ///
enum GL_CON_18_ATI = 0x8953; ///
enum GL_CON_19_ATI = 0x8954; ///
enum GL_CON_1_ATI = 0x8942; ///
enum GL_CON_20_ATI = 0x8955; ///
enum GL_CON_21_ATI = 0x8956; ///
enum GL_CON_22_ATI = 0x8957; ///
enum GL_CON_23_ATI = 0x8958; ///
enum GL_CON_24_ATI = 0x8959; ///
enum GL_CON_25_ATI = 0x895A; ///
enum GL_CON_26_ATI = 0x895B; ///
enum GL_CON_27_ATI = 0x895C; ///
enum GL_CON_28_ATI = 0x895D; ///
enum GL_CON_29_ATI = 0x895E; ///
enum GL_CON_2_ATI = 0x8943; ///
enum GL_CON_30_ATI = 0x895F; ///
enum GL_CON_31_ATI = 0x8960; ///
enum GL_CON_3_ATI = 0x8944; ///
enum GL_CON_4_ATI = 0x8945; ///
enum GL_CON_5_ATI = 0x8946; ///
enum GL_CON_6_ATI = 0x8947; ///
enum GL_CON_7_ATI = 0x8948; ///
enum GL_CON_8_ATI = 0x8949; ///
enum GL_CON_9_ATI = 0x894A; ///
enum GL_COORD_REPLACE = 0x8862; ///
enum GL_COORD_REPLACE_ARB = 0x8862; ///
enum GL_COORD_REPLACE_NV = 0x8862; ///
enum GL_COORD_REPLACE_OES = 0x8862; ///
enum GL_COPY = 0x1503; ///
enum GL_COPY_INVERTED = 0x150C; ///
enum GL_COPY_PIXEL_TOKEN = 0x0706; ///
enum GL_COPY_READ_BUFFER = 0x8F36; ///
enum GL_COPY_READ_BUFFER_BINDING = 0x8F36; ///
enum GL_COPY_READ_BUFFER_NV = 0x8F36; ///
enum GL_COPY_WRITE_BUFFER = 0x8F37; ///
enum GL_COPY_WRITE_BUFFER_BINDING = 0x8F37; ///
enum GL_COPY_WRITE_BUFFER_NV = 0x8F37; ///
enum GL_COUNTER_RANGE_AMD = 0x8BC1; ///
enum GL_COUNTER_TYPE_AMD = 0x8BC0; ///
enum GL_COUNT_DOWN_NV = 0x9089; ///
enum GL_COUNT_UP_NV = 0x9088; ///
enum GL_COVERAGE_ALL_FRAGMENTS_NV = 0x8ED5; ///
enum GL_COVERAGE_ATTACHMENT_NV = 0x8ED2; ///
enum GL_COVERAGE_AUTOMATIC_NV = 0x8ED7; ///
enum GL_COVERAGE_BUFFERS_NV = 0x8ED3; ///
enum GL_COVERAGE_BUFFER_BIT_NV = 0x00008000; ///
enum GL_COVERAGE_COMPONENT4_NV = 0x8ED1; ///
enum GL_COVERAGE_COMPONENT_NV = 0x8ED0; ///
enum GL_COVERAGE_EDGE_FRAGMENTS_NV = 0x8ED6; ///
enum GL_COVERAGE_MODULATION_NV = 0x9332; ///
enum GL_COVERAGE_MODULATION_TABLE_NV = 0x9331; ///
enum GL_COVERAGE_MODULATION_TABLE_SIZE_NV = 0x9333; ///
enum GL_COVERAGE_SAMPLES_NV = 0x8ED4; ///
enum GL_CPU_OPTIMIZED_QCOM = 0x8FB1; ///
enum GL_CUBIC_CURVE_TO_NV = 0x0C; ///
enum GL_CUBIC_EXT = 0x8334; ///
enum GL_CUBIC_HP = 0x815F; ///
enum GL_CUBIC_IMG = 0x9139; ///
enum GL_CUBIC_MIPMAP_LINEAR_IMG = 0x913B; ///
enum GL_CUBIC_MIPMAP_NEAREST_IMG = 0x913A; ///
enum GL_CULL_FACE = 0x0B44; ///
enum GL_CULL_FACE_MODE = 0x0B45; ///
enum GL_CULL_FRAGMENT_NV = 0x86E7; ///
enum GL_CULL_MODES_NV = 0x86E0; ///
enum GL_CULL_VERTEX_EXT = 0x81AA; ///
enum GL_CULL_VERTEX_EYE_POSITION_EXT = 0x81AB; ///
enum GL_CULL_VERTEX_IBM = 0x103050; ///
enum GL_CULL_VERTEX_OBJECT_POSITION_EXT = 0x81AC; ///
enum GL_CURRENT_ATTRIB_NV = 0x8626; ///
enum GL_CURRENT_BINORMAL_EXT = 0x843C; ///
enum GL_CURRENT_BIT = 0x00000001; ///
enum GL_CURRENT_COLOR = 0x0B00; ///
enum GL_CURRENT_FOG_COORD = 0x8453; ///
enum GL_CURRENT_FOG_COORDINATE = 0x8453; ///
enum GL_CURRENT_FOG_COORDINATE_EXT = 0x8453; ///
enum GL_CURRENT_INDEX = 0x0B01; ///
enum GL_CURRENT_MATRIX_ARB = 0x8641; ///
enum GL_CURRENT_MATRIX_INDEX_ARB = 0x8845; ///
enum GL_CURRENT_MATRIX_NV = 0x8641; ///
enum GL_CURRENT_MATRIX_STACK_DEPTH_ARB = 0x8640; ///
enum GL_CURRENT_MATRIX_STACK_DEPTH_NV = 0x8640; ///
enum GL_CURRENT_NORMAL = 0x0B02; ///
enum GL_CURRENT_OCCLUSION_QUERY_ID_NV = 0x8865; ///
enum GL_CURRENT_PALETTE_MATRIX_ARB = 0x8843; ///
enum GL_CURRENT_PALETTE_MATRIX_OES = 0x8843; ///
enum GL_CURRENT_PROGRAM = 0x8B8D; ///
enum GL_CURRENT_QUERY = 0x8865; ///
enum GL_CURRENT_QUERY_ARB = 0x8865; ///
enum GL_CURRENT_QUERY_EXT = 0x8865; ///
enum GL_CURRENT_RASTER_COLOR = 0x0B04; ///
enum GL_CURRENT_RASTER_DISTANCE = 0x0B09; ///
enum GL_CURRENT_RASTER_INDEX = 0x0B05; ///
enum GL_CURRENT_RASTER_NORMAL_SGIX = 0x8406; ///
enum GL_CURRENT_RASTER_POSITION = 0x0B07; ///
enum GL_CURRENT_RASTER_POSITION_VALID = 0x0B08; ///
enum GL_CURRENT_RASTER_SECONDARY_COLOR = 0x845F; ///
enum GL_CURRENT_RASTER_TEXTURE_COORDS = 0x0B06; ///
enum GL_CURRENT_SECONDARY_COLOR = 0x8459; ///
enum GL_CURRENT_SECONDARY_COLOR_EXT = 0x8459; ///
enum GL_CURRENT_TANGENT_EXT = 0x843B; ///
enum GL_CURRENT_TEXTURE_COORDS = 0x0B03; ///
enum GL_CURRENT_TIME_NV = 0x8E28; ///
enum GL_CURRENT_VERTEX_ATTRIB = 0x8626; ///
enum GL_CURRENT_VERTEX_ATTRIB_ARB = 0x8626; ///
enum GL_CURRENT_VERTEX_EXT = 0x87E2; ///
enum GL_CURRENT_VERTEX_WEIGHT_EXT = 0x850B; ///
enum GL_CURRENT_WEIGHT_ARB = 0x86A8; ///
enum GL_CW = 0x0900; ///
enum GL_DARKEN = 0x9297; ///
enum GL_DARKEN_KHR = 0x9297; ///
enum GL_DARKEN_NV = 0x9297; ///
enum GL_DATA_BUFFER_AMD = 0x9151; ///
enum GL_DEBUG_ASSERT_MESA = 0x875B; ///
enum GL_DEBUG_CALLBACK_FUNCTION = 0x8244; ///
enum GL_DEBUG_CALLBACK_FUNCTION_ARB = 0x8244; ///
enum GL_DEBUG_CALLBACK_FUNCTION_KHR = 0x8244; ///
enum GL_DEBUG_CALLBACK_USER_PARAM = 0x8245; ///
enum GL_DEBUG_CALLBACK_USER_PARAM_ARB = 0x8245; ///
enum GL_DEBUG_CALLBACK_USER_PARAM_KHR = 0x8245; ///
enum GL_DEBUG_CATEGORY_API_ERROR_AMD = 0x9149; ///
enum GL_DEBUG_CATEGORY_APPLICATION_AMD = 0x914F; ///
enum GL_DEBUG_CATEGORY_DEPRECATION_AMD = 0x914B; ///
enum GL_DEBUG_CATEGORY_OTHER_AMD = 0x9150; ///
enum GL_DEBUG_CATEGORY_PERFORMANCE_AMD = 0x914D; ///
enum GL_DEBUG_CATEGORY_SHADER_COMPILER_AMD = 0x914E; ///
enum GL_DEBUG_CATEGORY_UNDEFINED_BEHAVIOR_AMD = 0x914C; ///
enum GL_DEBUG_CATEGORY_WINDOW_SYSTEM_AMD = 0x914A; ///
enum GL_DEBUG_GROUP_STACK_DEPTH = 0x826D; ///
enum GL_DEBUG_GROUP_STACK_DEPTH_KHR = 0x826D; ///
enum GL_DEBUG_LOGGED_MESSAGES = 0x9145; ///
enum GL_DEBUG_LOGGED_MESSAGES_AMD = 0x9145; ///
enum GL_DEBUG_LOGGED_MESSAGES_ARB = 0x9145; ///
enum GL_DEBUG_LOGGED_MESSAGES_KHR = 0x9145; ///
enum GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH = 0x8243; ///
enum GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_ARB = 0x8243; ///
enum GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_KHR = 0x8243; ///
enum GL_DEBUG_OBJECT_MESA = 0x8759; ///
enum GL_DEBUG_OUTPUT = 0x92E0; ///
enum GL_DEBUG_OUTPUT_KHR = 0x92E0; ///
enum GL_DEBUG_OUTPUT_SYNCHRONOUS = 0x8242; ///
enum GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB = 0x8242; ///
enum GL_DEBUG_OUTPUT_SYNCHRONOUS_KHR = 0x8242; ///
enum GL_DEBUG_PRINT_MESA = 0x875A; ///
enum GL_DEBUG_SEVERITY_HIGH = 0x9146; ///
enum GL_DEBUG_SEVERITY_HIGH_AMD = 0x9146; ///
enum GL_DEBUG_SEVERITY_HIGH_ARB = 0x9146; ///
enum GL_DEBUG_SEVERITY_HIGH_KHR = 0x9146; ///
enum GL_DEBUG_SEVERITY_LOW = 0x9148; ///
enum GL_DEBUG_SEVERITY_LOW_AMD = 0x9148; ///
enum GL_DEBUG_SEVERITY_LOW_ARB = 0x9148; ///
enum GL_DEBUG_SEVERITY_LOW_KHR = 0x9148; ///
enum GL_DEBUG_SEVERITY_MEDIUM = 0x9147; ///
enum GL_DEBUG_SEVERITY_MEDIUM_AMD = 0x9147; ///
enum GL_DEBUG_SEVERITY_MEDIUM_ARB = 0x9147; ///
enum GL_DEBUG_SEVERITY_MEDIUM_KHR = 0x9147; ///
enum GL_DEBUG_SEVERITY_NOTIFICATION = 0x826B; ///
enum GL_DEBUG_SEVERITY_NOTIFICATION_KHR = 0x826B; ///
enum GL_DEBUG_SOURCE_API = 0x8246; ///
enum GL_DEBUG_SOURCE_API_ARB = 0x8246; ///
enum GL_DEBUG_SOURCE_API_KHR = 0x8246; ///
enum GL_DEBUG_SOURCE_APPLICATION = 0x824A; ///
enum GL_DEBUG_SOURCE_APPLICATION_ARB = 0x824A; ///
enum GL_DEBUG_SOURCE_APPLICATION_KHR = 0x824A; ///
enum GL_DEBUG_SOURCE_OTHER = 0x824B; ///
enum GL_DEBUG_SOURCE_OTHER_ARB = 0x824B; ///
enum GL_DEBUG_SOURCE_OTHER_KHR = 0x824B; ///
enum GL_DEBUG_SOURCE_SHADER_COMPILER = 0x8248; ///
enum GL_DEBUG_SOURCE_SHADER_COMPILER_ARB = 0x8248; ///
enum GL_DEBUG_SOURCE_SHADER_COMPILER_KHR = 0x8248; ///
enum GL_DEBUG_SOURCE_THIRD_PARTY = 0x8249; ///
enum GL_DEBUG_SOURCE_THIRD_PARTY_ARB = 0x8249; ///
enum GL_DEBUG_SOURCE_THIRD_PARTY_KHR = 0x8249; ///
enum GL_DEBUG_SOURCE_WINDOW_SYSTEM = 0x8247; ///
enum GL_DEBUG_SOURCE_WINDOW_SYSTEM_ARB = 0x8247; ///
enum GL_DEBUG_SOURCE_WINDOW_SYSTEM_KHR = 0x8247; ///
enum GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR = 0x824D; ///
enum GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_ARB = 0x824D; ///
enum GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_KHR = 0x824D; ///
enum GL_DEBUG_TYPE_ERROR = 0x824C; ///
enum GL_DEBUG_TYPE_ERROR_ARB = 0x824C; ///
enum GL_DEBUG_TYPE_ERROR_KHR = 0x824C; ///
enum GL_DEBUG_TYPE_MARKER = 0x8268; ///
enum GL_DEBUG_TYPE_MARKER_KHR = 0x8268; ///
enum GL_DEBUG_TYPE_OTHER = 0x8251; ///
enum GL_DEBUG_TYPE_OTHER_ARB = 0x8251; ///
enum GL_DEBUG_TYPE_OTHER_KHR = 0x8251; ///
enum GL_DEBUG_TYPE_PERFORMANCE = 0x8250; ///
enum GL_DEBUG_TYPE_PERFORMANCE_ARB = 0x8250; ///
enum GL_DEBUG_TYPE_PERFORMANCE_KHR = 0x8250; ///
enum GL_DEBUG_TYPE_POP_GROUP = 0x826A; ///
enum GL_DEBUG_TYPE_POP_GROUP_KHR = 0x826A; ///
enum GL_DEBUG_TYPE_PORTABILITY = 0x824F; ///
enum GL_DEBUG_TYPE_PORTABILITY_ARB = 0x824F; ///
enum GL_DEBUG_TYPE_PORTABILITY_KHR = 0x824F; ///
enum GL_DEBUG_TYPE_PUSH_GROUP = 0x8269; ///
enum GL_DEBUG_TYPE_PUSH_GROUP_KHR = 0x8269; ///
enum GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR = 0x824E; ///
enum GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_ARB = 0x824E; ///
enum GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_KHR = 0x824E; ///
enum GL_DECAL = 0x2101; ///
enum GL_DECODE_EXT = 0x8A49; ///
enum GL_DECR = 0x1E03; ///
enum GL_DECR_WRAP = 0x8508; ///
enum GL_DECR_WRAP_EXT = 0x8508; ///
enum GL_DECR_WRAP_OES = 0x8508; ///
enum GL_DEFORMATIONS_MASK_SGIX = 0x8196; ///
enum GL_DELETE_STATUS = 0x8B80; ///
enum GL_DEPENDENT_AR_TEXTURE_2D_NV = 0x86E9; ///
enum GL_DEPENDENT_GB_TEXTURE_2D_NV = 0x86EA; ///
enum GL_DEPENDENT_HILO_TEXTURE_2D_NV = 0x8858; ///
enum GL_DEPENDENT_RGB_TEXTURE_3D_NV = 0x8859; ///
enum GL_DEPENDENT_RGB_TEXTURE_CUBE_MAP_NV = 0x885A; ///
enum GL_DEPTH = 0x1801; ///
enum GL_DEPTH24_STENCIL8 = 0x88F0; ///
enum GL_DEPTH24_STENCIL8_EXT = 0x88F0; ///
enum GL_DEPTH24_STENCIL8_OES = 0x88F0; ///
enum GL_DEPTH32F_STENCIL8 = 0x8CAD; ///
enum GL_DEPTH32F_STENCIL8_NV = 0x8DAC; ///
enum GL_DEPTH_ATTACHMENT = 0x8D00; ///
enum GL_DEPTH_ATTACHMENT_EXT = 0x8D00; ///
enum GL_DEPTH_ATTACHMENT_OES = 0x8D00; ///
enum GL_DEPTH_BIAS = 0x0D1F; ///
enum GL_DEPTH_BITS = 0x0D56; ///
enum GL_DEPTH_BOUNDS_EXT = 0x8891; ///
enum GL_DEPTH_BOUNDS_TEST_EXT = 0x8890; ///
enum GL_DEPTH_BUFFER_BIT = 0x00000100; ///
enum GL_DEPTH_BUFFER_BIT0_QCOM = 0x00000100; ///
enum GL_DEPTH_BUFFER_BIT1_QCOM = 0x00000200; ///
enum GL_DEPTH_BUFFER_BIT2_QCOM = 0x00000400; ///
enum GL_DEPTH_BUFFER_BIT3_QCOM = 0x00000800; ///
enum GL_DEPTH_BUFFER_BIT4_QCOM = 0x00001000; ///
enum GL_DEPTH_BUFFER_BIT5_QCOM = 0x00002000; ///
enum GL_DEPTH_BUFFER_BIT6_QCOM = 0x00004000; ///
enum GL_DEPTH_BUFFER_BIT7_QCOM = 0x00008000; ///
enum GL_DEPTH_BUFFER_FLOAT_MODE_NV = 0x8DAF; ///
enum GL_DEPTH_CLAMP = 0x864F; ///
enum GL_DEPTH_CLAMP_FAR_AMD = 0x901F; ///
enum GL_DEPTH_CLAMP_NEAR_AMD = 0x901E; ///
enum GL_DEPTH_CLAMP_NV = 0x864F; ///
enum GL_DEPTH_CLEAR_VALUE = 0x0B73; ///
enum GL_DEPTH_COMPONENT = 0x1902; ///
enum GL_DEPTH_COMPONENT16 = 0x81A5; ///
enum GL_DEPTH_COMPONENT16_ARB = 0x81A5; ///
enum GL_DEPTH_COMPONENT16_NONLINEAR_NV = 0x8E2C; ///
enum GL_DEPTH_COMPONENT16_OES = 0x81A5; ///
enum GL_DEPTH_COMPONENT16_SGIX = 0x81A5; ///
enum GL_DEPTH_COMPONENT24 = 0x81A6; ///
enum GL_DEPTH_COMPONENT24_ARB = 0x81A6; ///
enum GL_DEPTH_COMPONENT24_OES = 0x81A6; ///
enum GL_DEPTH_COMPONENT24_SGIX = 0x81A6; ///
enum GL_DEPTH_COMPONENT32 = 0x81A7; ///
enum GL_DEPTH_COMPONENT32F = 0x8CAC; ///
enum GL_DEPTH_COMPONENT32F_NV = 0x8DAB; ///
enum GL_DEPTH_COMPONENT32_ARB = 0x81A7; ///
enum GL_DEPTH_COMPONENT32_OES = 0x81A7; ///
enum GL_DEPTH_COMPONENT32_SGIX = 0x81A7; ///
enum GL_DEPTH_COMPONENTS = 0x8284; ///
enum GL_DEPTH_EXT = 0x1801; ///
enum GL_DEPTH_FUNC = 0x0B74; ///
enum GL_DEPTH_PASS_INSTRUMENT_COUNTERS_SGIX = 0x8311; ///
enum GL_DEPTH_PASS_INSTRUMENT_MAX_SGIX = 0x8312; ///
enum GL_DEPTH_PASS_INSTRUMENT_SGIX = 0x8310; ///
enum GL_DEPTH_RANGE = 0x0B70; ///
enum GL_DEPTH_RENDERABLE = 0x8287; ///
enum GL_DEPTH_SAMPLES_NV = 0x932D; ///
enum GL_DEPTH_SCALE = 0x0D1E; ///
enum GL_DEPTH_STENCIL = 0x84F9; ///
enum GL_DEPTH_STENCIL_ATTACHMENT = 0x821A; ///
enum GL_DEPTH_STENCIL_EXT = 0x84F9; ///
enum GL_DEPTH_STENCIL_MESA = 0x8750; ///
enum GL_DEPTH_STENCIL_NV = 0x84F9; ///
enum GL_DEPTH_STENCIL_OES = 0x84F9; ///
enum GL_DEPTH_STENCIL_TEXTURE_MODE = 0x90EA; ///
enum GL_DEPTH_STENCIL_TO_BGRA_NV = 0x886F; ///
enum GL_DEPTH_STENCIL_TO_RGBA_NV = 0x886E; ///
enum GL_DEPTH_TEST = 0x0B71; ///
enum GL_DEPTH_TEXTURE_MODE = 0x884B; ///
enum GL_DEPTH_TEXTURE_MODE_ARB = 0x884B; ///
enum GL_DEPTH_WRITEMASK = 0x0B72; ///
enum GL_DETAIL_TEXTURE_2D_BINDING_SGIS = 0x8096; ///
enum GL_DETAIL_TEXTURE_2D_SGIS = 0x8095; ///
enum GL_DETAIL_TEXTURE_FUNC_POINTS_SGIS = 0x809C; ///
enum GL_DETAIL_TEXTURE_LEVEL_SGIS = 0x809A; ///
enum GL_DETAIL_TEXTURE_MODE_SGIS = 0x809B; ///
enum GL_DIFFERENCE = 0x929E; ///
enum GL_DIFFERENCE_KHR = 0x929E; ///
enum GL_DIFFERENCE_NV = 0x929E; ///
enum GL_DIFFUSE = 0x1201; ///
enum GL_DISCARD_ATI = 0x8763; ///
enum GL_DISCARD_NV = 0x8530; ///
enum GL_DISCRETE_AMD = 0x9006; ///
enum GL_DISJOINT_NV = 0x9283; ///
enum GL_DISPATCH_INDIRECT_BUFFER = 0x90EE; ///
enum GL_DISPATCH_INDIRECT_BUFFER_BINDING = 0x90EF; ///
enum GL_DISPLAY_LIST = 0x82E7; ///
enum GL_DISTANCE_ATTENUATION_EXT = 0x8129; ///
enum GL_DISTANCE_ATTENUATION_SGIS = 0x8129; ///
enum GL_DITHER = 0x0BD0; ///
enum GL_DMP_PROGRAM_BINARY_DMP = 0x9253; ///
enum GL_DOMAIN = 0x0A02; ///
enum GL_DONT_CARE = 0x1100; ///
enum GL_DOT2_ADD_ATI = 0x896C; ///
enum GL_DOT3_ATI = 0x8966; ///
enum GL_DOT3_RGB = 0x86AE; ///
enum GL_DOT3_RGBA = 0x86AF; ///
enum GL_DOT3_RGBA_ARB = 0x86AF; ///
enum GL_DOT3_RGBA_EXT = 0x8741; ///
enum GL_DOT3_RGBA_IMG = 0x86AF; ///
enum GL_DOT3_RGB_ARB = 0x86AE; ///
enum GL_DOT3_RGB_EXT = 0x8740; ///
enum GL_DOT4_ATI = 0x8967; ///
enum GL_DOT_PRODUCT_AFFINE_DEPTH_REPLACE_NV = 0x885D; ///
enum GL_DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV = 0x86F3; ///
enum GL_DOT_PRODUCT_DEPTH_REPLACE_NV = 0x86ED; ///
enum GL_DOT_PRODUCT_DIFFUSE_CUBE_MAP_NV = 0x86F1; ///
enum GL_DOT_PRODUCT_NV = 0x86EC; ///
enum GL_DOT_PRODUCT_PASS_THROUGH_NV = 0x885B; ///
enum GL_DOT_PRODUCT_REFLECT_CUBE_MAP_NV = 0x86F2; ///
enum GL_DOT_PRODUCT_TEXTURE_1D_NV = 0x885C; ///
enum GL_DOT_PRODUCT_TEXTURE_2D_NV = 0x86EE; ///
enum GL_DOT_PRODUCT_TEXTURE_3D_NV = 0x86EF; ///
enum GL_DOT_PRODUCT_TEXTURE_CUBE_MAP_NV = 0x86F0; ///
enum GL_DOT_PRODUCT_TEXTURE_RECTANGLE_NV = 0x864E; ///
enum GL_DOUBLE = 0x140A; ///
enum GL_DOUBLEBUFFER = 0x0C32; ///
enum GL_DOUBLE_EXT = 0x140A; ///
enum GL_DOUBLE_MAT2 = 0x8F46; ///
enum GL_DOUBLE_MAT2_EXT = 0x8F46; ///
enum GL_DOUBLE_MAT2x3 = 0x8F49; ///
enum GL_DOUBLE_MAT2x3_EXT = 0x8F49; ///
enum GL_DOUBLE_MAT2x4 = 0x8F4A; ///
enum GL_DOUBLE_MAT2x4_EXT = 0x8F4A; ///
enum GL_DOUBLE_MAT3 = 0x8F47; ///
enum GL_DOUBLE_MAT3_EXT = 0x8F47; ///
enum GL_DOUBLE_MAT3x2 = 0x8F4B; ///
enum GL_DOUBLE_MAT3x2_EXT = 0x8F4B; ///
enum GL_DOUBLE_MAT3x4 = 0x8F4C; ///
enum GL_DOUBLE_MAT3x4_EXT = 0x8F4C; ///
enum GL_DOUBLE_MAT4 = 0x8F48; ///
enum GL_DOUBLE_MAT4_EXT = 0x8F48; ///
enum GL_DOUBLE_MAT4x2 = 0x8F4D; ///
enum GL_DOUBLE_MAT4x2_EXT = 0x8F4D; ///
enum GL_DOUBLE_MAT4x3 = 0x8F4E; ///
enum GL_DOUBLE_MAT4x3_EXT = 0x8F4E; ///
enum GL_DOUBLE_VEC2 = 0x8FFC; ///
enum GL_DOUBLE_VEC2_EXT = 0x8FFC; ///
enum GL_DOUBLE_VEC3 = 0x8FFD; ///
enum GL_DOUBLE_VEC3_EXT = 0x8FFD; ///
enum GL_DOUBLE_VEC4 = 0x8FFE; ///
enum GL_DOUBLE_VEC4_EXT = 0x8FFE; ///
enum GL_DOWNSAMPLE_SCALES_IMG = 0x913E; ///
enum GL_DRAW_ARRAYS_COMMAND_NV = 0x0003; ///
enum GL_DRAW_ARRAYS_INSTANCED_COMMAND_NV = 0x0007; ///
enum GL_DRAW_ARRAYS_STRIP_COMMAND_NV = 0x0005; ///
enum GL_DRAW_BUFFER = 0x0C01; ///
enum GL_DRAW_BUFFER0 = 0x8825; ///
enum GL_DRAW_BUFFER0_ARB = 0x8825; ///
enum GL_DRAW_BUFFER0_ATI = 0x8825; ///
enum GL_DRAW_BUFFER0_EXT = 0x8825; ///
enum GL_DRAW_BUFFER0_NV = 0x8825; ///
enum GL_DRAW_BUFFER1 = 0x8826; ///
enum GL_DRAW_BUFFER10 = 0x882F; ///
enum GL_DRAW_BUFFER10_ARB = 0x882F; ///
enum GL_DRAW_BUFFER10_ATI = 0x882F; ///
enum GL_DRAW_BUFFER10_EXT = 0x882F; ///
enum GL_DRAW_BUFFER10_NV = 0x882F; ///
enum GL_DRAW_BUFFER11 = 0x8830; ///
enum GL_DRAW_BUFFER11_ARB = 0x8830; ///
enum GL_DRAW_BUFFER11_ATI = 0x8830; ///
enum GL_DRAW_BUFFER11_EXT = 0x8830; ///
enum GL_DRAW_BUFFER11_NV = 0x8830; ///
enum GL_DRAW_BUFFER12 = 0x8831; ///
enum GL_DRAW_BUFFER12_ARB = 0x8831; ///
enum GL_DRAW_BUFFER12_ATI = 0x8831; ///
enum GL_DRAW_BUFFER12_EXT = 0x8831; ///
enum GL_DRAW_BUFFER12_NV = 0x8831; ///
enum GL_DRAW_BUFFER13 = 0x8832; ///
enum GL_DRAW_BUFFER13_ARB = 0x8832; ///
enum GL_DRAW_BUFFER13_ATI = 0x8832; ///
enum GL_DRAW_BUFFER13_EXT = 0x8832; ///
enum GL_DRAW_BUFFER13_NV = 0x8832; ///
enum GL_DRAW_BUFFER14 = 0x8833; ///
enum GL_DRAW_BUFFER14_ARB = 0x8833; ///
enum GL_DRAW_BUFFER14_ATI = 0x8833; ///
enum GL_DRAW_BUFFER14_EXT = 0x8833; ///
enum GL_DRAW_BUFFER14_NV = 0x8833; ///
enum GL_DRAW_BUFFER15 = 0x8834; ///
enum GL_DRAW_BUFFER15_ARB = 0x8834; ///
enum GL_DRAW_BUFFER15_ATI = 0x8834; ///
enum GL_DRAW_BUFFER15_EXT = 0x8834; ///
enum GL_DRAW_BUFFER15_NV = 0x8834; ///
enum GL_DRAW_BUFFER1_ARB = 0x8826; ///
enum GL_DRAW_BUFFER1_ATI = 0x8826; ///
enum GL_DRAW_BUFFER1_EXT = 0x8826; ///
enum GL_DRAW_BUFFER1_NV = 0x8826; ///
enum GL_DRAW_BUFFER2 = 0x8827; ///
enum GL_DRAW_BUFFER2_ARB = 0x8827; ///
enum GL_DRAW_BUFFER2_ATI = 0x8827; ///
enum GL_DRAW_BUFFER2_EXT = 0x8827; ///
enum GL_DRAW_BUFFER2_NV = 0x8827; ///
enum GL_DRAW_BUFFER3 = 0x8828; ///
enum GL_DRAW_BUFFER3_ARB = 0x8828; ///
enum GL_DRAW_BUFFER3_ATI = 0x8828; ///
enum GL_DRAW_BUFFER3_EXT = 0x8828; ///
enum GL_DRAW_BUFFER3_NV = 0x8828; ///
enum GL_DRAW_BUFFER4 = 0x8829; ///
enum GL_DRAW_BUFFER4_ARB = 0x8829; ///
enum GL_DRAW_BUFFER4_ATI = 0x8829; ///
enum GL_DRAW_BUFFER4_EXT = 0x8829; ///
enum GL_DRAW_BUFFER4_NV = 0x8829; ///
enum GL_DRAW_BUFFER5 = 0x882A; ///
enum GL_DRAW_BUFFER5_ARB = 0x882A; ///
enum GL_DRAW_BUFFER5_ATI = 0x882A; ///
enum GL_DRAW_BUFFER5_EXT = 0x882A; ///
enum GL_DRAW_BUFFER5_NV = 0x882A; ///
enum GL_DRAW_BUFFER6 = 0x882B; ///
enum GL_DRAW_BUFFER6_ARB = 0x882B; ///
enum GL_DRAW_BUFFER6_ATI = 0x882B; ///
enum GL_DRAW_BUFFER6_EXT = 0x882B; ///
enum GL_DRAW_BUFFER6_NV = 0x882B; ///
enum GL_DRAW_BUFFER7 = 0x882C; ///
enum GL_DRAW_BUFFER7_ARB = 0x882C; ///
enum GL_DRAW_BUFFER7_ATI = 0x882C; ///
enum GL_DRAW_BUFFER7_EXT = 0x882C; ///
enum GL_DRAW_BUFFER7_NV = 0x882C; ///
enum GL_DRAW_BUFFER8 = 0x882D; ///
enum GL_DRAW_BUFFER8_ARB = 0x882D; ///
enum GL_DRAW_BUFFER8_ATI = 0x882D; ///
enum GL_DRAW_BUFFER8_EXT = 0x882D; ///
enum GL_DRAW_BUFFER8_NV = 0x882D; ///
enum GL_DRAW_BUFFER9 = 0x882E; ///
enum GL_DRAW_BUFFER9_ARB = 0x882E; ///
enum GL_DRAW_BUFFER9_ATI = 0x882E; ///
enum GL_DRAW_BUFFER9_EXT = 0x882E; ///
enum GL_DRAW_BUFFER9_NV = 0x882E; ///
enum GL_DRAW_BUFFER_EXT = 0x0C01; ///
enum GL_DRAW_ELEMENTS_COMMAND_NV = 0x0002; ///
enum GL_DRAW_ELEMENTS_INSTANCED_COMMAND_NV = 0x0006; ///
enum GL_DRAW_ELEMENTS_STRIP_COMMAND_NV = 0x0004; ///
enum GL_DRAW_FRAMEBUFFER = 0x8CA9; ///
enum GL_DRAW_FRAMEBUFFER_ANGLE = 0x8CA9; ///
enum GL_DRAW_FRAMEBUFFER_APPLE = 0x8CA9; ///
enum GL_DRAW_FRAMEBUFFER_BINDING = 0x8CA6; ///
enum GL_DRAW_FRAMEBUFFER_BINDING_ANGLE = 0x8CA6; ///
enum GL_DRAW_FRAMEBUFFER_BINDING_APPLE = 0x8CA6; ///
enum GL_DRAW_FRAMEBUFFER_BINDING_EXT = 0x8CA6; ///
enum GL_DRAW_FRAMEBUFFER_BINDING_NV = 0x8CA6; ///
enum GL_DRAW_FRAMEBUFFER_EXT = 0x8CA9; ///
enum GL_DRAW_FRAMEBUFFER_NV = 0x8CA9; ///
enum GL_DRAW_INDIRECT_ADDRESS_NV = 0x8F41; ///
enum GL_DRAW_INDIRECT_BUFFER = 0x8F3F; ///
enum GL_DRAW_INDIRECT_BUFFER_BINDING = 0x8F43; ///
enum GL_DRAW_INDIRECT_LENGTH_NV = 0x8F42; ///
enum GL_DRAW_INDIRECT_UNIFIED_NV = 0x8F40; ///
enum GL_DRAW_PIXELS_APPLE = 0x8A0A; ///
enum GL_DRAW_PIXEL_TOKEN = 0x0705; ///
enum GL_DSDT8_MAG8_INTENSITY8_NV = 0x870B; ///
enum GL_DSDT8_MAG8_NV = 0x870A; ///
enum GL_DSDT8_NV = 0x8709; ///
enum GL_DSDT_MAG_INTENSITY_NV = 0x86DC; ///
enum GL_DSDT_MAG_NV = 0x86F6; ///
enum GL_DSDT_MAG_VIB_NV = 0x86F7; ///
enum GL_DSDT_NV = 0x86F5; ///
enum GL_DST_ALPHA = 0x0304; ///
enum GL_DST_ATOP_NV = 0x928F; ///
enum GL_DST_COLOR = 0x0306; ///
enum GL_DST_IN_NV = 0x928B; ///
enum GL_DST_NV = 0x9287; ///
enum GL_DST_OUT_NV = 0x928D; ///
enum GL_DST_OVER_NV = 0x9289; ///
enum GL_DS_BIAS_NV = 0x8716; ///
enum GL_DS_SCALE_NV = 0x8710; ///
enum GL_DT_BIAS_NV = 0x8717; ///
enum GL_DT_SCALE_NV = 0x8711; ///
enum GL_DU8DV8_ATI = 0x877A; ///
enum GL_DUAL_ALPHA12_SGIS = 0x8112; ///
enum GL_DUAL_ALPHA16_SGIS = 0x8113; ///
enum GL_DUAL_ALPHA4_SGIS = 0x8110; ///
enum GL_DUAL_ALPHA8_SGIS = 0x8111; ///
enum GL_DUAL_INTENSITY12_SGIS = 0x811A; ///
enum GL_DUAL_INTENSITY16_SGIS = 0x811B; ///
enum GL_DUAL_INTENSITY4_SGIS = 0x8118; ///
enum GL_DUAL_INTENSITY8_SGIS = 0x8119; ///
enum GL_DUAL_LUMINANCE12_SGIS = 0x8116; ///
enum GL_DUAL_LUMINANCE16_SGIS = 0x8117; ///
enum GL_DUAL_LUMINANCE4_SGIS = 0x8114; ///
enum GL_DUAL_LUMINANCE8_SGIS = 0x8115; ///
enum GL_DUAL_LUMINANCE_ALPHA4_SGIS = 0x811C; ///
enum GL_DUAL_LUMINANCE_ALPHA8_SGIS = 0x811D; ///
enum GL_DUAL_TEXTURE_SELECT_SGIS = 0x8124; ///
enum GL_DUDV_ATI = 0x8779; ///
enum GL_DUP_FIRST_CUBIC_CURVE_TO_NV = 0xF2; ///
enum GL_DUP_LAST_CUBIC_CURVE_TO_NV = 0xF4; ///
enum GL_DYNAMIC_ATI = 0x8761; ///
enum GL_DYNAMIC_COPY = 0x88EA; ///
enum GL_DYNAMIC_COPY_ARB = 0x88EA; ///
enum GL_DYNAMIC_DRAW = 0x88E8; ///
enum GL_DYNAMIC_DRAW_ARB = 0x88E8; ///
enum GL_DYNAMIC_READ = 0x88E9; ///
enum GL_DYNAMIC_READ_ARB = 0x88E9; ///
enum GL_DYNAMIC_STORAGE_BIT = 0x0100; ///
enum GL_DYNAMIC_STORAGE_BIT_EXT = 0x0100; ///
enum GL_EDGEFLAG_BIT_PGI = 0x00040000; ///
enum GL_EDGE_FLAG = 0x0B43; ///
enum GL_EDGE_FLAG_ARRAY = 0x8079; ///
enum GL_EDGE_FLAG_ARRAY_ADDRESS_NV = 0x8F26; ///
enum GL_EDGE_FLAG_ARRAY_BUFFER_BINDING = 0x889B; ///
enum GL_EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB = 0x889B; ///
enum GL_EDGE_FLAG_ARRAY_COUNT_EXT = 0x808D; ///
enum GL_EDGE_FLAG_ARRAY_EXT = 0x8079; ///
enum GL_EDGE_FLAG_ARRAY_LENGTH_NV = 0x8F30; ///
enum GL_EDGE_FLAG_ARRAY_LIST_IBM = 0x103075; ///
enum GL_EDGE_FLAG_ARRAY_LIST_STRIDE_IBM = 0x103085; ///
enum GL_EDGE_FLAG_ARRAY_POINTER = 0x8093; ///
enum GL_EDGE_FLAG_ARRAY_POINTER_EXT = 0x8093; ///
enum GL_EDGE_FLAG_ARRAY_STRIDE = 0x808C; ///
enum GL_EDGE_FLAG_ARRAY_STRIDE_EXT = 0x808C; ///
enum GL_EFFECTIVE_RASTER_SAMPLES_EXT = 0x932C; ///
enum GL_EIGHTH_BIT_ATI = 0x00000020; ///
enum GL_ELEMENT_ADDRESS_COMMAND_NV = 0x0008; ///
enum GL_ELEMENT_ARRAY_ADDRESS_NV = 0x8F29; ///
enum GL_ELEMENT_ARRAY_APPLE = 0x8A0C; ///
enum GL_ELEMENT_ARRAY_ATI = 0x8768; ///
enum GL_ELEMENT_ARRAY_BARRIER_BIT = 0x00000002; ///
enum GL_ELEMENT_ARRAY_BARRIER_BIT_EXT = 0x00000002; ///
enum GL_ELEMENT_ARRAY_BUFFER = 0x8893; ///
enum GL_ELEMENT_ARRAY_BUFFER_ARB = 0x8893; ///
enum GL_ELEMENT_ARRAY_BUFFER_BINDING = 0x8895; ///
enum GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB = 0x8895; ///
enum GL_ELEMENT_ARRAY_LENGTH_NV = 0x8F33; ///
enum GL_ELEMENT_ARRAY_POINTER_APPLE = 0x8A0E; ///
enum GL_ELEMENT_ARRAY_POINTER_ATI = 0x876A; ///
enum GL_ELEMENT_ARRAY_TYPE_APPLE = 0x8A0D; ///
enum GL_ELEMENT_ARRAY_TYPE_ATI = 0x8769; ///
enum GL_ELEMENT_ARRAY_UNIFIED_NV = 0x8F1F; ///
enum GL_EMBOSS_CONSTANT_NV = 0x855E; ///
enum GL_EMBOSS_LIGHT_NV = 0x855D; ///
enum GL_EMBOSS_MAP_NV = 0x855F; ///
enum GL_EMISSION = 0x1600; ///
enum GL_ENABLE_BIT = 0x00002000; ///
enum GL_EQUAL = 0x0202; ///
enum GL_EQUIV = 0x1509; ///
enum GL_ETC1_RGB8_OES = 0x8D64; ///
enum GL_ETC1_SRGB8_NV = 0x88EE; ///
enum GL_EVAL_2D_NV = 0x86C0; ///
enum GL_EVAL_BIT = 0x00010000; ///
enum GL_EVAL_FRACTIONAL_TESSELLATION_NV = 0x86C5; ///
enum GL_EVAL_TRIANGULAR_2D_NV = 0x86C1; ///
enum GL_EVAL_VERTEX_ATTRIB0_NV = 0x86C6; ///
enum GL_EVAL_VERTEX_ATTRIB10_NV = 0x86D0; ///
enum GL_EVAL_VERTEX_ATTRIB11_NV = 0x86D1; ///
enum GL_EVAL_VERTEX_ATTRIB12_NV = 0x86D2; ///
enum GL_EVAL_VERTEX_ATTRIB13_NV = 0x86D3; ///
enum GL_EVAL_VERTEX_ATTRIB14_NV = 0x86D4; ///
enum GL_EVAL_VERTEX_ATTRIB15_NV = 0x86D5; ///
enum GL_EVAL_VERTEX_ATTRIB1_NV = 0x86C7; ///
enum GL_EVAL_VERTEX_ATTRIB2_NV = 0x86C8; ///
enum GL_EVAL_VERTEX_ATTRIB3_NV = 0x86C9; ///
enum GL_EVAL_VERTEX_ATTRIB4_NV = 0x86CA; ///
enum GL_EVAL_VERTEX_ATTRIB5_NV = 0x86CB; ///
enum GL_EVAL_VERTEX_ATTRIB6_NV = 0x86CC; ///
enum GL_EVAL_VERTEX_ATTRIB7_NV = 0x86CD; ///
enum GL_EVAL_VERTEX_ATTRIB8_NV = 0x86CE; ///
enum GL_EVAL_VERTEX_ATTRIB9_NV = 0x86CF; ///
enum GL_EXCLUSION = 0x92A0; ///
enum GL_EXCLUSION_KHR = 0x92A0; ///
enum GL_EXCLUSION_NV = 0x92A0; ///
enum GL_EXCLUSIVE_EXT = 0x8F11; ///
enum GL_EXP = 0x0800; ///
enum GL_EXP2 = 0x0801; ///
enum GL_EXPAND_NEGATE_NV = 0x8539; ///
enum GL_EXPAND_NORMAL_NV = 0x8538; ///
enum GL_EXTENSIONS = 0x1F03; ///
enum GL_EXTERNAL_VIRTUAL_MEMORY_BUFFER_AMD = 0x9160; ///
enum GL_EYE_DISTANCE_TO_LINE_SGIS = 0x81F2; ///
enum GL_EYE_DISTANCE_TO_POINT_SGIS = 0x81F0; ///
enum GL_EYE_LINEAR = 0x2400; ///
enum GL_EYE_LINEAR_NV = 0x2400; ///
enum GL_EYE_LINE_SGIS = 0x81F6; ///
enum GL_EYE_PLANE = 0x2502; ///
enum GL_EYE_PLANE_ABSOLUTE_NV = 0x855C; ///
enum GL_EYE_POINT_SGIS = 0x81F4; ///
enum GL_EYE_RADIAL_NV = 0x855B; ///
enum GL_E_TIMES_F_NV = 0x8531; ///
enum GL_FACTOR_ALPHA_MODULATE_IMG = 0x8C07; ///
enum GL_FACTOR_MAX_AMD = 0x901D; ///
enum GL_FACTOR_MIN_AMD = 0x901C; ///
enum GL_FAILURE_NV = 0x9030; ///
enum GL_FALSE = 0; ///
enum GL_FASTEST = 0x1101; ///
enum GL_FEEDBACK = 0x1C01; ///
enum GL_FEEDBACK_BUFFER_POINTER = 0x0DF0; ///
enum GL_FEEDBACK_BUFFER_SIZE = 0x0DF1; ///
enum GL_FEEDBACK_BUFFER_TYPE = 0x0DF2; ///
enum GL_FENCE_APPLE = 0x8A0B; ///
enum GL_FENCE_CONDITION_NV = 0x84F4; ///
enum GL_FENCE_STATUS_NV = 0x84F3; ///
enum GL_FETCH_PER_SAMPLE_ARM = 0x8F65; ///
enum GL_FIELDS_NV = 0x8E27; ///
enum GL_FIELD_LOWER_NV = 0x9023; ///
enum GL_FIELD_UPPER_NV = 0x9022; ///
enum GL_FILE_NAME_NV = 0x9074; ///
enum GL_FILL = 0x1B02; ///
enum GL_FILL_NV = 0x1B02; ///
enum GL_FILL_RECTANGLE_NV = 0x933C; ///
enum GL_FILTER = 0x829A; ///
enum GL_FILTER4_SGIS = 0x8146; ///
enum GL_FIRST_TO_REST_NV = 0x90AF; ///
enum GL_FIRST_VERTEX_CONVENTION = 0x8E4D; ///
enum GL_FIRST_VERTEX_CONVENTION_EXT = 0x8E4D; ///
enum GL_FIRST_VERTEX_CONVENTION_OES = 0x8E4D; ///
enum GL_FIXED = 0x140C; ///
enum GL_FIXED_OES = 0x140C; ///
enum GL_FIXED_ONLY = 0x891D; ///
enum GL_FIXED_ONLY_ARB = 0x891D; ///
enum GL_FLAT = 0x1D00; ///
enum GL_FLOAT = 0x1406; ///
enum GL_FLOAT16_MAT2_AMD = 0x91C5; ///
enum GL_FLOAT16_MAT2x3_AMD = 0x91C8; ///
enum GL_FLOAT16_MAT2x4_AMD = 0x91C9; ///
enum GL_FLOAT16_MAT3_AMD = 0x91C6; ///
enum GL_FLOAT16_MAT3x2_AMD = 0x91CA; ///
enum GL_FLOAT16_MAT3x4_AMD = 0x91CB; ///
enum GL_FLOAT16_MAT4_AMD = 0x91C7; ///
enum GL_FLOAT16_MAT4x2_AMD = 0x91CC; ///
enum GL_FLOAT16_MAT4x3_AMD = 0x91CD; ///
enum GL_FLOAT16_NV = 0x8FF8; ///
enum GL_FLOAT16_VEC2_NV = 0x8FF9; ///
enum GL_FLOAT16_VEC3_NV = 0x8FFA; ///
enum GL_FLOAT16_VEC4_NV = 0x8FFB; ///
enum GL_FLOAT_32_UNSIGNED_INT_24_8_REV = 0x8DAD; ///
enum GL_FLOAT_32_UNSIGNED_INT_24_8_REV_NV = 0x8DAD; ///
enum GL_FLOAT_CLEAR_COLOR_VALUE_NV = 0x888D; ///
enum GL_FLOAT_MAT2 = 0x8B5A; ///
enum GL_FLOAT_MAT2_ARB = 0x8B5A; ///
enum GL_FLOAT_MAT2x3 = 0x8B65; ///
enum GL_FLOAT_MAT2x3_NV = 0x8B65; ///
enum GL_FLOAT_MAT2x4 = 0x8B66; ///
enum GL_FLOAT_MAT2x4_NV = 0x8B66; ///
enum GL_FLOAT_MAT3 = 0x8B5B; ///
enum GL_FLOAT_MAT3_ARB = 0x8B5B; ///
enum GL_FLOAT_MAT3x2 = 0x8B67; ///
enum GL_FLOAT_MAT3x2_NV = 0x8B67; ///
enum GL_FLOAT_MAT3x4 = 0x8B68; ///
enum GL_FLOAT_MAT3x4_NV = 0x8B68; ///
enum GL_FLOAT_MAT4 = 0x8B5C; ///
enum GL_FLOAT_MAT4_ARB = 0x8B5C; ///
enum GL_FLOAT_MAT4x2 = 0x8B69; ///
enum GL_FLOAT_MAT4x2_NV = 0x8B69; ///
enum GL_FLOAT_MAT4x3 = 0x8B6A; ///
enum GL_FLOAT_MAT4x3_NV = 0x8B6A; ///
enum GL_FLOAT_R16_NV = 0x8884; ///
enum GL_FLOAT_R32_NV = 0x8885; ///
enum GL_FLOAT_RG16_NV = 0x8886; ///
enum GL_FLOAT_RG32_NV = 0x8887; ///
enum GL_FLOAT_RGB16_NV = 0x8888; ///
enum GL_FLOAT_RGB32_NV = 0x8889; ///
enum GL_FLOAT_RGBA16_NV = 0x888A; ///
enum GL_FLOAT_RGBA32_NV = 0x888B; ///
enum GL_FLOAT_RGBA_MODE_NV = 0x888E; ///
enum GL_FLOAT_RGBA_NV = 0x8883; ///
enum GL_FLOAT_RGB_NV = 0x8882; ///
enum GL_FLOAT_RG_NV = 0x8881; ///
enum GL_FLOAT_R_NV = 0x8880; ///
enum GL_FLOAT_VEC2 = 0x8B50; ///
enum GL_FLOAT_VEC2_ARB = 0x8B50; ///
enum GL_FLOAT_VEC3 = 0x8B51; ///
enum GL_FLOAT_VEC3_ARB = 0x8B51; ///
enum GL_FLOAT_VEC4 = 0x8B52; ///
enum GL_FLOAT_VEC4_ARB = 0x8B52; ///
enum GL_FOG = 0x0B60; ///
enum GL_FOG_BIT = 0x00000080; ///
enum GL_FOG_COLOR = 0x0B66; ///
enum GL_FOG_COORD = 0x8451; ///
enum GL_FOG_COORDINATE = 0x8451; ///
enum GL_FOG_COORDINATE_ARRAY = 0x8457; ///
enum GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING = 0x889D; ///
enum GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB = 0x889D; ///
enum GL_FOG_COORDINATE_ARRAY_EXT = 0x8457; ///
enum GL_FOG_COORDINATE_ARRAY_LIST_IBM = 0x103076; ///
enum GL_FOG_COORDINATE_ARRAY_LIST_STRIDE_IBM = 0x103086; ///
enum GL_FOG_COORDINATE_ARRAY_POINTER = 0x8456; ///
enum GL_FOG_COORDINATE_ARRAY_POINTER_EXT = 0x8456; ///
enum GL_FOG_COORDINATE_ARRAY_STRIDE = 0x8455; ///
enum GL_FOG_COORDINATE_ARRAY_STRIDE_EXT = 0x8455; ///
enum GL_FOG_COORDINATE_ARRAY_TYPE = 0x8454; ///
enum GL_FOG_COORDINATE_ARRAY_TYPE_EXT = 0x8454; ///
enum GL_FOG_COORDINATE_EXT = 0x8451; ///
enum GL_FOG_COORDINATE_SOURCE = 0x8450; ///
enum GL_FOG_COORDINATE_SOURCE_EXT = 0x8450; ///
enum GL_FOG_COORD_ARRAY = 0x8457; ///
enum GL_FOG_COORD_ARRAY_ADDRESS_NV = 0x8F28; ///
enum GL_FOG_COORD_ARRAY_BUFFER_BINDING = 0x889D; ///
enum GL_FOG_COORD_ARRAY_LENGTH_NV = 0x8F32; ///
enum GL_FOG_COORD_ARRAY_POINTER = 0x8456; ///
enum GL_FOG_COORD_ARRAY_STRIDE = 0x8455; ///
enum GL_FOG_COORD_ARRAY_TYPE = 0x8454; ///
enum GL_FOG_COORD_SRC = 0x8450; ///
enum GL_FOG_DENSITY = 0x0B62; ///
enum GL_FOG_DISTANCE_MODE_NV = 0x855A; ///
enum GL_FOG_END = 0x0B64; ///
enum GL_FOG_FUNC_POINTS_SGIS = 0x812B; ///
enum GL_FOG_FUNC_SGIS = 0x812A; ///
enum GL_FOG_HINT = 0x0C54; ///
enum GL_FOG_INDEX = 0x0B61; ///
enum GL_FOG_MODE = 0x0B65; ///
enum GL_FOG_OFFSET_SGIX = 0x8198; ///
enum GL_FOG_OFFSET_VALUE_SGIX = 0x8199; ///
enum GL_FOG_SPECULAR_TEXTURE_WIN = 0x80EC; ///
enum GL_FOG_START = 0x0B63; ///
enum GL_FONT_ASCENDER_BIT_NV = 0x00200000; ///
enum GL_FONT_DESCENDER_BIT_NV = 0x00400000; ///
enum GL_FONT_GLYPHS_AVAILABLE_NV = 0x9368; ///
enum GL_FONT_HAS_KERNING_BIT_NV = 0x10000000; ///
enum GL_FONT_HEIGHT_BIT_NV = 0x00800000; ///
enum GL_FONT_MAX_ADVANCE_HEIGHT_BIT_NV = 0x02000000; ///
enum GL_FONT_MAX_ADVANCE_WIDTH_BIT_NV = 0x01000000; ///
enum GL_FONT_NUM_GLYPH_INDICES_BIT_NV = 0x20000000; ///
enum GL_FONT_TARGET_UNAVAILABLE_NV = 0x9369; ///
enum GL_FONT_UNAVAILABLE_NV = 0x936A; ///
enum GL_FONT_UNDERLINE_POSITION_BIT_NV = 0x04000000; ///
enum GL_FONT_UNDERLINE_THICKNESS_BIT_NV = 0x08000000; ///
enum GL_FONT_UNINTELLIGIBLE_NV = 0x936B; ///
enum GL_FONT_UNITS_PER_EM_BIT_NV = 0x00100000; ///
enum GL_FONT_X_MAX_BOUNDS_BIT_NV = 0x00040000; ///
enum GL_FONT_X_MIN_BOUNDS_BIT_NV = 0x00010000; ///
enum GL_FONT_Y_MAX_BOUNDS_BIT_NV = 0x00080000; ///
enum GL_FONT_Y_MIN_BOUNDS_BIT_NV = 0x00020000; ///
enum GL_FORCE_BLUE_TO_ONE_NV = 0x8860; ///
enum GL_FORMAT_SUBSAMPLE_244_244_OML = 0x8983; ///
enum GL_FORMAT_SUBSAMPLE_24_24_OML = 0x8982; ///
enum GL_FRACTIONAL_EVEN = 0x8E7C; ///
enum GL_FRACTIONAL_EVEN_EXT = 0x8E7C; ///
enum GL_FRACTIONAL_EVEN_OES = 0x8E7C; ///
enum GL_FRACTIONAL_ODD = 0x8E7B; ///
enum GL_FRACTIONAL_ODD_EXT = 0x8E7B; ///
enum GL_FRACTIONAL_ODD_OES = 0x8E7B; ///
enum GL_FRAGMENTS_INSTRUMENT_COUNTERS_SGIX = 0x8314; ///
enum GL_FRAGMENTS_INSTRUMENT_MAX_SGIX = 0x8315; ///
enum GL_FRAGMENTS_INSTRUMENT_SGIX = 0x8313; ///
enum GL_FRAGMENT_ALPHA_MODULATE_IMG = 0x8C08; ///
enum GL_FRAGMENT_COLOR_EXT = 0x834C; ///
enum GL_FRAGMENT_COLOR_MATERIAL_FACE_SGIX = 0x8402; ///
enum GL_FRAGMENT_COLOR_MATERIAL_PARAMETER_SGIX = 0x8403; ///
enum GL_FRAGMENT_COLOR_MATERIAL_SGIX = 0x8401; ///
enum GL_FRAGMENT_COVERAGE_COLOR_NV = 0x92DE; ///
enum GL_FRAGMENT_COVERAGE_TO_COLOR_NV = 0x92DD; ///
enum GL_FRAGMENT_DEPTH = 0x8452; ///
enum GL_FRAGMENT_DEPTH_EXT = 0x8452; ///
enum GL_FRAGMENT_INPUT_NV = 0x936D; ///
enum GL_FRAGMENT_INTERPOLATION_OFFSET_BITS = 0x8E5D; ///
enum GL_FRAGMENT_INTERPOLATION_OFFSET_BITS_OES = 0x8E5D; ///
enum GL_FRAGMENT_LIGHT0_SGIX = 0x840C; ///
enum GL_FRAGMENT_LIGHT1_SGIX = 0x840D; ///
enum GL_FRAGMENT_LIGHT2_SGIX = 0x840E; ///
enum GL_FRAGMENT_LIGHT3_SGIX = 0x840F; ///
enum GL_FRAGMENT_LIGHT4_SGIX = 0x8410; ///
enum GL_FRAGMENT_LIGHT5_SGIX = 0x8411; ///
enum GL_FRAGMENT_LIGHT6_SGIX = 0x8412; ///
enum GL_FRAGMENT_LIGHT7_SGIX = 0x8413; ///
enum GL_FRAGMENT_LIGHTING_SGIX = 0x8400; ///
enum GL_FRAGMENT_LIGHT_MODEL_AMBIENT_SGIX = 0x840A; ///
enum GL_FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER_SGIX = 0x8408; ///
enum GL_FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION_SGIX = 0x840B; ///
enum GL_FRAGMENT_LIGHT_MODEL_TWO_SIDE_SGIX = 0x8409; ///
enum GL_FRAGMENT_MATERIAL_EXT = 0x8349; ///
enum GL_FRAGMENT_NORMAL_EXT = 0x834A; ///
enum GL_FRAGMENT_PROGRAM_ARB = 0x8804; ///
enum GL_FRAGMENT_PROGRAM_BINDING_NV = 0x8873; ///
enum GL_FRAGMENT_PROGRAM_CALLBACK_DATA_MESA = 0x8BB3; ///
enum GL_FRAGMENT_PROGRAM_CALLBACK_FUNC_MESA = 0x8BB2; ///
enum GL_FRAGMENT_PROGRAM_CALLBACK_MESA = 0x8BB1; ///
enum GL_FRAGMENT_PROGRAM_INTERPOLATION_OFFSET_BITS_NV = 0x8E5D; ///
enum GL_FRAGMENT_PROGRAM_NV = 0x8870; ///
enum GL_FRAGMENT_PROGRAM_PARAMETER_BUFFER_NV = 0x8DA4; ///
enum GL_FRAGMENT_PROGRAM_POSITION_MESA = 0x8BB0; ///
enum GL_FRAGMENT_SHADER = 0x8B30; ///
enum GL_FRAGMENT_SHADER_ARB = 0x8B30; ///
enum GL_FRAGMENT_SHADER_ATI = 0x8920; ///
enum GL_FRAGMENT_SHADER_BIT = 0x00000002; ///
enum GL_FRAGMENT_SHADER_BIT_EXT = 0x00000002; ///
enum GL_FRAGMENT_SHADER_DERIVATIVE_HINT = 0x8B8B; ///
enum GL_FRAGMENT_SHADER_DERIVATIVE_HINT_ARB = 0x8B8B; ///
enum GL_FRAGMENT_SHADER_DERIVATIVE_HINT_OES = 0x8B8B; ///
enum GL_FRAGMENT_SHADER_DISCARDS_SAMPLES_EXT = 0x8A52; ///
enum GL_FRAGMENT_SHADER_FRAMEBUFFER_FETCH_MRT_ARM = 0x8F66; ///
enum GL_FRAGMENT_SHADER_INVOCATIONS_ARB = 0x82F4; ///
enum GL_FRAGMENT_SUBROUTINE = 0x92EC; ///
enum GL_FRAGMENT_SUBROUTINE_UNIFORM = 0x92F2; ///
enum GL_FRAGMENT_TEXTURE = 0x829F; ///
enum GL_FRAMEBUFFER = 0x8D40; ///
enum GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = 0x8215; ///
enum GL_FRAMEBUFFER_ATTACHMENT_ANGLE = 0x93A3; ///
enum GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = 0x8214; ///
enum GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 0x8210; ///
enum GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT = 0x8210; ///
enum GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = 0x8211; ///
enum GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT = 0x8211; ///
enum GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = 0x8216; ///
enum GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = 0x8213; ///
enum GL_FRAMEBUFFER_ATTACHMENT_LAYERED = 0x8DA7; ///
enum GL_FRAMEBUFFER_ATTACHMENT_LAYERED_ARB = 0x8DA7; ///
enum GL_FRAMEBUFFER_ATTACHMENT_LAYERED_EXT = 0x8DA7; ///
enum GL_FRAMEBUFFER_ATTACHMENT_LAYERED_OES = 0x8DA7; ///
enum GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 0x8CD1; ///
enum GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_EXT = 0x8CD1; ///
enum GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_OES = 0x8CD1; ///
enum GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 0x8CD0; ///
enum GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_EXT = 0x8CD0; ///
enum GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_OES = 0x8CD0; ///
enum GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE = 0x8212; ///
enum GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = 0x8217; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_EXT = 0x8CD4; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_OES = 0x8CD4; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_BASE_VIEW_INDEX_OVR = 0x9632; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_EXT = 0x8CD3; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_OES = 0x8CD3; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = 0x8CD4; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER_EXT = 0x8CD4; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 0x8CD2; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_EXT = 0x8CD2; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_OES = 0x8CD2; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_NUM_VIEWS_OVR = 0x9630; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_SAMPLES_EXT = 0x8D6C; ///
enum GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_SCALE_IMG = 0x913F; ///
enum GL_FRAMEBUFFER_BARRIER_BIT = 0x00000400; ///
enum GL_FRAMEBUFFER_BARRIER_BIT_EXT = 0x00000400; ///
enum GL_FRAMEBUFFER_BINDING = 0x8CA6; ///
enum GL_FRAMEBUFFER_BINDING_ANGLE = 0x8CA6; ///
enum GL_FRAMEBUFFER_BINDING_EXT = 0x8CA6; ///
enum GL_FRAMEBUFFER_BINDING_OES = 0x8CA6; ///
enum GL_FRAMEBUFFER_BLEND = 0x828B; ///
enum GL_FRAMEBUFFER_COMPLETE = 0x8CD5; ///
enum GL_FRAMEBUFFER_COMPLETE_EXT = 0x8CD5; ///
enum GL_FRAMEBUFFER_COMPLETE_OES = 0x8CD5; ///
enum GL_FRAMEBUFFER_DEFAULT = 0x8218; ///
enum GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS = 0x9314; ///
enum GL_FRAMEBUFFER_DEFAULT_HEIGHT = 0x9311; ///
enum GL_FRAMEBUFFER_DEFAULT_LAYERS = 0x9312; ///
enum GL_FRAMEBUFFER_DEFAULT_LAYERS_EXT = 0x9312; ///
enum GL_FRAMEBUFFER_DEFAULT_LAYERS_OES = 0x9312; ///
enum GL_FRAMEBUFFER_DEFAULT_SAMPLES = 0x9313; ///
enum GL_FRAMEBUFFER_DEFAULT_WIDTH = 0x9310; ///
enum GL_FRAMEBUFFER_EXT = 0x8D40; ///
enum GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6; ///
enum GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT = 0x8CD6; ///
enum GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_OES = 0x8CD6; ///
enum GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9; ///
enum GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT = 0x8CD9; ///
enum GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_OES = 0x8CD9; ///
enum GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER = 0x8CDB; ///
enum GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT = 0x8CDB; ///
enum GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_OES = 0x8CDB; ///
enum GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT = 0x8CDA; ///
enum GL_FRAMEBUFFER_INCOMPLETE_FORMATS_OES = 0x8CDA; ///
enum GL_FRAMEBUFFER_INCOMPLETE_INSUFFICIENT_SHADER_COMBINED_LOCAL_STORAGE_EXT = 0x9652; ///
enum GL_FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_ARB = 0x8DA9; ///
enum GL_FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_EXT = 0x8DA9; ///
enum GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS = 0x8DA8; ///
enum GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_ARB = 0x8DA8; ///
enum GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_EXT = 0x8DA8; ///
enum GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_OES = 0x8DA8; ///
enum GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7; ///
enum GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT = 0x8CD7; ///
enum GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_OES = 0x8CD7; ///
enum GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = 0x8D56; ///
enum GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_AND_DOWNSAMPLE_IMG = 0x913C; ///
enum GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_ANGLE = 0x8D56; ///
enum GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_APPLE = 0x8D56; ///
enum GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_EXT = 0x8D56; ///
enum GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_IMG = 0x9134; ///
enum GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_NV = 0x8D56; ///
enum GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER = 0x8CDC; ///
enum GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT = 0x8CDC; ///
enum GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_OES = 0x8CDC; ///
enum GL_FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_OVR = 0x9633; ///
enum GL_FRAMEBUFFER_OES = 0x8D40; ///
enum GL_FRAMEBUFFER_PROGRAMMABLE_SAMPLE_LOCATIONS_ARB = 0x9342; ///
enum GL_FRAMEBUFFER_PROGRAMMABLE_SAMPLE_LOCATIONS_NV = 0x9342; ///
enum GL_FRAMEBUFFER_RENDERABLE = 0x8289; ///
enum GL_FRAMEBUFFER_RENDERABLE_LAYERED = 0x828A; ///
enum GL_FRAMEBUFFER_SAMPLE_LOCATION_PIXEL_GRID_ARB = 0x9343; ///
enum GL_FRAMEBUFFER_SAMPLE_LOCATION_PIXEL_GRID_NV = 0x9343; ///
enum GL_FRAMEBUFFER_SRGB = 0x8DB9; ///
enum GL_FRAMEBUFFER_SRGB_CAPABLE_EXT = 0x8DBA; ///
enum GL_FRAMEBUFFER_SRGB_EXT = 0x8DB9; ///
enum GL_FRAMEBUFFER_UNDEFINED = 0x8219; ///
enum GL_FRAMEBUFFER_UNDEFINED_OES = 0x8219; ///
enum GL_FRAMEBUFFER_UNSUPPORTED = 0x8CDD; ///
enum GL_FRAMEBUFFER_UNSUPPORTED_EXT = 0x8CDD; ///
enum GL_FRAMEBUFFER_UNSUPPORTED_OES = 0x8CDD; ///
enum GL_FRAMEZOOM_FACTOR_SGIX = 0x818C; ///
enum GL_FRAMEZOOM_SGIX = 0x818B; ///
enum GL_FRAME_NV = 0x8E26; ///
enum GL_FRONT = 0x0404; ///
enum GL_FRONT_AND_BACK = 0x0408; ///
enum GL_FRONT_FACE = 0x0B46; ///
enum GL_FRONT_FACE_COMMAND_NV = 0x0012; ///
enum GL_FRONT_LEFT = 0x0400; ///
enum GL_FRONT_RIGHT = 0x0401; ///
enum GL_FULL_RANGE_EXT = 0x87E1; ///
enum GL_FULL_STIPPLE_HINT_PGI = 0x1A219; ///
enum GL_FULL_SUPPORT = 0x82B7; ///
enum GL_FUNC_ADD = 0x8006; ///
enum GL_FUNC_ADD_EXT = 0x8006; ///
enum GL_FUNC_ADD_OES = 0x8006; ///
enum GL_FUNC_REVERSE_SUBTRACT = 0x800B; ///
enum GL_FUNC_REVERSE_SUBTRACT_EXT = 0x800B; ///
enum GL_FUNC_REVERSE_SUBTRACT_OES = 0x800B; ///
enum GL_FUNC_SUBTRACT = 0x800A; ///
enum GL_FUNC_SUBTRACT_EXT = 0x800A; ///
enum GL_FUNC_SUBTRACT_OES = 0x800A; ///
enum GL_GCCSO_SHADER_BINARY_FJ = 0x9260; ///
enum GL_GENERATE_MIPMAP = 0x8191; ///
enum GL_GENERATE_MIPMAP_HINT = 0x8192; ///
enum GL_GENERATE_MIPMAP_HINT_SGIS = 0x8192; ///
enum GL_GENERATE_MIPMAP_SGIS = 0x8191; ///
enum GL_GENERIC_ATTRIB_NV = 0x8C7D; ///
enum GL_GEOMETRY_DEFORMATION_BIT_SGIX = 0x00000002; ///
enum GL_GEOMETRY_DEFORMATION_SGIX = 0x8194; ///
enum GL_GEOMETRY_INPUT_TYPE = 0x8917; ///
enum GL_GEOMETRY_INPUT_TYPE_ARB = 0x8DDB; ///
enum GL_GEOMETRY_INPUT_TYPE_EXT = 0x8DDB; ///
enum GL_GEOMETRY_LINKED_INPUT_TYPE_EXT = 0x8917; ///
enum GL_GEOMETRY_LINKED_INPUT_TYPE_OES = 0x8917; ///
enum GL_GEOMETRY_LINKED_OUTPUT_TYPE_EXT = 0x8918; ///
enum GL_GEOMETRY_LINKED_OUTPUT_TYPE_OES = 0x8918; ///
enum GL_GEOMETRY_LINKED_VERTICES_OUT_EXT = 0x8916; ///
enum GL_GEOMETRY_LINKED_VERTICES_OUT_OES = 0x8916; ///
enum GL_GEOMETRY_OUTPUT_TYPE = 0x8918; ///
enum GL_GEOMETRY_OUTPUT_TYPE_ARB = 0x8DDC; ///
enum GL_GEOMETRY_OUTPUT_TYPE_EXT = 0x8DDC; ///
enum GL_GEOMETRY_PROGRAM_NV = 0x8C26; ///
enum GL_GEOMETRY_PROGRAM_PARAMETER_BUFFER_NV = 0x8DA3; ///
enum GL_GEOMETRY_SHADER = 0x8DD9; ///
enum GL_GEOMETRY_SHADER_ARB = 0x8DD9; ///
enum GL_GEOMETRY_SHADER_BIT = 0x00000004; ///
enum GL_GEOMETRY_SHADER_BIT_EXT = 0x00000004; ///
enum GL_GEOMETRY_SHADER_BIT_OES = 0x00000004; ///
enum GL_GEOMETRY_SHADER_EXT = 0x8DD9; ///
enum GL_GEOMETRY_SHADER_INVOCATIONS = 0x887F; ///
enum GL_GEOMETRY_SHADER_INVOCATIONS_EXT = 0x887F; ///
enum GL_GEOMETRY_SHADER_INVOCATIONS_OES = 0x887F; ///
enum GL_GEOMETRY_SHADER_OES = 0x8DD9; ///
enum GL_GEOMETRY_SHADER_PRIMITIVES_EMITTED_ARB = 0x82F3; ///
enum GL_GEOMETRY_SUBROUTINE = 0x92EB; ///
enum GL_GEOMETRY_SUBROUTINE_UNIFORM = 0x92F1; ///
enum GL_GEOMETRY_TEXTURE = 0x829E; ///
enum GL_GEOMETRY_VERTICES_OUT = 0x8916; ///
enum GL_GEOMETRY_VERTICES_OUT_ARB = 0x8DDA; ///
enum GL_GEOMETRY_VERTICES_OUT_EXT = 0x8DDA; ///
enum GL_GEQUAL = 0x0206; ///
enum GL_GET_TEXTURE_IMAGE_FORMAT = 0x8291; ///
enum GL_GET_TEXTURE_IMAGE_TYPE = 0x8292; ///
enum GL_GLOBAL_ALPHA_FACTOR_SUN = 0x81DA; ///
enum GL_GLOBAL_ALPHA_SUN = 0x81D9; ///
enum GL_GLYPH_HAS_KERNING_BIT_NV = 0x100; ///
enum GL_GLYPH_HEIGHT_BIT_NV = 0x02; ///
enum GL_GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT_NV = 0x10; ///
enum GL_GLYPH_HORIZONTAL_BEARING_X_BIT_NV = 0x04; ///
enum GL_GLYPH_HORIZONTAL_BEARING_Y_BIT_NV = 0x08; ///
enum GL_GLYPH_VERTICAL_BEARING_ADVANCE_BIT_NV = 0x80; ///
enum GL_GLYPH_VERTICAL_BEARING_X_BIT_NV = 0x20; ///
enum GL_GLYPH_VERTICAL_BEARING_Y_BIT_NV = 0x40; ///
enum GL_GLYPH_WIDTH_BIT_NV = 0x01; ///
enum GL_GPU_ADDRESS_NV = 0x8F34; ///
enum GL_GPU_DISJOINT_EXT = 0x8FBB; ///
enum GL_GPU_MEMORY_INFO_CURRENT_AVAILABLE_VIDMEM_NVX = 0x9049; ///
enum GL_GPU_MEMORY_INFO_DEDICATED_VIDMEM_NVX = 0x9047; ///
enum GL_GPU_MEMORY_INFO_EVICTED_MEMORY_NVX = 0x904B; ///
enum GL_GPU_MEMORY_INFO_EVICTION_COUNT_NVX = 0x904A; ///
enum GL_GPU_MEMORY_INFO_TOTAL_AVAILABLE_MEMORY_NVX = 0x9048; ///
enum GL_GPU_OPTIMIZED_QCOM = 0x8FB2; ///
enum GL_GREATER = 0x0204; ///
enum GL_GREEN = 0x1904; ///
enum GL_GREEN_BIAS = 0x0D19; ///
enum GL_GREEN_BITS = 0x0D53; ///
enum GL_GREEN_BIT_ATI = 0x00000002; ///
enum GL_GREEN_INTEGER = 0x8D95; ///
enum GL_GREEN_INTEGER_EXT = 0x8D95; ///
enum GL_GREEN_MAX_CLAMP_INGR = 0x8565; ///
enum GL_GREEN_MIN_CLAMP_INGR = 0x8561; ///
enum GL_GREEN_NV = 0x1904; ///
enum GL_GREEN_SCALE = 0x0D18; ///
enum GL_GS_PROGRAM_BINARY_MTK = 0x9641; ///
enum GL_GS_SHADER_BINARY_MTK = 0x9640; ///
enum GL_GUILTY_CONTEXT_RESET = 0x8253; ///
enum GL_GUILTY_CONTEXT_RESET_ARB = 0x8253; ///
enum GL_GUILTY_CONTEXT_RESET_EXT = 0x8253; ///
enum GL_GUILTY_CONTEXT_RESET_KHR = 0x8253; ///
enum GL_HALF_APPLE = 0x140B; ///
enum GL_HALF_BIAS_NEGATE_NV = 0x853B; ///
enum GL_HALF_BIAS_NORMAL_NV = 0x853A; ///
enum GL_HALF_BIT_ATI = 0x00000008; ///
enum GL_HALF_FLOAT = 0x140B; ///
enum GL_HALF_FLOAT_ARB = 0x140B; ///
enum GL_HALF_FLOAT_NV = 0x140B; ///
enum GL_HALF_FLOAT_OES = 0x8D61; ///
enum GL_HARDLIGHT = 0x929B; ///
enum GL_HARDLIGHT_KHR = 0x929B; ///
enum GL_HARDLIGHT_NV = 0x929B; ///
enum GL_HARDMIX_NV = 0x92A9; ///
enum GL_HIGH_FLOAT = 0x8DF2; ///
enum GL_HIGH_INT = 0x8DF5; ///
enum GL_HILO16_NV = 0x86F8; ///
enum GL_HILO8_NV = 0x885E; ///
enum GL_HILO_NV = 0x86F4; ///
enum GL_HINT_BIT = 0x00008000; ///
enum GL_HISTOGRAM = 0x8024; ///
enum GL_HISTOGRAM_ALPHA_SIZE = 0x802B; ///
enum GL_HISTOGRAM_ALPHA_SIZE_EXT = 0x802B; ///
enum GL_HISTOGRAM_BLUE_SIZE = 0x802A; ///
enum GL_HISTOGRAM_BLUE_SIZE_EXT = 0x802A; ///
enum GL_HISTOGRAM_EXT = 0x8024; ///
enum GL_HISTOGRAM_FORMAT = 0x8027; ///
enum GL_HISTOGRAM_FORMAT_EXT = 0x8027; ///
enum GL_HISTOGRAM_GREEN_SIZE = 0x8029; ///
enum GL_HISTOGRAM_GREEN_SIZE_EXT = 0x8029; ///
enum GL_HISTOGRAM_LUMINANCE_SIZE = 0x802C; ///
enum GL_HISTOGRAM_LUMINANCE_SIZE_EXT = 0x802C; ///
enum GL_HISTOGRAM_RED_SIZE = 0x8028; ///
enum GL_HISTOGRAM_RED_SIZE_EXT = 0x8028; ///
enum GL_HISTOGRAM_SINK = 0x802D; ///
enum GL_HISTOGRAM_SINK_EXT = 0x802D; ///
enum GL_HISTOGRAM_WIDTH = 0x8026; ///
enum GL_HISTOGRAM_WIDTH_EXT = 0x8026; ///
enum GL_HI_BIAS_NV = 0x8714; ///
enum GL_HI_SCALE_NV = 0x870E; ///
enum GL_HORIZONTAL_LINE_TO_NV = 0x06; ///
enum GL_HSL_COLOR = 0x92AF; ///
enum GL_HSL_COLOR_KHR = 0x92AF; ///
enum GL_HSL_COLOR_NV = 0x92AF; ///
enum GL_HSL_HUE = 0x92AD; ///
enum GL_HSL_HUE_KHR = 0x92AD; ///
enum GL_HSL_HUE_NV = 0x92AD; ///
enum GL_HSL_LUMINOSITY = 0x92B0; ///
enum GL_HSL_LUMINOSITY_KHR = 0x92B0; ///
enum GL_HSL_LUMINOSITY_NV = 0x92B0; ///
enum GL_HSL_SATURATION = 0x92AE; ///
enum GL_HSL_SATURATION_KHR = 0x92AE; ///
enum GL_HSL_SATURATION_NV = 0x92AE; ///
enum GL_IDENTITY_NV = 0x862A; ///
enum GL_IGNORE_BORDER_HP = 0x8150; ///
enum GL_IMAGE_1D = 0x904C; ///
enum GL_IMAGE_1D_ARRAY = 0x9052; ///
enum GL_IMAGE_1D_ARRAY_EXT = 0x9052; ///
enum GL_IMAGE_1D_EXT = 0x904C; ///
enum GL_IMAGE_2D = 0x904D; ///
enum GL_IMAGE_2D_ARRAY = 0x9053; ///
enum GL_IMAGE_2D_ARRAY_EXT = 0x9053; ///
enum GL_IMAGE_2D_EXT = 0x904D; ///
enum GL_IMAGE_2D_MULTISAMPLE = 0x9055; ///
enum GL_IMAGE_2D_MULTISAMPLE_ARRAY = 0x9056; ///
enum GL_IMAGE_2D_MULTISAMPLE_ARRAY_EXT = 0x9056; ///
enum GL_IMAGE_2D_MULTISAMPLE_EXT = 0x9055; ///
enum GL_IMAGE_2D_RECT = 0x904F; ///
enum GL_IMAGE_2D_RECT_EXT = 0x904F; ///
enum GL_IMAGE_3D = 0x904E; ///
enum GL_IMAGE_3D_EXT = 0x904E; ///
enum GL_IMAGE_BINDING_ACCESS = 0x8F3E; ///
enum GL_IMAGE_BINDING_ACCESS_EXT = 0x8F3E; ///
enum GL_IMAGE_BINDING_FORMAT = 0x906E; ///
enum GL_IMAGE_BINDING_FORMAT_EXT = 0x906E; ///
enum GL_IMAGE_BINDING_LAYER = 0x8F3D; ///
enum GL_IMAGE_BINDING_LAYERED = 0x8F3C; ///
enum GL_IMAGE_BINDING_LAYERED_EXT = 0x8F3C; ///
enum GL_IMAGE_BINDING_LAYER_EXT = 0x8F3D; ///
enum GL_IMAGE_BINDING_LEVEL = 0x8F3B; ///
enum GL_IMAGE_BINDING_LEVEL_EXT = 0x8F3B; ///
enum GL_IMAGE_BINDING_NAME = 0x8F3A; ///
enum GL_IMAGE_BINDING_NAME_EXT = 0x8F3A; ///
enum GL_IMAGE_BUFFER = 0x9051; ///
enum GL_IMAGE_BUFFER_EXT = 0x9051; ///
enum GL_IMAGE_BUFFER_OES = 0x9051; ///
enum GL_IMAGE_CLASS_10_10_10_2 = 0x82C3; ///
enum GL_IMAGE_CLASS_11_11_10 = 0x82C2; ///
enum GL_IMAGE_CLASS_1_X_16 = 0x82BE; ///
enum GL_IMAGE_CLASS_1_X_32 = 0x82BB; ///
enum GL_IMAGE_CLASS_1_X_8 = 0x82C1; ///
enum GL_IMAGE_CLASS_2_X_16 = 0x82BD; ///
enum GL_IMAGE_CLASS_2_X_32 = 0x82BA; ///
enum GL_IMAGE_CLASS_2_X_8 = 0x82C0; ///
enum GL_IMAGE_CLASS_4_X_16 = 0x82BC; ///
enum GL_IMAGE_CLASS_4_X_32 = 0x82B9; ///
enum GL_IMAGE_CLASS_4_X_8 = 0x82BF; ///
enum GL_IMAGE_COMPATIBILITY_CLASS = 0x82A8; ///
enum GL_IMAGE_CUBE = 0x9050; ///
enum GL_IMAGE_CUBE_EXT = 0x9050; ///
enum GL_IMAGE_CUBE_MAP_ARRAY = 0x9054; ///
enum GL_IMAGE_CUBE_MAP_ARRAY_EXT = 0x9054; ///
enum GL_IMAGE_CUBE_MAP_ARRAY_OES = 0x9054; ///
enum GL_IMAGE_CUBIC_WEIGHT_HP = 0x815E; ///
enum GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS = 0x90C9; ///
enum GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE = 0x90C8; ///
enum GL_IMAGE_FORMAT_COMPATIBILITY_TYPE = 0x90C7; ///
enum GL_IMAGE_MAG_FILTER_HP = 0x815C; ///
enum GL_IMAGE_MIN_FILTER_HP = 0x815D; ///
enum GL_IMAGE_PIXEL_FORMAT = 0x82A9; ///
enum GL_IMAGE_PIXEL_TYPE = 0x82AA; ///
enum GL_IMAGE_ROTATE_ANGLE_HP = 0x8159; ///
enum GL_IMAGE_ROTATE_ORIGIN_X_HP = 0x815A; ///
enum GL_IMAGE_ROTATE_ORIGIN_Y_HP = 0x815B; ///
enum GL_IMAGE_SCALE_X_HP = 0x8155; ///
enum GL_IMAGE_SCALE_Y_HP = 0x8156; ///
enum GL_IMAGE_TEXEL_SIZE = 0x82A7; ///
enum GL_IMAGE_TRANSFORM_2D_HP = 0x8161; ///
enum GL_IMAGE_TRANSLATE_X_HP = 0x8157; ///
enum GL_IMAGE_TRANSLATE_Y_HP = 0x8158; ///
enum GL_IMPLEMENTATION_COLOR_READ_FORMAT = 0x8B9B; ///
enum GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES = 0x8B9B; ///
enum GL_IMPLEMENTATION_COLOR_READ_TYPE = 0x8B9A; ///
enum GL_IMPLEMENTATION_COLOR_READ_TYPE_OES = 0x8B9A; ///
enum GL_INCLUSIVE_EXT = 0x8F10; ///
enum GL_INCR = 0x1E02; ///
enum GL_INCR_WRAP = 0x8507; ///
enum GL_INCR_WRAP_EXT = 0x8507; ///
enum GL_INCR_WRAP_OES = 0x8507; ///
enum GL_INDEX = 0x8222; ///
enum GL_INDEX_ARRAY = 0x8077; ///
enum GL_INDEX_ARRAY_ADDRESS_NV = 0x8F24; ///
enum GL_INDEX_ARRAY_BUFFER_BINDING = 0x8899; ///
enum GL_INDEX_ARRAY_BUFFER_BINDING_ARB = 0x8899; ///
enum GL_INDEX_ARRAY_COUNT_EXT = 0x8087; ///
enum GL_INDEX_ARRAY_EXT = 0x8077; ///
enum GL_INDEX_ARRAY_LENGTH_NV = 0x8F2E; ///
enum GL_INDEX_ARRAY_LIST_IBM = 0x103073; ///
enum GL_INDEX_ARRAY_LIST_STRIDE_IBM = 0x103083; ///
enum GL_INDEX_ARRAY_POINTER = 0x8091; ///
enum GL_INDEX_ARRAY_POINTER_EXT = 0x8091; ///
enum GL_INDEX_ARRAY_STRIDE = 0x8086; ///
enum GL_INDEX_ARRAY_STRIDE_EXT = 0x8086; ///
enum GL_INDEX_ARRAY_TYPE = 0x8085; ///
enum GL_INDEX_ARRAY_TYPE_EXT = 0x8085; ///
enum GL_INDEX_BITS = 0x0D51; ///
enum GL_INDEX_BIT_PGI = 0x00080000; ///
enum GL_INDEX_CLEAR_VALUE = 0x0C20; ///
enum GL_INDEX_LOGIC_OP = 0x0BF1; ///
enum GL_INDEX_MATERIAL_EXT = 0x81B8; ///
enum GL_INDEX_MATERIAL_FACE_EXT = 0x81BA; ///
enum GL_INDEX_MATERIAL_PARAMETER_EXT = 0x81B9; ///
enum GL_INDEX_MODE = 0x0C30; ///
enum GL_INDEX_OFFSET = 0x0D13; ///
enum GL_INDEX_SHIFT = 0x0D12; ///
enum GL_INDEX_TEST_EXT = 0x81B5; ///
enum GL_INDEX_TEST_FUNC_EXT = 0x81B6; ///
enum GL_INDEX_TEST_REF_EXT = 0x81B7; ///
enum GL_INDEX_WRITEMASK = 0x0C21; ///
enum GL_INFO_LOG_LENGTH = 0x8B84; ///
enum GL_INNOCENT_CONTEXT_RESET = 0x8254; ///
enum GL_INNOCENT_CONTEXT_RESET_ARB = 0x8254; ///
enum GL_INNOCENT_CONTEXT_RESET_EXT = 0x8254; ///
enum GL_INNOCENT_CONTEXT_RESET_KHR = 0x8254; ///
enum GL_INSTRUMENT_BUFFER_POINTER_SGIX = 0x8180; ///
enum GL_INSTRUMENT_MEASUREMENTS_SGIX = 0x8181; ///
enum GL_INT = 0x1404; ///
enum GL_INT16_NV = 0x8FE4; ///
enum GL_INT16_VEC2_NV = 0x8FE5; ///
enum GL_INT16_VEC3_NV = 0x8FE6; ///
enum GL_INT16_VEC4_NV = 0x8FE7; ///
enum GL_INT64_ARB = 0x140E; ///
enum GL_INT64_NV = 0x140E; ///
enum GL_INT64_VEC2_ARB = 0x8FE9; ///
enum GL_INT64_VEC2_NV = 0x8FE9; ///
enum GL_INT64_VEC3_ARB = 0x8FEA; ///
enum GL_INT64_VEC3_NV = 0x8FEA; ///
enum GL_INT64_VEC4_ARB = 0x8FEB; ///
enum GL_INT64_VEC4_NV = 0x8FEB; ///
enum GL_INT8_NV = 0x8FE0; ///
enum GL_INT8_VEC2_NV = 0x8FE1; ///
enum GL_INT8_VEC3_NV = 0x8FE2; ///
enum GL_INT8_VEC4_NV = 0x8FE3; ///
enum GL_INTENSITY = 0x8049; ///
enum GL_INTENSITY12 = 0x804C; ///
enum GL_INTENSITY12_EXT = 0x804C; ///
enum GL_INTENSITY16 = 0x804D; ///
enum GL_INTENSITY16F_ARB = 0x881D; ///
enum GL_INTENSITY16I_EXT = 0x8D8B; ///
enum GL_INTENSITY16UI_EXT = 0x8D79; ///
enum GL_INTENSITY16_EXT = 0x804D; ///
enum GL_INTENSITY16_SNORM = 0x901B; ///
enum GL_INTENSITY32F_ARB = 0x8817; ///
enum GL_INTENSITY32I_EXT = 0x8D85; ///
enum GL_INTENSITY32UI_EXT = 0x8D73; ///
enum GL_INTENSITY4 = 0x804A; ///
enum GL_INTENSITY4_EXT = 0x804A; ///
enum GL_INTENSITY8 = 0x804B; ///
enum GL_INTENSITY8I_EXT = 0x8D91; ///
enum GL_INTENSITY8UI_EXT = 0x8D7F; ///
enum GL_INTENSITY8_EXT = 0x804B; ///
enum GL_INTENSITY8_SNORM = 0x9017; ///
enum GL_INTENSITY_EXT = 0x8049; ///
enum GL_INTENSITY_FLOAT16_APPLE = 0x881D; ///
enum GL_INTENSITY_FLOAT16_ATI = 0x881D; ///
enum GL_INTENSITY_FLOAT32_APPLE = 0x8817; ///
enum GL_INTENSITY_FLOAT32_ATI = 0x8817; ///
enum GL_INTENSITY_SNORM = 0x9013; ///
enum GL_INTERLACE_OML = 0x8980; ///
enum GL_INTERLACE_READ_INGR = 0x8568; ///
enum GL_INTERLACE_READ_OML = 0x8981; ///
enum GL_INTERLACE_SGIX = 0x8094; ///
enum GL_INTERLEAVED_ATTRIBS = 0x8C8C; ///
enum GL_INTERLEAVED_ATTRIBS_EXT = 0x8C8C; ///
enum GL_INTERLEAVED_ATTRIBS_NV = 0x8C8C; ///
enum GL_INTERNALFORMAT_ALPHA_SIZE = 0x8274; ///
enum GL_INTERNALFORMAT_ALPHA_TYPE = 0x827B; ///
enum GL_INTERNALFORMAT_BLUE_SIZE = 0x8273; ///
enum GL_INTERNALFORMAT_BLUE_TYPE = 0x827A; ///
enum GL_INTERNALFORMAT_DEPTH_SIZE = 0x8275; ///
enum GL_INTERNALFORMAT_DEPTH_TYPE = 0x827C; ///
enum GL_INTERNALFORMAT_GREEN_SIZE = 0x8272; ///
enum GL_INTERNALFORMAT_GREEN_TYPE = 0x8279; ///
enum GL_INTERNALFORMAT_PREFERRED = 0x8270; ///
enum GL_INTERNALFORMAT_RED_SIZE = 0x8271; ///
enum GL_INTERNALFORMAT_RED_TYPE = 0x8278; ///
enum GL_INTERNALFORMAT_SHARED_SIZE = 0x8277; ///
enum GL_INTERNALFORMAT_STENCIL_SIZE = 0x8276; ///
enum GL_INTERNALFORMAT_STENCIL_TYPE = 0x827D; ///
enum GL_INTERNALFORMAT_SUPPORTED = 0x826F; ///
enum GL_INTERPOLATE = 0x8575; ///
enum GL_INTERPOLATE_ARB = 0x8575; ///
enum GL_INTERPOLATE_EXT = 0x8575; ///
enum GL_INT_10_10_10_2_OES = 0x8DF7; ///
enum GL_INT_2_10_10_10_REV = 0x8D9F; ///
enum GL_INT_IMAGE_1D = 0x9057; ///
enum GL_INT_IMAGE_1D_ARRAY = 0x905D; ///
enum GL_INT_IMAGE_1D_ARRAY_EXT = 0x905D; ///
enum GL_INT_IMAGE_1D_EXT = 0x9057; ///
enum GL_INT_IMAGE_2D = 0x9058; ///
enum GL_INT_IMAGE_2D_ARRAY = 0x905E; ///
enum GL_INT_IMAGE_2D_ARRAY_EXT = 0x905E; ///
enum GL_INT_IMAGE_2D_EXT = 0x9058; ///
enum GL_INT_IMAGE_2D_MULTISAMPLE = 0x9060; ///
enum GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY = 0x9061; ///
enum GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY_EXT = 0x9061; ///
enum GL_INT_IMAGE_2D_MULTISAMPLE_EXT = 0x9060; ///
enum GL_INT_IMAGE_2D_RECT = 0x905A; ///
enum GL_INT_IMAGE_2D_RECT_EXT = 0x905A; ///
enum GL_INT_IMAGE_3D = 0x9059; ///
enum GL_INT_IMAGE_3D_EXT = 0x9059; ///
enum GL_INT_IMAGE_BUFFER = 0x905C; ///
enum GL_INT_IMAGE_BUFFER_EXT = 0x905C; ///
enum GL_INT_IMAGE_BUFFER_OES = 0x905C; ///
enum GL_INT_IMAGE_CUBE = 0x905B; ///
enum GL_INT_IMAGE_CUBE_EXT = 0x905B; ///
enum GL_INT_IMAGE_CUBE_MAP_ARRAY = 0x905F; ///
enum GL_INT_IMAGE_CUBE_MAP_ARRAY_EXT = 0x905F; ///
enum GL_INT_IMAGE_CUBE_MAP_ARRAY_OES = 0x905F; ///
enum GL_INT_SAMPLER_1D = 0x8DC9; ///
enum GL_INT_SAMPLER_1D_ARRAY = 0x8DCE; ///
enum GL_INT_SAMPLER_1D_ARRAY_EXT = 0x8DCE; ///
enum GL_INT_SAMPLER_1D_EXT = 0x8DC9; ///
enum GL_INT_SAMPLER_2D = 0x8DCA; ///
enum GL_INT_SAMPLER_2D_ARRAY = 0x8DCF; ///
enum GL_INT_SAMPLER_2D_ARRAY_EXT = 0x8DCF; ///
enum GL_INT_SAMPLER_2D_EXT = 0x8DCA; ///
enum GL_INT_SAMPLER_2D_MULTISAMPLE = 0x9109; ///
enum GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY = 0x910C; ///
enum GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY_OES = 0x910C; ///
enum GL_INT_SAMPLER_2D_RECT = 0x8DCD; ///
enum GL_INT_SAMPLER_2D_RECT_EXT = 0x8DCD; ///
enum GL_INT_SAMPLER_3D = 0x8DCB; ///
enum GL_INT_SAMPLER_3D_EXT = 0x8DCB; ///
enum GL_INT_SAMPLER_BUFFER = 0x8DD0; ///
enum GL_INT_SAMPLER_BUFFER_AMD = 0x9002; ///
enum GL_INT_SAMPLER_BUFFER_EXT = 0x8DD0; ///
enum GL_INT_SAMPLER_BUFFER_OES = 0x8DD0; ///
enum GL_INT_SAMPLER_CUBE = 0x8DCC; ///
enum GL_INT_SAMPLER_CUBE_EXT = 0x8DCC; ///
enum GL_INT_SAMPLER_CUBE_MAP_ARRAY = 0x900E; ///
enum GL_INT_SAMPLER_CUBE_MAP_ARRAY_ARB = 0x900E; ///
enum GL_INT_SAMPLER_CUBE_MAP_ARRAY_EXT = 0x900E; ///
enum GL_INT_SAMPLER_CUBE_MAP_ARRAY_OES = 0x900E; ///
enum GL_INT_SAMPLER_RENDERBUFFER_NV = 0x8E57; ///
enum GL_INT_VEC2 = 0x8B53; ///
enum GL_INT_VEC2_ARB = 0x8B53; ///
enum GL_INT_VEC3 = 0x8B54; ///
enum GL_INT_VEC3_ARB = 0x8B54; ///
enum GL_INT_VEC4 = 0x8B55; ///
enum GL_INT_VEC4_ARB = 0x8B55; ///
enum GL_INVALID_ENUM = 0x0500; ///
enum GL_INVALID_FRAMEBUFFER_OPERATION = 0x0506; ///
enum GL_INVALID_FRAMEBUFFER_OPERATION_EXT = 0x0506; ///
enum GL_INVALID_FRAMEBUFFER_OPERATION_OES = 0x0506; ///
enum GL_INVALID_INDEX = 0xFFFFFFFF; ///
enum GL_INVALID_OPERATION = 0x0502; ///
enum GL_INVALID_VALUE = 0x0501; ///
enum GL_INVARIANT_DATATYPE_EXT = 0x87EB; ///
enum GL_INVARIANT_EXT = 0x87C2; ///
enum GL_INVARIANT_VALUE_EXT = 0x87EA; ///
enum GL_INVERSE_NV = 0x862B; ///
enum GL_INVERSE_TRANSPOSE_NV = 0x862D; ///
enum GL_INVERT = 0x150A; ///
enum GL_INVERTED_SCREEN_W_REND = 0x8491; ///
enum GL_INVERT_OVG_NV = 0x92B4; ///
enum GL_INVERT_RGB_NV = 0x92A3; ///
enum GL_IR_INSTRUMENT1_SGIX = 0x817F; ///
enum GL_ISOLINES = 0x8E7A; ///
enum GL_ISOLINES_EXT = 0x8E7A; ///
enum GL_ISOLINES_OES = 0x8E7A; ///
enum GL_IS_PER_PATCH = 0x92E7; ///
enum GL_IS_PER_PATCH_EXT = 0x92E7; ///
enum GL_IS_PER_PATCH_OES = 0x92E7; ///
enum GL_IS_ROW_MAJOR = 0x9300; ///
enum GL_ITALIC_BIT_NV = 0x02; ///
enum GL_IUI_N3F_V2F_EXT = 0x81AF; ///
enum GL_IUI_N3F_V3F_EXT = 0x81B0; ///
enum GL_IUI_V2F_EXT = 0x81AD; ///
enum GL_IUI_V3F_EXT = 0x81AE; ///
enum GL_KEEP = 0x1E00; ///
enum GL_LARGE_CCW_ARC_TO_NV = 0x16; ///
enum GL_LARGE_CW_ARC_TO_NV = 0x18; ///
enum GL_LAST_VERTEX_CONVENTION = 0x8E4E; ///
enum GL_LAST_VERTEX_CONVENTION_EXT = 0x8E4E; ///
enum GL_LAST_VERTEX_CONVENTION_OES = 0x8E4E; ///
enum GL_LAST_VIDEO_CAPTURE_STATUS_NV = 0x9027; ///
enum GL_LAYER_NV = 0x8DAA; ///
enum GL_LAYER_PROVOKING_VERTEX = 0x825E; ///
enum GL_LAYER_PROVOKING_VERTEX_EXT = 0x825E; ///
enum GL_LAYER_PROVOKING_VERTEX_OES = 0x825E; ///
enum GL_LAYOUT_DEFAULT_INTEL = 0; ///
enum GL_LAYOUT_LINEAR_CPU_CACHED_INTEL = 2; ///
enum GL_LAYOUT_LINEAR_INTEL = 1; ///
enum GL_LEFT = 0x0406; ///
enum GL_LEQUAL = 0x0203; ///
enum GL_LERP_ATI = 0x8969; ///
enum GL_LESS = 0x0201; ///
enum GL_LIGHT0 = 0x4000; ///
enum GL_LIGHT1 = 0x4001; ///
enum GL_LIGHT2 = 0x4002; ///
enum GL_LIGHT3 = 0x4003; ///
enum GL_LIGHT4 = 0x4004; ///
enum GL_LIGHT5 = 0x4005; ///
enum GL_LIGHT6 = 0x4006; ///
enum GL_LIGHT7 = 0x4007; ///
enum GL_LIGHTEN = 0x9298; ///
enum GL_LIGHTEN_KHR = 0x9298; ///
enum GL_LIGHTEN_NV = 0x9298; ///
enum GL_LIGHTING = 0x0B50; ///
enum GL_LIGHTING_BIT = 0x00000040; ///
enum GL_LIGHT_ENV_MODE_SGIX = 0x8407; ///
enum GL_LIGHT_MODEL_AMBIENT = 0x0B53; ///
enum GL_LIGHT_MODEL_COLOR_CONTROL = 0x81F8; ///
enum GL_LIGHT_MODEL_COLOR_CONTROL_EXT = 0x81F8; ///
enum GL_LIGHT_MODEL_LOCAL_VIEWER = 0x0B51; ///
enum GL_LIGHT_MODEL_SPECULAR_VECTOR_APPLE = 0x85B0; ///
enum GL_LIGHT_MODEL_TWO_SIDE = 0x0B52; ///
enum GL_LINE = 0x1B01; ///
enum GL_LINEAR = 0x2601; ///
enum GL_LINEARBURN_NV = 0x92A5; ///
enum GL_LINEARDODGE_NV = 0x92A4; ///
enum GL_LINEARLIGHT_NV = 0x92A7; ///
enum GL_LINEAR_ATTENUATION = 0x1208; ///
enum GL_LINEAR_CLIPMAP_LINEAR_SGIX = 0x8170; ///
enum GL_LINEAR_CLIPMAP_NEAREST_SGIX = 0x844F; ///
enum GL_LINEAR_DETAIL_ALPHA_SGIS = 0x8098; ///
enum GL_LINEAR_DETAIL_COLOR_SGIS = 0x8099; ///
enum GL_LINEAR_DETAIL_SGIS = 0x8097; ///
enum GL_LINEAR_MIPMAP_LINEAR = 0x2703; ///
enum GL_LINEAR_MIPMAP_NEAREST = 0x2701; ///
enum GL_LINEAR_SHARPEN_ALPHA_SGIS = 0x80AE; ///
enum GL_LINEAR_SHARPEN_COLOR_SGIS = 0x80AF; ///
enum GL_LINEAR_SHARPEN_SGIS = 0x80AD; ///
enum GL_LINES = 0x0001; ///
enum GL_LINES_ADJACENCY = 0x000A; ///
enum GL_LINES_ADJACENCY_ARB = 0x000A; ///
enum GL_LINES_ADJACENCY_EXT = 0x000A; ///
enum GL_LINES_ADJACENCY_OES = 0x000A; ///
enum GL_LINE_BIT = 0x00000004; ///
enum GL_LINE_LOOP = 0x0002; ///
enum GL_LINE_NV = 0x1B01; ///
enum GL_LINE_QUALITY_HINT_SGIX = 0x835B; ///
enum GL_LINE_RESET_TOKEN = 0x0707; ///
enum GL_LINE_SMOOTH = 0x0B20; ///
enum GL_LINE_SMOOTH_HINT = 0x0C52; ///
enum GL_LINE_STIPPLE = 0x0B24; ///
enum GL_LINE_STIPPLE_PATTERN = 0x0B25; ///
enum GL_LINE_STIPPLE_REPEAT = 0x0B26; ///
enum GL_LINE_STRIP = 0x0003; ///
enum GL_LINE_STRIP_ADJACENCY = 0x000B; ///
enum GL_LINE_STRIP_ADJACENCY_ARB = 0x000B; ///
enum GL_LINE_STRIP_ADJACENCY_EXT = 0x000B; ///
enum GL_LINE_STRIP_ADJACENCY_OES = 0x000B; ///
enum GL_LINE_TOKEN = 0x0702; ///
enum GL_LINE_TO_NV = 0x04; ///
enum GL_LINE_WIDTH = 0x0B21; ///
enum GL_LINE_WIDTH_COMMAND_NV = 0x000D; ///
enum GL_LINE_WIDTH_GRANULARITY = 0x0B23; ///
enum GL_LINE_WIDTH_RANGE = 0x0B22; ///
enum GL_LINK_STATUS = 0x8B82; ///
enum GL_LIST_BASE = 0x0B32; ///
enum GL_LIST_BIT = 0x00020000; ///
enum GL_LIST_INDEX = 0x0B33; ///
enum GL_LIST_MODE = 0x0B30; ///
enum GL_LIST_PRIORITY_SGIX = 0x8182; ///
enum GL_LOAD = 0x0101; ///
enum GL_LOCAL_CONSTANT_DATATYPE_EXT = 0x87ED; ///
enum GL_LOCAL_CONSTANT_EXT = 0x87C3; ///
enum GL_LOCAL_CONSTANT_VALUE_EXT = 0x87EC; ///
enum GL_LOCAL_EXT = 0x87C4; ///
enum GL_LOCATION = 0x930E; ///
enum GL_LOCATION_COMPONENT = 0x934A; ///
enum GL_LOCATION_INDEX = 0x930F; ///
enum GL_LOCATION_INDEX_EXT = 0x930F; ///
enum GL_LOGIC_OP = 0x0BF1; ///
enum GL_LOGIC_OP_MODE = 0x0BF0; ///
enum GL_LOSE_CONTEXT_ON_RESET = 0x8252; ///
enum GL_LOSE_CONTEXT_ON_RESET_ARB = 0x8252; ///
enum GL_LOSE_CONTEXT_ON_RESET_EXT = 0x8252; ///
enum GL_LOSE_CONTEXT_ON_RESET_KHR = 0x8252; ///
enum GL_LOWER_LEFT = 0x8CA1; ///
enum GL_LOW_FLOAT = 0x8DF0; ///
enum GL_LOW_INT = 0x8DF3; ///
enum GL_LO_BIAS_NV = 0x8715; ///
enum GL_LO_SCALE_NV = 0x870F; ///
enum GL_LUMINANCE = 0x1909; ///
enum GL_LUMINANCE12 = 0x8041; ///
enum GL_LUMINANCE12_ALPHA12 = 0x8047; ///
enum GL_LUMINANCE12_ALPHA12_EXT = 0x8047; ///
enum GL_LUMINANCE12_ALPHA4 = 0x8046; ///
enum GL_LUMINANCE12_ALPHA4_EXT = 0x8046; ///
enum GL_LUMINANCE12_EXT = 0x8041; ///
enum GL_LUMINANCE16 = 0x8042; ///
enum GL_LUMINANCE16F_ARB = 0x881E; ///
enum GL_LUMINANCE16F_EXT = 0x881E; ///
enum GL_LUMINANCE16I_EXT = 0x8D8C; ///
enum GL_LUMINANCE16UI_EXT = 0x8D7A; ///
enum GL_LUMINANCE16_ALPHA16 = 0x8048; ///
enum GL_LUMINANCE16_ALPHA16_EXT = 0x8048; ///
enum GL_LUMINANCE16_ALPHA16_SNORM = 0x901A; ///
enum GL_LUMINANCE16_EXT = 0x8042; ///
enum GL_LUMINANCE16_SNORM = 0x9019; ///
enum GL_LUMINANCE32F_ARB = 0x8818; ///
enum GL_LUMINANCE32F_EXT = 0x8818; ///
enum GL_LUMINANCE32I_EXT = 0x8D86; ///
enum GL_LUMINANCE32UI_EXT = 0x8D74; ///
enum GL_LUMINANCE4 = 0x803F; ///
enum GL_LUMINANCE4_ALPHA4 = 0x8043; ///
enum GL_LUMINANCE4_ALPHA4_EXT = 0x8043; ///
enum GL_LUMINANCE4_ALPHA4_OES = 0x8043; ///
enum GL_LUMINANCE4_EXT = 0x803F; ///
enum GL_LUMINANCE6_ALPHA2 = 0x8044; ///
enum GL_LUMINANCE6_ALPHA2_EXT = 0x8044; ///
enum GL_LUMINANCE8 = 0x8040; ///
enum GL_LUMINANCE8I_EXT = 0x8D92; ///
enum GL_LUMINANCE8UI_EXT = 0x8D80; ///
enum GL_LUMINANCE8_ALPHA8 = 0x8045; ///
enum GL_LUMINANCE8_ALPHA8_EXT = 0x8045; ///
enum GL_LUMINANCE8_ALPHA8_OES = 0x8045; ///
enum GL_LUMINANCE8_ALPHA8_SNORM = 0x9016; ///
enum GL_LUMINANCE8_EXT = 0x8040; ///
enum GL_LUMINANCE8_OES = 0x8040; ///
enum GL_LUMINANCE8_SNORM = 0x9015; ///
enum GL_LUMINANCE_ALPHA = 0x190A; ///
enum GL_LUMINANCE_ALPHA16F_ARB = 0x881F; ///
enum GL_LUMINANCE_ALPHA16F_EXT = 0x881F; ///
enum GL_LUMINANCE_ALPHA16I_EXT = 0x8D8D; ///
enum GL_LUMINANCE_ALPHA16UI_EXT = 0x8D7B; ///
enum GL_LUMINANCE_ALPHA32F_ARB = 0x8819; ///
enum GL_LUMINANCE_ALPHA32F_EXT = 0x8819; ///
enum GL_LUMINANCE_ALPHA32I_EXT = 0x8D87; ///
enum GL_LUMINANCE_ALPHA32UI_EXT = 0x8D75; ///
enum GL_LUMINANCE_ALPHA8I_EXT = 0x8D93; ///
enum GL_LUMINANCE_ALPHA8UI_EXT = 0x8D81; ///
enum GL_LUMINANCE_ALPHA_FLOAT16_APPLE = 0x881F; ///
enum GL_LUMINANCE_ALPHA_FLOAT16_ATI = 0x881F; ///
enum GL_LUMINANCE_ALPHA_FLOAT32_APPLE = 0x8819; ///
enum GL_LUMINANCE_ALPHA_FLOAT32_ATI = 0x8819; ///
enum GL_LUMINANCE_ALPHA_INTEGER_EXT = 0x8D9D; ///
enum GL_LUMINANCE_ALPHA_SNORM = 0x9012; ///
enum GL_LUMINANCE_FLOAT16_APPLE = 0x881E; ///
enum GL_LUMINANCE_FLOAT16_ATI = 0x881E; ///
enum GL_LUMINANCE_FLOAT32_APPLE = 0x8818; ///
enum GL_LUMINANCE_FLOAT32_ATI = 0x8818; ///
enum GL_LUMINANCE_INTEGER_EXT = 0x8D9C; ///
enum GL_LUMINANCE_SNORM = 0x9011; ///
enum GL_MAD_ATI = 0x8968; ///
enum GL_MAGNITUDE_BIAS_NV = 0x8718; ///
enum GL_MAGNITUDE_SCALE_NV = 0x8712; ///
enum GL_MAJOR_VERSION = 0x821B; ///
enum GL_MALI_PROGRAM_BINARY_ARM = 0x8F61; ///
enum GL_MALI_SHADER_BINARY_ARM = 0x8F60; ///
enum GL_MANUAL_GENERATE_MIPMAP = 0x8294; ///
enum GL_MAP1_BINORMAL_EXT = 0x8446; ///
enum GL_MAP1_COLOR_4 = 0x0D90; ///
enum GL_MAP1_GRID_DOMAIN = 0x0DD0; ///
enum GL_MAP1_GRID_SEGMENTS = 0x0DD1; ///
enum GL_MAP1_INDEX = 0x0D91; ///
enum GL_MAP1_NORMAL = 0x0D92; ///
enum GL_MAP1_TANGENT_EXT = 0x8444; ///
enum GL_MAP1_TEXTURE_COORD_1 = 0x0D93; ///
enum GL_MAP1_TEXTURE_COORD_2 = 0x0D94; ///
enum GL_MAP1_TEXTURE_COORD_3 = 0x0D95; ///
enum GL_MAP1_TEXTURE_COORD_4 = 0x0D96; ///
enum GL_MAP1_VERTEX_3 = 0x0D97; ///
enum GL_MAP1_VERTEX_4 = 0x0D98; ///
enum GL_MAP1_VERTEX_ATTRIB0_4_NV = 0x8660; ///
enum GL_MAP1_VERTEX_ATTRIB10_4_NV = 0x866A; ///
enum GL_MAP1_VERTEX_ATTRIB11_4_NV = 0x866B; ///
enum GL_MAP1_VERTEX_ATTRIB12_4_NV = 0x866C; ///
enum GL_MAP1_VERTEX_ATTRIB13_4_NV = 0x866D; ///
enum GL_MAP1_VERTEX_ATTRIB14_4_NV = 0x866E; ///
enum GL_MAP1_VERTEX_ATTRIB15_4_NV = 0x866F; ///
enum GL_MAP1_VERTEX_ATTRIB1_4_NV = 0x8661; ///
enum GL_MAP1_VERTEX_ATTRIB2_4_NV = 0x8662; ///
enum GL_MAP1_VERTEX_ATTRIB3_4_NV = 0x8663; ///
enum GL_MAP1_VERTEX_ATTRIB4_4_NV = 0x8664; ///
enum GL_MAP1_VERTEX_ATTRIB5_4_NV = 0x8665; ///
enum GL_MAP1_VERTEX_ATTRIB6_4_NV = 0x8666; ///
enum GL_MAP1_VERTEX_ATTRIB7_4_NV = 0x8667; ///
enum GL_MAP1_VERTEX_ATTRIB8_4_NV = 0x8668; ///
enum GL_MAP1_VERTEX_ATTRIB9_4_NV = 0x8669; ///
enum GL_MAP2_BINORMAL_EXT = 0x8447; ///
enum GL_MAP2_COLOR_4 = 0x0DB0; ///
enum GL_MAP2_GRID_DOMAIN = 0x0DD2; ///
enum GL_MAP2_GRID_SEGMENTS = 0x0DD3; ///
enum GL_MAP2_INDEX = 0x0DB1; ///
enum GL_MAP2_NORMAL = 0x0DB2; ///
enum GL_MAP2_TANGENT_EXT = 0x8445; ///
enum GL_MAP2_TEXTURE_COORD_1 = 0x0DB3; ///
enum GL_MAP2_TEXTURE_COORD_2 = 0x0DB4; ///
enum GL_MAP2_TEXTURE_COORD_3 = 0x0DB5; ///
enum GL_MAP2_TEXTURE_COORD_4 = 0x0DB6; ///
enum GL_MAP2_VERTEX_3 = 0x0DB7; ///
enum GL_MAP2_VERTEX_4 = 0x0DB8; ///
enum GL_MAP2_VERTEX_ATTRIB0_4_NV = 0x8670; ///
enum GL_MAP2_VERTEX_ATTRIB10_4_NV = 0x867A; ///
enum GL_MAP2_VERTEX_ATTRIB11_4_NV = 0x867B; ///
enum GL_MAP2_VERTEX_ATTRIB12_4_NV = 0x867C; ///
enum GL_MAP2_VERTEX_ATTRIB13_4_NV = 0x867D; ///
enum GL_MAP2_VERTEX_ATTRIB14_4_NV = 0x867E; ///
enum GL_MAP2_VERTEX_ATTRIB15_4_NV = 0x867F; ///
enum GL_MAP2_VERTEX_ATTRIB1_4_NV = 0x8671; ///
enum GL_MAP2_VERTEX_ATTRIB2_4_NV = 0x8672; ///
enum GL_MAP2_VERTEX_ATTRIB3_4_NV = 0x8673; ///
enum GL_MAP2_VERTEX_ATTRIB4_4_NV = 0x8674; ///
enum GL_MAP2_VERTEX_ATTRIB5_4_NV = 0x8675; ///
enum GL_MAP2_VERTEX_ATTRIB6_4_NV = 0x8676; ///
enum GL_MAP2_VERTEX_ATTRIB7_4_NV = 0x8677; ///
enum GL_MAP2_VERTEX_ATTRIB8_4_NV = 0x8678; ///
enum GL_MAP2_VERTEX_ATTRIB9_4_NV = 0x8679; ///
enum GL_MAP_ATTRIB_U_ORDER_NV = 0x86C3; ///
enum GL_MAP_ATTRIB_V_ORDER_NV = 0x86C4; ///
enum GL_MAP_COHERENT_BIT = 0x0080; ///
enum GL_MAP_COHERENT_BIT_EXT = 0x0080; ///
enum GL_MAP_COLOR = 0x0D10; ///
enum GL_MAP_FLUSH_EXPLICIT_BIT = 0x0010; ///
enum GL_MAP_FLUSH_EXPLICIT_BIT_EXT = 0x0010; ///
enum GL_MAP_INVALIDATE_BUFFER_BIT = 0x0008; ///
enum GL_MAP_INVALIDATE_BUFFER_BIT_EXT = 0x0008; ///
enum GL_MAP_INVALIDATE_RANGE_BIT = 0x0004; ///
enum GL_MAP_INVALIDATE_RANGE_BIT_EXT = 0x0004; ///
enum GL_MAP_PERSISTENT_BIT = 0x0040; ///
enum GL_MAP_PERSISTENT_BIT_EXT = 0x0040; ///
enum GL_MAP_READ_BIT = 0x0001; ///
enum GL_MAP_READ_BIT_EXT = 0x0001; ///
enum GL_MAP_STENCIL = 0x0D11; ///
enum GL_MAP_TESSELLATION_NV = 0x86C2; ///
enum GL_MAP_UNSYNCHRONIZED_BIT = 0x0020; ///
enum GL_MAP_UNSYNCHRONIZED_BIT_EXT = 0x0020; ///
enum GL_MAP_WRITE_BIT = 0x0002; ///
enum GL_MAP_WRITE_BIT_EXT = 0x0002; ///
enum GL_MATERIAL_SIDE_HINT_PGI = 0x1A22C; ///
enum GL_MATRIX0_ARB = 0x88C0; ///
enum GL_MATRIX0_NV = 0x8630; ///
enum GL_MATRIX10_ARB = 0x88CA; ///
enum GL_MATRIX11_ARB = 0x88CB; ///
enum GL_MATRIX12_ARB = 0x88CC; ///
enum GL_MATRIX13_ARB = 0x88CD; ///
enum GL_MATRIX14_ARB = 0x88CE; ///
enum GL_MATRIX15_ARB = 0x88CF; ///
enum GL_MATRIX16_ARB = 0x88D0; ///
enum GL_MATRIX17_ARB = 0x88D1; ///
enum GL_MATRIX18_ARB = 0x88D2; ///
enum GL_MATRIX19_ARB = 0x88D3; ///
enum GL_MATRIX1_ARB = 0x88C1; ///
enum GL_MATRIX1_NV = 0x8631; ///
enum GL_MATRIX20_ARB = 0x88D4; ///
enum GL_MATRIX21_ARB = 0x88D5; ///
enum GL_MATRIX22_ARB = 0x88D6; ///
enum GL_MATRIX23_ARB = 0x88D7; ///
enum GL_MATRIX24_ARB = 0x88D8; ///
enum GL_MATRIX25_ARB = 0x88D9; ///
enum GL_MATRIX26_ARB = 0x88DA; ///
enum GL_MATRIX27_ARB = 0x88DB; ///
enum GL_MATRIX28_ARB = 0x88DC; ///
enum GL_MATRIX29_ARB = 0x88DD; ///
enum GL_MATRIX2_ARB = 0x88C2; ///
enum GL_MATRIX2_NV = 0x8632; ///
enum GL_MATRIX30_ARB = 0x88DE; ///
enum GL_MATRIX31_ARB = 0x88DF; ///
enum GL_MATRIX3_ARB = 0x88C3; ///
enum GL_MATRIX3_NV = 0x8633; ///
enum GL_MATRIX4_ARB = 0x88C4; ///
enum GL_MATRIX4_NV = 0x8634; ///
enum GL_MATRIX5_ARB = 0x88C5; ///
enum GL_MATRIX5_NV = 0x8635; ///
enum GL_MATRIX6_ARB = 0x88C6; ///
enum GL_MATRIX6_NV = 0x8636; ///
enum GL_MATRIX7_ARB = 0x88C7; ///
enum GL_MATRIX7_NV = 0x8637; ///
enum GL_MATRIX8_ARB = 0x88C8; ///
enum GL_MATRIX9_ARB = 0x88C9; ///
enum GL_MATRIX_EXT = 0x87C0; ///
enum GL_MATRIX_INDEX_ARRAY_ARB = 0x8844; ///
enum GL_MATRIX_INDEX_ARRAY_BUFFER_BINDING_OES = 0x8B9E; ///
enum GL_MATRIX_INDEX_ARRAY_OES = 0x8844; ///
enum GL_MATRIX_INDEX_ARRAY_POINTER_ARB = 0x8849; ///
enum GL_MATRIX_INDEX_ARRAY_POINTER_OES = 0x8849; ///
enum GL_MATRIX_INDEX_ARRAY_SIZE_ARB = 0x8846; ///
enum GL_MATRIX_INDEX_ARRAY_SIZE_OES = 0x8846; ///
enum GL_MATRIX_INDEX_ARRAY_STRIDE_ARB = 0x8848; ///
enum GL_MATRIX_INDEX_ARRAY_STRIDE_OES = 0x8848; ///
enum GL_MATRIX_INDEX_ARRAY_TYPE_ARB = 0x8847; ///
enum GL_MATRIX_INDEX_ARRAY_TYPE_OES = 0x8847; ///
enum GL_MATRIX_MODE = 0x0BA0; ///
enum GL_MATRIX_PALETTE_ARB = 0x8840; ///
enum GL_MATRIX_PALETTE_OES = 0x8840; ///
enum GL_MATRIX_STRIDE = 0x92FF; ///
enum GL_MAT_AMBIENT_AND_DIFFUSE_BIT_PGI = 0x00200000; ///
enum GL_MAT_AMBIENT_BIT_PGI = 0x00100000; ///
enum GL_MAT_COLOR_INDEXES_BIT_PGI = 0x01000000; ///
enum GL_MAT_DIFFUSE_BIT_PGI = 0x00400000; ///
enum GL_MAT_EMISSION_BIT_PGI = 0x00800000; ///
enum GL_MAT_SHININESS_BIT_PGI = 0x02000000; ///
enum GL_MAT_SPECULAR_BIT_PGI = 0x04000000; ///
enum GL_MAX = 0x8008; ///
enum GL_MAX_3D_TEXTURE_SIZE = 0x8073; ///
enum GL_MAX_3D_TEXTURE_SIZE_EXT = 0x8073; ///
enum GL_MAX_3D_TEXTURE_SIZE_OES = 0x8073; ///
enum GL_MAX_4D_TEXTURE_SIZE_SGIS = 0x8138; ///
enum GL_MAX_ACTIVE_LIGHTS_SGIX = 0x8405; ///
enum GL_MAX_ARRAY_TEXTURE_LAYERS = 0x88FF; ///
enum GL_MAX_ARRAY_TEXTURE_LAYERS_EXT = 0x88FF; ///
enum GL_MAX_ASYNC_DRAW_PIXELS_SGIX = 0x8360; ///
enum GL_MAX_ASYNC_HISTOGRAM_SGIX = 0x832D; ///
enum GL_MAX_ASYNC_READ_PIXELS_SGIX = 0x8361; ///
enum GL_MAX_ASYNC_TEX_IMAGE_SGIX = 0x835F; ///
enum GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS = 0x92DC; ///
enum GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE = 0x92D8; ///
enum GL_MAX_ATTRIB_STACK_DEPTH = 0x0D35; ///
enum GL_MAX_BINDABLE_UNIFORM_SIZE_EXT = 0x8DED; ///
enum GL_MAX_CLIENT_ATTRIB_STACK_DEPTH = 0x0D3B; ///
enum GL_MAX_CLIPMAP_DEPTH_SGIX = 0x8177; ///
enum GL_MAX_CLIPMAP_VIRTUAL_DEPTH_SGIX = 0x8178; ///
enum GL_MAX_CLIP_DISTANCES = 0x0D32; ///
enum GL_MAX_CLIP_DISTANCES_APPLE = 0x0D32; ///
enum GL_MAX_CLIP_DISTANCES_EXT = 0x0D32; ///
enum GL_MAX_CLIP_PLANES = 0x0D32; ///
enum GL_MAX_CLIP_PLANES_IMG = 0x0D32; ///
enum GL_MAX_COLOR_ATTACHMENTS = 0x8CDF; ///
enum GL_MAX_COLOR_ATTACHMENTS_EXT = 0x8CDF; ///
enum GL_MAX_COLOR_ATTACHMENTS_NV = 0x8CDF; ///
enum GL_MAX_COLOR_MATRIX_STACK_DEPTH = 0x80B3; ///
enum GL_MAX_COLOR_MATRIX_STACK_DEPTH_SGI = 0x80B3; ///
enum GL_MAX_COLOR_TEXTURE_SAMPLES = 0x910E; ///
enum GL_MAX_COMBINED_ATOMIC_COUNTERS = 0x92D7; ///
enum GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS = 0x92D1; ///
enum GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES = 0x82FA; ///
enum GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES_EXT = 0x82FA; ///
enum GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS = 0x8266; ///
enum GL_MAX_COMBINED_DIMENSIONS = 0x8282; ///
enum GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = 0x8A33; ///
enum GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS = 0x8A32; ///
enum GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS_EXT = 0x8A32; ///
enum GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS_OES = 0x8A32; ///
enum GL_MAX_COMBINED_IMAGE_UNIFORMS = 0x90CF; ///
enum GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS = 0x8F39; ///
enum GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS_EXT = 0x8F39; ///
enum GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES = 0x8F39; ///
enum GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS = 0x90DC; ///
enum GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS = 0x8E1E; ///
enum GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS_EXT = 0x8E1E; ///
enum GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS_OES = 0x8E1E; ///
enum GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS = 0x8E1F; ///
enum GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS_EXT = 0x8E1F; ///
enum GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS_OES = 0x8E1F; ///
enum GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D; ///
enum GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB = 0x8B4D; ///
enum GL_MAX_COMBINED_UNIFORM_BLOCKS = 0x8A2E; ///
enum GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = 0x8A31; ///
enum GL_MAX_COMPUTE_ATOMIC_COUNTERS = 0x8265; ///
enum GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS = 0x8264; ///
enum GL_MAX_COMPUTE_FIXED_GROUP_INVOCATIONS_ARB = 0x90EB; ///
enum GL_MAX_COMPUTE_FIXED_GROUP_SIZE_ARB = 0x91BF; ///
enum GL_MAX_COMPUTE_IMAGE_UNIFORMS = 0x91BD; ///
enum GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS = 0x90DB; ///
enum GL_MAX_COMPUTE_SHARED_MEMORY_SIZE = 0x8262; ///
enum GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS = 0x91BC; ///
enum GL_MAX_COMPUTE_UNIFORM_BLOCKS = 0x91BB; ///
enum GL_MAX_COMPUTE_UNIFORM_COMPONENTS = 0x8263; ///
enum GL_MAX_COMPUTE_VARIABLE_GROUP_INVOCATIONS_ARB = 0x9344; ///
enum GL_MAX_COMPUTE_VARIABLE_GROUP_SIZE_ARB = 0x9345; ///
enum GL_MAX_COMPUTE_WORK_GROUP_COUNT = 0x91BE; ///
enum GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS = 0x90EB; ///
enum GL_MAX_COMPUTE_WORK_GROUP_SIZE = 0x91BF; ///
enum GL_MAX_CONVOLUTION_HEIGHT = 0x801B; ///
enum GL_MAX_CONVOLUTION_HEIGHT_EXT = 0x801B; ///
enum GL_MAX_CONVOLUTION_WIDTH = 0x801A; ///
enum GL_MAX_CONVOLUTION_WIDTH_EXT = 0x801A; ///
enum GL_MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C; ///
enum GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB = 0x851C; ///
enum GL_MAX_CUBE_MAP_TEXTURE_SIZE_EXT = 0x851C; ///
enum GL_MAX_CUBE_MAP_TEXTURE_SIZE_OES = 0x851C; ///
enum GL_MAX_CULL_DISTANCES = 0x82F9; ///
enum GL_MAX_CULL_DISTANCES_EXT = 0x82F9; ///
enum GL_MAX_DEBUG_GROUP_STACK_DEPTH = 0x826C; ///
enum GL_MAX_DEBUG_GROUP_STACK_DEPTH_KHR = 0x826C; ///
enum GL_MAX_DEBUG_LOGGED_MESSAGES = 0x9144; ///
enum GL_MAX_DEBUG_LOGGED_MESSAGES_AMD = 0x9144; ///
enum GL_MAX_DEBUG_LOGGED_MESSAGES_ARB = 0x9144; ///
enum GL_MAX_DEBUG_LOGGED_MESSAGES_KHR = 0x9144; ///
enum GL_MAX_DEBUG_MESSAGE_LENGTH = 0x9143; ///
enum GL_MAX_DEBUG_MESSAGE_LENGTH_AMD = 0x9143; ///
enum GL_MAX_DEBUG_MESSAGE_LENGTH_ARB = 0x9143; ///
enum GL_MAX_DEBUG_MESSAGE_LENGTH_KHR = 0x9143; ///
enum GL_MAX_DEEP_3D_TEXTURE_DEPTH_NV = 0x90D1; ///
enum GL_MAX_DEEP_3D_TEXTURE_WIDTH_HEIGHT_NV = 0x90D0; ///
enum GL_MAX_DEFORMATION_ORDER_SGIX = 0x8197; ///
enum GL_MAX_DEPTH = 0x8280; ///
enum GL_MAX_DEPTH_TEXTURE_SAMPLES = 0x910F; ///
enum GL_MAX_DRAW_BUFFERS = 0x8824; ///
enum GL_MAX_DRAW_BUFFERS_ARB = 0x8824; ///
enum GL_MAX_DRAW_BUFFERS_ATI = 0x8824; ///
enum GL_MAX_DRAW_BUFFERS_EXT = 0x8824; ///
enum GL_MAX_DRAW_BUFFERS_NV = 0x8824; ///
enum GL_MAX_DUAL_SOURCE_DRAW_BUFFERS = 0x88FC; ///
enum GL_MAX_DUAL_SOURCE_DRAW_BUFFERS_EXT = 0x88FC; ///
enum GL_MAX_ELEMENTS_INDICES = 0x80E9; ///
enum GL_MAX_ELEMENTS_INDICES_EXT = 0x80E9; ///
enum GL_MAX_ELEMENTS_VERTICES = 0x80E8; ///
enum GL_MAX_ELEMENTS_VERTICES_EXT = 0x80E8; ///
enum GL_MAX_ELEMENT_INDEX = 0x8D6B; ///
enum GL_MAX_EVAL_ORDER = 0x0D30; ///
enum GL_MAX_EXT = 0x8008; ///
enum GL_MAX_FOG_FUNC_POINTS_SGIS = 0x812C; ///
enum GL_MAX_FRAGMENT_ATOMIC_COUNTERS = 0x92D6; ///
enum GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS = 0x92D0; ///
enum GL_MAX_FRAGMENT_BINDABLE_UNIFORMS_EXT = 0x8DE3; ///
enum GL_MAX_FRAGMENT_IMAGE_UNIFORMS = 0x90CE; ///
enum GL_MAX_FRAGMENT_INPUT_COMPONENTS = 0x9125; ///
enum GL_MAX_FRAGMENT_INTERPOLATION_OFFSET = 0x8E5C; ///
enum GL_MAX_FRAGMENT_INTERPOLATION_OFFSET_NV = 0x8E5C; ///
enum GL_MAX_FRAGMENT_INTERPOLATION_OFFSET_OES = 0x8E5C; ///
enum GL_MAX_FRAGMENT_LIGHTS_SGIX = 0x8404; ///
enum GL_MAX_FRAGMENT_PROGRAM_LOCAL_PARAMETERS_NV = 0x8868; ///
enum GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS = 0x90DA; ///
enum GL_MAX_FRAGMENT_UNIFORM_BLOCKS = 0x8A2D; ///
enum GL_MAX_FRAGMENT_UNIFORM_COMPONENTS = 0x8B49; ///
enum GL_MAX_FRAGMENT_UNIFORM_COMPONENTS_ARB = 0x8B49; ///
enum GL_MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD; ///
enum GL_MAX_FRAMEBUFFER_HEIGHT = 0x9316; ///
enum GL_MAX_FRAMEBUFFER_LAYERS = 0x9317; ///
enum GL_MAX_FRAMEBUFFER_LAYERS_EXT = 0x9317; ///
enum GL_MAX_FRAMEBUFFER_LAYERS_OES = 0x9317; ///
enum GL_MAX_FRAMEBUFFER_SAMPLES = 0x9318; ///
enum GL_MAX_FRAMEBUFFER_WIDTH = 0x9315; ///
enum GL_MAX_FRAMEZOOM_FACTOR_SGIX = 0x818D; ///
enum GL_MAX_GENERAL_COMBINERS_NV = 0x854D; ///
enum GL_MAX_GEOMETRY_ATOMIC_COUNTERS = 0x92D5; ///
enum GL_MAX_GEOMETRY_ATOMIC_COUNTERS_EXT = 0x92D5; ///
enum GL_MAX_GEOMETRY_ATOMIC_COUNTERS_OES = 0x92D5; ///
enum GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS = 0x92CF; ///
enum GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS_EXT = 0x92CF; ///
enum GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS_OES = 0x92CF; ///
enum GL_MAX_GEOMETRY_BINDABLE_UNIFORMS_EXT = 0x8DE4; ///
enum GL_MAX_GEOMETRY_IMAGE_UNIFORMS = 0x90CD; ///
enum GL_MAX_GEOMETRY_IMAGE_UNIFORMS_EXT = 0x90CD; ///
enum GL_MAX_GEOMETRY_IMAGE_UNIFORMS_OES = 0x90CD; ///
enum GL_MAX_GEOMETRY_INPUT_COMPONENTS = 0x9123; ///
enum GL_MAX_GEOMETRY_INPUT_COMPONENTS_EXT = 0x9123; ///
enum GL_MAX_GEOMETRY_INPUT_COMPONENTS_OES = 0x9123; ///
enum GL_MAX_GEOMETRY_OUTPUT_COMPONENTS = 0x9124; ///
enum GL_MAX_GEOMETRY_OUTPUT_COMPONENTS_EXT = 0x9124; ///
enum GL_MAX_GEOMETRY_OUTPUT_COMPONENTS_OES = 0x9124; ///
enum GL_MAX_GEOMETRY_OUTPUT_VERTICES = 0x8DE0; ///
enum GL_MAX_GEOMETRY_OUTPUT_VERTICES_ARB = 0x8DE0; ///
enum GL_MAX_GEOMETRY_OUTPUT_VERTICES_EXT = 0x8DE0; ///
enum GL_MAX_GEOMETRY_OUTPUT_VERTICES_OES = 0x8DE0; ///
enum GL_MAX_GEOMETRY_PROGRAM_INVOCATIONS_NV = 0x8E5A; ///
enum GL_MAX_GEOMETRY_SHADER_INVOCATIONS = 0x8E5A; ///
enum GL_MAX_GEOMETRY_SHADER_INVOCATIONS_EXT = 0x8E5A; ///
enum GL_MAX_GEOMETRY_SHADER_INVOCATIONS_OES = 0x8E5A; ///
enum GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS = 0x90D7; ///
enum GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS_EXT = 0x90D7; ///
enum GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS_OES = 0x90D7; ///
enum GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS = 0x8C29; ///
enum GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_ARB = 0x8C29; ///
enum GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_EXT = 0x8C29; ///
enum GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_OES = 0x8C29; ///
enum GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS = 0x8DE1; ///
enum GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_ARB = 0x8DE1; ///
enum GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_EXT = 0x8DE1; ///
enum GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_OES = 0x8DE1; ///
enum GL_MAX_GEOMETRY_UNIFORM_BLOCKS = 0x8A2C; ///
enum GL_MAX_GEOMETRY_UNIFORM_BLOCKS_EXT = 0x8A2C; ///
enum GL_MAX_GEOMETRY_UNIFORM_BLOCKS_OES = 0x8A2C; ///
enum GL_MAX_GEOMETRY_UNIFORM_COMPONENTS = 0x8DDF; ///
enum GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_ARB = 0x8DDF; ///
enum GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_EXT = 0x8DDF; ///
enum GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_OES = 0x8DDF; ///
enum GL_MAX_GEOMETRY_VARYING_COMPONENTS_ARB = 0x8DDD; ///
enum GL_MAX_GEOMETRY_VARYING_COMPONENTS_EXT = 0x8DDD; ///
enum GL_MAX_HEIGHT = 0x827F; ///
enum GL_MAX_IMAGE_SAMPLES = 0x906D; ///
enum GL_MAX_IMAGE_SAMPLES_EXT = 0x906D; ///
enum GL_MAX_IMAGE_UNITS = 0x8F38; ///
enum GL_MAX_IMAGE_UNITS_EXT = 0x8F38; ///
enum GL_MAX_INTEGER_SAMPLES = 0x9110; ///
enum GL_MAX_LABEL_LENGTH = 0x82E8; ///
enum GL_MAX_LABEL_LENGTH_KHR = 0x82E8; ///
enum GL_MAX_LAYERS = 0x8281; ///
enum GL_MAX_LIGHTS = 0x0D31; ///
enum GL_MAX_LIST_NESTING = 0x0B31; ///
enum GL_MAX_MAP_TESSELLATION_NV = 0x86D6; ///
enum GL_MAX_MATRIX_PALETTE_STACK_DEPTH_ARB = 0x8841; ///
enum GL_MAX_MODELVIEW_STACK_DEPTH = 0x0D36; ///
enum GL_MAX_MULTISAMPLE_COVERAGE_MODES_NV = 0x8E11; ///
enum GL_MAX_MULTIVIEW_BUFFERS_EXT = 0x90F2; ///
enum GL_MAX_NAME_LENGTH = 0x92F6; ///
enum GL_MAX_NAME_STACK_DEPTH = 0x0D37; ///
enum GL_MAX_NUM_ACTIVE_VARIABLES = 0x92F7; ///
enum GL_MAX_NUM_COMPATIBLE_SUBROUTINES = 0x92F8; ///
enum GL_MAX_OPTIMIZED_VERTEX_SHADER_INSTRUCTIONS_EXT = 0x87CA; ///
enum GL_MAX_OPTIMIZED_VERTEX_SHADER_INVARIANTS_EXT = 0x87CD; ///
enum GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCALS_EXT = 0x87CE; ///
enum GL_MAX_OPTIMIZED_VERTEX_SHADER_LOCAL_CONSTANTS_EXT = 0x87CC; ///
enum GL_MAX_OPTIMIZED_VERTEX_SHADER_VARIANTS_EXT = 0x87CB; ///
enum GL_MAX_PALETTE_MATRICES_ARB = 0x8842; ///
enum GL_MAX_PALETTE_MATRICES_OES = 0x8842; ///
enum GL_MAX_PATCH_VERTICES = 0x8E7D; ///
enum GL_MAX_PATCH_VERTICES_EXT = 0x8E7D; ///
enum GL_MAX_PATCH_VERTICES_OES = 0x8E7D; ///
enum GL_MAX_PIXEL_MAP_TABLE = 0x0D34; ///
enum GL_MAX_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT = 0x8337; ///
enum GL_MAX_PN_TRIANGLES_TESSELATION_LEVEL_ATI = 0x87F1; ///
enum GL_MAX_PROGRAM_ADDRESS_REGISTERS_ARB = 0x88B1; ///
enum GL_MAX_PROGRAM_ALU_INSTRUCTIONS_ARB = 0x880B; ///
enum GL_MAX_PROGRAM_ATTRIBS_ARB = 0x88AD; ///
enum GL_MAX_PROGRAM_ATTRIB_COMPONENTS_NV = 0x8908; ///
enum GL_MAX_PROGRAM_CALL_DEPTH_NV = 0x88F5; ///
enum GL_MAX_PROGRAM_ENV_PARAMETERS_ARB = 0x88B5; ///
enum GL_MAX_PROGRAM_EXEC_INSTRUCTIONS_NV = 0x88F4; ///
enum GL_MAX_PROGRAM_GENERIC_ATTRIBS_NV = 0x8DA5; ///
enum GL_MAX_PROGRAM_GENERIC_RESULTS_NV = 0x8DA6; ///
enum GL_MAX_PROGRAM_IF_DEPTH_NV = 0x88F6; ///
enum GL_MAX_PROGRAM_INSTRUCTIONS_ARB = 0x88A1; ///
enum GL_MAX_PROGRAM_LOCAL_PARAMETERS_ARB = 0x88B4; ///
enum GL_MAX_PROGRAM_LOOP_COUNT_NV = 0x88F8; ///
enum GL_MAX_PROGRAM_LOOP_DEPTH_NV = 0x88F7; ///
enum GL_MAX_PROGRAM_MATRICES_ARB = 0x862F; ///
enum GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB = 0x862E; ///
enum GL_MAX_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB = 0x88B3; ///
enum GL_MAX_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB = 0x880E; ///
enum GL_MAX_PROGRAM_NATIVE_ATTRIBS_ARB = 0x88AF; ///
enum GL_MAX_PROGRAM_NATIVE_INSTRUCTIONS_ARB = 0x88A3; ///
enum GL_MAX_PROGRAM_NATIVE_PARAMETERS_ARB = 0x88AB; ///
enum GL_MAX_PROGRAM_NATIVE_TEMPORARIES_ARB = 0x88A7; ///
enum GL_MAX_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB = 0x8810; ///
enum GL_MAX_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB = 0x880F; ///
enum GL_MAX_PROGRAM_OUTPUT_VERTICES_NV = 0x8C27; ///
enum GL_MAX_PROGRAM_PARAMETERS_ARB = 0x88A9; ///
enum GL_MAX_PROGRAM_PARAMETER_BUFFER_BINDINGS_NV = 0x8DA0; ///
enum GL_MAX_PROGRAM_PARAMETER_BUFFER_SIZE_NV = 0x8DA1; ///
enum GL_MAX_PROGRAM_PATCH_ATTRIBS_NV = 0x86D8; ///
enum GL_MAX_PROGRAM_RESULT_COMPONENTS_NV = 0x8909; ///
enum GL_MAX_PROGRAM_SUBROUTINE_NUM_NV = 0x8F45; ///
enum GL_MAX_PROGRAM_SUBROUTINE_PARAMETERS_NV = 0x8F44; ///
enum GL_MAX_PROGRAM_TEMPORARIES_ARB = 0x88A5; ///
enum GL_MAX_PROGRAM_TEXEL_OFFSET = 0x8905; ///
enum GL_MAX_PROGRAM_TEXEL_OFFSET_EXT = 0x8905; ///
enum GL_MAX_PROGRAM_TEXEL_OFFSET_NV = 0x8905; ///
enum GL_MAX_PROGRAM_TEXTURE_GATHER_COMPONENTS_ARB = 0x8F9F; ///
enum GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET = 0x8E5F; ///
enum GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET_ARB = 0x8E5F; ///
enum GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET_NV = 0x8E5F; ///
enum GL_MAX_PROGRAM_TEX_INDIRECTIONS_ARB = 0x880D; ///
enum GL_MAX_PROGRAM_TEX_INSTRUCTIONS_ARB = 0x880C; ///
enum GL_MAX_PROGRAM_TOTAL_OUTPUT_COMPONENTS_NV = 0x8C28; ///
enum GL_MAX_PROJECTION_STACK_DEPTH = 0x0D38; ///
enum GL_MAX_RASTER_SAMPLES_EXT = 0x9329; ///
enum GL_MAX_RATIONAL_EVAL_ORDER_NV = 0x86D7; ///
enum GL_MAX_RECTANGLE_TEXTURE_SIZE = 0x84F8; ///
enum GL_MAX_RECTANGLE_TEXTURE_SIZE_ARB = 0x84F8; ///
enum GL_MAX_RECTANGLE_TEXTURE_SIZE_NV = 0x84F8; ///
enum GL_MAX_RENDERBUFFER_SIZE = 0x84E8; ///
enum GL_MAX_RENDERBUFFER_SIZE_EXT = 0x84E8; ///
enum GL_MAX_RENDERBUFFER_SIZE_OES = 0x84E8; ///
enum GL_MAX_SAMPLES = 0x8D57; ///
enum GL_MAX_SAMPLES_ANGLE = 0x8D57; ///
enum GL_MAX_SAMPLES_APPLE = 0x8D57; ///
enum GL_MAX_SAMPLES_EXT = 0x8D57; ///
enum GL_MAX_SAMPLES_IMG = 0x9135; ///
enum GL_MAX_SAMPLES_NV = 0x8D57; ///
enum GL_MAX_SAMPLE_MASK_WORDS = 0x8E59; ///
enum GL_MAX_SAMPLE_MASK_WORDS_NV = 0x8E59; ///
enum GL_MAX_SERVER_WAIT_TIMEOUT = 0x9111; ///
enum GL_MAX_SERVER_WAIT_TIMEOUT_APPLE = 0x9111; ///
enum GL_MAX_SHADER_BUFFER_ADDRESS_NV = 0x8F35; ///
enum GL_MAX_SHADER_COMBINED_LOCAL_STORAGE_FAST_SIZE_EXT = 0x9650; ///
enum GL_MAX_SHADER_COMBINED_LOCAL_STORAGE_SIZE_EXT = 0x9651; ///
enum GL_MAX_SHADER_COMPILER_THREADS_ARB = 0x91B0; ///
enum GL_MAX_SHADER_PIXEL_LOCAL_STORAGE_FAST_SIZE_EXT = 0x8F63; ///
enum GL_MAX_SHADER_PIXEL_LOCAL_STORAGE_SIZE_EXT = 0x8F67; ///
enum GL_MAX_SHADER_STORAGE_BLOCK_SIZE = 0x90DE; ///
enum GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS = 0x90DD; ///
enum GL_MAX_SHININESS_NV = 0x8504; ///
enum GL_MAX_SPARSE_3D_TEXTURE_SIZE_AMD = 0x9199; ///
enum GL_MAX_SPARSE_3D_TEXTURE_SIZE_ARB = 0x9199; ///
enum GL_MAX_SPARSE_3D_TEXTURE_SIZE_EXT = 0x9199; ///
enum GL_MAX_SPARSE_ARRAY_TEXTURE_LAYERS = 0x919A; ///
enum GL_MAX_SPARSE_ARRAY_TEXTURE_LAYERS_ARB = 0x919A; ///
enum GL_MAX_SPARSE_ARRAY_TEXTURE_LAYERS_EXT = 0x919A; ///
enum GL_MAX_SPARSE_TEXTURE_SIZE_AMD = 0x9198; ///
enum GL_MAX_SPARSE_TEXTURE_SIZE_ARB = 0x9198; ///
enum GL_MAX_SPARSE_TEXTURE_SIZE_EXT = 0x9198; ///
enum GL_MAX_SPOT_EXPONENT_NV = 0x8505; ///
enum GL_MAX_SUBPIXEL_PRECISION_BIAS_BITS_NV = 0x9349; ///
enum GL_MAX_SUBROUTINES = 0x8DE7; ///
enum GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS = 0x8DE8; ///
enum GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS = 0x92D3; ///
enum GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS_EXT = 0x92D3; ///
enum GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS_OES = 0x92D3; ///
enum GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS = 0x92CD; ///
enum GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS_EXT = 0x92CD; ///
enum GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS_OES = 0x92CD; ///
enum GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS = 0x90CB; ///
enum GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS_EXT = 0x90CB; ///
enum GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS_OES = 0x90CB; ///
enum GL_MAX_TESS_CONTROL_INPUT_COMPONENTS = 0x886C; ///
enum GL_MAX_TESS_CONTROL_INPUT_COMPONENTS_EXT = 0x886C; ///
enum GL_MAX_TESS_CONTROL_INPUT_COMPONENTS_OES = 0x886C; ///
enum GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS = 0x8E83; ///
enum GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS_EXT = 0x8E83; ///
enum GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS_OES = 0x8E83; ///
enum GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS = 0x90D8; ///
enum GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS_EXT = 0x90D8; ///
enum GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS_OES = 0x90D8; ///
enum GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS = 0x8E81; ///
enum GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS_EXT = 0x8E81; ///
enum GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS_OES = 0x8E81; ///
enum GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS = 0x8E85; ///
enum GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS_EXT = 0x8E85; ///
enum GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS_OES = 0x8E85; ///
enum GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS = 0x8E89; ///
enum GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS_EXT = 0x8E89; ///
enum GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS_OES = 0x8E89; ///
enum GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS = 0x8E7F; ///
enum GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS_EXT = 0x8E7F; ///
enum GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS_OES = 0x8E7F; ///
enum GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS = 0x92D4; ///
enum GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS_EXT = 0x92D4; ///
enum GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS_OES = 0x92D4; ///
enum GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS = 0x92CE; ///
enum GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS_EXT = 0x92CE; ///
enum GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS_OES = 0x92CE; ///
enum GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS = 0x90CC; ///
enum GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS_EXT = 0x90CC; ///
enum GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS_OES = 0x90CC; ///
enum GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS = 0x886D; ///
enum GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS_EXT = 0x886D; ///
enum GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS_OES = 0x886D; ///
enum GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS = 0x8E86; ///
enum GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS_EXT = 0x8E86; ///
enum GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS_OES = 0x8E86; ///
enum GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS = 0x90D9; ///
enum GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS_EXT = 0x90D9; ///
enum GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS_OES = 0x90D9; ///
enum GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS = 0x8E82; ///
enum GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS_EXT = 0x8E82; ///
enum GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS_OES = 0x8E82; ///
enum GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS = 0x8E8A; ///
enum GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS_EXT = 0x8E8A; ///
enum GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS_OES = 0x8E8A; ///
enum GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS = 0x8E80; ///
enum GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS_EXT = 0x8E80; ///
enum GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS_OES = 0x8E80; ///
enum GL_MAX_TESS_GEN_LEVEL = 0x8E7E; ///
enum GL_MAX_TESS_GEN_LEVEL_EXT = 0x8E7E; ///
enum GL_MAX_TESS_GEN_LEVEL_OES = 0x8E7E; ///
enum GL_MAX_TESS_PATCH_COMPONENTS = 0x8E84; ///
enum GL_MAX_TESS_PATCH_COMPONENTS_EXT = 0x8E84; ///
enum GL_MAX_TESS_PATCH_COMPONENTS_OES = 0x8E84; ///
enum GL_MAX_TEXTURE_BUFFER_SIZE = 0x8C2B; ///
enum GL_MAX_TEXTURE_BUFFER_SIZE_ARB = 0x8C2B; ///
enum GL_MAX_TEXTURE_BUFFER_SIZE_EXT = 0x8C2B; ///
enum GL_MAX_TEXTURE_BUFFER_SIZE_OES = 0x8C2B; ///
enum GL_MAX_TEXTURE_COORDS = 0x8871; ///
enum GL_MAX_TEXTURE_COORDS_ARB = 0x8871; ///
enum GL_MAX_TEXTURE_COORDS_NV = 0x8871; ///
enum GL_MAX_TEXTURE_IMAGE_UNITS = 0x8872; ///
enum GL_MAX_TEXTURE_IMAGE_UNITS_ARB = 0x8872; ///
enum GL_MAX_TEXTURE_IMAGE_UNITS_NV = 0x8872; ///
enum GL_MAX_TEXTURE_LOD_BIAS = 0x84FD; ///
enum GL_MAX_TEXTURE_LOD_BIAS_EXT = 0x84FD; ///
enum GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FF; ///
enum GL_MAX_TEXTURE_SIZE = 0x0D33; ///
enum GL_MAX_TEXTURE_STACK_DEPTH = 0x0D39; ///
enum GL_MAX_TEXTURE_UNITS = 0x84E2; ///
enum GL_MAX_TEXTURE_UNITS_ARB = 0x84E2; ///
enum GL_MAX_TRACK_MATRICES_NV = 0x862F; ///
enum GL_MAX_TRACK_MATRIX_STACK_DEPTH_NV = 0x862E; ///
enum GL_MAX_TRANSFORM_FEEDBACK_BUFFERS = 0x8E70; ///
enum GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 0x8C8A; ///
enum GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS_EXT = 0x8C8A; ///
enum GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS_NV = 0x8C8A; ///
enum GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS = 0x8C8B; ///
enum GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS_EXT = 0x8C8B; ///
enum GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS_NV = 0x8C8B; ///
enum GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS = 0x8C80; ///
enum GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS_EXT = 0x8C80; ///
enum GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS_NV = 0x8C80; ///
enum GL_MAX_UNIFORM_BLOCK_SIZE = 0x8A30; ///
enum GL_MAX_UNIFORM_BUFFER_BINDINGS = 0x8A2F; ///
enum GL_MAX_UNIFORM_LOCATIONS = 0x826E; ///
enum GL_MAX_VARYING_COMPONENTS = 0x8B4B; ///
enum GL_MAX_VARYING_COMPONENTS_EXT = 0x8B4B; ///
enum GL_MAX_VARYING_FLOATS = 0x8B4B; ///
enum GL_MAX_VARYING_FLOATS_ARB = 0x8B4B; ///
enum GL_MAX_VARYING_VECTORS = 0x8DFC; ///
enum GL_MAX_VERTEX_ARRAY_RANGE_ELEMENT_NV = 0x8520; ///
enum GL_MAX_VERTEX_ATOMIC_COUNTERS = 0x92D2; ///
enum GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS = 0x92CC; ///
enum GL_MAX_VERTEX_ATTRIBS = 0x8869; ///
enum GL_MAX_VERTEX_ATTRIBS_ARB = 0x8869; ///
enum GL_MAX_VERTEX_ATTRIB_BINDINGS = 0x82DA; ///
enum GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET = 0x82D9; ///
enum GL_MAX_VERTEX_ATTRIB_STRIDE = 0x82E5; ///
enum GL_MAX_VERTEX_BINDABLE_UNIFORMS_EXT = 0x8DE2; ///
enum GL_MAX_VERTEX_HINT_PGI = 0x1A22D; ///
enum GL_MAX_VERTEX_IMAGE_UNIFORMS = 0x90CA; ///
enum GL_MAX_VERTEX_OUTPUT_COMPONENTS = 0x9122; ///
enum GL_MAX_VERTEX_SHADER_INSTRUCTIONS_EXT = 0x87C5; ///
enum GL_MAX_VERTEX_SHADER_INVARIANTS_EXT = 0x87C7; ///
enum GL_MAX_VERTEX_SHADER_LOCALS_EXT = 0x87C9; ///
enum GL_MAX_VERTEX_SHADER_LOCAL_CONSTANTS_EXT = 0x87C8; ///
enum GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS = 0x90D6; ///
enum GL_MAX_VERTEX_SHADER_VARIANTS_EXT = 0x87C6; ///
enum GL_MAX_VERTEX_STREAMS = 0x8E71; ///
enum GL_MAX_VERTEX_STREAMS_ATI = 0x876B; ///
enum GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C; ///
enum GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB = 0x8B4C; ///
enum GL_MAX_VERTEX_UNIFORM_BLOCKS = 0x8A2B; ///
enum GL_MAX_VERTEX_UNIFORM_COMPONENTS = 0x8B4A; ///
enum GL_MAX_VERTEX_UNIFORM_COMPONENTS_ARB = 0x8B4A; ///
enum GL_MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB; ///
enum GL_MAX_VERTEX_UNITS_ARB = 0x86A4; ///
enum GL_MAX_VERTEX_UNITS_OES = 0x86A4; ///
enum GL_MAX_VERTEX_VARYING_COMPONENTS_ARB = 0x8DDE; ///
enum GL_MAX_VERTEX_VARYING_COMPONENTS_EXT = 0x8DDE; ///
enum GL_MAX_VIEWPORTS = 0x825B; ///
enum GL_MAX_VIEWPORTS_NV = 0x825B; ///
enum GL_MAX_VIEWPORTS_OES = 0x825B; ///
enum GL_MAX_VIEWPORT_DIMS = 0x0D3A; ///
enum GL_MAX_VIEWS_OVR = 0x9631; ///
enum GL_MAX_WIDTH = 0x827E; ///
enum GL_MAX_WINDOW_RECTANGLES_EXT = 0x8F14; ///
enum GL_MEDIUM_FLOAT = 0x8DF1; ///
enum GL_MEDIUM_INT = 0x8DF4; ///
enum GL_MIN = 0x8007; ///
enum GL_MINMAX = 0x802E; ///
enum GL_MINMAX_EXT = 0x802E; ///
enum GL_MINMAX_FORMAT = 0x802F; ///
enum GL_MINMAX_FORMAT_EXT = 0x802F; ///
enum GL_MINMAX_SINK = 0x8030; ///
enum GL_MINMAX_SINK_EXT = 0x8030; ///
enum GL_MINOR_VERSION = 0x821C; ///
enum GL_MINUS_CLAMPED_NV = 0x92B3; ///
enum GL_MINUS_NV = 0x929F; ///
enum GL_MIN_EXT = 0x8007; ///
enum GL_MIN_FRAGMENT_INTERPOLATION_OFFSET = 0x8E5B; ///
enum GL_MIN_FRAGMENT_INTERPOLATION_OFFSET_NV = 0x8E5B; ///
enum GL_MIN_FRAGMENT_INTERPOLATION_OFFSET_OES = 0x8E5B; ///
enum GL_MIN_LOD_WARNING_AMD = 0x919C; ///
enum GL_MIN_MAP_BUFFER_ALIGNMENT = 0x90BC; ///
enum GL_MIN_PROGRAM_TEXEL_OFFSET = 0x8904; ///
enum GL_MIN_PROGRAM_TEXEL_OFFSET_EXT = 0x8904; ///
enum GL_MIN_PROGRAM_TEXEL_OFFSET_NV = 0x8904; ///
enum GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET = 0x8E5E; ///
enum GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET_ARB = 0x8E5E; ///
enum GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET_NV = 0x8E5E; ///
enum GL_MIN_SAMPLE_SHADING_VALUE = 0x8C37; ///
enum GL_MIN_SAMPLE_SHADING_VALUE_ARB = 0x8C37; ///
enum GL_MIN_SAMPLE_SHADING_VALUE_OES = 0x8C37; ///
enum GL_MIN_SPARSE_LEVEL_AMD = 0x919B; ///
enum GL_MIPMAP = 0x8293; ///
enum GL_MIRRORED_REPEAT = 0x8370; ///
enum GL_MIRRORED_REPEAT_ARB = 0x8370; ///
enum GL_MIRRORED_REPEAT_IBM = 0x8370; ///
enum GL_MIRRORED_REPEAT_OES = 0x8370; ///
enum GL_MIRROR_CLAMP_ATI = 0x8742; ///
enum GL_MIRROR_CLAMP_EXT = 0x8742; ///
enum GL_MIRROR_CLAMP_TO_BORDER_EXT = 0x8912; ///
enum GL_MIRROR_CLAMP_TO_EDGE = 0x8743; ///
enum GL_MIRROR_CLAMP_TO_EDGE_ATI = 0x8743; ///
enum GL_MIRROR_CLAMP_TO_EDGE_EXT = 0x8743; ///
enum GL_MITER_REVERT_NV = 0x90A7; ///
enum GL_MITER_TRUNCATE_NV = 0x90A8; ///
enum GL_MIXED_DEPTH_SAMPLES_SUPPORTED_NV = 0x932F; ///
enum GL_MIXED_STENCIL_SAMPLES_SUPPORTED_NV = 0x9330; ///
enum GL_MODELVIEW = 0x1700; ///
enum GL_MODELVIEW0_ARB = 0x1700; ///
enum GL_MODELVIEW0_EXT = 0x1700; ///
enum GL_MODELVIEW0_MATRIX_EXT = 0x0BA6; ///
enum GL_MODELVIEW0_STACK_DEPTH_EXT = 0x0BA3; ///
enum GL_MODELVIEW10_ARB = 0x872A; ///
enum GL_MODELVIEW11_ARB = 0x872B; ///
enum GL_MODELVIEW12_ARB = 0x872C; ///
enum GL_MODELVIEW13_ARB = 0x872D; ///
enum GL_MODELVIEW14_ARB = 0x872E; ///
enum GL_MODELVIEW15_ARB = 0x872F; ///
enum GL_MODELVIEW16_ARB = 0x8730; ///
enum GL_MODELVIEW17_ARB = 0x8731; ///
enum GL_MODELVIEW18_ARB = 0x8732; ///
enum GL_MODELVIEW19_ARB = 0x8733; ///
enum GL_MODELVIEW1_ARB = 0x850A; ///
enum GL_MODELVIEW1_EXT = 0x850A; ///
enum GL_MODELVIEW1_MATRIX_EXT = 0x8506; ///
enum GL_MODELVIEW1_STACK_DEPTH_EXT = 0x8502; ///
enum GL_MODELVIEW20_ARB = 0x8734; ///
enum GL_MODELVIEW21_ARB = 0x8735; ///
enum GL_MODELVIEW22_ARB = 0x8736; ///
enum GL_MODELVIEW23_ARB = 0x8737; ///
enum GL_MODELVIEW24_ARB = 0x8738; ///
enum GL_MODELVIEW25_ARB = 0x8739; ///
enum GL_MODELVIEW26_ARB = 0x873A; ///
enum GL_MODELVIEW27_ARB = 0x873B; ///
enum GL_MODELVIEW28_ARB = 0x873C; ///
enum GL_MODELVIEW29_ARB = 0x873D; ///
enum GL_MODELVIEW2_ARB = 0x8722; ///
enum GL_MODELVIEW30_ARB = 0x873E; ///
enum GL_MODELVIEW31_ARB = 0x873F; ///
enum GL_MODELVIEW3_ARB = 0x8723; ///
enum GL_MODELVIEW4_ARB = 0x8724; ///
enum GL_MODELVIEW5_ARB = 0x8725; ///
enum GL_MODELVIEW6_ARB = 0x8726; ///
enum GL_MODELVIEW7_ARB = 0x8727; ///
enum GL_MODELVIEW8_ARB = 0x8728; ///
enum GL_MODELVIEW9_ARB = 0x8729; ///
enum GL_MODELVIEW_MATRIX = 0x0BA6; ///
enum GL_MODELVIEW_MATRIX_FLOAT_AS_INT_BITS_OES = 0x898D; ///
enum GL_MODELVIEW_PROJECTION_NV = 0x8629; ///
enum GL_MODELVIEW_STACK_DEPTH = 0x0BA3; ///
enum GL_MODULATE = 0x2100; ///
enum GL_MODULATE_ADD_ATI = 0x8744; ///
enum GL_MODULATE_COLOR_IMG = 0x8C04; ///
enum GL_MODULATE_SIGNED_ADD_ATI = 0x8745; ///
enum GL_MODULATE_SUBTRACT_ATI = 0x8746; ///
enum GL_MOVE_TO_CONTINUES_NV = 0x90B6; ///
enum GL_MOVE_TO_NV = 0x02; ///
enum GL_MOVE_TO_RESETS_NV = 0x90B5; ///
enum GL_MOV_ATI = 0x8961; ///
enum GL_MULT = 0x0103; ///
enum GL_MULTIPLY = 0x9294; ///
enum GL_MULTIPLY_KHR = 0x9294; ///
enum GL_MULTIPLY_NV = 0x9294; ///
enum GL_MULTISAMPLE = 0x809D; ///
enum GL_MULTISAMPLES_NV = 0x9371; ///
enum GL_MULTISAMPLE_3DFX = 0x86B2; ///
enum GL_MULTISAMPLE_ARB = 0x809D; ///
enum GL_MULTISAMPLE_BIT = 0x20000000; ///
enum GL_MULTISAMPLE_BIT_3DFX = 0x20000000; ///
enum GL_MULTISAMPLE_BIT_ARB = 0x20000000; ///
enum GL_MULTISAMPLE_BIT_EXT = 0x20000000; ///
enum GL_MULTISAMPLE_BUFFER_BIT0_QCOM = 0x01000000; ///
enum GL_MULTISAMPLE_BUFFER_BIT1_QCOM = 0x02000000; ///
enum GL_MULTISAMPLE_BUFFER_BIT2_QCOM = 0x04000000; ///
enum GL_MULTISAMPLE_BUFFER_BIT3_QCOM = 0x08000000; ///
enum GL_MULTISAMPLE_BUFFER_BIT4_QCOM = 0x10000000; ///
enum GL_MULTISAMPLE_BUFFER_BIT5_QCOM = 0x20000000; ///
enum GL_MULTISAMPLE_BUFFER_BIT6_QCOM = 0x40000000; ///
enum GL_MULTISAMPLE_BUFFER_BIT7_QCOM = 0x80000000; ///
enum GL_MULTISAMPLE_COVERAGE_MODES_NV = 0x8E12; ///
enum GL_MULTISAMPLE_EXT = 0x809D; ///
enum GL_MULTISAMPLE_FILTER_HINT_NV = 0x8534; ///
enum GL_MULTISAMPLE_LINE_WIDTH_GRANULARITY = 0x9382; ///
enum GL_MULTISAMPLE_LINE_WIDTH_GRANULARITY_ARB = 0x9382; ///
enum GL_MULTISAMPLE_LINE_WIDTH_RANGE = 0x9381; ///
enum GL_MULTISAMPLE_LINE_WIDTH_RANGE_ARB = 0x9381; ///
enum GL_MULTISAMPLE_RASTERIZATION_ALLOWED_EXT = 0x932B; ///
enum GL_MULTISAMPLE_SGIS = 0x809D; ///
enum GL_MULTIVIEW_EXT = 0x90F1; ///
enum GL_MUL_ATI = 0x8964; ///
enum GL_MVP_MATRIX_EXT = 0x87E3; ///
enum GL_N3F_V3F = 0x2A25; ///
enum GL_NAMED_STRING_LENGTH_ARB = 0x8DE9; ///
enum GL_NAMED_STRING_TYPE_ARB = 0x8DEA; ///
enum GL_NAME_LENGTH = 0x92F9; ///
enum GL_NAME_STACK_DEPTH = 0x0D70; ///
enum GL_NAND = 0x150E; ///
enum GL_NATIVE_GRAPHICS_BEGIN_HINT_PGI = 0x1A203; ///
enum GL_NATIVE_GRAPHICS_END_HINT_PGI = 0x1A204; ///
enum GL_NATIVE_GRAPHICS_HANDLE_PGI = 0x1A202; ///
enum GL_NEAREST = 0x2600; ///
enum GL_NEAREST_CLIPMAP_LINEAR_SGIX = 0x844E; ///
enum GL_NEAREST_CLIPMAP_NEAREST_SGIX = 0x844D; ///
enum GL_NEAREST_MIPMAP_LINEAR = 0x2702; ///
enum GL_NEAREST_MIPMAP_NEAREST = 0x2700; ///
enum GL_NEGATE_BIT_ATI = 0x00000004; ///
enum GL_NEGATIVE_ONE_EXT = 0x87DF; ///
enum GL_NEGATIVE_ONE_TO_ONE = 0x935E; ///
enum GL_NEGATIVE_W_EXT = 0x87DC; ///
enum GL_NEGATIVE_X_EXT = 0x87D9; ///
enum GL_NEGATIVE_Y_EXT = 0x87DA; ///
enum GL_NEGATIVE_Z_EXT = 0x87DB; ///
enum GL_NEVER = 0x0200; ///
enum GL_NEXT_BUFFER_NV = -2; ///
enum GL_NEXT_VIDEO_CAPTURE_BUFFER_STATUS_NV = 0x9025; ///
enum GL_NICEST = 0x1102; ///
enum GL_NONE = 0; ///
enum GL_NONE_OES = 0; ///
enum GL_NOOP = 0x1505; ///
enum GL_NOP_COMMAND_NV = 0x0001; ///
enum GL_NOR = 0x1508; ///
enum GL_NORMALIZE = 0x0BA1; ///
enum GL_NORMALIZED_RANGE_EXT = 0x87E0; ///
enum GL_NORMAL_ARRAY = 0x8075; ///
enum GL_NORMAL_ARRAY_ADDRESS_NV = 0x8F22; ///
enum GL_NORMAL_ARRAY_BUFFER_BINDING = 0x8897; ///
enum GL_NORMAL_ARRAY_BUFFER_BINDING_ARB = 0x8897; ///
enum GL_NORMAL_ARRAY_COUNT_EXT = 0x8080; ///
enum GL_NORMAL_ARRAY_EXT = 0x8075; ///
enum GL_NORMAL_ARRAY_LENGTH_NV = 0x8F2C; ///
enum GL_NORMAL_ARRAY_LIST_IBM = 0x103071; ///
enum GL_NORMAL_ARRAY_LIST_STRIDE_IBM = 0x103081; ///
enum GL_NORMAL_ARRAY_PARALLEL_POINTERS_INTEL = 0x83F6; ///
enum GL_NORMAL_ARRAY_POINTER = 0x808F; ///
enum GL_NORMAL_ARRAY_POINTER_EXT = 0x808F; ///
enum GL_NORMAL_ARRAY_STRIDE = 0x807F; ///
enum GL_NORMAL_ARRAY_STRIDE_EXT = 0x807F; ///
enum GL_NORMAL_ARRAY_TYPE = 0x807E; ///
enum GL_NORMAL_ARRAY_TYPE_EXT = 0x807E; ///
enum GL_NORMAL_BIT_PGI = 0x08000000; ///
enum GL_NORMAL_MAP = 0x8511; ///
enum GL_NORMAL_MAP_ARB = 0x8511; ///
enum GL_NORMAL_MAP_EXT = 0x8511; ///
enum GL_NORMAL_MAP_NV = 0x8511; ///
enum GL_NORMAL_MAP_OES = 0x8511; ///
enum GL_NOTEQUAL = 0x0205; ///
enum GL_NO_ERROR = 0; ///
enum GL_NO_RESET_NOTIFICATION = 0x8261; ///
enum GL_NO_RESET_NOTIFICATION_ARB = 0x8261; ///
enum GL_NO_RESET_NOTIFICATION_EXT = 0x8261; ///
enum GL_NO_RESET_NOTIFICATION_KHR = 0x8261; ///
enum GL_NUM_ACTIVE_VARIABLES = 0x9304; ///
enum GL_NUM_COMPATIBLE_SUBROUTINES = 0x8E4A; ///
enum GL_NUM_COMPRESSED_TEXTURE_FORMATS = 0x86A2; ///
enum GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB = 0x86A2; ///
enum GL_NUM_DOWNSAMPLE_SCALES_IMG = 0x913D; ///
enum GL_NUM_EXTENSIONS = 0x821D; ///
enum GL_NUM_FILL_STREAMS_NV = 0x8E29; ///
enum GL_NUM_FRAGMENT_CONSTANTS_ATI = 0x896F; ///
enum GL_NUM_FRAGMENT_REGISTERS_ATI = 0x896E; ///
enum GL_NUM_GENERAL_COMBINERS_NV = 0x854E; ///
enum GL_NUM_INPUT_INTERPOLATOR_COMPONENTS_ATI = 0x8973; ///
enum GL_NUM_INSTRUCTIONS_PER_PASS_ATI = 0x8971; ///
enum GL_NUM_INSTRUCTIONS_TOTAL_ATI = 0x8972; ///
enum GL_NUM_LOOPBACK_COMPONENTS_ATI = 0x8974; ///
enum GL_NUM_PASSES_ATI = 0x8970; ///
enum GL_NUM_PROGRAM_BINARY_FORMATS = 0x87FE; ///
enum GL_NUM_PROGRAM_BINARY_FORMATS_OES = 0x87FE; ///
enum GL_NUM_SAMPLE_COUNTS = 0x9380; ///
enum GL_NUM_SHADER_BINARY_FORMATS = 0x8DF9; ///
enum GL_NUM_SHADING_LANGUAGE_VERSIONS = 0x82E9; ///
enum GL_NUM_SPARSE_LEVELS_ARB = 0x91AA; ///
enum GL_NUM_SPARSE_LEVELS_EXT = 0x91AA; ///
enum GL_NUM_VIDEO_CAPTURE_STREAMS_NV = 0x9024; ///
enum GL_NUM_VIRTUAL_PAGE_SIZES_ARB = 0x91A8; ///
enum GL_NUM_VIRTUAL_PAGE_SIZES_EXT = 0x91A8; ///
enum GL_NUM_WINDOW_RECTANGLES_EXT = 0x8F15; ///
enum GL_OBJECT_ACTIVE_ATTRIBUTES_ARB = 0x8B89; ///
enum GL_OBJECT_ACTIVE_ATTRIBUTE_MAX_LENGTH_ARB = 0x8B8A; ///
enum GL_OBJECT_ACTIVE_UNIFORMS_ARB = 0x8B86; ///
enum GL_OBJECT_ACTIVE_UNIFORM_MAX_LENGTH_ARB = 0x8B87; ///
enum GL_OBJECT_ATTACHED_OBJECTS_ARB = 0x8B85; ///
enum GL_OBJECT_BUFFER_SIZE_ATI = 0x8764; ///
enum GL_OBJECT_BUFFER_USAGE_ATI = 0x8765; ///
enum GL_OBJECT_COMPILE_STATUS_ARB = 0x8B81; ///
enum GL_OBJECT_DELETE_STATUS_ARB = 0x8B80; ///
enum GL_OBJECT_DISTANCE_TO_LINE_SGIS = 0x81F3; ///
enum GL_OBJECT_DISTANCE_TO_POINT_SGIS = 0x81F1; ///
enum GL_OBJECT_INFO_LOG_LENGTH_ARB = 0x8B84; ///
enum GL_OBJECT_LINEAR = 0x2401; ///
enum GL_OBJECT_LINEAR_NV = 0x2401; ///
enum GL_OBJECT_LINE_SGIS = 0x81F7; ///
enum GL_OBJECT_LINK_STATUS_ARB = 0x8B82; ///
enum GL_OBJECT_PLANE = 0x2501; ///
enum GL_OBJECT_POINT_SGIS = 0x81F5; ///
enum GL_OBJECT_SHADER_SOURCE_LENGTH_ARB = 0x8B88; ///
enum GL_OBJECT_SUBTYPE_ARB = 0x8B4F; ///
enum GL_OBJECT_TYPE = 0x9112; ///
enum GL_OBJECT_TYPE_APPLE = 0x9112; ///
enum GL_OBJECT_TYPE_ARB = 0x8B4E; ///
enum GL_OBJECT_VALIDATE_STATUS_ARB = 0x8B83; ///
enum GL_OCCLUSION_QUERY_EVENT_MASK_AMD = 0x874F; ///
enum GL_OCCLUSION_TEST_HP = 0x8165; ///
enum GL_OCCLUSION_TEST_RESULT_HP = 0x8166; ///
enum GL_OFFSET = 0x92FC; ///
enum GL_OFFSET_HILO_PROJECTIVE_TEXTURE_2D_NV = 0x8856; ///
enum GL_OFFSET_HILO_PROJECTIVE_TEXTURE_RECTANGLE_NV = 0x8857; ///
enum GL_OFFSET_HILO_TEXTURE_2D_NV = 0x8854; ///
enum GL_OFFSET_HILO_TEXTURE_RECTANGLE_NV = 0x8855; ///
enum GL_OFFSET_PROJECTIVE_TEXTURE_2D_NV = 0x8850; ///
enum GL_OFFSET_PROJECTIVE_TEXTURE_2D_SCALE_NV = 0x8851; ///
enum GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_NV = 0x8852; ///
enum GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_SCALE_NV = 0x8853; ///
enum GL_OFFSET_TEXTURE_2D_BIAS_NV = 0x86E3; ///
enum GL_OFFSET_TEXTURE_2D_MATRIX_NV = 0x86E1; ///
enum GL_OFFSET_TEXTURE_2D_NV = 0x86E8; ///
enum GL_OFFSET_TEXTURE_2D_SCALE_NV = 0x86E2; ///
enum GL_OFFSET_TEXTURE_BIAS_NV = 0x86E3; ///
enum GL_OFFSET_TEXTURE_MATRIX_NV = 0x86E1; ///
enum GL_OFFSET_TEXTURE_RECTANGLE_NV = 0x864C; ///
enum GL_OFFSET_TEXTURE_RECTANGLE_SCALE_NV = 0x864D; ///
enum GL_OFFSET_TEXTURE_SCALE_NV = 0x86E2; ///
enum GL_ONE = 1; ///
enum GL_ONE_EXT = 0x87DE; ///
enum GL_ONE_MINUS_CONSTANT_ALPHA = 0x8004; ///
enum GL_ONE_MINUS_CONSTANT_ALPHA_EXT = 0x8004; ///
enum GL_ONE_MINUS_CONSTANT_COLOR = 0x8002; ///
enum GL_ONE_MINUS_CONSTANT_COLOR_EXT = 0x8002; ///
enum GL_ONE_MINUS_DST_ALPHA = 0x0305; ///
enum GL_ONE_MINUS_DST_COLOR = 0x0307; ///
enum GL_ONE_MINUS_SRC1_ALPHA = 0x88FB; ///
enum GL_ONE_MINUS_SRC1_ALPHA_EXT = 0x88FB; ///
enum GL_ONE_MINUS_SRC1_COLOR = 0x88FA; ///
enum GL_ONE_MINUS_SRC1_COLOR_EXT = 0x88FA; ///
enum GL_ONE_MINUS_SRC_ALPHA = 0x0303; ///
enum GL_ONE_MINUS_SRC_COLOR = 0x0301; ///
enum GL_OPERAND0_ALPHA = 0x8598; ///
enum GL_OPERAND0_ALPHA_ARB = 0x8598; ///
enum GL_OPERAND0_ALPHA_EXT = 0x8598; ///
enum GL_OPERAND0_RGB = 0x8590; ///
enum GL_OPERAND0_RGB_ARB = 0x8590; ///
enum GL_OPERAND0_RGB_EXT = 0x8590; ///
enum GL_OPERAND1_ALPHA = 0x8599; ///
enum GL_OPERAND1_ALPHA_ARB = 0x8599; ///
enum GL_OPERAND1_ALPHA_EXT = 0x8599; ///
enum GL_OPERAND1_RGB = 0x8591; ///
enum GL_OPERAND1_RGB_ARB = 0x8591; ///
enum GL_OPERAND1_RGB_EXT = 0x8591; ///
enum GL_OPERAND2_ALPHA = 0x859A; ///
enum GL_OPERAND2_ALPHA_ARB = 0x859A; ///
enum GL_OPERAND2_ALPHA_EXT = 0x859A; ///
enum GL_OPERAND2_RGB = 0x8592; ///
enum GL_OPERAND2_RGB_ARB = 0x8592; ///
enum GL_OPERAND2_RGB_EXT = 0x8592; ///
enum GL_OPERAND3_ALPHA_NV = 0x859B; ///
enum GL_OPERAND3_RGB_NV = 0x8593; ///
enum GL_OP_ADD_EXT = 0x8787; ///
enum GL_OP_CLAMP_EXT = 0x878E; ///
enum GL_OP_CROSS_PRODUCT_EXT = 0x8797; ///
enum GL_OP_DOT3_EXT = 0x8784; ///
enum GL_OP_DOT4_EXT = 0x8785; ///
enum GL_OP_EXP_BASE_2_EXT = 0x8791; ///
enum GL_OP_FLOOR_EXT = 0x878F; ///
enum GL_OP_FRAC_EXT = 0x8789; ///
enum GL_OP_INDEX_EXT = 0x8782; ///
enum GL_OP_LOG_BASE_2_EXT = 0x8792; ///
enum GL_OP_MADD_EXT = 0x8788; ///
enum GL_OP_MAX_EXT = 0x878A; ///
enum GL_OP_MIN_EXT = 0x878B; ///
enum GL_OP_MOV_EXT = 0x8799; ///
enum GL_OP_MULTIPLY_MATRIX_EXT = 0x8798; ///
enum GL_OP_MUL_EXT = 0x8786; ///
enum GL_OP_NEGATE_EXT = 0x8783; ///
enum GL_OP_POWER_EXT = 0x8793; ///
enum GL_OP_RECIP_EXT = 0x8794; ///
enum GL_OP_RECIP_SQRT_EXT = 0x8795; ///
enum GL_OP_ROUND_EXT = 0x8790; ///
enum GL_OP_SET_GE_EXT = 0x878C; ///
enum GL_OP_SET_LT_EXT = 0x878D; ///
enum GL_OP_SUB_EXT = 0x8796; ///
enum GL_OR = 0x1507; ///
enum GL_ORDER = 0x0A01; ///
enum GL_OR_INVERTED = 0x150D; ///
enum GL_OR_REVERSE = 0x150B; ///
enum GL_OUTPUT_COLOR0_EXT = 0x879B; ///
enum GL_OUTPUT_COLOR1_EXT = 0x879C; ///
enum GL_OUTPUT_FOG_EXT = 0x87BD; ///
enum GL_OUTPUT_TEXTURE_COORD0_EXT = 0x879D; ///
enum GL_OUTPUT_TEXTURE_COORD10_EXT = 0x87A7; ///
enum GL_OUTPUT_TEXTURE_COORD11_EXT = 0x87A8; ///
enum GL_OUTPUT_TEXTURE_COORD12_EXT = 0x87A9; ///
enum GL_OUTPUT_TEXTURE_COORD13_EXT = 0x87AA; ///
enum GL_OUTPUT_TEXTURE_COORD14_EXT = 0x87AB; ///
enum GL_OUTPUT_TEXTURE_COORD15_EXT = 0x87AC; ///
enum GL_OUTPUT_TEXTURE_COORD16_EXT = 0x87AD; ///
enum GL_OUTPUT_TEXTURE_COORD17_EXT = 0x87AE; ///
enum GL_OUTPUT_TEXTURE_COORD18_EXT = 0x87AF; ///
enum GL_OUTPUT_TEXTURE_COORD19_EXT = 0x87B0; ///
enum GL_OUTPUT_TEXTURE_COORD1_EXT = 0x879E; ///
enum GL_OUTPUT_TEXTURE_COORD20_EXT = 0x87B1; ///
enum GL_OUTPUT_TEXTURE_COORD21_EXT = 0x87B2; ///
enum GL_OUTPUT_TEXTURE_COORD22_EXT = 0x87B3; ///
enum GL_OUTPUT_TEXTURE_COORD23_EXT = 0x87B4; ///
enum GL_OUTPUT_TEXTURE_COORD24_EXT = 0x87B5; ///
enum GL_OUTPUT_TEXTURE_COORD25_EXT = 0x87B6; ///
enum GL_OUTPUT_TEXTURE_COORD26_EXT = 0x87B7; ///
enum GL_OUTPUT_TEXTURE_COORD27_EXT = 0x87B8; ///
enum GL_OUTPUT_TEXTURE_COORD28_EXT = 0x87B9; ///
enum GL_OUTPUT_TEXTURE_COORD29_EXT = 0x87BA; ///
enum GL_OUTPUT_TEXTURE_COORD2_EXT = 0x879F; ///
enum GL_OUTPUT_TEXTURE_COORD30_EXT = 0x87BB; ///
enum GL_OUTPUT_TEXTURE_COORD31_EXT = 0x87BC; ///
enum GL_OUTPUT_TEXTURE_COORD3_EXT = 0x87A0; ///
enum GL_OUTPUT_TEXTURE_COORD4_EXT = 0x87A1; ///
enum GL_OUTPUT_TEXTURE_COORD5_EXT = 0x87A2; ///
enum GL_OUTPUT_TEXTURE_COORD6_EXT = 0x87A3; ///
enum GL_OUTPUT_TEXTURE_COORD7_EXT = 0x87A4; ///
enum GL_OUTPUT_TEXTURE_COORD8_EXT = 0x87A5; ///
enum GL_OUTPUT_TEXTURE_COORD9_EXT = 0x87A6; ///
enum GL_OUTPUT_VERTEX_EXT = 0x879A; ///
enum GL_OUT_OF_MEMORY = 0x0505; ///
enum GL_OVERLAY = 0x9296; ///
enum GL_OVERLAY_KHR = 0x9296; ///
enum GL_OVERLAY_NV = 0x9296; ///
enum GL_PACK_ALIGNMENT = 0x0D05; ///
enum GL_PACK_CMYK_HINT_EXT = 0x800E; ///
enum GL_PACK_COMPRESSED_BLOCK_DEPTH = 0x912D; ///
enum GL_PACK_COMPRESSED_BLOCK_HEIGHT = 0x912C; ///
enum GL_PACK_COMPRESSED_BLOCK_SIZE = 0x912E; ///
enum GL_PACK_COMPRESSED_BLOCK_WIDTH = 0x912B; ///
enum GL_PACK_COMPRESSED_SIZE_SGIX = 0x831C; ///
enum GL_PACK_IMAGE_DEPTH_SGIS = 0x8131; ///
enum GL_PACK_IMAGE_HEIGHT = 0x806C; ///
enum GL_PACK_IMAGE_HEIGHT_EXT = 0x806C; ///
enum GL_PACK_INVERT_MESA = 0x8758; ///
enum GL_PACK_LSB_FIRST = 0x0D01; ///
enum GL_PACK_MAX_COMPRESSED_SIZE_SGIX = 0x831B; ///
enum GL_PACK_RESAMPLE_OML = 0x8984; ///
enum GL_PACK_RESAMPLE_SGIX = 0x842E; ///
enum GL_PACK_REVERSE_ROW_ORDER_ANGLE = 0x93A4; ///
enum GL_PACK_ROW_BYTES_APPLE = 0x8A15; ///
enum GL_PACK_ROW_LENGTH = 0x0D02; ///
enum GL_PACK_SKIP_IMAGES = 0x806B; ///
enum GL_PACK_SKIP_IMAGES_EXT = 0x806B; ///
enum GL_PACK_SKIP_PIXELS = 0x0D04; ///
enum GL_PACK_SKIP_ROWS = 0x0D03; ///
enum GL_PACK_SKIP_VOLUMES_SGIS = 0x8130; ///
enum GL_PACK_SUBSAMPLE_RATE_SGIX = 0x85A0; ///
enum GL_PACK_SWAP_BYTES = 0x0D00; ///
enum GL_PALETTE4_R5_G6_B5_OES = 0x8B92; ///
enum GL_PALETTE4_RGB5_A1_OES = 0x8B94; ///
enum GL_PALETTE4_RGB8_OES = 0x8B90; ///
enum GL_PALETTE4_RGBA4_OES = 0x8B93; ///
enum GL_PALETTE4_RGBA8_OES = 0x8B91; ///
enum GL_PALETTE8_R5_G6_B5_OES = 0x8B97; ///
enum GL_PALETTE8_RGB5_A1_OES = 0x8B99; ///
enum GL_PALETTE8_RGB8_OES = 0x8B95; ///
enum GL_PALETTE8_RGBA4_OES = 0x8B98; ///
enum GL_PALETTE8_RGBA8_OES = 0x8B96; ///
enum GL_PARALLEL_ARRAYS_INTEL = 0x83F4; ///
enum GL_PARAMETER_BUFFER_ARB = 0x80EE; ///
enum GL_PARAMETER_BUFFER_BINDING_ARB = 0x80EF; ///
enum GL_PARTIAL_SUCCESS_NV = 0x902E; ///
enum GL_PASS_THROUGH_NV = 0x86E6; ///
enum GL_PASS_THROUGH_TOKEN = 0x0700; ///
enum GL_PATCHES = 0x000E; ///
enum GL_PATCHES_EXT = 0x000E; ///
enum GL_PATCHES_OES = 0x000E; ///
enum GL_PATCH_DEFAULT_INNER_LEVEL = 0x8E73; ///
enum GL_PATCH_DEFAULT_INNER_LEVEL_EXT = 0x8E73; ///
enum GL_PATCH_DEFAULT_OUTER_LEVEL = 0x8E74; ///
enum GL_PATCH_DEFAULT_OUTER_LEVEL_EXT = 0x8E74; ///
enum GL_PATCH_VERTICES = 0x8E72; ///
enum GL_PATCH_VERTICES_EXT = 0x8E72; ///
enum GL_PATCH_VERTICES_OES = 0x8E72; ///
enum GL_PATH_CLIENT_LENGTH_NV = 0x907F; ///
enum GL_PATH_COMMAND_COUNT_NV = 0x909D; ///
enum GL_PATH_COMPUTED_LENGTH_NV = 0x90A0; ///
enum GL_PATH_COORD_COUNT_NV = 0x909E; ///
enum GL_PATH_COVER_DEPTH_FUNC_NV = 0x90BF; ///
enum GL_PATH_DASH_ARRAY_COUNT_NV = 0x909F; ///
enum GL_PATH_DASH_CAPS_NV = 0x907B; ///
enum GL_PATH_DASH_OFFSET_NV = 0x907E; ///
enum GL_PATH_DASH_OFFSET_RESET_NV = 0x90B4; ///
enum GL_PATH_END_CAPS_NV = 0x9076; ///
enum GL_PATH_ERROR_POSITION_NV = 0x90AB; ///
enum GL_PATH_FILL_BOUNDING_BOX_NV = 0x90A1; ///
enum GL_PATH_FILL_COVER_MODE_NV = 0x9082; ///
enum GL_PATH_FILL_MASK_NV = 0x9081; ///
enum GL_PATH_FILL_MODE_NV = 0x9080; ///
enum GL_PATH_FOG_GEN_MODE_NV = 0x90AC; ///
enum GL_PATH_FORMAT_PS_NV = 0x9071; ///
enum GL_PATH_FORMAT_SVG_NV = 0x9070; ///
enum GL_PATH_GEN_COEFF_NV = 0x90B1; ///
enum GL_PATH_GEN_COLOR_FORMAT_NV = 0x90B2; ///
enum GL_PATH_GEN_COMPONENTS_NV = 0x90B3; ///
enum GL_PATH_GEN_MODE_NV = 0x90B0; ///
enum GL_PATH_INITIAL_DASH_CAP_NV = 0x907C; ///
enum GL_PATH_INITIAL_END_CAP_NV = 0x9077; ///
enum GL_PATH_JOIN_STYLE_NV = 0x9079; ///
enum GL_PATH_MAX_MODELVIEW_STACK_DEPTH_NV = 0x0D36; ///
enum GL_PATH_MAX_PROJECTION_STACK_DEPTH_NV = 0x0D38; ///
enum GL_PATH_MITER_LIMIT_NV = 0x907A; ///
enum GL_PATH_MODELVIEW_MATRIX_NV = 0x0BA6; ///
enum GL_PATH_MODELVIEW_NV = 0x1700; ///
enum GL_PATH_MODELVIEW_STACK_DEPTH_NV = 0x0BA3; ///
enum GL_PATH_OBJECT_BOUNDING_BOX_NV = 0x908A; ///
enum GL_PATH_PROJECTION_MATRIX_NV = 0x0BA7; ///
enum GL_PATH_PROJECTION_NV = 0x1701; ///
enum GL_PATH_PROJECTION_STACK_DEPTH_NV = 0x0BA4; ///
enum GL_PATH_STENCIL_DEPTH_OFFSET_FACTOR_NV = 0x90BD; ///
enum GL_PATH_STENCIL_DEPTH_OFFSET_UNITS_NV = 0x90BE; ///
enum GL_PATH_STENCIL_FUNC_NV = 0x90B7; ///
enum GL_PATH_STENCIL_REF_NV = 0x90B8; ///
enum GL_PATH_STENCIL_VALUE_MASK_NV = 0x90B9; ///
enum GL_PATH_STROKE_BOUNDING_BOX_NV = 0x90A2; ///
enum GL_PATH_STROKE_COVER_MODE_NV = 0x9083; ///
enum GL_PATH_STROKE_MASK_NV = 0x9084; ///
enum GL_PATH_STROKE_WIDTH_NV = 0x9075; ///
enum GL_PATH_TERMINAL_DASH_CAP_NV = 0x907D; ///
enum GL_PATH_TERMINAL_END_CAP_NV = 0x9078; ///
enum GL_PATH_TRANSPOSE_MODELVIEW_MATRIX_NV = 0x84E3; ///
enum GL_PATH_TRANSPOSE_PROJECTION_MATRIX_NV = 0x84E4; ///
enum GL_PERCENTAGE_AMD = 0x8BC3; ///
enum GL_PERFMON_GLOBAL_MODE_QCOM = 0x8FA0; ///
enum GL_PERFMON_RESULT_AMD = 0x8BC6; ///
enum GL_PERFMON_RESULT_AVAILABLE_AMD = 0x8BC4; ///
enum GL_PERFMON_RESULT_SIZE_AMD = 0x8BC5; ///
enum GL_PERFORMANCE_MONITOR_AMD = 0x9152; ///
enum GL_PERFQUERY_COUNTER_DATA_BOOL32_INTEL = 0x94FC; ///
enum GL_PERFQUERY_COUNTER_DATA_DOUBLE_INTEL = 0x94FB; ///
enum GL_PERFQUERY_COUNTER_DATA_FLOAT_INTEL = 0x94FA; ///
enum GL_PERFQUERY_COUNTER_DATA_UINT32_INTEL = 0x94F8; ///
enum GL_PERFQUERY_COUNTER_DATA_UINT64_INTEL = 0x94F9; ///
enum GL_PERFQUERY_COUNTER_DESC_LENGTH_MAX_INTEL = 0x94FF; ///
enum GL_PERFQUERY_COUNTER_DURATION_NORM_INTEL = 0x94F1; ///
enum GL_PERFQUERY_COUNTER_DURATION_RAW_INTEL = 0x94F2; ///
enum GL_PERFQUERY_COUNTER_EVENT_INTEL = 0x94F0; ///
enum GL_PERFQUERY_COUNTER_NAME_LENGTH_MAX_INTEL = 0x94FE; ///
enum GL_PERFQUERY_COUNTER_RAW_INTEL = 0x94F4; ///
enum GL_PERFQUERY_COUNTER_THROUGHPUT_INTEL = 0x94F3; ///
enum GL_PERFQUERY_COUNTER_TIMESTAMP_INTEL = 0x94F5; ///
enum GL_PERFQUERY_DONOT_FLUSH_INTEL = 0x83F9; ///
enum GL_PERFQUERY_FLUSH_INTEL = 0x83FA; ///
enum GL_PERFQUERY_GLOBAL_CONTEXT_INTEL = 0x00000001; ///
enum GL_PERFQUERY_GPA_EXTENDED_COUNTERS_INTEL = 0x9500; ///
enum GL_PERFQUERY_QUERY_NAME_LENGTH_MAX_INTEL = 0x94FD; ///
enum GL_PERFQUERY_SINGLE_CONTEXT_INTEL = 0x00000000; ///
enum GL_PERFQUERY_WAIT_INTEL = 0x83FB; ///
enum GL_PERSPECTIVE_CORRECTION_HINT = 0x0C50; ///
enum GL_PERTURB_EXT = 0x85AE; ///
enum GL_PER_STAGE_CONSTANTS_NV = 0x8535; ///
enum GL_PHONG_HINT_WIN = 0x80EB; ///
enum GL_PHONG_WIN = 0x80EA; ///
enum GL_PINLIGHT_NV = 0x92A8; ///
enum GL_PIXEL_BUFFER_BARRIER_BIT = 0x00000080; ///
enum GL_PIXEL_BUFFER_BARRIER_BIT_EXT = 0x00000080; ///
enum GL_PIXEL_COUNTER_BITS_NV = 0x8864; ///
enum GL_PIXEL_COUNT_AVAILABLE_NV = 0x8867; ///
enum GL_PIXEL_COUNT_NV = 0x8866; ///
enum GL_PIXEL_CUBIC_WEIGHT_EXT = 0x8333; ///
enum GL_PIXEL_FRAGMENT_ALPHA_SOURCE_SGIS = 0x8355; ///
enum GL_PIXEL_FRAGMENT_RGB_SOURCE_SGIS = 0x8354; ///
enum GL_PIXEL_GROUP_COLOR_SGIS = 0x8356; ///
enum GL_PIXEL_MAG_FILTER_EXT = 0x8331; ///
enum GL_PIXEL_MAP_A_TO_A = 0x0C79; ///
enum GL_PIXEL_MAP_A_TO_A_SIZE = 0x0CB9; ///
enum GL_PIXEL_MAP_B_TO_B = 0x0C78; ///
enum GL_PIXEL_MAP_B_TO_B_SIZE = 0x0CB8; ///
enum GL_PIXEL_MAP_G_TO_G = 0x0C77; ///
enum GL_PIXEL_MAP_G_TO_G_SIZE = 0x0CB7; ///
enum GL_PIXEL_MAP_I_TO_A = 0x0C75; ///
enum GL_PIXEL_MAP_I_TO_A_SIZE = 0x0CB5; ///
enum GL_PIXEL_MAP_I_TO_B = 0x0C74; ///
enum GL_PIXEL_MAP_I_TO_B_SIZE = 0x0CB4; ///
enum GL_PIXEL_MAP_I_TO_G = 0x0C73; ///
enum GL_PIXEL_MAP_I_TO_G_SIZE = 0x0CB3; ///
enum GL_PIXEL_MAP_I_TO_I = 0x0C70; ///
enum GL_PIXEL_MAP_I_TO_I_SIZE = 0x0CB0; ///
enum GL_PIXEL_MAP_I_TO_R = 0x0C72; ///
enum GL_PIXEL_MAP_I_TO_R_SIZE = 0x0CB2; ///
enum GL_PIXEL_MAP_R_TO_R = 0x0C76; ///
enum GL_PIXEL_MAP_R_TO_R_SIZE = 0x0CB6; ///
enum GL_PIXEL_MAP_S_TO_S = 0x0C71; ///
enum GL_PIXEL_MAP_S_TO_S_SIZE = 0x0CB1; ///
enum GL_PIXEL_MIN_FILTER_EXT = 0x8332; ///
enum GL_PIXEL_MODE_BIT = 0x00000020; ///
enum GL_PIXEL_PACK_BUFFER = 0x88EB; ///
enum GL_PIXEL_PACK_BUFFER_ARB = 0x88EB; ///
enum GL_PIXEL_PACK_BUFFER_BINDING = 0x88ED; ///
enum GL_PIXEL_PACK_BUFFER_BINDING_ARB = 0x88ED; ///
enum GL_PIXEL_PACK_BUFFER_BINDING_EXT = 0x88ED; ///
enum GL_PIXEL_PACK_BUFFER_EXT = 0x88EB; ///
enum GL_PIXEL_SUBSAMPLE_2424_SGIX = 0x85A3; ///
enum GL_PIXEL_SUBSAMPLE_4242_SGIX = 0x85A4; ///
enum GL_PIXEL_SUBSAMPLE_4444_SGIX = 0x85A2; ///
enum GL_PIXEL_TEXTURE_SGIS = 0x8353; ///
enum GL_PIXEL_TEX_GEN_ALPHA_LS_SGIX = 0x8189; ///
enum GL_PIXEL_TEX_GEN_ALPHA_MS_SGIX = 0x818A; ///
enum GL_PIXEL_TEX_GEN_ALPHA_NO_REPLACE_SGIX = 0x8188; ///
enum GL_PIXEL_TEX_GEN_ALPHA_REPLACE_SGIX = 0x8187; ///
enum GL_PIXEL_TEX_GEN_MODE_SGIX = 0x832B; ///
enum GL_PIXEL_TEX_GEN_Q_CEILING_SGIX = 0x8184; ///
enum GL_PIXEL_TEX_GEN_Q_FLOOR_SGIX = 0x8186; ///
enum GL_PIXEL_TEX_GEN_Q_ROUND_SGIX = 0x8185; ///
enum GL_PIXEL_TEX_GEN_SGIX = 0x8139; ///
enum GL_PIXEL_TILE_BEST_ALIGNMENT_SGIX = 0x813E; ///
enum GL_PIXEL_TILE_CACHE_INCREMENT_SGIX = 0x813F; ///
enum GL_PIXEL_TILE_CACHE_SIZE_SGIX = 0x8145; ///
enum GL_PIXEL_TILE_GRID_DEPTH_SGIX = 0x8144; ///
enum GL_PIXEL_TILE_GRID_HEIGHT_SGIX = 0x8143; ///
enum GL_PIXEL_TILE_GRID_WIDTH_SGIX = 0x8142; ///
enum GL_PIXEL_TILE_HEIGHT_SGIX = 0x8141; ///
enum GL_PIXEL_TILE_WIDTH_SGIX = 0x8140; ///
enum GL_PIXEL_TRANSFORM_2D_EXT = 0x8330; ///
enum GL_PIXEL_TRANSFORM_2D_MATRIX_EXT = 0x8338; ///
enum GL_PIXEL_TRANSFORM_2D_STACK_DEPTH_EXT = 0x8336; ///
enum GL_PIXEL_UNPACK_BUFFER = 0x88EC; ///
enum GL_PIXEL_UNPACK_BUFFER_ARB = 0x88EC; ///
enum GL_PIXEL_UNPACK_BUFFER_BINDING = 0x88EF; ///
enum GL_PIXEL_UNPACK_BUFFER_BINDING_ARB = 0x88EF; ///
enum GL_PIXEL_UNPACK_BUFFER_BINDING_EXT = 0x88EF; ///
enum GL_PIXEL_UNPACK_BUFFER_EXT = 0x88EC; ///
enum GL_PLUS_CLAMPED_ALPHA_NV = 0x92B2; ///
enum GL_PLUS_CLAMPED_NV = 0x92B1; ///
enum GL_PLUS_DARKER_NV = 0x9292; ///
enum GL_PLUS_NV = 0x9291; ///
enum GL_PN_TRIANGLES_ATI = 0x87F0; ///
enum GL_PN_TRIANGLES_NORMAL_MODE_ATI = 0x87F3; ///
enum GL_PN_TRIANGLES_NORMAL_MODE_LINEAR_ATI = 0x87F7; ///
enum GL_PN_TRIANGLES_NORMAL_MODE_QUADRATIC_ATI = 0x87F8; ///
enum GL_PN_TRIANGLES_POINT_MODE_ATI = 0x87F2; ///
enum GL_PN_TRIANGLES_POINT_MODE_CUBIC_ATI = 0x87F6; ///
enum GL_PN_TRIANGLES_POINT_MODE_LINEAR_ATI = 0x87F5; ///
enum GL_PN_TRIANGLES_TESSELATION_LEVEL_ATI = 0x87F4; ///
enum GL_POINT = 0x1B00; ///
enum GL_POINTS = 0x0000; ///
enum GL_POINT_BIT = 0x00000002; ///
enum GL_POINT_DISTANCE_ATTENUATION = 0x8129; ///
enum GL_POINT_DISTANCE_ATTENUATION_ARB = 0x8129; ///
enum GL_POINT_FADE_THRESHOLD_SIZE = 0x8128; ///
enum GL_POINT_FADE_THRESHOLD_SIZE_ARB = 0x8128; ///
enum GL_POINT_FADE_THRESHOLD_SIZE_EXT = 0x8128; ///
enum GL_POINT_FADE_THRESHOLD_SIZE_SGIS = 0x8128; ///
enum GL_POINT_NV = 0x1B00; ///
enum GL_POINT_SIZE = 0x0B11; ///
enum GL_POINT_SIZE_ARRAY_BUFFER_BINDING_OES = 0x8B9F; ///
enum GL_POINT_SIZE_ARRAY_OES = 0x8B9C; ///
enum GL_POINT_SIZE_ARRAY_POINTER_OES = 0x898C; ///
enum GL_POINT_SIZE_ARRAY_STRIDE_OES = 0x898B; ///
enum GL_POINT_SIZE_ARRAY_TYPE_OES = 0x898A; ///
enum GL_POINT_SIZE_GRANULARITY = 0x0B13; ///
enum GL_POINT_SIZE_MAX = 0x8127; ///
enum GL_POINT_SIZE_MAX_ARB = 0x8127; ///
enum GL_POINT_SIZE_MAX_EXT = 0x8127; ///
enum GL_POINT_SIZE_MAX_SGIS = 0x8127; ///
enum GL_POINT_SIZE_MIN = 0x8126; ///
enum GL_POINT_SIZE_MIN_ARB = 0x8126; ///
enum GL_POINT_SIZE_MIN_EXT = 0x8126; ///
enum GL_POINT_SIZE_MIN_SGIS = 0x8126; ///
enum GL_POINT_SIZE_RANGE = 0x0B12; ///
enum GL_POINT_SMOOTH = 0x0B10; ///
enum GL_POINT_SMOOTH_HINT = 0x0C51; ///
enum GL_POINT_SPRITE = 0x8861; ///
enum GL_POINT_SPRITE_ARB = 0x8861; ///
enum GL_POINT_SPRITE_COORD_ORIGIN = 0x8CA0; ///
enum GL_POINT_SPRITE_NV = 0x8861; ///
enum GL_POINT_SPRITE_OES = 0x8861; ///
enum GL_POINT_SPRITE_R_MODE_NV = 0x8863; ///
enum GL_POINT_TOKEN = 0x0701; ///
enum GL_POLYGON = 0x0009; ///
enum GL_POLYGON_BIT = 0x00000008; ///
enum GL_POLYGON_MODE = 0x0B40; ///
enum GL_POLYGON_MODE_NV = 0x0B40; ///
enum GL_POLYGON_OFFSET_BIAS_EXT = 0x8039; ///
enum GL_POLYGON_OFFSET_CLAMP_EXT = 0x8E1B; ///
enum GL_POLYGON_OFFSET_COMMAND_NV = 0x000E; ///
enum GL_POLYGON_OFFSET_EXT = 0x8037; ///
enum GL_POLYGON_OFFSET_FACTOR = 0x8038; ///
enum GL_POLYGON_OFFSET_FACTOR_EXT = 0x8038; ///
enum GL_POLYGON_OFFSET_FILL = 0x8037; ///
enum GL_POLYGON_OFFSET_LINE = 0x2A02; ///
enum GL_POLYGON_OFFSET_LINE_NV = 0x2A02; ///
enum GL_POLYGON_OFFSET_POINT = 0x2A01; ///
enum GL_POLYGON_OFFSET_POINT_NV = 0x2A01; ///
enum GL_POLYGON_OFFSET_UNITS = 0x2A00; ///
enum GL_POLYGON_SMOOTH = 0x0B41; ///
enum GL_POLYGON_SMOOTH_HINT = 0x0C53; ///
enum GL_POLYGON_STIPPLE = 0x0B42; ///
enum GL_POLYGON_STIPPLE_BIT = 0x00000010; ///
enum GL_POLYGON_TOKEN = 0x0703; ///
enum GL_POSITION = 0x1203; ///
enum GL_POST_COLOR_MATRIX_ALPHA_BIAS = 0x80BB; ///
enum GL_POST_COLOR_MATRIX_ALPHA_BIAS_SGI = 0x80BB; ///
enum GL_POST_COLOR_MATRIX_ALPHA_SCALE = 0x80B7; ///
enum GL_POST_COLOR_MATRIX_ALPHA_SCALE_SGI = 0x80B7; ///
enum GL_POST_COLOR_MATRIX_BLUE_BIAS = 0x80BA; ///
enum GL_POST_COLOR_MATRIX_BLUE_BIAS_SGI = 0x80BA; ///
enum GL_POST_COLOR_MATRIX_BLUE_SCALE = 0x80B6; ///
enum GL_POST_COLOR_MATRIX_BLUE_SCALE_SGI = 0x80B6; ///
enum GL_POST_COLOR_MATRIX_COLOR_TABLE = 0x80D2; ///
enum GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI = 0x80D2; ///
enum GL_POST_COLOR_MATRIX_GREEN_BIAS = 0x80B9; ///
enum GL_POST_COLOR_MATRIX_GREEN_BIAS_SGI = 0x80B9; ///
enum GL_POST_COLOR_MATRIX_GREEN_SCALE = 0x80B5; ///
enum GL_POST_COLOR_MATRIX_GREEN_SCALE_SGI = 0x80B5; ///
enum GL_POST_COLOR_MATRIX_RED_BIAS = 0x80B8; ///
enum GL_POST_COLOR_MATRIX_RED_BIAS_SGI = 0x80B8; ///
enum GL_POST_COLOR_MATRIX_RED_SCALE = 0x80B4; ///
enum GL_POST_COLOR_MATRIX_RED_SCALE_SGI = 0x80B4; ///
enum GL_POST_CONVOLUTION_ALPHA_BIAS = 0x8023; ///
enum GL_POST_CONVOLUTION_ALPHA_BIAS_EXT = 0x8023; ///
enum GL_POST_CONVOLUTION_ALPHA_SCALE = 0x801F; ///
enum GL_POST_CONVOLUTION_ALPHA_SCALE_EXT = 0x801F; ///
enum GL_POST_CONVOLUTION_BLUE_BIAS = 0x8022; ///
enum GL_POST_CONVOLUTION_BLUE_BIAS_EXT = 0x8022; ///
enum GL_POST_CONVOLUTION_BLUE_SCALE = 0x801E; ///
enum GL_POST_CONVOLUTION_BLUE_SCALE_EXT = 0x801E; ///
enum GL_POST_CONVOLUTION_COLOR_TABLE = 0x80D1; ///
enum GL_POST_CONVOLUTION_COLOR_TABLE_SGI = 0x80D1; ///
enum GL_POST_CONVOLUTION_GREEN_BIAS = 0x8021; ///
enum GL_POST_CONVOLUTION_GREEN_BIAS_EXT = 0x8021; ///
enum GL_POST_CONVOLUTION_GREEN_SCALE = 0x801D; ///
enum GL_POST_CONVOLUTION_GREEN_SCALE_EXT = 0x801D; ///
enum GL_POST_CONVOLUTION_RED_BIAS = 0x8020; ///
enum GL_POST_CONVOLUTION_RED_BIAS_EXT = 0x8020; ///
enum GL_POST_CONVOLUTION_RED_SCALE = 0x801C; ///
enum GL_POST_CONVOLUTION_RED_SCALE_EXT = 0x801C; ///
enum GL_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP = 0x8162; ///
enum GL_POST_TEXTURE_FILTER_BIAS_RANGE_SGIX = 0x817B; ///
enum GL_POST_TEXTURE_FILTER_BIAS_SGIX = 0x8179; ///
enum GL_POST_TEXTURE_FILTER_SCALE_RANGE_SGIX = 0x817C; ///
enum GL_POST_TEXTURE_FILTER_SCALE_SGIX = 0x817A; ///
enum GL_PREFER_DOUBLEBUFFER_HINT_PGI = 0x1A1F8; ///
enum GL_PRESENT_DURATION_NV = 0x8E2B; ///
enum GL_PRESENT_TIME_NV = 0x8E2A; ///
enum GL_PRESERVE_ATI = 0x8762; ///
enum GL_PREVIOUS = 0x8578; ///
enum GL_PREVIOUS_ARB = 0x8578; ///
enum GL_PREVIOUS_EXT = 0x8578; ///
enum GL_PREVIOUS_TEXTURE_INPUT_NV = 0x86E4; ///
enum GL_PRIMARY_COLOR = 0x8577; ///
enum GL_PRIMARY_COLOR_ARB = 0x8577; ///
enum GL_PRIMARY_COLOR_EXT = 0x8577; ///
enum GL_PRIMARY_COLOR_NV = 0x852C; ///
enum GL_PRIMITIVES_GENERATED = 0x8C87; ///
enum GL_PRIMITIVES_GENERATED_EXT = 0x8C87; ///
enum GL_PRIMITIVES_GENERATED_NV = 0x8C87; ///
enum GL_PRIMITIVES_GENERATED_OES = 0x8C87; ///
enum GL_PRIMITIVES_SUBMITTED_ARB = 0x82EF; ///
enum GL_PRIMITIVE_BOUNDING_BOX = 0x92BE; ///
enum GL_PRIMITIVE_BOUNDING_BOX_ARB = 0x92BE; ///
enum GL_PRIMITIVE_BOUNDING_BOX_EXT = 0x92BE; ///
enum GL_PRIMITIVE_BOUNDING_BOX_OES = 0x92BE; ///
enum GL_PRIMITIVE_ID_NV = 0x8C7C; ///
enum GL_PRIMITIVE_RESTART = 0x8F9D; ///
enum GL_PRIMITIVE_RESTART_FIXED_INDEX = 0x8D69; ///
enum GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED = 0x8221; ///
enum GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED_OES = 0x8221; ///
enum GL_PRIMITIVE_RESTART_INDEX = 0x8F9E; ///
enum GL_PRIMITIVE_RESTART_INDEX_NV = 0x8559; ///
enum GL_PRIMITIVE_RESTART_NV = 0x8558; ///
enum GL_PROGRAM = 0x82E2; ///
enum GL_PROGRAMMABLE_SAMPLE_LOCATION_ARB = 0x9341; ///
enum GL_PROGRAMMABLE_SAMPLE_LOCATION_NV = 0x9341; ///
enum GL_PROGRAMMABLE_SAMPLE_LOCATION_TABLE_SIZE_ARB = 0x9340; ///
enum GL_PROGRAMMABLE_SAMPLE_LOCATION_TABLE_SIZE_NV = 0x9340; ///
enum GL_PROGRAM_ADDRESS_REGISTERS_ARB = 0x88B0; ///
enum GL_PROGRAM_ALU_INSTRUCTIONS_ARB = 0x8805; ///
enum GL_PROGRAM_ATTRIBS_ARB = 0x88AC; ///
enum GL_PROGRAM_ATTRIB_COMPONENTS_NV = 0x8906; ///
enum GL_PROGRAM_BINARY_ANGLE = 0x93A6; ///
enum GL_PROGRAM_BINARY_FORMATS = 0x87FF; ///
enum GL_PROGRAM_BINARY_FORMATS_OES = 0x87FF; ///
enum GL_PROGRAM_BINARY_LENGTH = 0x8741; ///
enum GL_PROGRAM_BINARY_LENGTH_OES = 0x8741; ///
enum GL_PROGRAM_BINARY_RETRIEVABLE_HINT = 0x8257; ///
enum GL_PROGRAM_BINDING_ARB = 0x8677; ///
enum GL_PROGRAM_ERROR_POSITION_ARB = 0x864B; ///
enum GL_PROGRAM_ERROR_POSITION_NV = 0x864B; ///
enum GL_PROGRAM_ERROR_STRING_ARB = 0x8874; ///
enum GL_PROGRAM_ERROR_STRING_NV = 0x8874; ///
enum GL_PROGRAM_FORMAT_ARB = 0x8876; ///
enum GL_PROGRAM_FORMAT_ASCII_ARB = 0x8875; ///
enum GL_PROGRAM_INPUT = 0x92E3; ///
enum GL_PROGRAM_INSTRUCTIONS_ARB = 0x88A0; ///
enum GL_PROGRAM_KHR = 0x82E2; ///
enum GL_PROGRAM_LENGTH_ARB = 0x8627; ///
enum GL_PROGRAM_LENGTH_NV = 0x8627; ///
enum GL_PROGRAM_MATRIX_EXT = 0x8E2D; ///
enum GL_PROGRAM_MATRIX_STACK_DEPTH_EXT = 0x8E2F; ///
enum GL_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB = 0x88B2; ///
enum GL_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB = 0x8808; ///
enum GL_PROGRAM_NATIVE_ATTRIBS_ARB = 0x88AE; ///
enum GL_PROGRAM_NATIVE_INSTRUCTIONS_ARB = 0x88A2; ///
enum GL_PROGRAM_NATIVE_PARAMETERS_ARB = 0x88AA; ///
enum GL_PROGRAM_NATIVE_TEMPORARIES_ARB = 0x88A6; ///
enum GL_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB = 0x880A; ///
enum GL_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB = 0x8809; ///
enum GL_PROGRAM_OBJECT_ARB = 0x8B40; ///
enum GL_PROGRAM_OBJECT_EXT = 0x8B40; ///
enum GL_PROGRAM_OUTPUT = 0x92E4; ///
enum GL_PROGRAM_PARAMETERS_ARB = 0x88A8; ///
enum GL_PROGRAM_PARAMETER_NV = 0x8644; ///
enum GL_PROGRAM_PIPELINE = 0x82E4; ///
enum GL_PROGRAM_PIPELINE_BINDING = 0x825A; ///
enum GL_PROGRAM_PIPELINE_BINDING_EXT = 0x825A; ///
enum GL_PROGRAM_PIPELINE_KHR = 0x82E4; ///
enum GL_PROGRAM_PIPELINE_OBJECT_EXT = 0x8A4F; ///
enum GL_PROGRAM_POINT_SIZE = 0x8642; ///
enum GL_PROGRAM_POINT_SIZE_ARB = 0x8642; ///
enum GL_PROGRAM_POINT_SIZE_EXT = 0x8642; ///
enum GL_PROGRAM_RESIDENT_NV = 0x8647; ///
enum GL_PROGRAM_RESULT_COMPONENTS_NV = 0x8907; ///
enum GL_PROGRAM_SEPARABLE = 0x8258; ///
enum GL_PROGRAM_SEPARABLE_EXT = 0x8258; ///
enum GL_PROGRAM_STRING_ARB = 0x8628; ///
enum GL_PROGRAM_STRING_NV = 0x8628; ///
enum GL_PROGRAM_TARGET_NV = 0x8646; ///
enum GL_PROGRAM_TEMPORARIES_ARB = 0x88A4; ///
enum GL_PROGRAM_TEX_INDIRECTIONS_ARB = 0x8807; ///
enum GL_PROGRAM_TEX_INSTRUCTIONS_ARB = 0x8806; ///
enum GL_PROGRAM_UNDER_NATIVE_LIMITS_ARB = 0x88B6; ///
enum GL_PROJECTION = 0x1701; ///
enum GL_PROJECTION_MATRIX = 0x0BA7; ///
enum GL_PROJECTION_MATRIX_FLOAT_AS_INT_BITS_OES = 0x898E; ///
enum GL_PROJECTION_STACK_DEPTH = 0x0BA4; ///
enum GL_PROVOKING_VERTEX = 0x8E4F; ///
enum GL_PROVOKING_VERTEX_EXT = 0x8E4F; ///
enum GL_PROXY_COLOR_TABLE = 0x80D3; ///
enum GL_PROXY_COLOR_TABLE_SGI = 0x80D3; ///
enum GL_PROXY_HISTOGRAM = 0x8025; ///
enum GL_PROXY_HISTOGRAM_EXT = 0x8025; ///
enum GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE = 0x80D5; ///
enum GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE_SGI = 0x80D5; ///
enum GL_PROXY_POST_CONVOLUTION_COLOR_TABLE = 0x80D4; ///
enum GL_PROXY_POST_CONVOLUTION_COLOR_TABLE_SGI = 0x80D4; ///
enum GL_PROXY_POST_IMAGE_TRANSFORM_COLOR_TABLE_HP = 0x8163; ///
enum GL_PROXY_TEXTURE_1D = 0x8063; ///
enum GL_PROXY_TEXTURE_1D_ARRAY = 0x8C19; ///
enum GL_PROXY_TEXTURE_1D_ARRAY_EXT = 0x8C19; ///
enum GL_PROXY_TEXTURE_1D_EXT = 0x8063; ///
enum GL_PROXY_TEXTURE_1D_STACK_MESAX = 0x875B; ///
enum GL_PROXY_TEXTURE_2D = 0x8064; ///
enum GL_PROXY_TEXTURE_2D_ARRAY = 0x8C1B; ///
enum GL_PROXY_TEXTURE_2D_ARRAY_EXT = 0x8C1B; ///
enum GL_PROXY_TEXTURE_2D_EXT = 0x8064; ///
enum GL_PROXY_TEXTURE_2D_MULTISAMPLE = 0x9101; ///
enum GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY = 0x9103; ///
enum GL_PROXY_TEXTURE_2D_STACK_MESAX = 0x875C; ///
enum GL_PROXY_TEXTURE_3D = 0x8070; ///
enum GL_PROXY_TEXTURE_3D_EXT = 0x8070; ///
enum GL_PROXY_TEXTURE_4D_SGIS = 0x8135; ///
enum GL_PROXY_TEXTURE_COLOR_TABLE_SGI = 0x80BD; ///
enum GL_PROXY_TEXTURE_CUBE_MAP = 0x851B; ///
enum GL_PROXY_TEXTURE_CUBE_MAP_ARB = 0x851B; ///
enum GL_PROXY_TEXTURE_CUBE_MAP_ARRAY = 0x900B; ///
enum GL_PROXY_TEXTURE_CUBE_MAP_ARRAY_ARB = 0x900B; ///
enum GL_PROXY_TEXTURE_CUBE_MAP_EXT = 0x851B; ///
enum GL_PROXY_TEXTURE_RECTANGLE = 0x84F7; ///
enum GL_PROXY_TEXTURE_RECTANGLE_ARB = 0x84F7; ///
enum GL_PROXY_TEXTURE_RECTANGLE_NV = 0x84F7; ///
enum GL_PURGEABLE_APPLE = 0x8A1D; ///
enum GL_PURGED_CONTEXT_RESET_NV = 0x92BB; ///
enum GL_Q = 0x2003; ///
enum GL_QUADRATIC_ATTENUATION = 0x1209; ///
enum GL_QUADRATIC_CURVE_TO_NV = 0x0A; ///
enum GL_QUADS = 0x0007; ///
enum GL_QUADS_EXT = 0x0007; ///
enum GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION = 0x8E4C; ///
enum GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION_EXT = 0x8E4C; ///
enum GL_QUADS_OES = 0x0007; ///
enum GL_QUAD_ALPHA4_SGIS = 0x811E; ///
enum GL_QUAD_ALPHA8_SGIS = 0x811F; ///
enum GL_QUAD_INTENSITY4_SGIS = 0x8122; ///
enum GL_QUAD_INTENSITY8_SGIS = 0x8123; ///
enum GL_QUAD_LUMINANCE4_SGIS = 0x8120; ///
enum GL_QUAD_LUMINANCE8_SGIS = 0x8121; ///
enum GL_QUAD_MESH_SUN = 0x8614; ///
enum GL_QUAD_STRIP = 0x0008; ///
enum GL_QUAD_TEXTURE_SELECT_SGIS = 0x8125; ///
enum GL_QUARTER_BIT_ATI = 0x00000010; ///
enum GL_QUERY = 0x82E3; ///
enum GL_QUERY_ALL_EVENT_BITS_AMD = 0xFFFFFFFF; ///
enum GL_QUERY_BUFFER = 0x9192; ///
enum GL_QUERY_BUFFER_AMD = 0x9192; ///
enum GL_QUERY_BUFFER_BARRIER_BIT = 0x00008000; ///
enum GL_QUERY_BUFFER_BINDING = 0x9193; ///
enum GL_QUERY_BUFFER_BINDING_AMD = 0x9193; ///
enum GL_QUERY_BY_REGION_NO_WAIT = 0x8E16; ///
enum GL_QUERY_BY_REGION_NO_WAIT_INVERTED = 0x8E1A; ///
enum GL_QUERY_BY_REGION_NO_WAIT_NV = 0x8E16; ///
enum GL_QUERY_BY_REGION_WAIT = 0x8E15; ///
enum GL_QUERY_BY_REGION_WAIT_INVERTED = 0x8E19; ///
enum GL_QUERY_BY_REGION_WAIT_NV = 0x8E15; ///
enum GL_QUERY_COUNTER_BITS = 0x8864; ///
enum GL_QUERY_COUNTER_BITS_ARB = 0x8864; ///
enum GL_QUERY_COUNTER_BITS_EXT = 0x8864; ///
enum GL_QUERY_DEPTH_BOUNDS_FAIL_EVENT_BIT_AMD = 0x00000008; ///
enum GL_QUERY_DEPTH_FAIL_EVENT_BIT_AMD = 0x00000002; ///
enum GL_QUERY_DEPTH_PASS_EVENT_BIT_AMD = 0x00000001; ///
enum GL_QUERY_KHR = 0x82E3; ///
enum GL_QUERY_NO_WAIT = 0x8E14; ///
enum GL_QUERY_NO_WAIT_INVERTED = 0x8E18; ///
enum GL_QUERY_NO_WAIT_NV = 0x8E14; ///
enum GL_QUERY_OBJECT_AMD = 0x9153; ///
enum GL_QUERY_OBJECT_EXT = 0x9153; ///
enum GL_QUERY_RESULT = 0x8866; ///
enum GL_QUERY_RESULT_ARB = 0x8866; ///
enum GL_QUERY_RESULT_AVAILABLE = 0x8867; ///
enum GL_QUERY_RESULT_AVAILABLE_ARB = 0x8867; ///
enum GL_QUERY_RESULT_AVAILABLE_EXT = 0x8867; ///
enum GL_QUERY_RESULT_EXT = 0x8866; ///
enum GL_QUERY_RESULT_NO_WAIT = 0x9194; ///
enum GL_QUERY_RESULT_NO_WAIT_AMD = 0x9194; ///
enum GL_QUERY_STENCIL_FAIL_EVENT_BIT_AMD = 0x00000004; ///
enum GL_QUERY_TARGET = 0x82EA; ///
enum GL_QUERY_WAIT = 0x8E13; ///
enum GL_QUERY_WAIT_INVERTED = 0x8E17; ///
enum GL_QUERY_WAIT_NV = 0x8E13; ///
enum GL_R = 0x2002; ///
enum GL_R11F_G11F_B10F = 0x8C3A; ///
enum GL_R11F_G11F_B10F_APPLE = 0x8C3A; ///
enum GL_R11F_G11F_B10F_EXT = 0x8C3A; ///
enum GL_R16 = 0x822A; ///
enum GL_R16F = 0x822D; ///
enum GL_R16F_EXT = 0x822D; ///
enum GL_R16I = 0x8233; ///
enum GL_R16UI = 0x8234; ///
enum GL_R16_EXT = 0x822A; ///
enum GL_R16_SNORM = 0x8F98; ///
enum GL_R16_SNORM_EXT = 0x8F98; ///
enum GL_R1UI_C3F_V3F_SUN = 0x85C6; ///
enum GL_R1UI_C4F_N3F_V3F_SUN = 0x85C8; ///
enum GL_R1UI_C4UB_V3F_SUN = 0x85C5; ///
enum GL_R1UI_N3F_V3F_SUN = 0x85C7; ///
enum GL_R1UI_T2F_C4F_N3F_V3F_SUN = 0x85CB; ///
enum GL_R1UI_T2F_N3F_V3F_SUN = 0x85CA; ///
enum GL_R1UI_T2F_V3F_SUN = 0x85C9; ///
enum GL_R1UI_V3F_SUN = 0x85C4; ///
enum GL_R32F = 0x822E; ///
enum GL_R32F_EXT = 0x822E; ///
enum GL_R32I = 0x8235; ///
enum GL_R32UI = 0x8236; ///
enum GL_R3_G3_B2 = 0x2A10; ///
enum GL_R8 = 0x8229; ///
enum GL_R8I = 0x8231; ///
enum GL_R8UI = 0x8232; ///
enum GL_R8_EXT = 0x8229; ///
enum GL_R8_SNORM = 0x8F94; ///
enum GL_RASTERIZER_DISCARD = 0x8C89; ///
enum GL_RASTERIZER_DISCARD_EXT = 0x8C89; ///
enum GL_RASTERIZER_DISCARD_NV = 0x8C89; ///
enum GL_RASTER_FIXED_SAMPLE_LOCATIONS_EXT = 0x932A; ///
enum GL_RASTER_MULTISAMPLE_EXT = 0x9327; ///
enum GL_RASTER_POSITION_UNCLIPPED_IBM = 0x19262; ///
enum GL_RASTER_SAMPLES_EXT = 0x9328; ///
enum GL_READ_BUFFER = 0x0C02; ///
enum GL_READ_BUFFER_EXT = 0x0C02; ///
enum GL_READ_BUFFER_NV = 0x0C02; ///
enum GL_READ_FRAMEBUFFER = 0x8CA8; ///
enum GL_READ_FRAMEBUFFER_ANGLE = 0x8CA8; ///
enum GL_READ_FRAMEBUFFER_APPLE = 0x8CA8; ///
enum GL_READ_FRAMEBUFFER_BINDING = 0x8CAA; ///
enum GL_READ_FRAMEBUFFER_BINDING_ANGLE = 0x8CAA; ///
enum GL_READ_FRAMEBUFFER_BINDING_APPLE = 0x8CAA; ///
enum GL_READ_FRAMEBUFFER_BINDING_EXT = 0x8CAA; ///
enum GL_READ_FRAMEBUFFER_BINDING_NV = 0x8CAA; ///
enum GL_READ_FRAMEBUFFER_EXT = 0x8CA8; ///
enum GL_READ_FRAMEBUFFER_NV = 0x8CA8; ///
enum GL_READ_ONLY = 0x88B8; ///
enum GL_READ_ONLY_ARB = 0x88B8; ///
enum GL_READ_PIXELS = 0x828C; ///
enum GL_READ_PIXELS_FORMAT = 0x828D; ///
enum GL_READ_PIXELS_TYPE = 0x828E; ///
enum GL_READ_PIXEL_DATA_RANGE_LENGTH_NV = 0x887B; ///
enum GL_READ_PIXEL_DATA_RANGE_NV = 0x8879; ///
enum GL_READ_PIXEL_DATA_RANGE_POINTER_NV = 0x887D; ///
enum GL_READ_WRITE = 0x88BA; ///
enum GL_READ_WRITE_ARB = 0x88BA; ///
enum GL_RECIP_ADD_SIGNED_ALPHA_IMG = 0x8C05; ///
enum GL_RECLAIM_MEMORY_HINT_PGI = 0x1A1FE; ///
enum GL_RECT_NV = 0xF6; ///
enum GL_RED = 0x1903; ///
enum GL_REDUCE = 0x8016; ///
enum GL_REDUCE_EXT = 0x8016; ///
enum GL_RED_BIAS = 0x0D15; ///
enum GL_RED_BITS = 0x0D52; ///
enum GL_RED_BIT_ATI = 0x00000001; ///
enum GL_RED_EXT = 0x1903; ///
enum GL_RED_INTEGER = 0x8D94; ///
enum GL_RED_INTEGER_EXT = 0x8D94; ///
enum GL_RED_MAX_CLAMP_INGR = 0x8564; ///
enum GL_RED_MIN_CLAMP_INGR = 0x8560; ///
enum GL_RED_NV = 0x1903; ///
enum GL_RED_SCALE = 0x0D14; ///
enum GL_RED_SNORM = 0x8F90; ///
enum GL_REFERENCED_BY_COMPUTE_SHADER = 0x930B; ///
enum GL_REFERENCED_BY_FRAGMENT_SHADER = 0x930A; ///
enum GL_REFERENCED_BY_GEOMETRY_SHADER = 0x9309; ///
enum GL_REFERENCED_BY_GEOMETRY_SHADER_EXT = 0x9309; ///
enum GL_REFERENCED_BY_GEOMETRY_SHADER_OES = 0x9309; ///
enum GL_REFERENCED_BY_TESS_CONTROL_SHADER = 0x9307; ///
enum GL_REFERENCED_BY_TESS_CONTROL_SHADER_EXT = 0x9307; ///
enum GL_REFERENCED_BY_TESS_CONTROL_SHADER_OES = 0x9307; ///
enum GL_REFERENCED_BY_TESS_EVALUATION_SHADER = 0x9308; ///
enum GL_REFERENCED_BY_TESS_EVALUATION_SHADER_EXT = 0x9308; ///
enum GL_REFERENCED_BY_TESS_EVALUATION_SHADER_OES = 0x9308; ///
enum GL_REFERENCED_BY_VERTEX_SHADER = 0x9306; ///
enum GL_REFERENCE_PLANE_EQUATION_SGIX = 0x817E; ///
enum GL_REFERENCE_PLANE_SGIX = 0x817D; ///
enum GL_REFLECTION_MAP = 0x8512; ///
enum GL_REFLECTION_MAP_ARB = 0x8512; ///
enum GL_REFLECTION_MAP_EXT = 0x8512; ///
enum GL_REFLECTION_MAP_NV = 0x8512; ///
enum GL_REFLECTION_MAP_OES = 0x8512; ///
enum GL_REGISTER_COMBINERS_NV = 0x8522; ///
enum GL_REG_0_ATI = 0x8921; ///
enum GL_REG_10_ATI = 0x892B; ///
enum GL_REG_11_ATI = 0x892C; ///
enum GL_REG_12_ATI = 0x892D; ///
enum GL_REG_13_ATI = 0x892E; ///
enum GL_REG_14_ATI = 0x892F; ///
enum GL_REG_15_ATI = 0x8930; ///
enum GL_REG_16_ATI = 0x8931; ///
enum GL_REG_17_ATI = 0x8932; ///
enum GL_REG_18_ATI = 0x8933; ///
enum GL_REG_19_ATI = 0x8934; ///
enum GL_REG_1_ATI = 0x8922; ///
enum GL_REG_20_ATI = 0x8935; ///
enum GL_REG_21_ATI = 0x8936; ///
enum GL_REG_22_ATI = 0x8937; ///
enum GL_REG_23_ATI = 0x8938; ///
enum GL_REG_24_ATI = 0x8939; ///
enum GL_REG_25_ATI = 0x893A; ///
enum GL_REG_26_ATI = 0x893B; ///
enum GL_REG_27_ATI = 0x893C; ///
enum GL_REG_28_ATI = 0x893D; ///
enum GL_REG_29_ATI = 0x893E; ///
enum GL_REG_2_ATI = 0x8923; ///
enum GL_REG_30_ATI = 0x893F; ///
enum GL_REG_31_ATI = 0x8940; ///
enum GL_REG_3_ATI = 0x8924; ///
enum GL_REG_4_ATI = 0x8925; ///
enum GL_REG_5_ATI = 0x8926; ///
enum GL_REG_6_ATI = 0x8927; ///
enum GL_REG_7_ATI = 0x8928; ///
enum GL_REG_8_ATI = 0x8929; ///
enum GL_REG_9_ATI = 0x892A; ///
enum GL_RELATIVE_ARC_TO_NV = 0xFF; ///
enum GL_RELATIVE_CONIC_CURVE_TO_NV = 0x1B; ///
enum GL_RELATIVE_CUBIC_CURVE_TO_NV = 0x0D; ///
enum GL_RELATIVE_HORIZONTAL_LINE_TO_NV = 0x07; ///
enum GL_RELATIVE_LARGE_CCW_ARC_TO_NV = 0x17; ///
enum GL_RELATIVE_LARGE_CW_ARC_TO_NV = 0x19; ///
enum GL_RELATIVE_LINE_TO_NV = 0x05; ///
enum GL_RELATIVE_MOVE_TO_NV = 0x03; ///
enum GL_RELATIVE_QUADRATIC_CURVE_TO_NV = 0x0B; ///
enum GL_RELATIVE_RECT_NV = 0xF7; ///
enum GL_RELATIVE_ROUNDED_RECT2_NV = 0xEB; ///
enum GL_RELATIVE_ROUNDED_RECT4_NV = 0xED; ///
enum GL_RELATIVE_ROUNDED_RECT8_NV = 0xEF; ///
enum GL_RELATIVE_ROUNDED_RECT_NV = 0xE9; ///
enum GL_RELATIVE_SMALL_CCW_ARC_TO_NV = 0x13; ///
enum GL_RELATIVE_SMALL_CW_ARC_TO_NV = 0x15; ///
enum GL_RELATIVE_SMOOTH_CUBIC_CURVE_TO_NV = 0x11; ///
enum GL_RELATIVE_SMOOTH_QUADRATIC_CURVE_TO_NV = 0x0F; ///
enum GL_RELATIVE_VERTICAL_LINE_TO_NV = 0x09; ///
enum GL_RELEASED_APPLE = 0x8A19; ///
enum GL_RENDER = 0x1C00; ///
enum GL_RENDERBUFFER = 0x8D41; ///
enum GL_RENDERBUFFER_ALPHA_SIZE = 0x8D53; ///
enum GL_RENDERBUFFER_ALPHA_SIZE_EXT = 0x8D53; ///
enum GL_RENDERBUFFER_ALPHA_SIZE_OES = 0x8D53; ///
enum GL_RENDERBUFFER_BINDING = 0x8CA7; ///
enum GL_RENDERBUFFER_BINDING_ANGLE = 0x8CA7; ///
enum GL_RENDERBUFFER_BINDING_EXT = 0x8CA7; ///
enum GL_RENDERBUFFER_BINDING_OES = 0x8CA7; ///
enum GL_RENDERBUFFER_BLUE_SIZE = 0x8D52; ///
enum GL_RENDERBUFFER_BLUE_SIZE_EXT = 0x8D52; ///
enum GL_RENDERBUFFER_BLUE_SIZE_OES = 0x8D52; ///
enum GL_RENDERBUFFER_COLOR_SAMPLES_NV = 0x8E10; ///
enum GL_RENDERBUFFER_COVERAGE_SAMPLES_NV = 0x8CAB; ///
enum GL_RENDERBUFFER_DEPTH_SIZE = 0x8D54; ///
enum GL_RENDERBUFFER_DEPTH_SIZE_EXT = 0x8D54; ///
enum GL_RENDERBUFFER_DEPTH_SIZE_OES = 0x8D54; ///
enum GL_RENDERBUFFER_EXT = 0x8D41; ///
enum GL_RENDERBUFFER_FREE_MEMORY_ATI = 0x87FD; ///
enum GL_RENDERBUFFER_GREEN_SIZE = 0x8D51; ///
enum GL_RENDERBUFFER_GREEN_SIZE_EXT = 0x8D51; ///
enum GL_RENDERBUFFER_GREEN_SIZE_OES = 0x8D51; ///
enum GL_RENDERBUFFER_HEIGHT = 0x8D43; ///
enum GL_RENDERBUFFER_HEIGHT_EXT = 0x8D43; ///
enum GL_RENDERBUFFER_HEIGHT_OES = 0x8D43; ///
enum GL_RENDERBUFFER_INTERNAL_FORMAT = 0x8D44; ///
enum GL_RENDERBUFFER_INTERNAL_FORMAT_EXT = 0x8D44; ///
enum GL_RENDERBUFFER_INTERNAL_FORMAT_OES = 0x8D44; ///
enum GL_RENDERBUFFER_OES = 0x8D41; ///
enum GL_RENDERBUFFER_RED_SIZE = 0x8D50; ///
enum GL_RENDERBUFFER_RED_SIZE_EXT = 0x8D50; ///
enum GL_RENDERBUFFER_RED_SIZE_OES = 0x8D50; ///
enum GL_RENDERBUFFER_SAMPLES = 0x8CAB; ///
enum GL_RENDERBUFFER_SAMPLES_ANGLE = 0x8CAB; ///
enum GL_RENDERBUFFER_SAMPLES_APPLE = 0x8CAB; ///
enum GL_RENDERBUFFER_SAMPLES_EXT = 0x8CAB; ///
enum GL_RENDERBUFFER_SAMPLES_IMG = 0x9133; ///
enum GL_RENDERBUFFER_SAMPLES_NV = 0x8CAB; ///
enum GL_RENDERBUFFER_STENCIL_SIZE = 0x8D55; ///
enum GL_RENDERBUFFER_STENCIL_SIZE_EXT = 0x8D55; ///
enum GL_RENDERBUFFER_STENCIL_SIZE_OES = 0x8D55; ///
enum GL_RENDERBUFFER_WIDTH = 0x8D42; ///
enum GL_RENDERBUFFER_WIDTH_EXT = 0x8D42; ///
enum GL_RENDERBUFFER_WIDTH_OES = 0x8D42; ///
enum GL_RENDERER = 0x1F01; ///
enum GL_RENDER_DIRECT_TO_FRAMEBUFFER_QCOM = 0x8FB3; ///
enum GL_RENDER_MODE = 0x0C40; ///
enum GL_REPEAT = 0x2901; ///
enum GL_REPLACE = 0x1E01; ///
enum GL_REPLACEMENT_CODE_ARRAY_POINTER_SUN = 0x85C3; ///
enum GL_REPLACEMENT_CODE_ARRAY_STRIDE_SUN = 0x85C2; ///
enum GL_REPLACEMENT_CODE_ARRAY_SUN = 0x85C0; ///
enum GL_REPLACEMENT_CODE_ARRAY_TYPE_SUN = 0x85C1; ///
enum GL_REPLACEMENT_CODE_SUN = 0x81D8; ///
enum GL_REPLACE_EXT = 0x8062; ///
enum GL_REPLACE_MIDDLE_SUN = 0x0002; ///
enum GL_REPLACE_OLDEST_SUN = 0x0003; ///
enum GL_REPLACE_VALUE_AMD = 0x874B; ///
enum GL_REPLICATE_BORDER = 0x8153; ///
enum GL_REPLICATE_BORDER_HP = 0x8153; ///
enum GL_REQUIRED_TEXTURE_IMAGE_UNITS_OES = 0x8D68; ///
enum GL_RESAMPLE_AVERAGE_OML = 0x8988; ///
enum GL_RESAMPLE_DECIMATE_OML = 0x8989; ///
enum GL_RESAMPLE_DECIMATE_SGIX = 0x8430; ///
enum GL_RESAMPLE_REPLICATE_OML = 0x8986; ///
enum GL_RESAMPLE_REPLICATE_SGIX = 0x8433; ///
enum GL_RESAMPLE_ZERO_FILL_OML = 0x8987; ///
enum GL_RESAMPLE_ZERO_FILL_SGIX = 0x8434; ///
enum GL_RESCALE_NORMAL = 0x803A; ///
enum GL_RESCALE_NORMAL_EXT = 0x803A; ///
enum GL_RESET_NOTIFICATION_STRATEGY = 0x8256; ///
enum GL_RESET_NOTIFICATION_STRATEGY_ARB = 0x8256; ///
enum GL_RESET_NOTIFICATION_STRATEGY_EXT = 0x8256; ///
enum GL_RESET_NOTIFICATION_STRATEGY_KHR = 0x8256; ///
enum GL_RESTART_PATH_NV = 0xF0; ///
enum GL_RESTART_SUN = 0x0001; ///
enum GL_RETAINED_APPLE = 0x8A1B; ///
enum GL_RETURN = 0x0102; ///
enum GL_RG = 0x8227; ///
enum GL_RG16 = 0x822C; ///
enum GL_RG16F = 0x822F; ///
enum GL_RG16F_EXT = 0x822F; ///
enum GL_RG16I = 0x8239; ///
enum GL_RG16UI = 0x823A; ///
enum GL_RG16_EXT = 0x822C; ///
enum GL_RG16_SNORM = 0x8F99; ///
enum GL_RG16_SNORM_EXT = 0x8F99; ///
enum GL_RG32F = 0x8230; ///
enum GL_RG32F_EXT = 0x8230; ///
enum GL_RG32I = 0x823B; ///
enum GL_RG32UI = 0x823C; ///
enum GL_RG8 = 0x822B; ///
enum GL_RG8I = 0x8237; ///
enum GL_RG8UI = 0x8238; ///
enum GL_RG8_EXT = 0x822B; ///
enum GL_RG8_SNORM = 0x8F95; ///
enum GL_RGB = 0x1907; ///
enum GL_RGB10 = 0x8052; ///
enum GL_RGB10_A2 = 0x8059; ///
enum GL_RGB10_A2UI = 0x906F; ///
enum GL_RGB10_A2_EXT = 0x8059; ///
enum GL_RGB10_EXT = 0x8052; ///
enum GL_RGB12 = 0x8053; ///
enum GL_RGB12_EXT = 0x8053; ///
enum GL_RGB16 = 0x8054; ///
enum GL_RGB16F = 0x881B; ///
enum GL_RGB16F_ARB = 0x881B; ///
enum GL_RGB16F_EXT = 0x881B; ///
enum GL_RGB16I = 0x8D89; ///
enum GL_RGB16I_EXT = 0x8D89; ///
enum GL_RGB16UI = 0x8D77; ///
enum GL_RGB16UI_EXT = 0x8D77; ///
enum GL_RGB16_EXT = 0x8054; ///
enum GL_RGB16_SNORM = 0x8F9A; ///
enum GL_RGB16_SNORM_EXT = 0x8F9A; ///
enum GL_RGB2_EXT = 0x804E; ///
enum GL_RGB32F = 0x8815; ///
enum GL_RGB32F_ARB = 0x8815; ///
enum GL_RGB32F_EXT = 0x8815; ///
enum GL_RGB32I = 0x8D83; ///
enum GL_RGB32I_EXT = 0x8D83; ///
enum GL_RGB32UI = 0x8D71; ///
enum GL_RGB32UI_EXT = 0x8D71; ///
enum GL_RGB4 = 0x804F; ///
enum GL_RGB4_EXT = 0x804F; ///
enum GL_RGB4_S3TC = 0x83A1; ///
enum GL_RGB5 = 0x8050; ///
enum GL_RGB565 = 0x8D62; ///
enum GL_RGB565_OES = 0x8D62; ///
enum GL_RGB5_A1 = 0x8057; ///
enum GL_RGB5_A1_EXT = 0x8057; ///
enum GL_RGB5_A1_OES = 0x8057; ///
enum GL_RGB5_EXT = 0x8050; ///
enum GL_RGB8 = 0x8051; ///
enum GL_RGB8I = 0x8D8F; ///
enum GL_RGB8I_EXT = 0x8D8F; ///
enum GL_RGB8UI = 0x8D7D; ///
enum GL_RGB8UI_EXT = 0x8D7D; ///
enum GL_RGB8_EXT = 0x8051; ///
enum GL_RGB8_OES = 0x8051; ///
enum GL_RGB8_SNORM = 0x8F96; ///
enum GL_RGB9_E5 = 0x8C3D; ///
enum GL_RGB9_E5_APPLE = 0x8C3D; ///
enum GL_RGB9_E5_EXT = 0x8C3D; ///
enum GL_RGBA = 0x1908; ///
enum GL_RGBA12 = 0x805A; ///
enum GL_RGBA12_EXT = 0x805A; ///
enum GL_RGBA16 = 0x805B; ///
enum GL_RGBA16F = 0x881A; ///
enum GL_RGBA16F_ARB = 0x881A; ///
enum GL_RGBA16F_EXT = 0x881A; ///
enum GL_RGBA16I = 0x8D88; ///
enum GL_RGBA16I_EXT = 0x8D88; ///
enum GL_RGBA16UI = 0x8D76; ///
enum GL_RGBA16UI_EXT = 0x8D76; ///
enum GL_RGBA16_EXT = 0x805B; ///
enum GL_RGBA16_SNORM = 0x8F9B; ///
enum GL_RGBA16_SNORM_EXT = 0x8F9B; ///
enum GL_RGBA2 = 0x8055; ///
enum GL_RGBA2_EXT = 0x8055; ///
enum GL_RGBA32F = 0x8814; ///
enum GL_RGBA32F_ARB = 0x8814; ///
enum GL_RGBA32F_EXT = 0x8814; ///
enum GL_RGBA32I = 0x8D82; ///
enum GL_RGBA32I_EXT = 0x8D82; ///
enum GL_RGBA32UI = 0x8D70; ///
enum GL_RGBA32UI_EXT = 0x8D70; ///
enum GL_RGBA4 = 0x8056; ///
enum GL_RGBA4_DXT5_S3TC = 0x83A5; ///
enum GL_RGBA4_EXT = 0x8056; ///
enum GL_RGBA4_OES = 0x8056; ///
enum GL_RGBA4_S3TC = 0x83A3; ///
enum GL_RGBA8 = 0x8058; ///
enum GL_RGBA8I = 0x8D8E; ///
enum GL_RGBA8I_EXT = 0x8D8E; ///
enum GL_RGBA8UI = 0x8D7C; ///
enum GL_RGBA8UI_EXT = 0x8D7C; ///
enum GL_RGBA8_EXT = 0x8058; ///
enum GL_RGBA8_OES = 0x8058; ///
enum GL_RGBA8_SNORM = 0x8F97; ///
enum GL_RGBA_DXT5_S3TC = 0x83A4; ///
enum GL_RGBA_FLOAT16_APPLE = 0x881A; ///
enum GL_RGBA_FLOAT16_ATI = 0x881A; ///
enum GL_RGBA_FLOAT32_APPLE = 0x8814; ///
enum GL_RGBA_FLOAT32_ATI = 0x8814; ///
enum GL_RGBA_FLOAT_MODE_ARB = 0x8820; ///
enum GL_RGBA_FLOAT_MODE_ATI = 0x8820; ///
enum GL_RGBA_INTEGER = 0x8D99; ///
enum GL_RGBA_INTEGER_EXT = 0x8D99; ///
enum GL_RGBA_INTEGER_MODE_EXT = 0x8D9E; ///
enum GL_RGBA_MODE = 0x0C31; ///
enum GL_RGBA_S3TC = 0x83A2; ///
enum GL_RGBA_SIGNED_COMPONENTS_EXT = 0x8C3C; ///
enum GL_RGBA_SNORM = 0x8F93; ///
enum GL_RGBA_UNSIGNED_DOT_PRODUCT_MAPPING_NV = 0x86D9; ///
enum GL_RGB_422_APPLE = 0x8A1F; ///
enum GL_RGB_FLOAT16_APPLE = 0x881B; ///
enum GL_RGB_FLOAT16_ATI = 0x881B; ///
enum GL_RGB_FLOAT32_APPLE = 0x8815; ///
enum GL_RGB_FLOAT32_ATI = 0x8815; ///
enum GL_RGB_INTEGER = 0x8D98; ///
enum GL_RGB_INTEGER_EXT = 0x8D98; ///
enum GL_RGB_RAW_422_APPLE = 0x8A51; ///
enum GL_RGB_S3TC = 0x83A0; ///
enum GL_RGB_SCALE = 0x8573; ///
enum GL_RGB_SCALE_ARB = 0x8573; ///
enum GL_RGB_SCALE_EXT = 0x8573; ///
enum GL_RGB_SNORM = 0x8F92; ///
enum GL_RG_EXT = 0x8227; ///
enum GL_RG_INTEGER = 0x8228; ///
enum GL_RG_SNORM = 0x8F91; ///
enum GL_RIGHT = 0x0407; ///
enum GL_ROUNDED_RECT2_NV = 0xEA; ///
enum GL_ROUNDED_RECT4_NV = 0xEC; ///
enum GL_ROUNDED_RECT8_NV = 0xEE; ///
enum GL_ROUNDED_RECT_NV = 0xE8; ///
enum GL_ROUND_NV = 0x90A4; ///
enum GL_S = 0x2000; ///
enum GL_SAMPLER = 0x82E6; ///
enum GL_SAMPLER_1D = 0x8B5D; ///
enum GL_SAMPLER_1D_ARB = 0x8B5D; ///
enum GL_SAMPLER_1D_ARRAY = 0x8DC0; ///
enum GL_SAMPLER_1D_ARRAY_EXT = 0x8DC0; ///
enum GL_SAMPLER_1D_ARRAY_SHADOW = 0x8DC3; ///
enum GL_SAMPLER_1D_ARRAY_SHADOW_EXT = 0x8DC3; ///
enum GL_SAMPLER_1D_SHADOW = 0x8B61; ///
enum GL_SAMPLER_1D_SHADOW_ARB = 0x8B61; ///
enum GL_SAMPLER_2D = 0x8B5E; ///
enum GL_SAMPLER_2D_ARB = 0x8B5E; ///
enum GL_SAMPLER_2D_ARRAY = 0x8DC1; ///
enum GL_SAMPLER_2D_ARRAY_EXT = 0x8DC1; ///
enum GL_SAMPLER_2D_ARRAY_SHADOW = 0x8DC4; ///
enum GL_SAMPLER_2D_ARRAY_SHADOW_EXT = 0x8DC4; ///
enum GL_SAMPLER_2D_ARRAY_SHADOW_NV = 0x8DC4; ///
enum GL_SAMPLER_2D_MULTISAMPLE = 0x9108; ///
enum GL_SAMPLER_2D_MULTISAMPLE_ARRAY = 0x910B; ///
enum GL_SAMPLER_2D_MULTISAMPLE_ARRAY_OES = 0x910B; ///
enum GL_SAMPLER_2D_RECT = 0x8B63; ///
enum GL_SAMPLER_2D_RECT_ARB = 0x8B63; ///
enum GL_SAMPLER_2D_RECT_SHADOW = 0x8B64; ///
enum GL_SAMPLER_2D_RECT_SHADOW_ARB = 0x8B64; ///
enum GL_SAMPLER_2D_SHADOW = 0x8B62; ///
enum GL_SAMPLER_2D_SHADOW_ARB = 0x8B62; ///
enum GL_SAMPLER_2D_SHADOW_EXT = 0x8B62; ///
enum GL_SAMPLER_3D = 0x8B5F; ///
enum GL_SAMPLER_3D_ARB = 0x8B5F; ///
enum GL_SAMPLER_3D_OES = 0x8B5F; ///
enum GL_SAMPLER_BINDING = 0x8919; ///
enum GL_SAMPLER_BUFFER = 0x8DC2; ///
enum GL_SAMPLER_BUFFER_AMD = 0x9001; ///
enum GL_SAMPLER_BUFFER_EXT = 0x8DC2; ///
enum GL_SAMPLER_BUFFER_OES = 0x8DC2; ///
enum GL_SAMPLER_CUBE = 0x8B60; ///
enum GL_SAMPLER_CUBE_ARB = 0x8B60; ///
enum GL_SAMPLER_CUBE_MAP_ARRAY = 0x900C; ///
enum GL_SAMPLER_CUBE_MAP_ARRAY_ARB = 0x900C; ///
enum GL_SAMPLER_CUBE_MAP_ARRAY_EXT = 0x900C; ///
enum GL_SAMPLER_CUBE_MAP_ARRAY_OES = 0x900C; ///
enum GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW = 0x900D; ///
enum GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW_ARB = 0x900D; ///
enum GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW_EXT = 0x900D; ///
enum GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW_OES = 0x900D; ///
enum GL_SAMPLER_CUBE_SHADOW = 0x8DC5; ///
enum GL_SAMPLER_CUBE_SHADOW_EXT = 0x8DC5; ///
enum GL_SAMPLER_CUBE_SHADOW_NV = 0x8DC5; ///
enum GL_SAMPLER_EXTERNAL_2D_Y2Y_EXT = 0x8BE7; ///
enum GL_SAMPLER_EXTERNAL_OES = 0x8D66; ///
enum GL_SAMPLER_KHR = 0x82E6; ///
enum GL_SAMPLER_OBJECT_AMD = 0x9155; ///
enum GL_SAMPLER_RENDERBUFFER_NV = 0x8E56; ///
enum GL_SAMPLES = 0x80A9; ///
enum GL_SAMPLES_3DFX = 0x86B4; ///
enum GL_SAMPLES_ARB = 0x80A9; ///
enum GL_SAMPLES_EXT = 0x80A9; ///
enum GL_SAMPLES_PASSED = 0x8914; ///
enum GL_SAMPLES_PASSED_ARB = 0x8914; ///
enum GL_SAMPLES_SGIS = 0x80A9; ///
enum GL_SAMPLE_ALPHA_TO_COVERAGE = 0x809E; ///
enum GL_SAMPLE_ALPHA_TO_COVERAGE_ARB = 0x809E; ///
enum GL_SAMPLE_ALPHA_TO_MASK_EXT = 0x809E; ///
enum GL_SAMPLE_ALPHA_TO_MASK_SGIS = 0x809E; ///
enum GL_SAMPLE_ALPHA_TO_ONE = 0x809F; ///
enum GL_SAMPLE_ALPHA_TO_ONE_ARB = 0x809F; ///
enum GL_SAMPLE_ALPHA_TO_ONE_EXT = 0x809F; ///
enum GL_SAMPLE_ALPHA_TO_ONE_SGIS = 0x809F; ///
enum GL_SAMPLE_BUFFERS = 0x80A8; ///
enum GL_SAMPLE_BUFFERS_3DFX = 0x86B3; ///
enum GL_SAMPLE_BUFFERS_ARB = 0x80A8; ///
enum GL_SAMPLE_BUFFERS_EXT = 0x80A8; ///
enum GL_SAMPLE_BUFFERS_SGIS = 0x80A8; ///
enum GL_SAMPLE_COVERAGE = 0x80A0; ///
enum GL_SAMPLE_COVERAGE_ARB = 0x80A0; ///
enum GL_SAMPLE_COVERAGE_INVERT = 0x80AB; ///
enum GL_SAMPLE_COVERAGE_INVERT_ARB = 0x80AB; ///
enum GL_SAMPLE_COVERAGE_VALUE = 0x80AA; ///
enum GL_SAMPLE_COVERAGE_VALUE_ARB = 0x80AA; ///
enum GL_SAMPLE_LOCATION_ARB = 0x8E50; ///
enum GL_SAMPLE_LOCATION_NV = 0x8E50; ///
enum GL_SAMPLE_LOCATION_PIXEL_GRID_HEIGHT_ARB = 0x933F; ///
enum GL_SAMPLE_LOCATION_PIXEL_GRID_HEIGHT_NV = 0x933F; ///
enum GL_SAMPLE_LOCATION_PIXEL_GRID_WIDTH_ARB = 0x933E; ///
enum GL_SAMPLE_LOCATION_PIXEL_GRID_WIDTH_NV = 0x933E; ///
enum GL_SAMPLE_LOCATION_SUBPIXEL_BITS_ARB = 0x933D; ///
enum GL_SAMPLE_LOCATION_SUBPIXEL_BITS_NV = 0x933D; ///
enum GL_SAMPLE_MASK = 0x8E51; ///
enum GL_SAMPLE_MASK_EXT = 0x80A0; ///
enum GL_SAMPLE_MASK_INVERT_EXT = 0x80AB; ///
enum GL_SAMPLE_MASK_INVERT_SGIS = 0x80AB; ///
enum GL_SAMPLE_MASK_NV = 0x8E51; ///
enum GL_SAMPLE_MASK_SGIS = 0x80A0; ///
enum GL_SAMPLE_MASK_VALUE = 0x8E52; ///
enum GL_SAMPLE_MASK_VALUE_EXT = 0x80AA; ///
enum GL_SAMPLE_MASK_VALUE_NV = 0x8E52; ///
enum GL_SAMPLE_MASK_VALUE_SGIS = 0x80AA; ///
enum GL_SAMPLE_PATTERN_EXT = 0x80AC; ///
enum GL_SAMPLE_PATTERN_SGIS = 0x80AC; ///
enum GL_SAMPLE_POSITION = 0x8E50; ///
enum GL_SAMPLE_POSITION_NV = 0x8E50; ///
enum GL_SAMPLE_SHADING = 0x8C36; ///
enum GL_SAMPLE_SHADING_ARB = 0x8C36; ///
enum GL_SAMPLE_SHADING_OES = 0x8C36; ///
enum GL_SATURATE_BIT_ATI = 0x00000040; ///
enum GL_SCALAR_EXT = 0x87BE; ///
enum GL_SCALEBIAS_HINT_SGIX = 0x8322; ///
enum GL_SCALED_RESOLVE_FASTEST_EXT = 0x90BA; ///
enum GL_SCALED_RESOLVE_NICEST_EXT = 0x90BB; ///
enum GL_SCALE_BY_FOUR_NV = 0x853F; ///
enum GL_SCALE_BY_ONE_HALF_NV = 0x8540; ///
enum GL_SCALE_BY_TWO_NV = 0x853E; ///
enum GL_SCISSOR_BIT = 0x00080000; ///
enum GL_SCISSOR_BOX = 0x0C10; ///
enum GL_SCISSOR_COMMAND_NV = 0x0011; ///
enum GL_SCISSOR_TEST = 0x0C11; ///
enum GL_SCREEN = 0x9295; ///
enum GL_SCREEN_COORDINATES_REND = 0x8490; ///
enum GL_SCREEN_KHR = 0x9295; ///
enum GL_SCREEN_NV = 0x9295; ///
enum GL_SECONDARY_COLOR_ARRAY = 0x845E; ///
enum GL_SECONDARY_COLOR_ARRAY_ADDRESS_NV = 0x8F27; ///
enum GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING = 0x889C; ///
enum GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB = 0x889C; ///
enum GL_SECONDARY_COLOR_ARRAY_EXT = 0x845E; ///
enum GL_SECONDARY_COLOR_ARRAY_LENGTH_NV = 0x8F31; ///
enum GL_SECONDARY_COLOR_ARRAY_LIST_IBM = 0x103077; ///
enum GL_SECONDARY_COLOR_ARRAY_LIST_STRIDE_IBM = 0x103087; ///
enum GL_SECONDARY_COLOR_ARRAY_POINTER = 0x845D; ///
enum GL_SECONDARY_COLOR_ARRAY_POINTER_EXT = 0x845D; ///
enum GL_SECONDARY_COLOR_ARRAY_SIZE = 0x845A; ///
enum GL_SECONDARY_COLOR_ARRAY_SIZE_EXT = 0x845A; ///
enum GL_SECONDARY_COLOR_ARRAY_STRIDE = 0x845C; ///
enum GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT = 0x845C; ///
enum GL_SECONDARY_COLOR_ARRAY_TYPE = 0x845B; ///
enum GL_SECONDARY_COLOR_ARRAY_TYPE_EXT = 0x845B; ///
enum GL_SECONDARY_COLOR_NV = 0x852D; ///
enum GL_SECONDARY_INTERPOLATOR_ATI = 0x896D; ///
enum GL_SELECT = 0x1C02; ///
enum GL_SELECTION_BUFFER_POINTER = 0x0DF3; ///
enum GL_SELECTION_BUFFER_SIZE = 0x0DF4; ///
enum GL_SEPARABLE_2D = 0x8012; ///
enum GL_SEPARABLE_2D_EXT = 0x8012; ///
enum GL_SEPARATE_ATTRIBS = 0x8C8D; ///
enum GL_SEPARATE_ATTRIBS_EXT = 0x8C8D; ///
enum GL_SEPARATE_ATTRIBS_NV = 0x8C8D; ///
enum GL_SEPARATE_SPECULAR_COLOR = 0x81FA; ///
enum GL_SEPARATE_SPECULAR_COLOR_EXT = 0x81FA; ///
enum GL_SET = 0x150F; ///
enum GL_SET_AMD = 0x874A; ///
enum GL_SGX_BINARY_IMG = 0x8C0A; ///
enum GL_SGX_PROGRAM_BINARY_IMG = 0x9130; ///
enum GL_SHADER = 0x82E1; ///
enum GL_SHADER_BINARY_DMP = 0x9250; ///
enum GL_SHADER_BINARY_FORMATS = 0x8DF8; ///
enum GL_SHADER_BINARY_VIV = 0x8FC4; ///
enum GL_SHADER_COMPILER = 0x8DFA; ///
enum GL_SHADER_CONSISTENT_NV = 0x86DD; ///
enum GL_SHADER_GLOBAL_ACCESS_BARRIER_BIT_NV = 0x00000010; ///
enum GL_SHADER_IMAGE_ACCESS_BARRIER_BIT = 0x00000020; ///
enum GL_SHADER_IMAGE_ACCESS_BARRIER_BIT_EXT = 0x00000020; ///
enum GL_SHADER_IMAGE_ATOMIC = 0x82A6; ///
enum GL_SHADER_IMAGE_LOAD = 0x82A4; ///
enum GL_SHADER_IMAGE_STORE = 0x82A5; ///
enum GL_SHADER_INCLUDE_ARB = 0x8DAE; ///
enum GL_SHADER_KHR = 0x82E1; ///
enum GL_SHADER_OBJECT_ARB = 0x8B48; ///
enum GL_SHADER_OBJECT_EXT = 0x8B48; ///
enum GL_SHADER_OPERATION_NV = 0x86DF; ///
enum GL_SHADER_PIXEL_LOCAL_STORAGE_EXT = 0x8F64; ///
enum GL_SHADER_SOURCE_LENGTH = 0x8B88; ///
enum GL_SHADER_STORAGE_BARRIER_BIT = 0x00002000; ///
enum GL_SHADER_STORAGE_BLOCK = 0x92E6; ///
enum GL_SHADER_STORAGE_BUFFER = 0x90D2; ///
enum GL_SHADER_STORAGE_BUFFER_BINDING = 0x90D3; ///
enum GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT = 0x90DF; ///
enum GL_SHADER_STORAGE_BUFFER_SIZE = 0x90D5; ///
enum GL_SHADER_STORAGE_BUFFER_START = 0x90D4; ///
enum GL_SHADER_TYPE = 0x8B4F; ///
enum GL_SHADE_MODEL = 0x0B54; ///
enum GL_SHADING_LANGUAGE_VERSION = 0x8B8C; ///
enum GL_SHADING_LANGUAGE_VERSION_ARB = 0x8B8C; ///
enum GL_SHADOW_AMBIENT_SGIX = 0x80BF; ///
enum GL_SHADOW_ATTENUATION_EXT = 0x834E; ///
enum GL_SHARED_EDGE_NV = 0xC0; ///
enum GL_SHARED_TEXTURE_PALETTE_EXT = 0x81FB; ///
enum GL_SHARPEN_TEXTURE_FUNC_POINTS_SGIS = 0x80B0; ///
enum GL_SHININESS = 0x1601; ///
enum GL_SHORT = 0x1402; ///
enum GL_SIGNALED = 0x9119; ///
enum GL_SIGNALED_APPLE = 0x9119; ///
enum GL_SIGNED_ALPHA8_NV = 0x8706; ///
enum GL_SIGNED_ALPHA_NV = 0x8705; ///
enum GL_SIGNED_HILO16_NV = 0x86FA; ///
enum GL_SIGNED_HILO8_NV = 0x885F; ///
enum GL_SIGNED_HILO_NV = 0x86F9; ///
enum GL_SIGNED_IDENTITY_NV = 0x853C; ///
enum GL_SIGNED_INTENSITY8_NV = 0x8708; ///
enum GL_SIGNED_INTENSITY_NV = 0x8707; ///
enum GL_SIGNED_LUMINANCE8_ALPHA8_NV = 0x8704; ///
enum GL_SIGNED_LUMINANCE8_NV = 0x8702; ///
enum GL_SIGNED_LUMINANCE_ALPHA_NV = 0x8703; ///
enum GL_SIGNED_LUMINANCE_NV = 0x8701; ///
enum GL_SIGNED_NEGATE_NV = 0x853D; ///
enum GL_SIGNED_NORMALIZED = 0x8F9C; ///
enum GL_SIGNED_RGB8_NV = 0x86FF; ///
enum GL_SIGNED_RGB8_UNSIGNED_ALPHA8_NV = 0x870D; ///
enum GL_SIGNED_RGBA8_NV = 0x86FC; ///
enum GL_SIGNED_RGBA_NV = 0x86FB; ///
enum GL_SIGNED_RGB_NV = 0x86FE; ///
enum GL_SIGNED_RGB_UNSIGNED_ALPHA_NV = 0x870C; ///
enum GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST = 0x82AC; ///
enum GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE = 0x82AE; ///
enum GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST = 0x82AD; ///
enum GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE = 0x82AF; ///
enum GL_SINGLE_COLOR = 0x81F9; ///
enum GL_SINGLE_COLOR_EXT = 0x81F9; ///
enum GL_SKIP_COMPONENTS1_NV = -6; ///
enum GL_SKIP_COMPONENTS2_NV = -5; ///
enum GL_SKIP_COMPONENTS3_NV = -4; ///
enum GL_SKIP_COMPONENTS4_NV = -3; ///
enum GL_SKIP_DECODE_EXT = 0x8A4A; ///
enum GL_SKIP_MISSING_GLYPH_NV = 0x90A9; ///
enum GL_SLICE_ACCUM_SUN = 0x85CC; ///
enum GL_SLIM10U_SGIX = 0x831E; ///
enum GL_SLIM12S_SGIX = 0x831F; ///
enum GL_SLIM8U_SGIX = 0x831D; ///
enum GL_SLUMINANCE = 0x8C46; ///
enum GL_SLUMINANCE8 = 0x8C47; ///
enum GL_SLUMINANCE8_ALPHA8 = 0x8C45; ///
enum GL_SLUMINANCE8_ALPHA8_EXT = 0x8C45; ///
enum GL_SLUMINANCE8_ALPHA8_NV = 0x8C45; ///
enum GL_SLUMINANCE8_EXT = 0x8C47; ///
enum GL_SLUMINANCE8_NV = 0x8C47; ///
enum GL_SLUMINANCE_ALPHA = 0x8C44; ///
enum GL_SLUMINANCE_ALPHA_EXT = 0x8C44; ///
enum GL_SLUMINANCE_ALPHA_NV = 0x8C44; ///
enum GL_SLUMINANCE_EXT = 0x8C46; ///
enum GL_SLUMINANCE_NV = 0x8C46; ///
enum GL_SMALL_CCW_ARC_TO_NV = 0x12; ///
enum GL_SMALL_CW_ARC_TO_NV = 0x14; ///
enum GL_SMAPHS30_PROGRAM_BINARY_DMP = 0x9251; ///
enum GL_SMAPHS_PROGRAM_BINARY_DMP = 0x9252; ///
enum GL_SMOOTH = 0x1D01; ///
enum GL_SMOOTH_CUBIC_CURVE_TO_NV = 0x10; ///
enum GL_SMOOTH_LINE_WIDTH_GRANULARITY = 0x0B23; ///
enum GL_SMOOTH_LINE_WIDTH_RANGE = 0x0B22; ///
enum GL_SMOOTH_POINT_SIZE_GRANULARITY = 0x0B13; ///
enum GL_SMOOTH_POINT_SIZE_RANGE = 0x0B12; ///
enum GL_SMOOTH_QUADRATIC_CURVE_TO_NV = 0x0E; ///
enum GL_SM_COUNT_NV = 0x933B; ///
enum GL_SOFTLIGHT = 0x929C; ///
enum GL_SOFTLIGHT_KHR = 0x929C; ///
enum GL_SOFTLIGHT_NV = 0x929C; ///
enum GL_SOURCE0_ALPHA = 0x8588; ///
enum GL_SOURCE0_ALPHA_ARB = 0x8588; ///
enum GL_SOURCE0_ALPHA_EXT = 0x8588; ///
enum GL_SOURCE0_RGB = 0x8580; ///
enum GL_SOURCE0_RGB_ARB = 0x8580; ///
enum GL_SOURCE0_RGB_EXT = 0x8580; ///
enum GL_SOURCE1_ALPHA = 0x8589; ///
enum GL_SOURCE1_ALPHA_ARB = 0x8589; ///
enum GL_SOURCE1_ALPHA_EXT = 0x8589; ///
enum GL_SOURCE1_RGB = 0x8581; ///
enum GL_SOURCE1_RGB_ARB = 0x8581; ///
enum GL_SOURCE1_RGB_EXT = 0x8581; ///
enum GL_SOURCE2_ALPHA = 0x858A; ///
enum GL_SOURCE2_ALPHA_ARB = 0x858A; ///
enum GL_SOURCE2_ALPHA_EXT = 0x858A; ///
enum GL_SOURCE2_RGB = 0x8582; ///
enum GL_SOURCE2_RGB_ARB = 0x8582; ///
enum GL_SOURCE2_RGB_EXT = 0x8582; ///
enum GL_SOURCE3_ALPHA_NV = 0x858B; ///
enum GL_SOURCE3_RGB_NV = 0x8583; ///
enum GL_SPARE0_NV = 0x852E; ///
enum GL_SPARE0_PLUS_SECONDARY_COLOR_NV = 0x8532; ///
enum GL_SPARE1_NV = 0x852F; ///
enum GL_SPARSE_BUFFER_PAGE_SIZE_ARB = 0x82F8; ///
enum GL_SPARSE_STORAGE_BIT_ARB = 0x0400; ///
enum GL_SPARSE_TEXTURE_FULL_ARRAY_CUBE_MIPMAPS_ARB = 0x91A9; ///
enum GL_SPARSE_TEXTURE_FULL_ARRAY_CUBE_MIPMAPS_EXT = 0x91A9; ///
enum GL_SPECULAR = 0x1202; ///
enum GL_SPHERE_MAP = 0x2402; ///
enum GL_SPOT_CUTOFF = 0x1206; ///
enum GL_SPOT_DIRECTION = 0x1204; ///
enum GL_SPOT_EXPONENT = 0x1205; ///
enum GL_SPRITE_AXIAL_SGIX = 0x814C; ///
enum GL_SPRITE_AXIS_SGIX = 0x814A; ///
enum GL_SPRITE_EYE_ALIGNED_SGIX = 0x814E; ///
enum GL_SPRITE_MODE_SGIX = 0x8149; ///
enum GL_SPRITE_OBJECT_ALIGNED_SGIX = 0x814D; ///
enum GL_SPRITE_SGIX = 0x8148; ///
enum GL_SPRITE_TRANSLATION_SGIX = 0x814B; ///
enum GL_SQUARE_NV = 0x90A3; ///
enum GL_SR8_EXT = 0x8FBD; ///
enum GL_SRC0_ALPHA = 0x8588; ///
enum GL_SRC0_RGB = 0x8580; ///
enum GL_SRC1_ALPHA = 0x8589; ///
enum GL_SRC1_ALPHA_EXT = 0x8589; ///
enum GL_SRC1_COLOR = 0x88F9; ///
enum GL_SRC1_COLOR_EXT = 0x88F9; ///
enum GL_SRC1_RGB = 0x8581; ///
enum GL_SRC2_ALPHA = 0x858A; ///
enum GL_SRC2_RGB = 0x8582; ///
enum GL_SRC_ALPHA = 0x0302; ///
enum GL_SRC_ALPHA_SATURATE = 0x0308; ///
enum GL_SRC_ALPHA_SATURATE_EXT = 0x0308; ///
enum GL_SRC_ATOP_NV = 0x928E; ///
enum GL_SRC_COLOR = 0x0300; ///
enum GL_SRC_IN_NV = 0x928A; ///
enum GL_SRC_NV = 0x9286; ///
enum GL_SRC_OUT_NV = 0x928C; ///
enum GL_SRC_OVER_NV = 0x9288; ///
enum GL_SRG8_EXT = 0x8FBE; ///
enum GL_SRGB = 0x8C40; ///
enum GL_SRGB8 = 0x8C41; ///
enum GL_SRGB8_ALPHA8 = 0x8C43; ///
enum GL_SRGB8_ALPHA8_EXT = 0x8C43; ///
enum GL_SRGB8_EXT = 0x8C41; ///
enum GL_SRGB8_NV = 0x8C41; ///
enum GL_SRGB_ALPHA = 0x8C42; ///
enum GL_SRGB_ALPHA_EXT = 0x8C42; ///
enum GL_SRGB_DECODE_ARB = 0x8299; ///
enum GL_SRGB_EXT = 0x8C40; ///
enum GL_SRGB_READ = 0x8297; ///
enum GL_SRGB_WRITE = 0x8298; ///
enum GL_STACK_OVERFLOW = 0x0503; ///
enum GL_STACK_OVERFLOW_KHR = 0x0503; ///
enum GL_STACK_UNDERFLOW = 0x0504; ///
enum GL_STACK_UNDERFLOW_KHR = 0x0504; ///
enum GL_STANDARD_FONT_FORMAT_NV = 0x936C; ///
enum GL_STANDARD_FONT_NAME_NV = 0x9072; ///
enum GL_STATE_RESTORE = 0x8BDC; ///
enum GL_STATIC_ATI = 0x8760; ///
enum GL_STATIC_COPY = 0x88E6; ///
enum GL_STATIC_COPY_ARB = 0x88E6; ///
enum GL_STATIC_DRAW = 0x88E4; ///
enum GL_STATIC_DRAW_ARB = 0x88E4; ///
enum GL_STATIC_READ = 0x88E5; ///
enum GL_STATIC_READ_ARB = 0x88E5; ///
enum GL_STATIC_VERTEX_ARRAY_IBM = 0x103061; ///
enum GL_STENCIL = 0x1802; ///
enum GL_STENCIL_ATTACHMENT = 0x8D20; ///
enum GL_STENCIL_ATTACHMENT_EXT = 0x8D20; ///
enum GL_STENCIL_ATTACHMENT_OES = 0x8D20; ///
enum GL_STENCIL_BACK_FAIL = 0x8801; ///
enum GL_STENCIL_BACK_FAIL_ATI = 0x8801; ///
enum GL_STENCIL_BACK_FUNC = 0x8800; ///
enum GL_STENCIL_BACK_FUNC_ATI = 0x8800; ///
enum GL_STENCIL_BACK_OP_VALUE_AMD = 0x874D; ///
enum GL_STENCIL_BACK_PASS_DEPTH_FAIL = 0x8802; ///
enum GL_STENCIL_BACK_PASS_DEPTH_FAIL_ATI = 0x8802; ///
enum GL_STENCIL_BACK_PASS_DEPTH_PASS = 0x8803; ///
enum GL_STENCIL_BACK_PASS_DEPTH_PASS_ATI = 0x8803; ///
enum GL_STENCIL_BACK_REF = 0x8CA3; ///
enum GL_STENCIL_BACK_VALUE_MASK = 0x8CA4; ///
enum GL_STENCIL_BACK_WRITEMASK = 0x8CA5; ///
enum GL_STENCIL_BITS = 0x0D57; ///
enum GL_STENCIL_BUFFER_BIT = 0x00000400; ///
enum GL_STENCIL_BUFFER_BIT0_QCOM = 0x00010000; ///
enum GL_STENCIL_BUFFER_BIT1_QCOM = 0x00020000; ///
enum GL_STENCIL_BUFFER_BIT2_QCOM = 0x00040000; ///
enum GL_STENCIL_BUFFER_BIT3_QCOM = 0x00080000; ///
enum GL_STENCIL_BUFFER_BIT4_QCOM = 0x00100000; ///
enum GL_STENCIL_BUFFER_BIT5_QCOM = 0x00200000; ///
enum GL_STENCIL_BUFFER_BIT6_QCOM = 0x00400000; ///
enum GL_STENCIL_BUFFER_BIT7_QCOM = 0x00800000; ///
enum GL_STENCIL_CLEAR_TAG_VALUE_EXT = 0x88F3; ///
enum GL_STENCIL_CLEAR_VALUE = 0x0B91; ///
enum GL_STENCIL_COMPONENTS = 0x8285; ///
enum GL_STENCIL_EXT = 0x1802; ///
enum GL_STENCIL_FAIL = 0x0B94; ///
enum GL_STENCIL_FUNC = 0x0B92; ///
enum GL_STENCIL_INDEX = 0x1901; ///
enum GL_STENCIL_INDEX1 = 0x8D46; ///
enum GL_STENCIL_INDEX16 = 0x8D49; ///
enum GL_STENCIL_INDEX16_EXT = 0x8D49; ///
enum GL_STENCIL_INDEX1_EXT = 0x8D46; ///
enum GL_STENCIL_INDEX1_OES = 0x8D46; ///
enum GL_STENCIL_INDEX4 = 0x8D47; ///
enum GL_STENCIL_INDEX4_EXT = 0x8D47; ///
enum GL_STENCIL_INDEX4_OES = 0x8D47; ///
enum GL_STENCIL_INDEX8 = 0x8D48; ///
enum GL_STENCIL_INDEX8_EXT = 0x8D48; ///
enum GL_STENCIL_INDEX8_OES = 0x8D48; ///
enum GL_STENCIL_INDEX_OES = 0x1901; ///
enum GL_STENCIL_OP_VALUE_AMD = 0x874C; ///
enum GL_STENCIL_PASS_DEPTH_FAIL = 0x0B95; ///
enum GL_STENCIL_PASS_DEPTH_PASS = 0x0B96; ///
enum GL_STENCIL_REF = 0x0B97; ///
enum GL_STENCIL_REF_COMMAND_NV = 0x000C; ///
enum GL_STENCIL_RENDERABLE = 0x8288; ///
enum GL_STENCIL_SAMPLES_NV = 0x932E; ///
enum GL_STENCIL_TAG_BITS_EXT = 0x88F2; ///
enum GL_STENCIL_TEST = 0x0B90; ///
enum GL_STENCIL_TEST_TWO_SIDE_EXT = 0x8910; ///
enum GL_STENCIL_VALUE_MASK = 0x0B93; ///
enum GL_STENCIL_WRITEMASK = 0x0B98; ///
enum GL_STEREO = 0x0C33; ///
enum GL_STORAGE_CACHED_APPLE = 0x85BE; ///
enum GL_STORAGE_CLIENT_APPLE = 0x85B4; ///
enum GL_STORAGE_PRIVATE_APPLE = 0x85BD; ///
enum GL_STORAGE_SHARED_APPLE = 0x85BF; ///
enum GL_STREAM_COPY = 0x88E2; ///
enum GL_STREAM_COPY_ARB = 0x88E2; ///
enum GL_STREAM_DRAW = 0x88E0; ///
enum GL_STREAM_DRAW_ARB = 0x88E0; ///
enum GL_STREAM_RASTERIZATION_AMD = 0x91A0; ///
enum GL_STREAM_READ = 0x88E1; ///
enum GL_STREAM_READ_ARB = 0x88E1; ///
enum GL_STRICT_DEPTHFUNC_HINT_PGI = 0x1A216; ///
enum GL_STRICT_LIGHTING_HINT_PGI = 0x1A217; ///
enum GL_STRICT_SCISSOR_HINT_PGI = 0x1A218; ///
enum GL_SUBPIXEL_BITS = 0x0D50; ///
enum GL_SUBPIXEL_PRECISION_BIAS_X_BITS_NV = 0x9347; ///
enum GL_SUBPIXEL_PRECISION_BIAS_Y_BITS_NV = 0x9348; ///
enum GL_SUBSAMPLE_DISTANCE_AMD = 0x883F; ///
enum GL_SUBTRACT = 0x84E7; ///
enum GL_SUBTRACT_ARB = 0x84E7; ///
enum GL_SUB_ATI = 0x8965; ///
enum GL_SUCCESS_NV = 0x902F; ///
enum GL_SUPERSAMPLE_SCALE_X_NV = 0x9372; ///
enum GL_SUPERSAMPLE_SCALE_Y_NV = 0x9373; ///
enum GL_SURFACE_MAPPED_NV = 0x8700; ///
enum GL_SURFACE_REGISTERED_NV = 0x86FD; ///
enum GL_SURFACE_STATE_NV = 0x86EB; ///
enum GL_SWIZZLE_STQ_ATI = 0x8977; ///
enum GL_SWIZZLE_STQ_DQ_ATI = 0x8979; ///
enum GL_SWIZZLE_STRQ_ATI = 0x897A; ///
enum GL_SWIZZLE_STRQ_DQ_ATI = 0x897B; ///
enum GL_SWIZZLE_STR_ATI = 0x8976; ///
enum GL_SWIZZLE_STR_DR_ATI = 0x8978; ///
enum GL_SYNC_CL_EVENT_ARB = 0x8240; ///
enum GL_SYNC_CL_EVENT_COMPLETE_ARB = 0x8241; ///
enum GL_SYNC_CONDITION = 0x9113; ///
enum GL_SYNC_CONDITION_APPLE = 0x9113; ///
enum GL_SYNC_FENCE = 0x9116; ///
enum GL_SYNC_FENCE_APPLE = 0x9116; ///
enum GL_SYNC_FLAGS = 0x9115; ///
enum GL_SYNC_FLAGS_APPLE = 0x9115; ///
enum GL_SYNC_FLUSH_COMMANDS_BIT = 0x00000001; ///
enum GL_SYNC_FLUSH_COMMANDS_BIT_APPLE = 0x00000001; ///
enum GL_SYNC_GPU_COMMANDS_COMPLETE = 0x9117; ///
enum GL_SYNC_GPU_COMMANDS_COMPLETE_APPLE = 0x9117; ///
enum GL_SYNC_OBJECT_APPLE = 0x8A53; ///
enum GL_SYNC_STATUS = 0x9114; ///
enum GL_SYNC_STATUS_APPLE = 0x9114; ///
enum GL_SYNC_X11_FENCE_EXT = 0x90E1; ///
enum GL_SYSTEM_FONT_NAME_NV = 0x9073; ///
enum GL_T = 0x2001; ///
enum GL_T2F_C3F_V3F = 0x2A2A; ///
enum GL_T2F_C4F_N3F_V3F = 0x2A2C; ///
enum GL_T2F_C4UB_V3F = 0x2A29; ///
enum GL_T2F_IUI_N3F_V2F_EXT = 0x81B3; ///
enum GL_T2F_IUI_N3F_V3F_EXT = 0x81B4; ///
enum GL_T2F_IUI_V2F_EXT = 0x81B1; ///
enum GL_T2F_IUI_V3F_EXT = 0x81B2; ///
enum GL_T2F_N3F_V3F = 0x2A2B; ///
enum GL_T2F_V3F = 0x2A27; ///
enum GL_T4F_C4F_N3F_V4F = 0x2A2D; ///
enum GL_T4F_V4F = 0x2A28; ///
enum GL_TABLE_TOO_LARGE = 0x8031; ///
enum GL_TABLE_TOO_LARGE_EXT = 0x8031; ///
enum GL_TANGENT_ARRAY_EXT = 0x8439; ///
enum GL_TANGENT_ARRAY_POINTER_EXT = 0x8442; ///
enum GL_TANGENT_ARRAY_STRIDE_EXT = 0x843F; ///
enum GL_TANGENT_ARRAY_TYPE_EXT = 0x843E; ///
enum GL_TERMINATE_SEQUENCE_COMMAND_NV = 0x0000; ///
enum GL_TESSELLATION_FACTOR_AMD = 0x9005; ///
enum GL_TESSELLATION_MODE_AMD = 0x9004; ///
enum GL_TESS_CONTROL_OUTPUT_VERTICES = 0x8E75; ///
enum GL_TESS_CONTROL_OUTPUT_VERTICES_EXT = 0x8E75; ///
enum GL_TESS_CONTROL_OUTPUT_VERTICES_OES = 0x8E75; ///
enum GL_TESS_CONTROL_PROGRAM_NV = 0x891E; ///
enum GL_TESS_CONTROL_PROGRAM_PARAMETER_BUFFER_NV = 0x8C74; ///
enum GL_TESS_CONTROL_SHADER = 0x8E88; ///
enum GL_TESS_CONTROL_SHADER_BIT = 0x00000008; ///
enum GL_TESS_CONTROL_SHADER_BIT_EXT = 0x00000008; ///
enum GL_TESS_CONTROL_SHADER_BIT_OES = 0x00000008; ///
enum GL_TESS_CONTROL_SHADER_EXT = 0x8E88; ///
enum GL_TESS_CONTROL_SHADER_OES = 0x8E88; ///
enum GL_TESS_CONTROL_SHADER_PATCHES_ARB = 0x82F1; ///
enum GL_TESS_CONTROL_SUBROUTINE = 0x92E9; ///
enum GL_TESS_CONTROL_SUBROUTINE_UNIFORM = 0x92EF; ///
enum GL_TESS_CONTROL_TEXTURE = 0x829C; ///
enum GL_TESS_EVALUATION_PROGRAM_NV = 0x891F; ///
enum GL_TESS_EVALUATION_PROGRAM_PARAMETER_BUFFER_NV = 0x8C75; ///
enum GL_TESS_EVALUATION_SHADER = 0x8E87; ///
enum GL_TESS_EVALUATION_SHADER_BIT = 0x00000010; ///
enum GL_TESS_EVALUATION_SHADER_BIT_EXT = 0x00000010; ///
enum GL_TESS_EVALUATION_SHADER_BIT_OES = 0x00000010; ///
enum GL_TESS_EVALUATION_SHADER_EXT = 0x8E87; ///
enum GL_TESS_EVALUATION_SHADER_INVOCATIONS_ARB = 0x82F2; ///
enum GL_TESS_EVALUATION_SHADER_OES = 0x8E87; ///
enum GL_TESS_EVALUATION_SUBROUTINE = 0x92EA; ///
enum GL_TESS_EVALUATION_SUBROUTINE_UNIFORM = 0x92F0; ///
enum GL_TESS_EVALUATION_TEXTURE = 0x829D; ///
enum GL_TESS_GEN_MODE = 0x8E76; ///
enum GL_TESS_GEN_MODE_EXT = 0x8E76; ///
enum GL_TESS_GEN_MODE_OES = 0x8E76; ///
enum GL_TESS_GEN_POINT_MODE = 0x8E79; ///
enum GL_TESS_GEN_POINT_MODE_EXT = 0x8E79; ///
enum GL_TESS_GEN_POINT_MODE_OES = 0x8E79; ///
enum GL_TESS_GEN_SPACING = 0x8E77; ///
enum GL_TESS_GEN_SPACING_EXT = 0x8E77; ///
enum GL_TESS_GEN_SPACING_OES = 0x8E77; ///
enum GL_TESS_GEN_VERTEX_ORDER = 0x8E78; ///
enum GL_TESS_GEN_VERTEX_ORDER_EXT = 0x8E78; ///
enum GL_TESS_GEN_VERTEX_ORDER_OES = 0x8E78; ///
enum GL_TEXCOORD1_BIT_PGI = 0x10000000; ///
enum GL_TEXCOORD2_BIT_PGI = 0x20000000; ///
enum GL_TEXCOORD3_BIT_PGI = 0x40000000; ///
enum GL_TEXCOORD4_BIT_PGI = 0x80000000; ///
enum GL_TEXTURE = 0x1702; ///
enum GL_TEXTURE0 = 0x84C0; ///
enum GL_TEXTURE0_ARB = 0x84C0; ///
enum GL_TEXTURE1 = 0x84C1; ///
enum GL_TEXTURE10 = 0x84CA; ///
enum GL_TEXTURE10_ARB = 0x84CA; ///
enum GL_TEXTURE11 = 0x84CB; ///
enum GL_TEXTURE11_ARB = 0x84CB; ///
enum GL_TEXTURE12 = 0x84CC; ///
enum GL_TEXTURE12_ARB = 0x84CC; ///
enum GL_TEXTURE13 = 0x84CD; ///
enum GL_TEXTURE13_ARB = 0x84CD; ///
enum GL_TEXTURE14 = 0x84CE; ///
enum GL_TEXTURE14_ARB = 0x84CE; ///
enum GL_TEXTURE15 = 0x84CF; ///
enum GL_TEXTURE15_ARB = 0x84CF; ///
enum GL_TEXTURE16 = 0x84D0; ///
enum GL_TEXTURE16_ARB = 0x84D0; ///
enum GL_TEXTURE17 = 0x84D1; ///
enum GL_TEXTURE17_ARB = 0x84D1; ///
enum GL_TEXTURE18 = 0x84D2; ///
enum GL_TEXTURE18_ARB = 0x84D2; ///
enum GL_TEXTURE19 = 0x84D3; ///
enum GL_TEXTURE19_ARB = 0x84D3; ///
enum GL_TEXTURE1_ARB = 0x84C1; ///
enum GL_TEXTURE2 = 0x84C2; ///
enum GL_TEXTURE20 = 0x84D4; ///
enum GL_TEXTURE20_ARB = 0x84D4; ///
enum GL_TEXTURE21 = 0x84D5; ///
enum GL_TEXTURE21_ARB = 0x84D5; ///
enum GL_TEXTURE22 = 0x84D6; ///
enum GL_TEXTURE22_ARB = 0x84D6; ///
enum GL_TEXTURE23 = 0x84D7; ///
enum GL_TEXTURE23_ARB = 0x84D7; ///
enum GL_TEXTURE24 = 0x84D8; ///
enum GL_TEXTURE24_ARB = 0x84D8; ///
enum GL_TEXTURE25 = 0x84D9; ///
enum GL_TEXTURE25_ARB = 0x84D9; ///
enum GL_TEXTURE26 = 0x84DA; ///
enum GL_TEXTURE26_ARB = 0x84DA; ///
enum GL_TEXTURE27 = 0x84DB; ///
enum GL_TEXTURE27_ARB = 0x84DB; ///
enum GL_TEXTURE28 = 0x84DC; ///
enum GL_TEXTURE28_ARB = 0x84DC; ///
enum GL_TEXTURE29 = 0x84DD; ///
enum GL_TEXTURE29_ARB = 0x84DD; ///
enum GL_TEXTURE2_ARB = 0x84C2; ///
enum GL_TEXTURE3 = 0x84C3; ///
enum GL_TEXTURE30 = 0x84DE; ///
enum GL_TEXTURE30_ARB = 0x84DE; ///
enum GL_TEXTURE31 = 0x84DF; ///
enum GL_TEXTURE31_ARB = 0x84DF; ///
enum GL_TEXTURE3_ARB = 0x84C3; ///
enum GL_TEXTURE4 = 0x84C4; ///
enum GL_TEXTURE4_ARB = 0x84C4; ///
enum GL_TEXTURE5 = 0x84C5; ///
enum GL_TEXTURE5_ARB = 0x84C5; ///
enum GL_TEXTURE6 = 0x84C6; ///
enum GL_TEXTURE6_ARB = 0x84C6; ///
enum GL_TEXTURE7 = 0x84C7; ///
enum GL_TEXTURE7_ARB = 0x84C7; ///
enum GL_TEXTURE8 = 0x84C8; ///
enum GL_TEXTURE8_ARB = 0x84C8; ///
enum GL_TEXTURE9 = 0x84C9; ///
enum GL_TEXTURE9_ARB = 0x84C9; ///
enum GL_TEXTURE_1D = 0x0DE0; ///
enum GL_TEXTURE_1D_ARRAY = 0x8C18; ///
enum GL_TEXTURE_1D_ARRAY_EXT = 0x8C18; ///
enum GL_TEXTURE_1D_BINDING_EXT = 0x8068; ///
enum GL_TEXTURE_1D_STACK_BINDING_MESAX = 0x875D; ///
enum GL_TEXTURE_1D_STACK_MESAX = 0x8759; ///
enum GL_TEXTURE_2D = 0x0DE1; ///
enum GL_TEXTURE_2D_ARRAY = 0x8C1A; ///
enum GL_TEXTURE_2D_ARRAY_EXT = 0x8C1A; ///
enum GL_TEXTURE_2D_BINDING_EXT = 0x8069; ///
enum GL_TEXTURE_2D_MULTISAMPLE = 0x9100; ///
enum GL_TEXTURE_2D_MULTISAMPLE_ARRAY = 0x9102; ///
enum GL_TEXTURE_2D_MULTISAMPLE_ARRAY_OES = 0x9102; ///
enum GL_TEXTURE_2D_STACK_BINDING_MESAX = 0x875E; ///
enum GL_TEXTURE_2D_STACK_MESAX = 0x875A; ///
enum GL_TEXTURE_3D = 0x806F; ///
enum GL_TEXTURE_3D_BINDING_EXT = 0x806A; ///
enum GL_TEXTURE_3D_BINDING_OES = 0x806A; ///
enum GL_TEXTURE_3D_EXT = 0x806F; ///
enum GL_TEXTURE_3D_OES = 0x806F; ///
enum GL_TEXTURE_4DSIZE_SGIS = 0x8136; ///
enum GL_TEXTURE_4D_BINDING_SGIS = 0x814F; ///
enum GL_TEXTURE_4D_SGIS = 0x8134; ///
enum GL_TEXTURE_ALPHA_MODULATE_IMG = 0x8C06; ///
enum GL_TEXTURE_ALPHA_SIZE = 0x805F; ///
enum GL_TEXTURE_ALPHA_SIZE_EXT = 0x805F; ///
enum GL_TEXTURE_ALPHA_TYPE = 0x8C13; ///
enum GL_TEXTURE_ALPHA_TYPE_ARB = 0x8C13; ///
enum GL_TEXTURE_APPLICATION_MODE_EXT = 0x834F; ///
enum GL_TEXTURE_BASE_LEVEL = 0x813C; ///
enum GL_TEXTURE_BASE_LEVEL_SGIS = 0x813C; ///
enum GL_TEXTURE_BINDING_1D = 0x8068; ///
enum GL_TEXTURE_BINDING_1D_ARRAY = 0x8C1C; ///
enum GL_TEXTURE_BINDING_1D_ARRAY_EXT = 0x8C1C; ///
enum GL_TEXTURE_BINDING_2D = 0x8069; ///
enum GL_TEXTURE_BINDING_2D_ARRAY = 0x8C1D; ///
enum GL_TEXTURE_BINDING_2D_ARRAY_EXT = 0x8C1D; ///
enum GL_TEXTURE_BINDING_2D_MULTISAMPLE = 0x9104; ///
enum GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY = 0x9105; ///
enum GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY_OES = 0x9105; ///
enum GL_TEXTURE_BINDING_3D = 0x806A; ///
enum GL_TEXTURE_BINDING_3D_OES = 0x806A; ///
enum GL_TEXTURE_BINDING_BUFFER = 0x8C2C; ///
enum GL_TEXTURE_BINDING_BUFFER_ARB = 0x8C2C; ///
enum GL_TEXTURE_BINDING_BUFFER_EXT = 0x8C2C; ///
enum GL_TEXTURE_BINDING_BUFFER_OES = 0x8C2C; ///
enum GL_TEXTURE_BINDING_CUBE_MAP = 0x8514; ///
enum GL_TEXTURE_BINDING_CUBE_MAP_ARB = 0x8514; ///
enum GL_TEXTURE_BINDING_CUBE_MAP_ARRAY = 0x900A; ///
enum GL_TEXTURE_BINDING_CUBE_MAP_ARRAY_ARB = 0x900A; ///
enum GL_TEXTURE_BINDING_CUBE_MAP_ARRAY_EXT = 0x900A; ///
enum GL_TEXTURE_BINDING_CUBE_MAP_ARRAY_OES = 0x900A; ///
enum GL_TEXTURE_BINDING_CUBE_MAP_EXT = 0x8514; ///
enum GL_TEXTURE_BINDING_CUBE_MAP_OES = 0x8514; ///
enum GL_TEXTURE_BINDING_EXTERNAL_OES = 0x8D67; ///
enum GL_TEXTURE_BINDING_RECTANGLE = 0x84F6; ///
enum GL_TEXTURE_BINDING_RECTANGLE_ARB = 0x84F6; ///
enum GL_TEXTURE_BINDING_RECTANGLE_NV = 0x84F6; ///
enum GL_TEXTURE_BINDING_RENDERBUFFER_NV = 0x8E53; ///
enum GL_TEXTURE_BIT = 0x00040000; ///
enum GL_TEXTURE_BLUE_SIZE = 0x805E; ///
enum GL_TEXTURE_BLUE_SIZE_EXT = 0x805E; ///
enum GL_TEXTURE_BLUE_TYPE = 0x8C12; ///
enum GL_TEXTURE_BLUE_TYPE_ARB = 0x8C12; ///
enum GL_TEXTURE_BORDER = 0x1005; ///
enum GL_TEXTURE_BORDER_COLOR = 0x1004; ///
enum GL_TEXTURE_BORDER_COLOR_EXT = 0x1004; ///
enum GL_TEXTURE_BORDER_COLOR_NV = 0x1004; ///
enum GL_TEXTURE_BORDER_COLOR_OES = 0x1004; ///
enum GL_TEXTURE_BORDER_VALUES_NV = 0x871A; ///
enum GL_TEXTURE_BUFFER = 0x8C2A; ///
enum GL_TEXTURE_BUFFER_ARB = 0x8C2A; ///
enum GL_TEXTURE_BUFFER_BINDING = 0x8C2A; ///
enum GL_TEXTURE_BUFFER_BINDING_EXT = 0x8C2A; ///
enum GL_TEXTURE_BUFFER_BINDING_OES = 0x8C2A; ///
enum GL_TEXTURE_BUFFER_DATA_STORE_BINDING = 0x8C2D; ///
enum GL_TEXTURE_BUFFER_DATA_STORE_BINDING_ARB = 0x8C2D; ///
enum GL_TEXTURE_BUFFER_DATA_STORE_BINDING_EXT = 0x8C2D; ///
enum GL_TEXTURE_BUFFER_DATA_STORE_BINDING_OES = 0x8C2D; ///
enum GL_TEXTURE_BUFFER_EXT = 0x8C2A; ///
enum GL_TEXTURE_BUFFER_FORMAT_ARB = 0x8C2E; ///
enum GL_TEXTURE_BUFFER_FORMAT_EXT = 0x8C2E; ///
enum GL_TEXTURE_BUFFER_OES = 0x8C2A; ///
enum GL_TEXTURE_BUFFER_OFFSET = 0x919D; ///
enum GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT = 0x919F; ///
enum GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT_EXT = 0x919F; ///
enum GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT_OES = 0x919F; ///
enum GL_TEXTURE_BUFFER_OFFSET_EXT = 0x919D; ///
enum GL_TEXTURE_BUFFER_OFFSET_OES = 0x919D; ///
enum GL_TEXTURE_BUFFER_SIZE = 0x919E; ///
enum GL_TEXTURE_BUFFER_SIZE_EXT = 0x919E; ///
enum GL_TEXTURE_BUFFER_SIZE_OES = 0x919E; ///
enum GL_TEXTURE_CLIPMAP_CENTER_SGIX = 0x8171; ///
enum GL_TEXTURE_CLIPMAP_DEPTH_SGIX = 0x8176; ///
enum GL_TEXTURE_CLIPMAP_FRAME_SGIX = 0x8172; ///
enum GL_TEXTURE_CLIPMAP_LOD_OFFSET_SGIX = 0x8175; ///
enum GL_TEXTURE_CLIPMAP_OFFSET_SGIX = 0x8173; ///
enum GL_TEXTURE_CLIPMAP_VIRTUAL_DEPTH_SGIX = 0x8174; ///
enum GL_TEXTURE_COLOR_SAMPLES_NV = 0x9046; ///
enum GL_TEXTURE_COLOR_TABLE_SGI = 0x80BC; ///
enum GL_TEXTURE_COLOR_WRITEMASK_SGIS = 0x81EF; ///
enum GL_TEXTURE_COMPARE_FAIL_VALUE_ARB = 0x80BF; ///
enum GL_TEXTURE_COMPARE_FUNC = 0x884D; ///
enum GL_TEXTURE_COMPARE_FUNC_ARB = 0x884D; ///
enum GL_TEXTURE_COMPARE_FUNC_EXT = 0x884D; ///
enum GL_TEXTURE_COMPARE_MODE = 0x884C; ///
enum GL_TEXTURE_COMPARE_MODE_ARB = 0x884C; ///
enum GL_TEXTURE_COMPARE_MODE_EXT = 0x884C; ///
enum GL_TEXTURE_COMPARE_OPERATOR_SGIX = 0x819B; ///
enum GL_TEXTURE_COMPARE_SGIX = 0x819A; ///
enum GL_TEXTURE_COMPONENTS = 0x1003; ///
enum GL_TEXTURE_COMPRESSED = 0x86A1; ///
enum GL_TEXTURE_COMPRESSED_ARB = 0x86A1; ///
enum GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT = 0x82B2; ///
enum GL_TEXTURE_COMPRESSED_BLOCK_SIZE = 0x82B3; ///
enum GL_TEXTURE_COMPRESSED_BLOCK_WIDTH = 0x82B1; ///
enum GL_TEXTURE_COMPRESSED_IMAGE_SIZE = 0x86A0; ///
enum GL_TEXTURE_COMPRESSED_IMAGE_SIZE_ARB = 0x86A0; ///
enum GL_TEXTURE_COMPRESSION_HINT = 0x84EF; ///
enum GL_TEXTURE_COMPRESSION_HINT_ARB = 0x84EF; ///
enum GL_TEXTURE_CONSTANT_DATA_SUNX = 0x81D6; ///
enum GL_TEXTURE_COORD_ARRAY = 0x8078; ///
enum GL_TEXTURE_COORD_ARRAY_ADDRESS_NV = 0x8F25; ///
enum GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING = 0x889A; ///
enum GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB = 0x889A; ///
enum GL_TEXTURE_COORD_ARRAY_COUNT_EXT = 0x808B; ///
enum GL_TEXTURE_COORD_ARRAY_EXT = 0x8078; ///
enum GL_TEXTURE_COORD_ARRAY_LENGTH_NV = 0x8F2F; ///
enum GL_TEXTURE_COORD_ARRAY_LIST_IBM = 0x103074; ///
enum GL_TEXTURE_COORD_ARRAY_LIST_STRIDE_IBM = 0x103084; ///
enum GL_TEXTURE_COORD_ARRAY_PARALLEL_POINTERS_INTEL = 0x83F8; ///
enum GL_TEXTURE_COORD_ARRAY_POINTER = 0x8092; ///
enum GL_TEXTURE_COORD_ARRAY_POINTER_EXT = 0x8092; ///
enum GL_TEXTURE_COORD_ARRAY_SIZE = 0x8088; ///
enum GL_TEXTURE_COORD_ARRAY_SIZE_EXT = 0x8088; ///
enum GL_TEXTURE_COORD_ARRAY_STRIDE = 0x808A; ///
enum GL_TEXTURE_COORD_ARRAY_STRIDE_EXT = 0x808A; ///
enum GL_TEXTURE_COORD_ARRAY_TYPE = 0x8089; ///
enum GL_TEXTURE_COORD_ARRAY_TYPE_EXT = 0x8089; ///
enum GL_TEXTURE_COORD_NV = 0x8C79; ///
enum GL_TEXTURE_COVERAGE_SAMPLES_NV = 0x9045; ///
enum GL_TEXTURE_CROP_RECT_OES = 0x8B9D; ///
enum GL_TEXTURE_CUBE_MAP = 0x8513; ///
enum GL_TEXTURE_CUBE_MAP_ARB = 0x8513; ///
enum GL_TEXTURE_CUBE_MAP_ARRAY = 0x9009; ///
enum GL_TEXTURE_CUBE_MAP_ARRAY_ARB = 0x9009; ///
enum GL_TEXTURE_CUBE_MAP_ARRAY_EXT = 0x9009; ///
enum GL_TEXTURE_CUBE_MAP_ARRAY_OES = 0x9009; ///
enum GL_TEXTURE_CUBE_MAP_EXT = 0x8513; ///
enum GL_TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516; ///
enum GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB = 0x8516; ///
enum GL_TEXTURE_CUBE_MAP_NEGATIVE_X_EXT = 0x8516; ///
enum GL_TEXTURE_CUBE_MAP_NEGATIVE_X_OES = 0x8516; ///
enum GL_TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518; ///
enum GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB = 0x8518; ///
enum GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_EXT = 0x8518; ///
enum GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_OES = 0x8518; ///
enum GL_TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851A; ///
enum GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB = 0x851A; ///
enum GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_EXT = 0x851A; ///
enum GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_OES = 0x851A; ///
enum GL_TEXTURE_CUBE_MAP_OES = 0x8513; ///
enum GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515; ///
enum GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB = 0x8515; ///
enum GL_TEXTURE_CUBE_MAP_POSITIVE_X_EXT = 0x8515; ///
enum GL_TEXTURE_CUBE_MAP_POSITIVE_X_OES = 0x8515; ///
enum GL_TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517; ///
enum GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB = 0x8517; ///
enum GL_TEXTURE_CUBE_MAP_POSITIVE_Y_EXT = 0x8517; ///
enum GL_TEXTURE_CUBE_MAP_POSITIVE_Y_OES = 0x8517; ///
enum GL_TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519; ///
enum GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB = 0x8519; ///
enum GL_TEXTURE_CUBE_MAP_POSITIVE_Z_EXT = 0x8519; ///
enum GL_TEXTURE_CUBE_MAP_POSITIVE_Z_OES = 0x8519; ///
enum GL_TEXTURE_CUBE_MAP_SEAMLESS = 0x884F; ///
enum GL_TEXTURE_DEFORMATION_BIT_SGIX = 0x00000001; ///
enum GL_TEXTURE_DEFORMATION_SGIX = 0x8195; ///
enum GL_TEXTURE_DEPTH = 0x8071; ///
enum GL_TEXTURE_DEPTH_EXT = 0x8071; ///
enum GL_TEXTURE_DEPTH_QCOM = 0x8BD4; ///
enum GL_TEXTURE_DEPTH_SIZE = 0x884A; ///
enum GL_TEXTURE_DEPTH_SIZE_ARB = 0x884A; ///
enum GL_TEXTURE_DEPTH_TYPE = 0x8C16; ///
enum GL_TEXTURE_DEPTH_TYPE_ARB = 0x8C16; ///
enum GL_TEXTURE_DS_SIZE_NV = 0x871D; ///
enum GL_TEXTURE_DT_SIZE_NV = 0x871E; ///
enum GL_TEXTURE_ENV = 0x2300; ///
enum GL_TEXTURE_ENV_BIAS_SGIX = 0x80BE; ///
enum GL_TEXTURE_ENV_COLOR = 0x2201; ///
enum GL_TEXTURE_ENV_MODE = 0x2200; ///
enum GL_TEXTURE_EXTERNAL_OES = 0x8D65; ///
enum GL_TEXTURE_FETCH_BARRIER_BIT = 0x00000008; ///
enum GL_TEXTURE_FETCH_BARRIER_BIT_EXT = 0x00000008; ///
enum GL_TEXTURE_FILTER4_SIZE_SGIS = 0x8147; ///
enum GL_TEXTURE_FILTER_CONTROL = 0x8500; ///
enum GL_TEXTURE_FILTER_CONTROL_EXT = 0x8500; ///
enum GL_TEXTURE_FIXED_SAMPLE_LOCATIONS = 0x9107; ///
enum GL_TEXTURE_FLOAT_COMPONENTS_NV = 0x888C; ///
enum GL_TEXTURE_FORMAT_QCOM = 0x8BD6; ///
enum GL_TEXTURE_FREE_MEMORY_ATI = 0x87FC; ///
enum GL_TEXTURE_GATHER = 0x82A2; ///
enum GL_TEXTURE_GATHER_SHADOW = 0x82A3; ///
enum GL_TEXTURE_GEN_MODE = 0x2500; ///
enum GL_TEXTURE_GEN_MODE_OES = 0x2500; ///
enum GL_TEXTURE_GEN_Q = 0x0C63; ///
enum GL_TEXTURE_GEN_R = 0x0C62; ///
enum GL_TEXTURE_GEN_S = 0x0C60; ///
enum GL_TEXTURE_GEN_STR_OES = 0x8D60; ///
enum GL_TEXTURE_GEN_T = 0x0C61; ///
enum GL_TEXTURE_GEQUAL_R_SGIX = 0x819D; ///
enum GL_TEXTURE_GREEN_SIZE = 0x805D; ///
enum GL_TEXTURE_GREEN_SIZE_EXT = 0x805D; ///
enum GL_TEXTURE_GREEN_TYPE = 0x8C11; ///
enum GL_TEXTURE_GREEN_TYPE_ARB = 0x8C11; ///
enum GL_TEXTURE_HEIGHT = 0x1001; ///
enum GL_TEXTURE_HEIGHT_QCOM = 0x8BD3; ///
enum GL_TEXTURE_HI_SIZE_NV = 0x871B; ///
enum GL_TEXTURE_IMAGE_FORMAT = 0x828F; ///
enum GL_TEXTURE_IMAGE_TYPE = 0x8290; ///
enum GL_TEXTURE_IMAGE_VALID_QCOM = 0x8BD8; ///
enum GL_TEXTURE_IMMUTABLE_FORMAT = 0x912F; ///
enum GL_TEXTURE_IMMUTABLE_FORMAT_EXT = 0x912F; ///
enum GL_TEXTURE_IMMUTABLE_LEVELS = 0x82DF; ///
enum GL_TEXTURE_INDEX_SIZE_EXT = 0x80ED; ///
enum GL_TEXTURE_INTENSITY_SIZE = 0x8061; ///
enum GL_TEXTURE_INTENSITY_SIZE_EXT = 0x8061; ///
enum GL_TEXTURE_INTENSITY_TYPE = 0x8C15; ///
enum GL_TEXTURE_INTENSITY_TYPE_ARB = 0x8C15; ///
enum GL_TEXTURE_INTERNAL_FORMAT = 0x1003; ///
enum GL_TEXTURE_INTERNAL_FORMAT_QCOM = 0x8BD5; ///
enum GL_TEXTURE_LEQUAL_R_SGIX = 0x819C; ///
enum GL_TEXTURE_LIGHTING_MODE_HP = 0x8167; ///
enum GL_TEXTURE_LIGHT_EXT = 0x8350; ///
enum GL_TEXTURE_LOD_BIAS = 0x8501; ///
enum GL_TEXTURE_LOD_BIAS_EXT = 0x8501; ///
enum GL_TEXTURE_LOD_BIAS_R_SGIX = 0x8190; ///
enum GL_TEXTURE_LOD_BIAS_S_SGIX = 0x818E; ///
enum GL_TEXTURE_LOD_BIAS_T_SGIX = 0x818F; ///
enum GL_TEXTURE_LO_SIZE_NV = 0x871C; ///
enum GL_TEXTURE_LUMINANCE_SIZE = 0x8060; ///
enum GL_TEXTURE_LUMINANCE_SIZE_EXT = 0x8060; ///
enum GL_TEXTURE_LUMINANCE_TYPE = 0x8C14; ///
enum GL_TEXTURE_LUMINANCE_TYPE_ARB = 0x8C14; ///
enum GL_TEXTURE_MAG_FILTER = 0x2800; ///
enum GL_TEXTURE_MAG_SIZE_NV = 0x871F; ///
enum GL_TEXTURE_MATERIAL_FACE_EXT = 0x8351; ///
enum GL_TEXTURE_MATERIAL_PARAMETER_EXT = 0x8352; ///
enum GL_TEXTURE_MATRIX = 0x0BA8; ///
enum GL_TEXTURE_MATRIX_FLOAT_AS_INT_BITS_OES = 0x898F; ///
enum GL_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FE; ///
enum GL_TEXTURE_MAX_CLAMP_R_SGIX = 0x836B; ///
enum GL_TEXTURE_MAX_CLAMP_S_SGIX = 0x8369; ///
enum GL_TEXTURE_MAX_CLAMP_T_SGIX = 0x836A; ///
enum GL_TEXTURE_MAX_LEVEL = 0x813D; ///
enum GL_TEXTURE_MAX_LEVEL_APPLE = 0x813D; ///
enum GL_TEXTURE_MAX_LEVEL_SGIS = 0x813D; ///
enum GL_TEXTURE_MAX_LOD = 0x813B; ///
enum GL_TEXTURE_MAX_LOD_SGIS = 0x813B; ///
enum GL_TEXTURE_MEMORY_LAYOUT_INTEL = 0x83FF; ///
enum GL_TEXTURE_MIN_FILTER = 0x2801; ///
enum GL_TEXTURE_MIN_LOD = 0x813A; ///
enum GL_TEXTURE_MIN_LOD_SGIS = 0x813A; ///
enum GL_TEXTURE_MULTI_BUFFER_HINT_SGIX = 0x812E; ///
enum GL_TEXTURE_NORMAL_EXT = 0x85AF; ///
enum GL_TEXTURE_NUM_LEVELS_QCOM = 0x8BD9; ///
enum GL_TEXTURE_OBJECT_VALID_QCOM = 0x8BDB; ///
enum GL_TEXTURE_POST_SPECULAR_HP = 0x8168; ///
enum GL_TEXTURE_PRE_SPECULAR_HP = 0x8169; ///
enum GL_TEXTURE_PRIORITY = 0x8066; ///
enum GL_TEXTURE_PRIORITY_EXT = 0x8066; ///
enum GL_TEXTURE_PROTECTED_EXT = 0x8BFA; ///
enum GL_TEXTURE_RANGE_LENGTH_APPLE = 0x85B7; ///
enum GL_TEXTURE_RANGE_POINTER_APPLE = 0x85B8; ///
enum GL_TEXTURE_RECTANGLE = 0x84F5; ///
enum GL_TEXTURE_RECTANGLE_ARB = 0x84F5; ///
enum GL_TEXTURE_RECTANGLE_NV = 0x84F5; ///
enum GL_TEXTURE_REDUCTION_MODE_ARB = 0x9366; ///
enum GL_TEXTURE_RED_SIZE = 0x805C; ///
enum GL_TEXTURE_RED_SIZE_EXT = 0x805C; ///
enum GL_TEXTURE_RED_TYPE = 0x8C10; ///
enum GL_TEXTURE_RED_TYPE_ARB = 0x8C10; ///
enum GL_TEXTURE_RENDERBUFFER_DATA_STORE_BINDING_NV = 0x8E54; ///
enum GL_TEXTURE_RENDERBUFFER_NV = 0x8E55; ///
enum GL_TEXTURE_RESIDENT = 0x8067; ///
enum GL_TEXTURE_RESIDENT_EXT = 0x8067; ///
enum GL_TEXTURE_SAMPLES = 0x9106; ///
enum GL_TEXTURE_SAMPLES_IMG = 0x9136; ///
enum GL_TEXTURE_SHADER_NV = 0x86DE; ///
enum GL_TEXTURE_SHADOW = 0x82A1; ///
enum GL_TEXTURE_SHARED_SIZE = 0x8C3F; ///
enum GL_TEXTURE_SHARED_SIZE_EXT = 0x8C3F; ///
enum GL_TEXTURE_SPARSE_ARB = 0x91A6; ///
enum GL_TEXTURE_SPARSE_EXT = 0x91A6; ///
enum GL_TEXTURE_SRGB_DECODE_EXT = 0x8A48; ///
enum GL_TEXTURE_STACK_DEPTH = 0x0BA5; ///
enum GL_TEXTURE_STENCIL_SIZE = 0x88F1; ///
enum GL_TEXTURE_STENCIL_SIZE_EXT = 0x88F1; ///
enum GL_TEXTURE_STORAGE_HINT_APPLE = 0x85BC; ///
enum GL_TEXTURE_STORAGE_SPARSE_BIT_AMD = 0x00000001; ///
enum GL_TEXTURE_SWIZZLE_A = 0x8E45; ///
enum GL_TEXTURE_SWIZZLE_A_EXT = 0x8E45; ///
enum GL_TEXTURE_SWIZZLE_B = 0x8E44; ///
enum GL_TEXTURE_SWIZZLE_B_EXT = 0x8E44; ///
enum GL_TEXTURE_SWIZZLE_G = 0x8E43; ///
enum GL_TEXTURE_SWIZZLE_G_EXT = 0x8E43; ///
enum GL_TEXTURE_SWIZZLE_R = 0x8E42; ///
enum GL_TEXTURE_SWIZZLE_RGBA = 0x8E46; ///
enum GL_TEXTURE_SWIZZLE_RGBA_EXT = 0x8E46; ///
enum GL_TEXTURE_SWIZZLE_R_EXT = 0x8E42; ///
enum GL_TEXTURE_TARGET = 0x1006; ///
enum GL_TEXTURE_TARGET_QCOM = 0x8BDA; ///
enum GL_TEXTURE_TOO_LARGE_EXT = 0x8065; ///
enum GL_TEXTURE_TYPE_QCOM = 0x8BD7; ///
enum GL_TEXTURE_UNSIGNED_REMAP_MODE_NV = 0x888F; ///
enum GL_TEXTURE_UPDATE_BARRIER_BIT = 0x00000100; ///
enum GL_TEXTURE_UPDATE_BARRIER_BIT_EXT = 0x00000100; ///
enum GL_TEXTURE_USAGE_ANGLE = 0x93A2; ///
enum GL_TEXTURE_VIEW = 0x82B5; ///
enum GL_TEXTURE_VIEW_MIN_LAYER = 0x82DD; ///
enum GL_TEXTURE_VIEW_MIN_LAYER_EXT = 0x82DD; ///
enum GL_TEXTURE_VIEW_MIN_LAYER_OES = 0x82DD; ///
enum GL_TEXTURE_VIEW_MIN_LEVEL = 0x82DB; ///
enum GL_TEXTURE_VIEW_MIN_LEVEL_EXT = 0x82DB; ///
enum GL_TEXTURE_VIEW_MIN_LEVEL_OES = 0x82DB; ///
enum GL_TEXTURE_VIEW_NUM_LAYERS = 0x82DE; ///
enum GL_TEXTURE_VIEW_NUM_LAYERS_EXT = 0x82DE; ///
enum GL_TEXTURE_VIEW_NUM_LAYERS_OES = 0x82DE; ///
enum GL_TEXTURE_VIEW_NUM_LEVELS = 0x82DC; ///
enum GL_TEXTURE_VIEW_NUM_LEVELS_EXT = 0x82DC; ///
enum GL_TEXTURE_VIEW_NUM_LEVELS_OES = 0x82DC; ///
enum GL_TEXTURE_WIDTH = 0x1000; ///
enum GL_TEXTURE_WIDTH_QCOM = 0x8BD2; ///
enum GL_TEXTURE_WRAP_Q_SGIS = 0x8137; ///
enum GL_TEXTURE_WRAP_R = 0x8072; ///
enum GL_TEXTURE_WRAP_R_EXT = 0x8072; ///
enum GL_TEXTURE_WRAP_R_OES = 0x8072; ///
enum GL_TEXTURE_WRAP_S = 0x2802; ///
enum GL_TEXTURE_WRAP_T = 0x2803; ///
enum GL_TEXT_FRAGMENT_SHADER_ATI = 0x8200; ///
enum GL_TIMEOUT_EXPIRED = 0x911B; ///
enum GL_TIMEOUT_EXPIRED_APPLE = 0x911B; ///
enum GL_TIMEOUT_IGNORED = 0xFFFFFFFFFFFFFFFF; ///
enum GL_TIMEOUT_IGNORED_APPLE = 0xFFFFFFFFFFFFFFFF; ///
enum GL_TIMESTAMP = 0x8E28; ///
enum GL_TIMESTAMP_EXT = 0x8E28; ///
enum GL_TIME_ELAPSED = 0x88BF; ///
enum GL_TIME_ELAPSED_EXT = 0x88BF; ///
enum GL_TOP_LEVEL_ARRAY_SIZE = 0x930C; ///
enum GL_TOP_LEVEL_ARRAY_STRIDE = 0x930D; ///
enum GL_TRACE_ALL_BITS_MESA = 0xFFFF; ///
enum GL_TRACE_ARRAYS_BIT_MESA = 0x0004; ///
enum GL_TRACE_ERRORS_BIT_MESA = 0x0020; ///
enum GL_TRACE_MASK_MESA = 0x8755; ///
enum GL_TRACE_NAME_MESA = 0x8756; ///
enum GL_TRACE_OPERATIONS_BIT_MESA = 0x0001; ///
enum GL_TRACE_PIXELS_BIT_MESA = 0x0010; ///
enum GL_TRACE_PRIMITIVES_BIT_MESA = 0x0002; ///
enum GL_TRACE_TEXTURES_BIT_MESA = 0x0008; ///
enum GL_TRACK_MATRIX_NV = 0x8648; ///
enum GL_TRACK_MATRIX_TRANSFORM_NV = 0x8649; ///
enum GL_TRANSFORM_BIT = 0x00001000; ///
enum GL_TRANSFORM_FEEDBACK = 0x8E22; ///
enum GL_TRANSFORM_FEEDBACK_ACTIVE = 0x8E24; ///
enum GL_TRANSFORM_FEEDBACK_ATTRIBS_NV = 0x8C7E; ///
enum GL_TRANSFORM_FEEDBACK_BARRIER_BIT = 0x00000800; ///
enum GL_TRANSFORM_FEEDBACK_BARRIER_BIT_EXT = 0x00000800; ///
enum GL_TRANSFORM_FEEDBACK_BINDING = 0x8E25; ///
enum GL_TRANSFORM_FEEDBACK_BINDING_NV = 0x8E25; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER = 0x8C8E; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE = 0x8E24; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE_NV = 0x8E24; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_BINDING = 0x8C8F; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_BINDING_EXT = 0x8C8F; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_BINDING_NV = 0x8C8F; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_EXT = 0x8C8E; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_INDEX = 0x934B; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_MODE = 0x8C7F; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_MODE_EXT = 0x8C7F; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_MODE_NV = 0x8C7F; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_NV = 0x8C8E; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED = 0x8E23; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED_NV = 0x8E23; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_SIZE = 0x8C85; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_SIZE_EXT = 0x8C85; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_SIZE_NV = 0x8C85; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_START = 0x8C84; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_START_EXT = 0x8C84; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_START_NV = 0x8C84; ///
enum GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE = 0x934C; ///
enum GL_TRANSFORM_FEEDBACK_NV = 0x8E22; ///
enum GL_TRANSFORM_FEEDBACK_OVERFLOW_ARB = 0x82EC; ///
enum GL_TRANSFORM_FEEDBACK_PAUSED = 0x8E23; ///
enum GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 0x8C88; ///
enum GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN_EXT = 0x8C88; ///
enum GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN_NV = 0x8C88; ///
enum GL_TRANSFORM_FEEDBACK_RECORD_NV = 0x8C86; ///
enum GL_TRANSFORM_FEEDBACK_STREAM_OVERFLOW_ARB = 0x82ED; ///
enum GL_TRANSFORM_FEEDBACK_VARYING = 0x92F4; ///
enum GL_TRANSFORM_FEEDBACK_VARYINGS = 0x8C83; ///
enum GL_TRANSFORM_FEEDBACK_VARYINGS_EXT = 0x8C83; ///
enum GL_TRANSFORM_FEEDBACK_VARYINGS_NV = 0x8C83; ///
enum GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH = 0x8C76; ///
enum GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH_EXT = 0x8C76; ///
enum GL_TRANSFORM_HINT_APPLE = 0x85B1; ///
enum GL_TRANSLATED_SHADER_SOURCE_LENGTH_ANGLE = 0x93A0; ///
enum GL_TRANSLATE_2D_NV = 0x9090; ///
enum GL_TRANSLATE_3D_NV = 0x9091; ///
enum GL_TRANSLATE_X_NV = 0x908E; ///
enum GL_TRANSLATE_Y_NV = 0x908F; ///
enum GL_TRANSPOSE_AFFINE_2D_NV = 0x9096; ///
enum GL_TRANSPOSE_AFFINE_3D_NV = 0x9098; ///
enum GL_TRANSPOSE_COLOR_MATRIX = 0x84E6; ///
enum GL_TRANSPOSE_COLOR_MATRIX_ARB = 0x84E6; ///
enum GL_TRANSPOSE_CURRENT_MATRIX_ARB = 0x88B7; ///
enum GL_TRANSPOSE_MODELVIEW_MATRIX = 0x84E3; ///
enum GL_TRANSPOSE_MODELVIEW_MATRIX_ARB = 0x84E3; ///
enum GL_TRANSPOSE_NV = 0x862C; ///
enum GL_TRANSPOSE_PROGRAM_MATRIX_EXT = 0x8E2E; ///
enum GL_TRANSPOSE_PROJECTION_MATRIX = 0x84E4; ///
enum GL_TRANSPOSE_PROJECTION_MATRIX_ARB = 0x84E4; ///
enum GL_TRANSPOSE_TEXTURE_MATRIX = 0x84E5; ///
enum GL_TRANSPOSE_TEXTURE_MATRIX_ARB = 0x84E5; ///
enum GL_TRIANGLES = 0x0004; ///
enum GL_TRIANGLES_ADJACENCY = 0x000C; ///
enum GL_TRIANGLES_ADJACENCY_ARB = 0x000C; ///
enum GL_TRIANGLES_ADJACENCY_EXT = 0x000C; ///
enum GL_TRIANGLES_ADJACENCY_OES = 0x000C; ///
enum GL_TRIANGLE_FAN = 0x0006; ///
enum GL_TRIANGLE_LIST_SUN = 0x81D7; ///
enum GL_TRIANGLE_MESH_SUN = 0x8615; ///
enum GL_TRIANGLE_STRIP = 0x0005; ///
enum GL_TRIANGLE_STRIP_ADJACENCY = 0x000D; ///
enum GL_TRIANGLE_STRIP_ADJACENCY_ARB = 0x000D; ///
enum GL_TRIANGLE_STRIP_ADJACENCY_EXT = 0x000D; ///
enum GL_TRIANGLE_STRIP_ADJACENCY_OES = 0x000D; ///
enum GL_TRIANGULAR_NV = 0x90A5; ///
enum GL_TRUE = 1; ///
enum GL_TYPE = 0x92FA; ///
enum GL_UNCORRELATED_NV = 0x9282; ///
enum GL_UNDEFINED_APPLE = 0x8A1C; ///
enum GL_UNDEFINED_VERTEX = 0x8260; ///
enum GL_UNDEFINED_VERTEX_EXT = 0x8260; ///
enum GL_UNDEFINED_VERTEX_OES = 0x8260; ///
enum GL_UNIFORM = 0x92E1; ///
enum GL_UNIFORM_ADDRESS_COMMAND_NV = 0x000A; ///
enum GL_UNIFORM_ARRAY_STRIDE = 0x8A3C; ///
enum GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX = 0x92DA; ///
enum GL_UNIFORM_BARRIER_BIT = 0x00000004; ///
enum GL_UNIFORM_BARRIER_BIT_EXT = 0x00000004; ///
enum GL_UNIFORM_BLOCK = 0x92E2; ///
enum GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS = 0x8A42; ///
enum GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = 0x8A43; ///
enum GL_UNIFORM_BLOCK_BINDING = 0x8A3F; ///
enum GL_UNIFORM_BLOCK_DATA_SIZE = 0x8A40; ///
enum GL_UNIFORM_BLOCK_INDEX = 0x8A3A; ///
enum GL_UNIFORM_BLOCK_NAME_LENGTH = 0x8A41; ///
enum GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER = 0x90EC; ///
enum GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 0x8A46; ///
enum GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER = 0x8A45; ///
enum GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER = 0x84F0; ///
enum GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER = 0x84F1; ///
enum GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = 0x8A44; ///
enum GL_UNIFORM_BUFFER = 0x8A11; ///
enum GL_UNIFORM_BUFFER_ADDRESS_NV = 0x936F; ///
enum GL_UNIFORM_BUFFER_BINDING = 0x8A28; ///
enum GL_UNIFORM_BUFFER_BINDING_EXT = 0x8DEF; ///
enum GL_UNIFORM_BUFFER_EXT = 0x8DEE; ///
enum GL_UNIFORM_BUFFER_LENGTH_NV = 0x9370; ///
enum GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT = 0x8A34; ///
enum GL_UNIFORM_BUFFER_SIZE = 0x8A2A; ///
enum GL_UNIFORM_BUFFER_START = 0x8A29; ///
enum GL_UNIFORM_BUFFER_UNIFIED_NV = 0x936E; ///
enum GL_UNIFORM_IS_ROW_MAJOR = 0x8A3E; ///
enum GL_UNIFORM_MATRIX_STRIDE = 0x8A3D; ///
enum GL_UNIFORM_NAME_LENGTH = 0x8A39; ///
enum GL_UNIFORM_OFFSET = 0x8A3B; ///
enum GL_UNIFORM_SIZE = 0x8A38; ///
enum GL_UNIFORM_TYPE = 0x8A37; ///
enum GL_UNKNOWN_CONTEXT_RESET = 0x8255; ///
enum GL_UNKNOWN_CONTEXT_RESET_ARB = 0x8255; ///
enum GL_UNKNOWN_CONTEXT_RESET_EXT = 0x8255; ///
enum GL_UNKNOWN_CONTEXT_RESET_KHR = 0x8255; ///
enum GL_UNPACK_ALIGNMENT = 0x0CF5; ///
enum GL_UNPACK_CLIENT_STORAGE_APPLE = 0x85B2; ///
enum GL_UNPACK_CMYK_HINT_EXT = 0x800F; ///
enum GL_UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243; ///
enum GL_UNPACK_COMPRESSED_BLOCK_DEPTH = 0x9129; ///
enum GL_UNPACK_COMPRESSED_BLOCK_HEIGHT = 0x9128; ///
enum GL_UNPACK_COMPRESSED_BLOCK_SIZE = 0x912A; ///
enum GL_UNPACK_COMPRESSED_BLOCK_WIDTH = 0x9127; ///
enum GL_UNPACK_COMPRESSED_SIZE_SGIX = 0x831A; ///
enum GL_UNPACK_CONSTANT_DATA_SUNX = 0x81D5; ///
enum GL_UNPACK_FLIP_Y_WEBGL = 0x9240; ///
enum GL_UNPACK_IMAGE_DEPTH_SGIS = 0x8133; ///
enum GL_UNPACK_IMAGE_HEIGHT = 0x806E; ///
enum GL_UNPACK_IMAGE_HEIGHT_EXT = 0x806E; ///
enum GL_UNPACK_LSB_FIRST = 0x0CF1; ///
enum GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241; ///
enum GL_UNPACK_RESAMPLE_OML = 0x8985; ///
enum GL_UNPACK_RESAMPLE_SGIX = 0x842F; ///
enum GL_UNPACK_ROW_BYTES_APPLE = 0x8A16; ///
enum GL_UNPACK_ROW_LENGTH = 0x0CF2; ///
enum GL_UNPACK_ROW_LENGTH_EXT = 0x0CF2; ///
enum GL_UNPACK_SKIP_IMAGES = 0x806D; ///
enum GL_UNPACK_SKIP_IMAGES_EXT = 0x806D; ///
enum GL_UNPACK_SKIP_PIXELS = 0x0CF4; ///
enum GL_UNPACK_SKIP_PIXELS_EXT = 0x0CF4; ///
enum GL_UNPACK_SKIP_ROWS = 0x0CF3; ///
enum GL_UNPACK_SKIP_ROWS_EXT = 0x0CF3; ///
enum GL_UNPACK_SKIP_VOLUMES_SGIS = 0x8132; ///
enum GL_UNPACK_SUBSAMPLE_RATE_SGIX = 0x85A1; ///
enum GL_UNPACK_SWAP_BYTES = 0x0CF0; ///
enum GL_UNSIGNALED = 0x9118; ///
enum GL_UNSIGNALED_APPLE = 0x9118; ///
enum GL_UNSIGNED_BYTE = 0x1401; ///
enum GL_UNSIGNED_BYTE_2_3_3_REV = 0x8362; ///
enum GL_UNSIGNED_BYTE_2_3_3_REV_EXT = 0x8362; ///
enum GL_UNSIGNED_BYTE_3_3_2 = 0x8032; ///
enum GL_UNSIGNED_BYTE_3_3_2_EXT = 0x8032; ///
enum GL_UNSIGNED_IDENTITY_NV = 0x8536; ///
enum GL_UNSIGNED_INT = 0x1405; ///
enum GL_UNSIGNED_INT16_NV = 0x8FF0; ///
enum GL_UNSIGNED_INT16_VEC2_NV = 0x8FF1; ///
enum GL_UNSIGNED_INT16_VEC3_NV = 0x8FF2; ///
enum GL_UNSIGNED_INT16_VEC4_NV = 0x8FF3; ///
enum GL_UNSIGNED_INT64_AMD = 0x8BC2; ///
enum GL_UNSIGNED_INT64_ARB = 0x140F; ///
enum GL_UNSIGNED_INT64_NV = 0x140F; ///
enum GL_UNSIGNED_INT64_VEC2_ARB = 0x8FF5; ///
enum GL_UNSIGNED_INT64_VEC2_NV = 0x8FF5; ///
enum GL_UNSIGNED_INT64_VEC3_ARB = 0x8FF6; ///
enum GL_UNSIGNED_INT64_VEC3_NV = 0x8FF6; ///
enum GL_UNSIGNED_INT64_VEC4_ARB = 0x8FF7; ///
enum GL_UNSIGNED_INT64_VEC4_NV = 0x8FF7; ///
enum GL_UNSIGNED_INT8_NV = 0x8FEC; ///
enum GL_UNSIGNED_INT8_VEC2_NV = 0x8FED; ///
enum GL_UNSIGNED_INT8_VEC3_NV = 0x8FEE; ///
enum GL_UNSIGNED_INT8_VEC4_NV = 0x8FEF; ///
enum GL_UNSIGNED_INT_10F_11F_11F_REV = 0x8C3B; ///
enum GL_UNSIGNED_INT_10F_11F_11F_REV_APPLE = 0x8C3B; ///
enum GL_UNSIGNED_INT_10F_11F_11F_REV_EXT = 0x8C3B; ///
enum GL_UNSIGNED_INT_10_10_10_2 = 0x8036; ///
enum GL_UNSIGNED_INT_10_10_10_2_EXT = 0x8036; ///
enum GL_UNSIGNED_INT_10_10_10_2_OES = 0x8DF6; ///
enum GL_UNSIGNED_INT_24_8 = 0x84FA; ///
enum GL_UNSIGNED_INT_24_8_EXT = 0x84FA; ///
enum GL_UNSIGNED_INT_24_8_MESA = 0x8751; ///
enum GL_UNSIGNED_INT_24_8_NV = 0x84FA; ///
enum GL_UNSIGNED_INT_24_8_OES = 0x84FA; ///
enum GL_UNSIGNED_INT_2_10_10_10_REV = 0x8368; ///
enum GL_UNSIGNED_INT_2_10_10_10_REV_EXT = 0x8368; ///
enum GL_UNSIGNED_INT_5_9_9_9_REV = 0x8C3E; ///
enum GL_UNSIGNED_INT_5_9_9_9_REV_APPLE = 0x8C3E; ///
enum GL_UNSIGNED_INT_5_9_9_9_REV_EXT = 0x8C3E; ///
enum GL_UNSIGNED_INT_8_24_REV_MESA = 0x8752; ///
enum GL_UNSIGNED_INT_8_8_8_8 = 0x8035; ///
enum GL_UNSIGNED_INT_8_8_8_8_EXT = 0x8035; ///
enum GL_UNSIGNED_INT_8_8_8_8_REV = 0x8367; ///
enum GL_UNSIGNED_INT_8_8_8_8_REV_EXT = 0x8367; ///
enum GL_UNSIGNED_INT_8_8_S8_S8_REV_NV = 0x86DB; ///
enum GL_UNSIGNED_INT_ATOMIC_COUNTER = 0x92DB; ///
enum GL_UNSIGNED_INT_IMAGE_1D = 0x9062; ///
enum GL_UNSIGNED_INT_IMAGE_1D_ARRAY = 0x9068; ///
enum GL_UNSIGNED_INT_IMAGE_1D_ARRAY_EXT = 0x9068; ///
enum GL_UNSIGNED_INT_IMAGE_1D_EXT = 0x9062; ///
enum GL_UNSIGNED_INT_IMAGE_2D = 0x9063; ///
enum GL_UNSIGNED_INT_IMAGE_2D_ARRAY = 0x9069; ///
enum GL_UNSIGNED_INT_IMAGE_2D_ARRAY_EXT = 0x9069; ///
enum GL_UNSIGNED_INT_IMAGE_2D_EXT = 0x9063; ///
enum GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE = 0x906B; ///
enum GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY = 0x906C; ///
enum GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY_EXT = 0x906C; ///
enum GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_EXT = 0x906B; ///
enum GL_UNSIGNED_INT_IMAGE_2D_RECT = 0x9065; ///
enum GL_UNSIGNED_INT_IMAGE_2D_RECT_EXT = 0x9065; ///
enum GL_UNSIGNED_INT_IMAGE_3D = 0x9064; ///
enum GL_UNSIGNED_INT_IMAGE_3D_EXT = 0x9064; ///
enum GL_UNSIGNED_INT_IMAGE_BUFFER = 0x9067; ///
enum GL_UNSIGNED_INT_IMAGE_BUFFER_EXT = 0x9067; ///
enum GL_UNSIGNED_INT_IMAGE_BUFFER_OES = 0x9067; ///
enum GL_UNSIGNED_INT_IMAGE_CUBE = 0x9066; ///
enum GL_UNSIGNED_INT_IMAGE_CUBE_EXT = 0x9066; ///
enum GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY = 0x906A; ///
enum GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY_EXT = 0x906A; ///
enum GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY_OES = 0x906A; ///
enum GL_UNSIGNED_INT_S8_S8_8_8_NV = 0x86DA; ///
enum GL_UNSIGNED_INT_SAMPLER_1D = 0x8DD1; ///
enum GL_UNSIGNED_INT_SAMPLER_1D_ARRAY = 0x8DD6; ///
enum GL_UNSIGNED_INT_SAMPLER_1D_ARRAY_EXT = 0x8DD6; ///
enum GL_UNSIGNED_INT_SAMPLER_1D_EXT = 0x8DD1; ///
enum GL_UNSIGNED_INT_SAMPLER_2D = 0x8DD2; ///
enum GL_UNSIGNED_INT_SAMPLER_2D_ARRAY = 0x8DD7; ///
enum GL_UNSIGNED_INT_SAMPLER_2D_ARRAY_EXT = 0x8DD7; ///
enum GL_UNSIGNED_INT_SAMPLER_2D_EXT = 0x8DD2; ///
enum GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE = 0x910A; ///
enum GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY = 0x910D; ///
enum GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY_OES = 0x910D; ///
enum GL_UNSIGNED_INT_SAMPLER_2D_RECT = 0x8DD5; ///
enum GL_UNSIGNED_INT_SAMPLER_2D_RECT_EXT = 0x8DD5; ///
enum GL_UNSIGNED_INT_SAMPLER_3D = 0x8DD3; ///
enum GL_UNSIGNED_INT_SAMPLER_3D_EXT = 0x8DD3; ///
enum GL_UNSIGNED_INT_SAMPLER_BUFFER = 0x8DD8; ///
enum GL_UNSIGNED_INT_SAMPLER_BUFFER_AMD = 0x9003; ///
enum GL_UNSIGNED_INT_SAMPLER_BUFFER_EXT = 0x8DD8; ///
enum GL_UNSIGNED_INT_SAMPLER_BUFFER_OES = 0x8DD8; ///
enum GL_UNSIGNED_INT_SAMPLER_CUBE = 0x8DD4; ///
enum GL_UNSIGNED_INT_SAMPLER_CUBE_EXT = 0x8DD4; ///
enum GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY = 0x900F; ///
enum GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_ARB = 0x900F; ///
enum GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_EXT = 0x900F; ///
enum GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_OES = 0x900F; ///
enum GL_UNSIGNED_INT_SAMPLER_RENDERBUFFER_NV = 0x8E58; ///
enum GL_UNSIGNED_INT_VEC2 = 0x8DC6; ///
enum GL_UNSIGNED_INT_VEC2_EXT = 0x8DC6; ///
enum GL_UNSIGNED_INT_VEC3 = 0x8DC7; ///
enum GL_UNSIGNED_INT_VEC3_EXT = 0x8DC7; ///
enum GL_UNSIGNED_INT_VEC4 = 0x8DC8; ///
enum GL_UNSIGNED_INT_VEC4_EXT = 0x8DC8; ///
enum GL_UNSIGNED_INVERT_NV = 0x8537; ///
enum GL_UNSIGNED_NORMALIZED = 0x8C17; ///
enum GL_UNSIGNED_NORMALIZED_ARB = 0x8C17; ///
enum GL_UNSIGNED_NORMALIZED_EXT = 0x8C17; ///
enum GL_UNSIGNED_SHORT = 0x1403; ///
enum GL_UNSIGNED_SHORT_15_1_MESA = 0x8753; ///
enum GL_UNSIGNED_SHORT_1_15_REV_MESA = 0x8754; ///
enum GL_UNSIGNED_SHORT_1_5_5_5_REV = 0x8366; ///
enum GL_UNSIGNED_SHORT_1_5_5_5_REV_EXT = 0x8366; ///
enum GL_UNSIGNED_SHORT_4_4_4_4 = 0x8033; ///
enum GL_UNSIGNED_SHORT_4_4_4_4_EXT = 0x8033; ///
enum GL_UNSIGNED_SHORT_4_4_4_4_REV = 0x8365; ///
enum GL_UNSIGNED_SHORT_4_4_4_4_REV_EXT = 0x8365; ///
enum GL_UNSIGNED_SHORT_4_4_4_4_REV_IMG = 0x8365; ///
enum GL_UNSIGNED_SHORT_5_5_5_1 = 0x8034; ///
enum GL_UNSIGNED_SHORT_5_5_5_1_EXT = 0x8034; ///
enum GL_UNSIGNED_SHORT_5_6_5 = 0x8363; ///
enum GL_UNSIGNED_SHORT_5_6_5_EXT = 0x8363; ///
enum GL_UNSIGNED_SHORT_5_6_5_REV = 0x8364; ///
enum GL_UNSIGNED_SHORT_5_6_5_REV_EXT = 0x8364; ///
enum GL_UNSIGNED_SHORT_8_8_APPLE = 0x85BA; ///
enum GL_UNSIGNED_SHORT_8_8_MESA = 0x85BA; ///
enum GL_UNSIGNED_SHORT_8_8_REV_APPLE = 0x85BB; ///
enum GL_UNSIGNED_SHORT_8_8_REV_MESA = 0x85BB; ///
enum GL_UPPER_LEFT = 0x8CA2; ///
enum GL_USE_MISSING_GLYPH_NV = 0x90AA; ///
enum GL_UTF16_NV = 0x909B; ///
enum GL_UTF8_NV = 0x909A; ///
enum GL_V2F = 0x2A20; ///
enum GL_V3F = 0x2A21; ///
enum GL_VALIDATE_STATUS = 0x8B83; ///
enum GL_VARIABLE_A_NV = 0x8523; ///
enum GL_VARIABLE_B_NV = 0x8524; ///
enum GL_VARIABLE_C_NV = 0x8525; ///
enum GL_VARIABLE_D_NV = 0x8526; ///
enum GL_VARIABLE_E_NV = 0x8527; ///
enum GL_VARIABLE_F_NV = 0x8528; ///
enum GL_VARIABLE_G_NV = 0x8529; ///
enum GL_VARIANT_ARRAY_EXT = 0x87E8; ///
enum GL_VARIANT_ARRAY_POINTER_EXT = 0x87E9; ///
enum GL_VARIANT_ARRAY_STRIDE_EXT = 0x87E6; ///
enum GL_VARIANT_ARRAY_TYPE_EXT = 0x87E7; ///
enum GL_VARIANT_DATATYPE_EXT = 0x87E5; ///
enum GL_VARIANT_EXT = 0x87C1; ///
enum GL_VARIANT_VALUE_EXT = 0x87E4; ///
enum GL_VBO_FREE_MEMORY_ATI = 0x87FB; ///
enum GL_VECTOR_EXT = 0x87BF; ///
enum GL_VENDOR = 0x1F00; ///
enum GL_VERSION = 0x1F02; ///
enum GL_VERSION_ES_CL_1_0 = 1; ///
enum GL_VERSION_ES_CL_1_1 = 1; ///
enum GL_VERSION_ES_CM_1_1 = 1; ///
enum GL_VERTEX23_BIT_PGI = 0x00000004; ///
enum GL_VERTEX4_BIT_PGI = 0x00000008; ///
enum GL_VERTEX_ARRAY = 0x8074; ///
enum GL_VERTEX_ARRAY_ADDRESS_NV = 0x8F21; ///
enum GL_VERTEX_ARRAY_BINDING = 0x85B5; ///
enum GL_VERTEX_ARRAY_BINDING_APPLE = 0x85B5; ///
enum GL_VERTEX_ARRAY_BINDING_OES = 0x85B5; ///
enum GL_VERTEX_ARRAY_BUFFER_BINDING = 0x8896; ///
enum GL_VERTEX_ARRAY_BUFFER_BINDING_ARB = 0x8896; ///
enum GL_VERTEX_ARRAY_COUNT_EXT = 0x807D; ///
enum GL_VERTEX_ARRAY_EXT = 0x8074; ///
enum GL_VERTEX_ARRAY_KHR = 0x8074; ///
enum GL_VERTEX_ARRAY_LENGTH_NV = 0x8F2B; ///
enum GL_VERTEX_ARRAY_LIST_IBM = 0x103070; ///
enum GL_VERTEX_ARRAY_LIST_STRIDE_IBM = 0x103080; ///
enum GL_VERTEX_ARRAY_OBJECT_AMD = 0x9154; ///
enum GL_VERTEX_ARRAY_OBJECT_EXT = 0x9154; ///
enum GL_VERTEX_ARRAY_PARALLEL_POINTERS_INTEL = 0x83F5; ///
enum GL_VERTEX_ARRAY_POINTER = 0x808E; ///
enum GL_VERTEX_ARRAY_POINTER_EXT = 0x808E; ///
enum GL_VERTEX_ARRAY_RANGE_APPLE = 0x851D; ///
enum GL_VERTEX_ARRAY_RANGE_LENGTH_APPLE = 0x851E; ///
enum GL_VERTEX_ARRAY_RANGE_LENGTH_NV = 0x851E; ///
enum GL_VERTEX_ARRAY_RANGE_NV = 0x851D; ///
enum GL_VERTEX_ARRAY_RANGE_POINTER_APPLE = 0x8521; ///
enum GL_VERTEX_ARRAY_RANGE_POINTER_NV = 0x8521; ///
enum GL_VERTEX_ARRAY_RANGE_VALID_NV = 0x851F; ///
enum GL_VERTEX_ARRAY_RANGE_WITHOUT_FLUSH_NV = 0x8533; ///
enum GL_VERTEX_ARRAY_SIZE = 0x807A; ///
enum GL_VERTEX_ARRAY_SIZE_EXT = 0x807A; ///
enum GL_VERTEX_ARRAY_STORAGE_HINT_APPLE = 0x851F; ///
enum GL_VERTEX_ARRAY_STRIDE = 0x807C; ///
enum GL_VERTEX_ARRAY_STRIDE_EXT = 0x807C; ///
enum GL_VERTEX_ARRAY_TYPE = 0x807B; ///
enum GL_VERTEX_ARRAY_TYPE_EXT = 0x807B; ///
enum GL_VERTEX_ATTRIB_ARRAY0_NV = 0x8650; ///
enum GL_VERTEX_ATTRIB_ARRAY10_NV = 0x865A; ///
enum GL_VERTEX_ATTRIB_ARRAY11_NV = 0x865B; ///
enum GL_VERTEX_ATTRIB_ARRAY12_NV = 0x865C; ///
enum GL_VERTEX_ATTRIB_ARRAY13_NV = 0x865D; ///
enum GL_VERTEX_ATTRIB_ARRAY14_NV = 0x865E; ///
enum GL_VERTEX_ATTRIB_ARRAY15_NV = 0x865F; ///
enum GL_VERTEX_ATTRIB_ARRAY1_NV = 0x8651; ///
enum GL_VERTEX_ATTRIB_ARRAY2_NV = 0x8652; ///
enum GL_VERTEX_ATTRIB_ARRAY3_NV = 0x8653; ///
enum GL_VERTEX_ATTRIB_ARRAY4_NV = 0x8654; ///
enum GL_VERTEX_ATTRIB_ARRAY5_NV = 0x8655; ///
enum GL_VERTEX_ATTRIB_ARRAY6_NV = 0x8656; ///
enum GL_VERTEX_ATTRIB_ARRAY7_NV = 0x8657; ///
enum GL_VERTEX_ATTRIB_ARRAY8_NV = 0x8658; ///
enum GL_VERTEX_ATTRIB_ARRAY9_NV = 0x8659; ///
enum GL_VERTEX_ATTRIB_ARRAY_ADDRESS_NV = 0x8F20; ///
enum GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT = 0x00000001; ///
enum GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT_EXT = 0x00000001; ///
enum GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F; ///
enum GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB = 0x889F; ///
enum GL_VERTEX_ATTRIB_ARRAY_DIVISOR = 0x88FE; ///
enum GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE = 0x88FE; ///
enum GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ARB = 0x88FE; ///
enum GL_VERTEX_ATTRIB_ARRAY_DIVISOR_EXT = 0x88FE; ///
enum GL_VERTEX_ATTRIB_ARRAY_DIVISOR_NV = 0x88FE; ///
enum GL_VERTEX_ATTRIB_ARRAY_ENABLED = 0x8622; ///
enum GL_VERTEX_ATTRIB_ARRAY_ENABLED_ARB = 0x8622; ///
enum GL_VERTEX_ATTRIB_ARRAY_INTEGER = 0x88FD; ///
enum GL_VERTEX_ATTRIB_ARRAY_INTEGER_EXT = 0x88FD; ///
enum GL_VERTEX_ATTRIB_ARRAY_INTEGER_NV = 0x88FD; ///
enum GL_VERTEX_ATTRIB_ARRAY_LENGTH_NV = 0x8F2A; ///
enum GL_VERTEX_ATTRIB_ARRAY_LONG = 0x874E; ///
enum GL_VERTEX_ATTRIB_ARRAY_NORMALIZED = 0x886A; ///
enum GL_VERTEX_ATTRIB_ARRAY_NORMALIZED_ARB = 0x886A; ///
enum GL_VERTEX_ATTRIB_ARRAY_POINTER = 0x8645; ///
enum GL_VERTEX_ATTRIB_ARRAY_POINTER_ARB = 0x8645; ///
enum GL_VERTEX_ATTRIB_ARRAY_SIZE = 0x8623; ///
enum GL_VERTEX_ATTRIB_ARRAY_SIZE_ARB = 0x8623; ///
enum GL_VERTEX_ATTRIB_ARRAY_STRIDE = 0x8624; ///
enum GL_VERTEX_ATTRIB_ARRAY_STRIDE_ARB = 0x8624; ///
enum GL_VERTEX_ATTRIB_ARRAY_TYPE = 0x8625; ///
enum GL_VERTEX_ATTRIB_ARRAY_TYPE_ARB = 0x8625; ///
enum GL_VERTEX_ATTRIB_ARRAY_UNIFIED_NV = 0x8F1E; ///
enum GL_VERTEX_ATTRIB_BINDING = 0x82D4; ///
enum GL_VERTEX_ATTRIB_MAP1_APPLE = 0x8A00; ///
enum GL_VERTEX_ATTRIB_MAP1_COEFF_APPLE = 0x8A03; ///
enum GL_VERTEX_ATTRIB_MAP1_DOMAIN_APPLE = 0x8A05; ///
enum GL_VERTEX_ATTRIB_MAP1_ORDER_APPLE = 0x8A04; ///
enum GL_VERTEX_ATTRIB_MAP1_SIZE_APPLE = 0x8A02; ///
enum GL_VERTEX_ATTRIB_MAP2_APPLE = 0x8A01; ///
enum GL_VERTEX_ATTRIB_MAP2_COEFF_APPLE = 0x8A07; ///
enum GL_VERTEX_ATTRIB_MAP2_DOMAIN_APPLE = 0x8A09; ///
enum GL_VERTEX_ATTRIB_MAP2_ORDER_APPLE = 0x8A08; ///
enum GL_VERTEX_ATTRIB_MAP2_SIZE_APPLE = 0x8A06; ///
enum GL_VERTEX_ATTRIB_RELATIVE_OFFSET = 0x82D5; ///
enum GL_VERTEX_BINDING_BUFFER = 0x8F4F; ///
enum GL_VERTEX_BINDING_DIVISOR = 0x82D6; ///
enum GL_VERTEX_BINDING_OFFSET = 0x82D7; ///
enum GL_VERTEX_BINDING_STRIDE = 0x82D8; ///
enum GL_VERTEX_BLEND_ARB = 0x86A7; ///
enum GL_VERTEX_CONSISTENT_HINT_PGI = 0x1A22B; ///
enum GL_VERTEX_DATA_HINT_PGI = 0x1A22A; ///
enum GL_VERTEX_ELEMENT_SWIZZLE_AMD = 0x91A4; ///
enum GL_VERTEX_ID_NV = 0x8C7B; ///
enum GL_VERTEX_ID_SWIZZLE_AMD = 0x91A5; ///
enum GL_VERTEX_PRECLIP_HINT_SGIX = 0x83EF; ///
enum GL_VERTEX_PRECLIP_SGIX = 0x83EE; ///
enum GL_VERTEX_PROGRAM_ARB = 0x8620; ///
enum GL_VERTEX_PROGRAM_BINDING_NV = 0x864A; ///
enum GL_VERTEX_PROGRAM_CALLBACK_DATA_MESA = 0x8BB7; ///
enum GL_VERTEX_PROGRAM_CALLBACK_FUNC_MESA = 0x8BB6; ///
enum GL_VERTEX_PROGRAM_CALLBACK_MESA = 0x8BB5; ///
enum GL_VERTEX_PROGRAM_NV = 0x8620; ///
enum GL_VERTEX_PROGRAM_PARAMETER_BUFFER_NV = 0x8DA2; ///
enum GL_VERTEX_PROGRAM_POINT_SIZE = 0x8642; ///
enum GL_VERTEX_PROGRAM_POINT_SIZE_ARB = 0x8642; ///
enum GL_VERTEX_PROGRAM_POINT_SIZE_NV = 0x8642; ///
enum GL_VERTEX_PROGRAM_POSITION_MESA = 0x8BB4; ///
enum GL_VERTEX_PROGRAM_TWO_SIDE = 0x8643; ///
enum GL_VERTEX_PROGRAM_TWO_SIDE_ARB = 0x8643; ///
enum GL_VERTEX_PROGRAM_TWO_SIDE_NV = 0x8643; ///
enum GL_VERTEX_SHADER = 0x8B31; ///
enum GL_VERTEX_SHADER_ARB = 0x8B31; ///
enum GL_VERTEX_SHADER_BINDING_EXT = 0x8781; ///
enum GL_VERTEX_SHADER_BIT = 0x00000001; ///
enum GL_VERTEX_SHADER_BIT_EXT = 0x00000001; ///
enum GL_VERTEX_SHADER_EXT = 0x8780; ///
enum GL_VERTEX_SHADER_INSTRUCTIONS_EXT = 0x87CF; ///
enum GL_VERTEX_SHADER_INVARIANTS_EXT = 0x87D1; ///
enum GL_VERTEX_SHADER_INVOCATIONS_ARB = 0x82F0; ///
enum GL_VERTEX_SHADER_LOCALS_EXT = 0x87D3; ///
enum GL_VERTEX_SHADER_LOCAL_CONSTANTS_EXT = 0x87D2; ///
enum GL_VERTEX_SHADER_OPTIMIZED_EXT = 0x87D4; ///
enum GL_VERTEX_SHADER_VARIANTS_EXT = 0x87D0; ///
enum GL_VERTEX_SOURCE_ATI = 0x8774; ///
enum GL_VERTEX_STATE_PROGRAM_NV = 0x8621; ///
enum GL_VERTEX_STREAM0_ATI = 0x876C; ///
enum GL_VERTEX_STREAM1_ATI = 0x876D; ///
enum GL_VERTEX_STREAM2_ATI = 0x876E; ///
enum GL_VERTEX_STREAM3_ATI = 0x876F; ///
enum GL_VERTEX_STREAM4_ATI = 0x8770; ///
enum GL_VERTEX_STREAM5_ATI = 0x8771; ///
enum GL_VERTEX_STREAM6_ATI = 0x8772; ///
enum GL_VERTEX_STREAM7_ATI = 0x8773; ///
enum GL_VERTEX_SUBROUTINE = 0x92E8; ///
enum GL_VERTEX_SUBROUTINE_UNIFORM = 0x92EE; ///
enum GL_VERTEX_TEXTURE = 0x829B; ///
enum GL_VERTEX_WEIGHTING_EXT = 0x8509; ///
enum GL_VERTEX_WEIGHT_ARRAY_EXT = 0x850C; ///
enum GL_VERTEX_WEIGHT_ARRAY_POINTER_EXT = 0x8510; ///
enum GL_VERTEX_WEIGHT_ARRAY_SIZE_EXT = 0x850D; ///
enum GL_VERTEX_WEIGHT_ARRAY_STRIDE_EXT = 0x850F; ///
enum GL_VERTEX_WEIGHT_ARRAY_TYPE_EXT = 0x850E; ///
enum GL_VERTICAL_LINE_TO_NV = 0x08; ///
enum GL_VERTICES_SUBMITTED_ARB = 0x82EE; ///
enum GL_VIBRANCE_BIAS_NV = 0x8719; ///
enum GL_VIBRANCE_SCALE_NV = 0x8713; ///
enum GL_VIDEO_BUFFER_BINDING_NV = 0x9021; ///
enum GL_VIDEO_BUFFER_INTERNAL_FORMAT_NV = 0x902D; ///
enum GL_VIDEO_BUFFER_NV = 0x9020; ///
enum GL_VIDEO_BUFFER_PITCH_NV = 0x9028; ///
enum GL_VIDEO_CAPTURE_FIELD_LOWER_HEIGHT_NV = 0x903B; ///
enum GL_VIDEO_CAPTURE_FIELD_UPPER_HEIGHT_NV = 0x903A; ///
enum GL_VIDEO_CAPTURE_FRAME_HEIGHT_NV = 0x9039; ///
enum GL_VIDEO_CAPTURE_FRAME_WIDTH_NV = 0x9038; ///
enum GL_VIDEO_CAPTURE_SURFACE_ORIGIN_NV = 0x903C; ///
enum GL_VIDEO_CAPTURE_TO_422_SUPPORTED_NV = 0x9026; ///
enum GL_VIDEO_COLOR_CONVERSION_MATRIX_NV = 0x9029; ///
enum GL_VIDEO_COLOR_CONVERSION_MAX_NV = 0x902A; ///
enum GL_VIDEO_COLOR_CONVERSION_MIN_NV = 0x902B; ///
enum GL_VIDEO_COLOR_CONVERSION_OFFSET_NV = 0x902C; ///
enum GL_VIEWPORT = 0x0BA2; ///
enum GL_VIEWPORT_BIT = 0x00000800; ///
enum GL_VIEWPORT_BOUNDS_RANGE = 0x825D; ///
enum GL_VIEWPORT_BOUNDS_RANGE_EXT = 0x825D; ///
enum GL_VIEWPORT_BOUNDS_RANGE_NV = 0x825D; ///
enum GL_VIEWPORT_BOUNDS_RANGE_OES = 0x825D; ///
enum GL_VIEWPORT_COMMAND_NV = 0x0010; ///
enum GL_VIEWPORT_INDEX_PROVOKING_VERTEX = 0x825F; ///
enum GL_VIEWPORT_INDEX_PROVOKING_VERTEX_EXT = 0x825F; ///
enum GL_VIEWPORT_INDEX_PROVOKING_VERTEX_NV = 0x825F; ///
enum GL_VIEWPORT_INDEX_PROVOKING_VERTEX_OES = 0x825F; ///
enum GL_VIEWPORT_POSITION_W_SCALE_NV = 0x937C; ///
enum GL_VIEWPORT_POSITION_W_SCALE_X_COEFF_NV = 0x937D; ///
enum GL_VIEWPORT_POSITION_W_SCALE_Y_COEFF_NV = 0x937E; ///
enum GL_VIEWPORT_SUBPIXEL_BITS = 0x825C; ///
enum GL_VIEWPORT_SUBPIXEL_BITS_EXT = 0x825C; ///
enum GL_VIEWPORT_SUBPIXEL_BITS_NV = 0x825C; ///
enum GL_VIEWPORT_SUBPIXEL_BITS_OES = 0x825C; ///
enum GL_VIEWPORT_SWIZZLE_NEGATIVE_W_NV = 0x9357; ///
enum GL_VIEWPORT_SWIZZLE_NEGATIVE_X_NV = 0x9351; ///
enum GL_VIEWPORT_SWIZZLE_NEGATIVE_Y_NV = 0x9353; ///
enum GL_VIEWPORT_SWIZZLE_NEGATIVE_Z_NV = 0x9355; ///
enum GL_VIEWPORT_SWIZZLE_POSITIVE_W_NV = 0x9356; ///
enum GL_VIEWPORT_SWIZZLE_POSITIVE_X_NV = 0x9350; ///
enum GL_VIEWPORT_SWIZZLE_POSITIVE_Y_NV = 0x9352; ///
enum GL_VIEWPORT_SWIZZLE_POSITIVE_Z_NV = 0x9354; ///
enum GL_VIEWPORT_SWIZZLE_W_NV = 0x935B; ///
enum GL_VIEWPORT_SWIZZLE_X_NV = 0x9358; ///
enum GL_VIEWPORT_SWIZZLE_Y_NV = 0x9359; ///
enum GL_VIEWPORT_SWIZZLE_Z_NV = 0x935A; ///
enum GL_VIEW_CLASS_128_BITS = 0x82C4; ///
enum GL_VIEW_CLASS_16_BITS = 0x82CA; ///
enum GL_VIEW_CLASS_24_BITS = 0x82C9; ///
enum GL_VIEW_CLASS_32_BITS = 0x82C8; ///
enum GL_VIEW_CLASS_48_BITS = 0x82C7; ///
enum GL_VIEW_CLASS_64_BITS = 0x82C6; ///
enum GL_VIEW_CLASS_8_BITS = 0x82CB; ///
enum GL_VIEW_CLASS_96_BITS = 0x82C5; ///
enum GL_VIEW_CLASS_BPTC_FLOAT = 0x82D3; ///
enum GL_VIEW_CLASS_BPTC_UNORM = 0x82D2; ///
enum GL_VIEW_CLASS_RGTC1_RED = 0x82D0; ///
enum GL_VIEW_CLASS_RGTC2_RG = 0x82D1; ///
enum GL_VIEW_CLASS_S3TC_DXT1_RGB = 0x82CC; ///
enum GL_VIEW_CLASS_S3TC_DXT1_RGBA = 0x82CD; ///
enum GL_VIEW_CLASS_S3TC_DXT3_RGBA = 0x82CE; ///
enum GL_VIEW_CLASS_S3TC_DXT5_RGBA = 0x82CF; ///
enum GL_VIEW_COMPATIBILITY_CLASS = 0x82B6; ///
enum GL_VIRTUAL_PAGE_SIZE_INDEX_ARB = 0x91A7; ///
enum GL_VIRTUAL_PAGE_SIZE_INDEX_EXT = 0x91A7; ///
enum GL_VIRTUAL_PAGE_SIZE_X_AMD = 0x9195; ///
enum GL_VIRTUAL_PAGE_SIZE_X_ARB = 0x9195; ///
enum GL_VIRTUAL_PAGE_SIZE_X_EXT = 0x9195; ///
enum GL_VIRTUAL_PAGE_SIZE_Y_AMD = 0x9196; ///
enum GL_VIRTUAL_PAGE_SIZE_Y_ARB = 0x9196; ///
enum GL_VIRTUAL_PAGE_SIZE_Y_EXT = 0x9196; ///
enum GL_VIRTUAL_PAGE_SIZE_Z_AMD = 0x9197; ///
enum GL_VIRTUAL_PAGE_SIZE_Z_ARB = 0x9197; ///
enum GL_VIRTUAL_PAGE_SIZE_Z_EXT = 0x9197; ///
enum GL_VIVIDLIGHT_NV = 0x92A6; ///
enum GL_VOLATILE_APPLE = 0x8A1A; ///
enum GL_WAIT_FAILED = 0x911D; ///
enum GL_WAIT_FAILED_APPLE = 0x911D; ///
enum GL_WARPS_PER_SM_NV = 0x933A; ///
enum GL_WARP_SIZE_NV = 0x9339; ///
enum GL_WEIGHTED_AVERAGE_ARB = 0x9367; ///
enum GL_WEIGHT_ARRAY_ARB = 0x86AD; ///
enum GL_WEIGHT_ARRAY_BUFFER_BINDING = 0x889E; ///
enum GL_WEIGHT_ARRAY_BUFFER_BINDING_ARB = 0x889E; ///
enum GL_WEIGHT_ARRAY_BUFFER_BINDING_OES = 0x889E; ///
enum GL_WEIGHT_ARRAY_OES = 0x86AD; ///
enum GL_WEIGHT_ARRAY_POINTER_ARB = 0x86AC; ///
enum GL_WEIGHT_ARRAY_POINTER_OES = 0x86AC; ///
enum GL_WEIGHT_ARRAY_SIZE_ARB = 0x86AB; ///
enum GL_WEIGHT_ARRAY_SIZE_OES = 0x86AB; ///
enum GL_WEIGHT_ARRAY_STRIDE_ARB = 0x86AA; ///
enum GL_WEIGHT_ARRAY_STRIDE_OES = 0x86AA; ///
enum GL_WEIGHT_ARRAY_TYPE_ARB = 0x86A9; ///
enum GL_WEIGHT_ARRAY_TYPE_OES = 0x86A9; ///
enum GL_WEIGHT_SUM_UNITY_ARB = 0x86A6; ///
enum GL_WIDE_LINE_HINT_PGI = 0x1A222; ///
enum GL_WINDOW_RECTANGLE_EXT = 0x8F12; ///
enum GL_WINDOW_RECTANGLE_MODE_EXT = 0x8F13; ///
enum GL_WRAP_BORDER_SUN = 0x81D4; ///
enum GL_WRITEONLY_RENDERING_QCOM = 0x8823; ///
enum GL_WRITE_DISCARD_NV = 0x88BE; ///
enum GL_WRITE_ONLY = 0x88B9; ///
enum GL_WRITE_ONLY_ARB = 0x88B9; ///
enum GL_WRITE_ONLY_OES = 0x88B9; ///
enum GL_WRITE_PIXEL_DATA_RANGE_LENGTH_NV = 0x887A; ///
enum GL_WRITE_PIXEL_DATA_RANGE_NV = 0x8878; ///
enum GL_WRITE_PIXEL_DATA_RANGE_POINTER_NV = 0x887C; ///
enum GL_W_EXT = 0x87D8; ///
enum GL_XOR = 0x1506; ///
enum GL_XOR_NV = 0x1506; ///
enum GL_X_EXT = 0x87D5; ///
enum GL_YCBAYCR8A_4224_NV = 0x9032; ///
enum GL_YCBCR_422_APPLE = 0x85B9; ///
enum GL_YCBCR_MESA = 0x8757; ///
enum GL_YCBYCR8_422_NV = 0x9031; ///
enum GL_YCRCBA_SGIX = 0x8319; ///
enum GL_YCRCB_422_SGIX = 0x81BB; ///
enum GL_YCRCB_444_SGIX = 0x81BC; ///
enum GL_YCRCB_SGIX = 0x8318; ///
enum GL_Y_EXT = 0x87D6; ///
enum GL_Z400_BINARY_AMD = 0x8740; ///
enum GL_Z4Y12Z4CB12Z4A12Z4Y12Z4CR12Z4A12_4224_NV = 0x9036; ///
enum GL_Z4Y12Z4CB12Z4CR12_444_NV = 0x9037; ///
enum GL_Z4Y12Z4CB12Z4Y12Z4CR12_422_NV = 0x9035; ///
enum GL_Z6Y10Z6CB10Z6A10Z6Y10Z6CR10Z6A10_4224_NV = 0x9034; ///
enum GL_Z6Y10Z6CB10Z6Y10Z6CR10_422_NV = 0x9033; ///
enum GL_ZERO = 0; ///
enum GL_ZERO_EXT = 0x87DD; ///
enum GL_ZERO_TO_ONE = 0x935F; ///
enum GL_ZOOM_X = 0x0D16; ///
enum GL_ZOOM_Y = 0x0D17; ///
enum GL_Z_EXT = 0x87D7; ///

/// Container for bindings
struct GL {
	///
	enum AccumOp {
    	///
	    ACCUM = 0x0100,
    	///
	    LOAD = 0x0101,
    	///
	    RETURN = 0x0102,
    	///
	    MULT = 0x0103,
    	///
	    ADD = 0x0104
	}

	///
	@Bitmaskable
	enum AttribMask {
    	///
	    ACCUM_BUFFER_BIT = 0x00000200,
    	///
	    ALL_ATTRIB_BITS = 0xFFFFFFFF,
    	///
	    COLOR_BUFFER_BIT = 0x00004000,
    	///
	    CURRENT_BIT = 0x00000001,
    	///
	    DEPTH_BUFFER_BIT = 0x00000100,
    	///
	    ENABLE_BIT = 0x00002000,
    	///
	    EVAL_BIT = 0x00010000,
    	///
	    FOG_BIT = 0x00000080,
    	///
	    HINT_BIT = 0x00008000,
    	///
	    LIGHTING_BIT = 0x00000040,
    	///
	    LINE_BIT = 0x00000004,
    	///
	    LIST_BIT = 0x00020000,
    	///
	    MULTISAMPLE_BIT = 0x20000000,
    	///
	    MULTISAMPLE_BIT_3DFX = 0x20000000,
    	///
	    MULTISAMPLE_BIT_ARB = 0x20000000,
    	///
	    MULTISAMPLE_BIT_EXT = 0x20000000,
    	///
	    PIXEL_MODE_BIT = 0x00000020,
    	///
	    POINT_BIT = 0x00000002,
    	///
	    POLYGON_BIT = 0x00000008,
    	///
	    POLYGON_STIPPLE_BIT = 0x00000010,
    	///
	    SCISSOR_BIT = 0x00080000,
    	///
	    STENCIL_BUFFER_BIT = 0x00000400,
    	///
	    TEXTURE_BIT = 0x00040000,
    	///
	    TRANSFORM_BIT = 0x00001000,
    	///
	    VIEWPORT_BIT = 0x00000800
	}

	///
	enum AlphaFunction {
    	///
	    ALWAYS = 0x0207,
    	///
	    EQUAL = 0x0202,
    	///
	    GEQUAL = 0x0206,
    	///
	    GREATER = 0x0204,
    	///
	    LEQUAL = 0x0203,
    	///
	    LESS = 0x0201,
    	///
	    NEVER = 0x0200,
    	///
	    NOTEQUAL = 0x0205
	}

	///
	enum BlendEquationModeEXT {
    	///
	    ALPHA_MAX_SGIX = 0x8321,
    	///
	    ALPHA_MIN_SGIX = 0x8320,
    	///
	    FUNC_ADD_EXT = 0x8006,
    	///
	    FUNC_REVERSE_SUBTRACT_EXT = 0x800B,
    	///
	    FUNC_SUBTRACT_EXT = 0x800A,
    	///
	    LOGIC_OP = 0x0BF1,
    	///
	    MAX_EXT = 0x8008,
    	///
	    MIN_EXT = 0x8007
	}

	///
	enum BlendingFactorDest {
    	///
	    CONSTANT_ALPHA_EXT = 0x8003,
    	///
	    CONSTANT_COLOR_EXT = 0x8001,
    	///
	    DST_ALPHA = 0x0304,
    	///
	    ONE = 1,
    	///
	    ONE_MINUS_CONSTANT_ALPHA_EXT = 0x8004,
    	///
	    ONE_MINUS_CONSTANT_COLOR_EXT = 0x8002,
    	///
	    ONE_MINUS_DST_ALPHA = 0x0305,
    	///
	    ONE_MINUS_SRC_ALPHA = 0x0303,
    	///
	    ONE_MINUS_SRC_COLOR = 0x0301,
    	///
	    SRC_ALPHA = 0x0302,
    	///
	    SRC_COLOR = 0x0300,
    	///
	    ZERO = 0
	}

	///
	enum BlendingFactorSrc {
    	///
	    CONSTANT_ALPHA_EXT = 0x8003,
    	///
	    CONSTANT_COLOR_EXT = 0x8001,
    	///
	    DST_ALPHA = 0x0304,
    	///
	    DST_COLOR = 0x0306,
    	///
	    ONE = 1,
    	///
	    ONE_MINUS_CONSTANT_ALPHA_EXT = 0x8004,
    	///
	    ONE_MINUS_CONSTANT_COLOR_EXT = 0x8002,
    	///
	    ONE_MINUS_DST_ALPHA = 0x0305,
    	///
	    ONE_MINUS_DST_COLOR = 0x0307,
    	///
	    ONE_MINUS_SRC_ALPHA = 0x0303,
    	///
	    SRC_ALPHA = 0x0302,
    	///
	    SRC_ALPHA_SATURATE = 0x0308,
    	///
	    ZERO = 0
	}

	///
	enum Boolean {
    	///
	    FALSE = 0,
    	///
	    TRUE = 1
	}

	///
	@Bitmaskable
	enum ClearBufferMask {
    	///
	    ACCUM_BUFFER_BIT = 0x00000200,
    	///
	    COLOR_BUFFER_BIT = 0x00004000,
    	///
	    COVERAGE_BUFFER_BIT_NV = 0x00008000,
    	///
	    DEPTH_BUFFER_BIT = 0x00000100,
    	///
	    STENCIL_BUFFER_BIT = 0x00000400
	}

	///
	@Bitmaskable
	enum ClientAttribMask {
    	///
	    CLIENT_ALL_ATTRIB_BITS = 0xFFFFFFFF,
    	///
	    CLIENT_PIXEL_STORE_BIT = 0x00000001,
    	///
	    CLIENT_VERTEX_ARRAY_BIT = 0x00000002
	}

	///
	enum ClipPlaneName {
    	///
	    CLIP_DISTANCE0 = 0x3000,
    	///
	    CLIP_DISTANCE1 = 0x3001,
    	///
	    CLIP_DISTANCE2 = 0x3002,
    	///
	    CLIP_DISTANCE3 = 0x3003,
    	///
	    CLIP_DISTANCE4 = 0x3004,
    	///
	    CLIP_DISTANCE5 = 0x3005,
    	///
	    CLIP_DISTANCE6 = 0x3006,
    	///
	    CLIP_DISTANCE7 = 0x3007,
    	///
	    CLIP_PLANE0 = 0x3000,
    	///
	    CLIP_PLANE1 = 0x3001,
    	///
	    CLIP_PLANE2 = 0x3002,
    	///
	    CLIP_PLANE3 = 0x3003,
    	///
	    CLIP_PLANE4 = 0x3004,
    	///
	    CLIP_PLANE5 = 0x3005
	}

	///
	enum ColorMaterialFace {
    	///
	    BACK = 0x0405,
    	///
	    FRONT = 0x0404,
    	///
	    FRONT_AND_BACK = 0x0408
	}

	///
	enum ColorMaterialParameter {
    	///
	    AMBIENT = 0x1200,
    	///
	    AMBIENT_AND_DIFFUSE = 0x1602,
    	///
	    DIFFUSE = 0x1201,
    	///
	    EMISSION = 0x1600,
    	///
	    SPECULAR = 0x1202
	}

	///
	enum ColorPointerType {
    	///
	    BYTE = 0x1400,
    	///
	    DOUBLE = 0x140A,
    	///
	    FLOAT = 0x1406,
    	///
	    INT = 0x1404,
    	///
	    SHORT = 0x1402,
    	///
	    UNSIGNED_BYTE = 0x1401,
    	///
	    UNSIGNED_INT = 0x1405,
    	///
	    UNSIGNED_SHORT = 0x1403
	}

	///
	enum ColorTableParameterPNameSGI {
    	///
	    COLOR_TABLE_BIAS = 0x80D7,
    	///
	    COLOR_TABLE_BIAS_SGI = 0x80D7,
    	///
	    COLOR_TABLE_SCALE = 0x80D6,
    	///
	    COLOR_TABLE_SCALE_SGI = 0x80D6
	}

	///
	enum ColorTableTargetSGI {
    	///
	    COLOR_TABLE = 0x80D0,
    	///
	    COLOR_TABLE_SGI = 0x80D0,
    	///
	    POST_COLOR_MATRIX_COLOR_TABLE = 0x80D2,
    	///
	    POST_COLOR_MATRIX_COLOR_TABLE_SGI = 0x80D2,
    	///
	    POST_CONVOLUTION_COLOR_TABLE = 0x80D1,
    	///
	    POST_CONVOLUTION_COLOR_TABLE_SGI = 0x80D1,
    	///
	    PROXY_COLOR_TABLE = 0x80D3,
    	///
	    PROXY_COLOR_TABLE_SGI = 0x80D3,
    	///
	    PROXY_POST_COLOR_MATRIX_COLOR_TABLE = 0x80D5,
    	///
	    PROXY_POST_COLOR_MATRIX_COLOR_TABLE_SGI = 0x80D5,
    	///
	    PROXY_POST_CONVOLUTION_COLOR_TABLE = 0x80D4,
    	///
	    PROXY_POST_CONVOLUTION_COLOR_TABLE_SGI = 0x80D4,
    	///
	    PROXY_TEXTURE_COLOR_TABLE_SGI = 0x80BD,
    	///
	    TEXTURE_COLOR_TABLE_SGI = 0x80BC
	}

	///
	@Bitmaskable
	enum ContextFlagMask {
    	///
	    CONTEXT_FLAG_DEBUG_BIT = 0x00000002,
    	///
	    CONTEXT_FLAG_DEBUG_BIT_KHR = 0x00000002,
    	///
	    CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT = 0x00000001,
    	///
	    CONTEXT_FLAG_ROBUST_ACCESS_BIT_ARB = 0x00000004,
    	///
	    CONTEXT_FLAG_PROTECTED_CONTENT_BIT_EXT = 0x00000010
	}

	///
	@Bitmaskable
	enum ContextProfileMask {
    	///
	    CONTEXT_COMPATIBILITY_PROFILE_BIT = 0x00000002,
    	///
	    CONTEXT_CORE_PROFILE_BIT = 0x00000001
	}

	///
	enum ConvolutionBorderModeEXT {
    	///
	    REDUCE = 0x8016,
    	///
	    REDUCE_EXT = 0x8016
	}

	///
	enum ConvolutionParameterEXT {
    	///
	    CONVOLUTION_BORDER_MODE = 0x8013,
    	///
	    CONVOLUTION_BORDER_MODE_EXT = 0x8013,
    	///
	    CONVOLUTION_FILTER_BIAS = 0x8015,
    	///
	    CONVOLUTION_FILTER_BIAS_EXT = 0x8015,
    	///
	    CONVOLUTION_FILTER_SCALE = 0x8014,
    	///
	    CONVOLUTION_FILTER_SCALE_EXT = 0x8014
	}

	///
	enum ConvolutionTargetEXT {
    	///
	    CONVOLUTION_1D = 0x8010,
    	///
	    CONVOLUTION_1D_EXT = 0x8010,
    	///
	    CONVOLUTION_2D = 0x8011,
    	///
	    CONVOLUTION_2D_EXT = 0x8011
	}

	///
	enum CullFaceMode {
    	///
	    BACK = 0x0405,
    	///
	    FRONT = 0x0404,
    	///
	    FRONT_AND_BACK = 0x0408
	}

	///
	enum DepthFunction {
    	///
	    ALWAYS = 0x0207,
    	///
	    EQUAL = 0x0202,
    	///
	    GEQUAL = 0x0206,
    	///
	    GREATER = 0x0204,
    	///
	    LEQUAL = 0x0203,
    	///
	    LESS = 0x0201,
    	///
	    NEVER = 0x0200,
    	///
	    NOTEQUAL = 0x0205
	}

	///
	enum DrawBufferMode {
    	///
	    AUX0 = 0x0409,
    	///
	    AUX1 = 0x040A,
    	///
	    AUX2 = 0x040B,
    	///
	    AUX3 = 0x040C,
    	///
	    BACK = 0x0405,
    	///
	    BACK_LEFT = 0x0402,
    	///
	    BACK_RIGHT = 0x0403,
    	///
	    FRONT = 0x0404,
    	///
	    FRONT_AND_BACK = 0x0408,
    	///
	    FRONT_LEFT = 0x0400,
    	///
	    FRONT_RIGHT = 0x0401,
    	///
	    LEFT = 0x0406,
    	///
	    NONE = 0,
    	///
	    NONE_OES = 0,
    	///
	    RIGHT = 0x0407
	}

	///
	enum EnableCap {
    	///
	    ALPHA_TEST = 0x0BC0,
    	///
	    ASYNC_DRAW_PIXELS_SGIX = 0x835D,
    	///
	    ASYNC_HISTOGRAM_SGIX = 0x832C,
    	///
	    ASYNC_READ_PIXELS_SGIX = 0x835E,
    	///
	    ASYNC_TEX_IMAGE_SGIX = 0x835C,
    	///
	    AUTO_NORMAL = 0x0D80,
    	///
	    BLEND = 0x0BE2,
    	///
	    CALLIGRAPHIC_FRAGMENT_SGIX = 0x8183,
    	///
	    CLIP_PLANE0 = 0x3000,
    	///
	    CLIP_PLANE1 = 0x3001,
    	///
	    CLIP_PLANE2 = 0x3002,
    	///
	    CLIP_PLANE3 = 0x3003,
    	///
	    CLIP_PLANE4 = 0x3004,
    	///
	    CLIP_PLANE5 = 0x3005,
    	///
	    COLOR_ARRAY = 0x8076,
    	///
	    COLOR_LOGIC_OP = 0x0BF2,
    	///
	    COLOR_MATERIAL = 0x0B57,
    	///
	    COLOR_TABLE_SGI = 0x80D0,
    	///
	    CONVOLUTION_1D_EXT = 0x8010,
    	///
	    CONVOLUTION_2D_EXT = 0x8011,
    	///
	    CULL_FACE = 0x0B44,
    	///
	    DEPTH_TEST = 0x0B71,
    	///
	    DITHER = 0x0BD0,
    	///
	    EDGE_FLAG_ARRAY = 0x8079,
    	///
	    FOG = 0x0B60,
    	///
	    FOG_OFFSET_SGIX = 0x8198,
    	///
	    FRAGMENT_COLOR_MATERIAL_SGIX = 0x8401,
    	///
	    FRAGMENT_LIGHT0_SGIX = 0x840C,
    	///
	    FRAGMENT_LIGHT1_SGIX = 0x840D,
    	///
	    FRAGMENT_LIGHT2_SGIX = 0x840E,
    	///
	    FRAGMENT_LIGHT3_SGIX = 0x840F,
    	///
	    FRAGMENT_LIGHT4_SGIX = 0x8410,
    	///
	    FRAGMENT_LIGHT5_SGIX = 0x8411,
    	///
	    FRAGMENT_LIGHT6_SGIX = 0x8412,
    	///
	    FRAGMENT_LIGHT7_SGIX = 0x8413,
    	///
	    FRAGMENT_LIGHTING_SGIX = 0x8400,
    	///
	    FRAMEZOOM_SGIX = 0x818B,
    	///
	    HISTOGRAM_EXT = 0x8024,
    	///
	    INDEX_ARRAY = 0x8077,
    	///
	    INDEX_LOGIC_OP = 0x0BF1,
    	///
	    INTERLACE_SGIX = 0x8094,
    	///
	    IR_INSTRUMENT1_SGIX = 0x817F,
    	///
	    LIGHT0 = 0x4000,
    	///
	    LIGHT1 = 0x4001,
    	///
	    LIGHT2 = 0x4002,
    	///
	    LIGHT3 = 0x4003,
    	///
	    LIGHT4 = 0x4004,
    	///
	    LIGHT5 = 0x4005,
    	///
	    LIGHT6 = 0x4006,
    	///
	    LIGHT7 = 0x4007,
    	///
	    LIGHTING = 0x0B50,
    	///
	    LINE_SMOOTH = 0x0B20,
    	///
	    LINE_STIPPLE = 0x0B24,
    	///
	    MAP1_COLOR_4 = 0x0D90,
    	///
	    MAP1_INDEX = 0x0D91,
    	///
	    MAP1_NORMAL = 0x0D92,
    	///
	    MAP1_TEXTURE_COORD_1 = 0x0D93,
    	///
	    MAP1_TEXTURE_COORD_2 = 0x0D94,
    	///
	    MAP1_TEXTURE_COORD_3 = 0x0D95,
    	///
	    MAP1_TEXTURE_COORD_4 = 0x0D96,
    	///
	    MAP1_VERTEX_3 = 0x0D97,
    	///
	    MAP1_VERTEX_4 = 0x0D98,
    	///
	    MAP2_COLOR_4 = 0x0DB0,
    	///
	    MAP2_INDEX = 0x0DB1,
    	///
	    MAP2_NORMAL = 0x0DB2,
    	///
	    MAP2_TEXTURE_COORD_1 = 0x0DB3,
    	///
	    MAP2_TEXTURE_COORD_2 = 0x0DB4,
    	///
	    MAP2_TEXTURE_COORD_3 = 0x0DB5,
    	///
	    MAP2_TEXTURE_COORD_4 = 0x0DB6,
    	///
	    MAP2_VERTEX_3 = 0x0DB7,
    	///
	    MAP2_VERTEX_4 = 0x0DB8,
    	///
	    MINMAX_EXT = 0x802E,
    	///
	    MULTISAMPLE_SGIS = 0x809D,
    	///
	    NORMALIZE = 0x0BA1,
    	///
	    NORMAL_ARRAY = 0x8075,
    	///
	    PIXEL_TEXTURE_SGIS = 0x8353,
    	///
	    PIXEL_TEX_GEN_SGIX = 0x8139,
    	///
	    POINT_SMOOTH = 0x0B10,
    	///
	    POLYGON_OFFSET_FILL = 0x8037,
    	///
	    POLYGON_OFFSET_LINE = 0x2A02,
    	///
	    POLYGON_OFFSET_POINT = 0x2A01,
    	///
	    POLYGON_SMOOTH = 0x0B41,
    	///
	    POLYGON_STIPPLE = 0x0B42,
    	///
	    POST_COLOR_MATRIX_COLOR_TABLE_SGI = 0x80D2,
    	///
	    POST_CONVOLUTION_COLOR_TABLE_SGI = 0x80D1,
    	///
	    REFERENCE_PLANE_SGIX = 0x817D,
    	///
	    RESCALE_NORMAL_EXT = 0x803A,
    	///
	    SAMPLE_ALPHA_TO_MASK_SGIS = 0x809E,
    	///
	    SAMPLE_ALPHA_TO_ONE_SGIS = 0x809F,
    	///
	    SAMPLE_MASK_SGIS = 0x80A0,
    	///
	    SCISSOR_TEST = 0x0C11,
    	///
	    SEPARABLE_2D_EXT = 0x8012,
    	///
	    SHARED_TEXTURE_PALETTE_EXT = 0x81FB,
    	///
	    SPRITE_SGIX = 0x8148,
    	///
	    STENCIL_TEST = 0x0B90,
    	///
	    TEXTURE_1D = 0x0DE0,
    	///
	    TEXTURE_2D = 0x0DE1,
    	///
	    TEXTURE_3D_EXT = 0x806F,
    	///
	    TEXTURE_4D_SGIS = 0x8134,
    	///
	    TEXTURE_COLOR_TABLE_SGI = 0x80BC,
    	///
	    TEXTURE_COORD_ARRAY = 0x8078,
    	///
	    TEXTURE_GEN_Q = 0x0C63,
    	///
	    TEXTURE_GEN_R = 0x0C62,
    	///
	    TEXTURE_GEN_S = 0x0C60,
    	///
	    TEXTURE_GEN_T = 0x0C61,
    	///
	    VERTEX_ARRAY = 0x8074
	}

	///
	enum ErrorCode {
    	///
	    INVALID_ENUM = 0x0500,
    	///
	    INVALID_FRAMEBUFFER_OPERATION = 0x0506,
    	///
	    INVALID_FRAMEBUFFER_OPERATION_EXT = 0x0506,
    	///
	    INVALID_FRAMEBUFFER_OPERATION_OES = 0x0506,
    	///
	    INVALID_OPERATION = 0x0502,
    	///
	    INVALID_VALUE = 0x0501,
    	///
	    NO_ERROR = 0,
    	///
	    OUT_OF_MEMORY = 0x0505,
    	///
	    STACK_OVERFLOW = 0x0503,
    	///
	    STACK_UNDERFLOW = 0x0504,
    	///
	    TABLE_TOO_LARGE = 0x8031,
    	///
	    TABLE_TOO_LARGE_EXT = 0x8031,
    	///
	    TEXTURE_TOO_LARGE_EXT = 0x8065
	}

	///
	enum FeedbackType {
    	///
	    _2D = 0x0600,
    	///
	    _3D = 0x0601,
    	///
	    COLOR_3D = 0x0602,
    	///
	    COLOR_TEXTURE_3D = 0x0603,
    	///
	    COLOR_TEXTURE_4D = 0x0604
	}

	///
	enum FeedBackToken {
    	///
	    BITMAP_TOKEN = 0x0704,
    	///
	    COPY_PIXEL_TOKEN = 0x0706,
    	///
	    DRAW_PIXEL_TOKEN = 0x0705,
    	///
	    LINE_RESET_TOKEN = 0x0707,
    	///
	    LINE_TOKEN = 0x0702,
    	///
	    PASS_THROUGH_TOKEN = 0x0700,
    	///
	    POINT_TOKEN = 0x0701,
    	///
	    POLYGON_TOKEN = 0x0703
	}

	///
	enum FfdTargetSGIX {
    	///
	    GEOMETRY_DEFORMATION_SGIX = 0x8194,
    	///
	    TEXTURE_DEFORMATION_SGIX = 0x8195
	}

	///
	enum FogCoordinatePointerType {
    	///
	    FLOAT = 0x1406,
    	///
	    DOUBLE = 0x140A
	}

	///
	enum FogMode {
    	///
	    EXP = 0x0800,
    	///
	    EXP2 = 0x0801,
    	///
	    FOG_FUNC_SGIS = 0x812A,
    	///
	    LINEAR = 0x2601
	}

	///
	enum FogParameter {
    	///
	    FOG_COLOR = 0x0B66,
    	///
	    FOG_DENSITY = 0x0B62,
    	///
	    FOG_END = 0x0B64,
    	///
	    FOG_INDEX = 0x0B61,
    	///
	    FOG_MODE = 0x0B65,
    	///
	    FOG_OFFSET_VALUE_SGIX = 0x8199,
    	///
	    FOG_START = 0x0B63
	}

	///
	enum FogPointerTypeEXT {
    	///
	    FLOAT = 0x1406,
    	///
	    DOUBLE = 0x140A
	}

	///
	enum FogPointerTypeIBM {
    	///
	    FLOAT = 0x1406,
    	///
	    DOUBLE = 0x140A
	}

	///
	enum FragmentLightModelParameterSGIX {
    	///
	    FRAGMENT_LIGHT_MODEL_AMBIENT_SGIX = 0x840A,
    	///
	    FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER_SGIX = 0x8408,
    	///
	    FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION_SGIX = 0x840B,
    	///
	    FRAGMENT_LIGHT_MODEL_TWO_SIDE_SGIX = 0x8409
	}

	///
	enum FrontFaceDirection {
    	///
	    CCW = 0x0901,
    	///
	    CW = 0x0900
	}

	///
	enum GetColorTableParameterPNameSGI {
    	///
	    COLOR_TABLE_ALPHA_SIZE_SGI = 0x80DD,
    	///
	    COLOR_TABLE_BIAS_SGI = 0x80D7,
    	///
	    COLOR_TABLE_BLUE_SIZE_SGI = 0x80DC,
    	///
	    COLOR_TABLE_FORMAT_SGI = 0x80D8,
    	///
	    COLOR_TABLE_GREEN_SIZE_SGI = 0x80DB,
    	///
	    COLOR_TABLE_INTENSITY_SIZE_SGI = 0x80DF,
    	///
	    COLOR_TABLE_LUMINANCE_SIZE_SGI = 0x80DE,
    	///
	    COLOR_TABLE_RED_SIZE_SGI = 0x80DA,
    	///
	    COLOR_TABLE_SCALE_SGI = 0x80D6,
    	///
	    COLOR_TABLE_WIDTH_SGI = 0x80D9
	}

	///
	enum GetConvolutionParameter {
    	///
	    CONVOLUTION_BORDER_MODE_EXT = 0x8013,
    	///
	    CONVOLUTION_FILTER_BIAS_EXT = 0x8015,
    	///
	    CONVOLUTION_FILTER_SCALE_EXT = 0x8014,
    	///
	    CONVOLUTION_FORMAT_EXT = 0x8017,
    	///
	    CONVOLUTION_HEIGHT_EXT = 0x8019,
    	///
	    CONVOLUTION_WIDTH_EXT = 0x8018,
    	///
	    MAX_CONVOLUTION_HEIGHT_EXT = 0x801B,
    	///
	    MAX_CONVOLUTION_WIDTH_EXT = 0x801A
	}

	///
	enum GetHistogramParameterPNameEXT {
    	///
	    HISTOGRAM_ALPHA_SIZE_EXT = 0x802B,
    	///
	    HISTOGRAM_BLUE_SIZE_EXT = 0x802A,
    	///
	    HISTOGRAM_FORMAT_EXT = 0x8027,
    	///
	    HISTOGRAM_GREEN_SIZE_EXT = 0x8029,
    	///
	    HISTOGRAM_LUMINANCE_SIZE_EXT = 0x802C,
    	///
	    HISTOGRAM_RED_SIZE_EXT = 0x8028,
    	///
	    HISTOGRAM_SINK_EXT = 0x802D,
    	///
	    HISTOGRAM_WIDTH_EXT = 0x8026
	}

	///
	enum GetMapQuery {
    	///
	    COEFF = 0x0A00,
    	///
	    DOMAIN = 0x0A02,
    	///
	    ORDER = 0x0A01
	}

	///
	enum GetMinmaxParameterPNameEXT {
    	///
	    MINMAX_FORMAT = 0x802F,
    	///
	    MINMAX_FORMAT_EXT = 0x802F,
    	///
	    MINMAX_SINK = 0x8030,
    	///
	    MINMAX_SINK_EXT = 0x8030
	}

	///
	enum GetPixelMap {
    	///
	    PIXEL_MAP_A_TO_A = 0x0C79,
    	///
	    PIXEL_MAP_B_TO_B = 0x0C78,
    	///
	    PIXEL_MAP_G_TO_G = 0x0C77,
    	///
	    PIXEL_MAP_I_TO_A = 0x0C75,
    	///
	    PIXEL_MAP_I_TO_B = 0x0C74,
    	///
	    PIXEL_MAP_I_TO_G = 0x0C73,
    	///
	    PIXEL_MAP_I_TO_I = 0x0C70,
    	///
	    PIXEL_MAP_I_TO_R = 0x0C72,
    	///
	    PIXEL_MAP_R_TO_R = 0x0C76,
    	///
	    PIXEL_MAP_S_TO_S = 0x0C71
	}

	///
	enum GetPName {
    	///
	    ACCUM_ALPHA_BITS = 0x0D5B,
    	///
	    ACCUM_BLUE_BITS = 0x0D5A,
    	///
	    ACCUM_CLEAR_VALUE = 0x0B80,
    	///
	    ACCUM_GREEN_BITS = 0x0D59,
    	///
	    ACCUM_RED_BITS = 0x0D58,
    	///
	    ALIASED_LINE_WIDTH_RANGE = 0x846E,
    	///
	    ALIASED_POINT_SIZE_RANGE = 0x846D,
    	///
	    ALPHA_BIAS = 0x0D1D,
    	///
	    ALPHA_BITS = 0x0D55,
    	///
	    ALPHA_SCALE = 0x0D1C,
    	///
	    ALPHA_TEST = 0x0BC0,
    	///
	    ALPHA_TEST_FUNC = 0x0BC1,
    	///
	    ALPHA_TEST_FUNC_QCOM = 0x0BC1,
    	///
	    ALPHA_TEST_QCOM = 0x0BC0,
    	///
	    ALPHA_TEST_REF = 0x0BC2,
    	///
	    ALPHA_TEST_REF_QCOM = 0x0BC2,
    	///
	    ASYNC_DRAW_PIXELS_SGIX = 0x835D,
    	///
	    ASYNC_HISTOGRAM_SGIX = 0x832C,
    	///
	    ASYNC_MARKER_SGIX = 0x8329,
    	///
	    ASYNC_READ_PIXELS_SGIX = 0x835E,
    	///
	    ASYNC_TEX_IMAGE_SGIX = 0x835C,
    	///
	    ATTRIB_STACK_DEPTH = 0x0BB0,
    	///
	    AUTO_NORMAL = 0x0D80,
    	///
	    AUX_BUFFERS = 0x0C00,
    	///
	    BLEND = 0x0BE2,
    	///
	    BLEND_COLOR_EXT = 0x8005,
    	///
	    BLEND_DST = 0x0BE0,
    	///
	    BLEND_EQUATION_EXT = 0x8009,
    	///
	    BLEND_SRC = 0x0BE1,
    	///
	    BLUE_BIAS = 0x0D1B,
    	///
	    BLUE_BITS = 0x0D54,
    	///
	    BLUE_SCALE = 0x0D1A,
    	///
	    CALLIGRAPHIC_FRAGMENT_SGIX = 0x8183,
    	///
	    CLIENT_ATTRIB_STACK_DEPTH = 0x0BB1,
    	///
	    CLIP_PLANE0 = 0x3000,
    	///
	    CLIP_PLANE1 = 0x3001,
    	///
	    CLIP_PLANE2 = 0x3002,
    	///
	    CLIP_PLANE3 = 0x3003,
    	///
	    CLIP_PLANE4 = 0x3004,
    	///
	    CLIP_PLANE5 = 0x3005,
    	///
	    COLOR_ARRAY = 0x8076,
    	///
	    COLOR_ARRAY_COUNT_EXT = 0x8084,
    	///
	    COLOR_ARRAY_SIZE = 0x8081,
    	///
	    COLOR_ARRAY_STRIDE = 0x8083,
    	///
	    COLOR_ARRAY_TYPE = 0x8082,
    	///
	    COLOR_CLEAR_VALUE = 0x0C22,
    	///
	    COLOR_LOGIC_OP = 0x0BF2,
    	///
	    COLOR_MATERIAL = 0x0B57,
    	///
	    COLOR_MATERIAL_FACE = 0x0B55,
    	///
	    COLOR_MATERIAL_PARAMETER = 0x0B56,
    	///
	    COLOR_MATRIX_SGI = 0x80B1,
    	///
	    COLOR_MATRIX_STACK_DEPTH_SGI = 0x80B2,
    	///
	    COLOR_TABLE_SGI = 0x80D0,
    	///
	    COLOR_WRITEMASK = 0x0C23,
    	///
	    CONVOLUTION_1D_EXT = 0x8010,
    	///
	    CONVOLUTION_2D_EXT = 0x8011,
    	///
	    CONVOLUTION_HINT_SGIX = 0x8316,
    	///
	    CULL_FACE = 0x0B44,
    	///
	    CULL_FACE_MODE = 0x0B45,
    	///
	    CURRENT_COLOR = 0x0B00,
    	///
	    CURRENT_INDEX = 0x0B01,
    	///
	    CURRENT_NORMAL = 0x0B02,
    	///
	    CURRENT_RASTER_COLOR = 0x0B04,
    	///
	    CURRENT_RASTER_DISTANCE = 0x0B09,
    	///
	    CURRENT_RASTER_INDEX = 0x0B05,
    	///
	    CURRENT_RASTER_POSITION = 0x0B07,
    	///
	    CURRENT_RASTER_POSITION_VALID = 0x0B08,
    	///
	    CURRENT_RASTER_TEXTURE_COORDS = 0x0B06,
    	///
	    CURRENT_TEXTURE_COORDS = 0x0B03,
    	///
	    DEFORMATIONS_MASK_SGIX = 0x8196,
    	///
	    DEPTH_BIAS = 0x0D1F,
    	///
	    DEPTH_BITS = 0x0D56,
    	///
	    DEPTH_CLEAR_VALUE = 0x0B73,
    	///
	    DEPTH_FUNC = 0x0B74,
    	///
	    DEPTH_RANGE = 0x0B70,
    	///
	    DEPTH_SCALE = 0x0D1E,
    	///
	    DEPTH_TEST = 0x0B71,
    	///
	    DEPTH_WRITEMASK = 0x0B72,
    	///
	    DETAIL_TEXTURE_2D_BINDING_SGIS = 0x8096,
    	///
	    DISTANCE_ATTENUATION_SGIS = 0x8129,
    	///
	    DITHER = 0x0BD0,
    	///
	    DOUBLEBUFFER = 0x0C32,
    	///
	    DRAW_BUFFER = 0x0C01,
    	///
	    DRAW_BUFFER_EXT = 0x0C01,
    	///
	    EDGE_FLAG = 0x0B43,
    	///
	    EDGE_FLAG_ARRAY = 0x8079,
    	///
	    EDGE_FLAG_ARRAY_COUNT_EXT = 0x808D,
    	///
	    EDGE_FLAG_ARRAY_STRIDE = 0x808C,
    	///
	    FEEDBACK_BUFFER_SIZE = 0x0DF1,
    	///
	    FEEDBACK_BUFFER_TYPE = 0x0DF2,
    	///
	    FOG = 0x0B60,
    	///
	    FOG_COLOR = 0x0B66,
    	///
	    FOG_DENSITY = 0x0B62,
    	///
	    FOG_END = 0x0B64,
    	///
	    FOG_FUNC_POINTS_SGIS = 0x812B,
    	///
	    FOG_HINT = 0x0C54,
    	///
	    FOG_INDEX = 0x0B61,
    	///
	    FOG_MODE = 0x0B65,
    	///
	    FOG_OFFSET_SGIX = 0x8198,
    	///
	    FOG_OFFSET_VALUE_SGIX = 0x8199,
    	///
	    FOG_START = 0x0B63,
    	///
	    FRAGMENT_COLOR_MATERIAL_FACE_SGIX = 0x8402,
    	///
	    FRAGMENT_COLOR_MATERIAL_PARAMETER_SGIX = 0x8403,
    	///
	    FRAGMENT_COLOR_MATERIAL_SGIX = 0x8401,
    	///
	    FRAGMENT_LIGHT0_SGIX = 0x840C,
    	///
	    FRAGMENT_LIGHTING_SGIX = 0x8400,
    	///
	    FRAGMENT_LIGHT_MODEL_AMBIENT_SGIX = 0x840A,
    	///
	    FRAGMENT_LIGHT_MODEL_LOCAL_VIEWER_SGIX = 0x8408,
    	///
	    FRAGMENT_LIGHT_MODEL_NORMAL_INTERPOLATION_SGIX = 0x840B,
    	///
	    FRAGMENT_LIGHT_MODEL_TWO_SIDE_SGIX = 0x8409,
    	///
	    FRAMEZOOM_FACTOR_SGIX = 0x818C,
    	///
	    FRAMEZOOM_SGIX = 0x818B,
    	///
	    FRONT_FACE = 0x0B46,
    	///
	    GENERATE_MIPMAP_HINT_SGIS = 0x8192,
    	///
	    GREEN_BIAS = 0x0D19,
    	///
	    GREEN_BITS = 0x0D53,
    	///
	    GREEN_SCALE = 0x0D18,
    	///
	    HISTOGRAM_EXT = 0x8024,
    	///
	    INDEX_ARRAY = 0x8077,
    	///
	    INDEX_ARRAY_COUNT_EXT = 0x8087,
    	///
	    INDEX_ARRAY_STRIDE = 0x8086,
    	///
	    INDEX_ARRAY_TYPE = 0x8085,
    	///
	    INDEX_BITS = 0x0D51,
    	///
	    INDEX_CLEAR_VALUE = 0x0C20,
    	///
	    INDEX_LOGIC_OP = 0x0BF1,
    	///
	    INDEX_MODE = 0x0C30,
    	///
	    INDEX_OFFSET = 0x0D13,
    	///
	    INDEX_SHIFT = 0x0D12,
    	///
	    INDEX_WRITEMASK = 0x0C21,
    	///
	    INSTRUMENT_MEASUREMENTS_SGIX = 0x8181,
    	///
	    INTERLACE_SGIX = 0x8094,
    	///
	    IR_INSTRUMENT1_SGIX = 0x817F,
    	///
	    LIGHT0 = 0x4000,
    	///
	    LIGHT1 = 0x4001,
    	///
	    LIGHT2 = 0x4002,
    	///
	    LIGHT3 = 0x4003,
    	///
	    LIGHT4 = 0x4004,
    	///
	    LIGHT5 = 0x4005,
    	///
	    LIGHT6 = 0x4006,
    	///
	    LIGHT7 = 0x4007,
    	///
	    LIGHTING = 0x0B50,
    	///
	    LIGHT_ENV_MODE_SGIX = 0x8407,
    	///
	    LIGHT_MODEL_AMBIENT = 0x0B53,
    	///
	    LIGHT_MODEL_COLOR_CONTROL = 0x81F8,
    	///
	    LIGHT_MODEL_LOCAL_VIEWER = 0x0B51,
    	///
	    LIGHT_MODEL_TWO_SIDE = 0x0B52,
    	///
	    LINE_SMOOTH = 0x0B20,
    	///
	    LINE_SMOOTH_HINT = 0x0C52,
    	///
	    LINE_STIPPLE = 0x0B24,
    	///
	    LINE_STIPPLE_PATTERN = 0x0B25,
    	///
	    LINE_STIPPLE_REPEAT = 0x0B26,
    	///
	    LINE_WIDTH = 0x0B21,
    	///
	    LINE_WIDTH_GRANULARITY = 0x0B23,
    	///
	    LINE_WIDTH_RANGE = 0x0B22,
    	///
	    LIST_BASE = 0x0B32,
    	///
	    LIST_INDEX = 0x0B33,
    	///
	    LIST_MODE = 0x0B30,
    	///
	    LOGIC_OP = 0x0BF1,
    	///
	    LOGIC_OP_MODE = 0x0BF0,
    	///
	    MAP1_COLOR_4 = 0x0D90,
    	///
	    MAP1_GRID_DOMAIN = 0x0DD0,
    	///
	    MAP1_GRID_SEGMENTS = 0x0DD1,
    	///
	    MAP1_INDEX = 0x0D91,
    	///
	    MAP1_NORMAL = 0x0D92,
    	///
	    MAP1_TEXTURE_COORD_1 = 0x0D93,
    	///
	    MAP1_TEXTURE_COORD_2 = 0x0D94,
    	///
	    MAP1_TEXTURE_COORD_3 = 0x0D95,
    	///
	    MAP1_TEXTURE_COORD_4 = 0x0D96,
    	///
	    MAP1_VERTEX_3 = 0x0D97,
    	///
	    MAP1_VERTEX_4 = 0x0D98,
    	///
	    MAP2_COLOR_4 = 0x0DB0,
    	///
	    MAP2_GRID_DOMAIN = 0x0DD2,
    	///
	    MAP2_GRID_SEGMENTS = 0x0DD3,
    	///
	    MAP2_INDEX = 0x0DB1,
    	///
	    MAP2_NORMAL = 0x0DB2,
    	///
	    MAP2_TEXTURE_COORD_1 = 0x0DB3,
    	///
	    MAP2_TEXTURE_COORD_2 = 0x0DB4,
    	///
	    MAP2_TEXTURE_COORD_3 = 0x0DB5,
    	///
	    MAP2_TEXTURE_COORD_4 = 0x0DB6,
    	///
	    MAP2_VERTEX_3 = 0x0DB7,
    	///
	    MAP2_VERTEX_4 = 0x0DB8,
    	///
	    MAP_COLOR = 0x0D10,
    	///
	    MAP_STENCIL = 0x0D11,
    	///
	    MATRIX_MODE = 0x0BA0,
    	///
	    MAX_3D_TEXTURE_SIZE_EXT = 0x8073,
    	///
	    MAX_4D_TEXTURE_SIZE_SGIS = 0x8138,
    	///
	    MAX_ACTIVE_LIGHTS_SGIX = 0x8405,
    	///
	    MAX_ASYNC_DRAW_PIXELS_SGIX = 0x8360,
    	///
	    MAX_ASYNC_HISTOGRAM_SGIX = 0x832D,
    	///
	    MAX_ASYNC_READ_PIXELS_SGIX = 0x8361,
    	///
	    MAX_ASYNC_TEX_IMAGE_SGIX = 0x835F,
    	///
	    MAX_ATTRIB_STACK_DEPTH = 0x0D35,
    	///
	    MAX_CLIENT_ATTRIB_STACK_DEPTH = 0x0D3B,
    	///
	    MAX_CLIPMAP_DEPTH_SGIX = 0x8177,
    	///
	    MAX_CLIPMAP_VIRTUAL_DEPTH_SGIX = 0x8178,
    	///
	    MAX_CLIP_DISTANCES = 0x0D32,
    	///
	    MAX_CLIP_PLANES = 0x0D32,
    	///
	    MAX_COLOR_MATRIX_STACK_DEPTH_SGI = 0x80B3,
    	///
	    MAX_EVAL_ORDER = 0x0D30,
    	///
	    MAX_FOG_FUNC_POINTS_SGIS = 0x812C,
    	///
	    MAX_FRAGMENT_LIGHTS_SGIX = 0x8404,
    	///
	    MAX_FRAMEZOOM_FACTOR_SGIX = 0x818D,
    	///
	    MAX_LIGHTS = 0x0D31,
    	///
	    MAX_LIST_NESTING = 0x0B31,
    	///
	    MAX_MODELVIEW_STACK_DEPTH = 0x0D36,
    	///
	    MAX_NAME_STACK_DEPTH = 0x0D37,
    	///
	    MAX_PIXEL_MAP_TABLE = 0x0D34,
    	///
	    MAX_PROJECTION_STACK_DEPTH = 0x0D38,
    	///
	    MAX_TEXTURE_SIZE = 0x0D33,
    	///
	    MAX_TEXTURE_STACK_DEPTH = 0x0D39,
    	///
	    MAX_VIEWPORT_DIMS = 0x0D3A,
    	///
	    MINMAX_EXT = 0x802E,
    	///
	    MODELVIEW0_MATRIX_EXT = 0x0BA6,
    	///
	    MODELVIEW0_STACK_DEPTH_EXT = 0x0BA3,
    	///
	    MODELVIEW_MATRIX = 0x0BA6,
    	///
	    MODELVIEW_STACK_DEPTH = 0x0BA3,
    	///
	    MULTISAMPLE_SGIS = 0x809D,
    	///
	    NAME_STACK_DEPTH = 0x0D70,
    	///
	    NORMALIZE = 0x0BA1,
    	///
	    NORMAL_ARRAY = 0x8075,
    	///
	    NORMAL_ARRAY_COUNT_EXT = 0x8080,
    	///
	    NORMAL_ARRAY_STRIDE = 0x807F,
    	///
	    NORMAL_ARRAY_TYPE = 0x807E,
    	///
	    PACK_ALIGNMENT = 0x0D05,
    	///
	    PACK_CMYK_HINT_EXT = 0x800E,
    	///
	    PACK_IMAGE_DEPTH_SGIS = 0x8131,
    	///
	    PACK_IMAGE_HEIGHT_EXT = 0x806C,
    	///
	    PACK_LSB_FIRST = 0x0D01,
    	///
	    PACK_RESAMPLE_SGIX = 0x842E,
    	///
	    PACK_ROW_LENGTH = 0x0D02,
    	///
	    PACK_SKIP_IMAGES_EXT = 0x806B,
    	///
	    PACK_SKIP_PIXELS = 0x0D04,
    	///
	    PACK_SKIP_ROWS = 0x0D03,
    	///
	    PACK_SKIP_VOLUMES_SGIS = 0x8130,
    	///
	    PACK_SUBSAMPLE_RATE_SGIX = 0x85A0,
    	///
	    PACK_SWAP_BYTES = 0x0D00,
    	///
	    PERSPECTIVE_CORRECTION_HINT = 0x0C50,
    	///
	    PIXEL_MAP_A_TO_A_SIZE = 0x0CB9,
    	///
	    PIXEL_MAP_B_TO_B_SIZE = 0x0CB8,
    	///
	    PIXEL_MAP_G_TO_G_SIZE = 0x0CB7,
    	///
	    PIXEL_MAP_I_TO_A_SIZE = 0x0CB5,
    	///
	    PIXEL_MAP_I_TO_B_SIZE = 0x0CB4,
    	///
	    PIXEL_MAP_I_TO_G_SIZE = 0x0CB3,
    	///
	    PIXEL_MAP_I_TO_I_SIZE = 0x0CB0,
    	///
	    PIXEL_MAP_I_TO_R_SIZE = 0x0CB2,
    	///
	    PIXEL_MAP_R_TO_R_SIZE = 0x0CB6,
    	///
	    PIXEL_MAP_S_TO_S_SIZE = 0x0CB1,
    	///
	    PIXEL_TEXTURE_SGIS = 0x8353,
    	///
	    PIXEL_TEX_GEN_MODE_SGIX = 0x832B,
    	///
	    PIXEL_TEX_GEN_SGIX = 0x8139,
    	///
	    PIXEL_TILE_BEST_ALIGNMENT_SGIX = 0x813E,
    	///
	    PIXEL_TILE_CACHE_INCREMENT_SGIX = 0x813F,
    	///
	    PIXEL_TILE_CACHE_SIZE_SGIX = 0x8145,
    	///
	    PIXEL_TILE_GRID_DEPTH_SGIX = 0x8144,
    	///
	    PIXEL_TILE_GRID_HEIGHT_SGIX = 0x8143,
    	///
	    PIXEL_TILE_GRID_WIDTH_SGIX = 0x8142,
    	///
	    PIXEL_TILE_HEIGHT_SGIX = 0x8141,
    	///
	    PIXEL_TILE_WIDTH_SGIX = 0x8140,
    	///
	    POINT_FADE_THRESHOLD_SIZE_SGIS = 0x8128,
    	///
	    POINT_SIZE = 0x0B11,
    	///
	    POINT_SIZE_GRANULARITY = 0x0B13,
    	///
	    POINT_SIZE_MAX_SGIS = 0x8127,
    	///
	    POINT_SIZE_MIN_SGIS = 0x8126,
    	///
	    POINT_SIZE_RANGE = 0x0B12,
    	///
	    POINT_SMOOTH = 0x0B10,
    	///
	    POINT_SMOOTH_HINT = 0x0C51,
    	///
	    POLYGON_MODE = 0x0B40,
    	///
	    POLYGON_OFFSET_BIAS_EXT = 0x8039,
    	///
	    POLYGON_OFFSET_FACTOR = 0x8038,
    	///
	    POLYGON_OFFSET_FILL = 0x8037,
    	///
	    POLYGON_OFFSET_LINE = 0x2A02,
    	///
	    POLYGON_OFFSET_POINT = 0x2A01,
    	///
	    POLYGON_OFFSET_UNITS = 0x2A00,
    	///
	    POLYGON_SMOOTH = 0x0B41,
    	///
	    POLYGON_SMOOTH_HINT = 0x0C53,
    	///
	    POLYGON_STIPPLE = 0x0B42,
    	///
	    POST_COLOR_MATRIX_ALPHA_BIAS_SGI = 0x80BB,
    	///
	    POST_COLOR_MATRIX_ALPHA_SCALE_SGI = 0x80B7,
    	///
	    POST_COLOR_MATRIX_BLUE_BIAS_SGI = 0x80BA,
    	///
	    POST_COLOR_MATRIX_BLUE_SCALE_SGI = 0x80B6,
    	///
	    POST_COLOR_MATRIX_COLOR_TABLE_SGI = 0x80D2,
    	///
	    POST_COLOR_MATRIX_GREEN_BIAS_SGI = 0x80B9,
    	///
	    POST_COLOR_MATRIX_GREEN_SCALE_SGI = 0x80B5,
    	///
	    POST_COLOR_MATRIX_RED_BIAS_SGI = 0x80B8,
    	///
	    POST_COLOR_MATRIX_RED_SCALE_SGI = 0x80B4,
    	///
	    POST_CONVOLUTION_ALPHA_BIAS_EXT = 0x8023,
    	///
	    POST_CONVOLUTION_ALPHA_SCALE_EXT = 0x801F,
    	///
	    POST_CONVOLUTION_BLUE_BIAS_EXT = 0x8022,
    	///
	    POST_CONVOLUTION_BLUE_SCALE_EXT = 0x801E,
    	///
	    POST_CONVOLUTION_COLOR_TABLE_SGI = 0x80D1,
    	///
	    POST_CONVOLUTION_GREEN_BIAS_EXT = 0x8021,
    	///
	    POST_CONVOLUTION_GREEN_SCALE_EXT = 0x801D,
    	///
	    POST_CONVOLUTION_RED_BIAS_EXT = 0x8020,
    	///
	    POST_CONVOLUTION_RED_SCALE_EXT = 0x801C,
    	///
	    POST_TEXTURE_FILTER_BIAS_RANGE_SGIX = 0x817B,
    	///
	    POST_TEXTURE_FILTER_SCALE_RANGE_SGIX = 0x817C,
    	///
	    PROJECTION_MATRIX = 0x0BA7,
    	///
	    PROJECTION_STACK_DEPTH = 0x0BA4,
    	///
	    READ_BUFFER = 0x0C02,
    	///
	    READ_BUFFER_EXT = 0x0C02,
    	///
	    READ_BUFFER_NV = 0x0C02,
    	///
	    RED_BIAS = 0x0D15,
    	///
	    RED_BITS = 0x0D52,
    	///
	    RED_SCALE = 0x0D14,
    	///
	    REFERENCE_PLANE_EQUATION_SGIX = 0x817E,
    	///
	    REFERENCE_PLANE_SGIX = 0x817D,
    	///
	    RENDER_MODE = 0x0C40,
    	///
	    RESCALE_NORMAL_EXT = 0x803A,
    	///
	    RGBA_MODE = 0x0C31,
    	///
	    SAMPLES_SGIS = 0x80A9,
    	///
	    SAMPLE_ALPHA_TO_MASK_SGIS = 0x809E,
    	///
	    SAMPLE_ALPHA_TO_ONE_SGIS = 0x809F,
    	///
	    SAMPLE_BUFFERS_SGIS = 0x80A8,
    	///
	    SAMPLE_MASK_INVERT_SGIS = 0x80AB,
    	///
	    SAMPLE_MASK_SGIS = 0x80A0,
    	///
	    SAMPLE_MASK_VALUE_SGIS = 0x80AA,
    	///
	    SAMPLE_PATTERN_SGIS = 0x80AC,
    	///
	    SCISSOR_BOX = 0x0C10,
    	///
	    SCISSOR_TEST = 0x0C11,
    	///
	    SELECTION_BUFFER_SIZE = 0x0DF4,
    	///
	    SEPARABLE_2D_EXT = 0x8012,
    	///
	    SHADE_MODEL = 0x0B54,
    	///
	    SHARED_TEXTURE_PALETTE_EXT = 0x81FB,
    	///
	    SMOOTH_LINE_WIDTH_GRANULARITY = 0x0B23,
    	///
	    SMOOTH_LINE_WIDTH_RANGE = 0x0B22,
    	///
	    SMOOTH_POINT_SIZE_GRANULARITY = 0x0B13,
    	///
	    SMOOTH_POINT_SIZE_RANGE = 0x0B12,
    	///
	    SPRITE_AXIS_SGIX = 0x814A,
    	///
	    SPRITE_MODE_SGIX = 0x8149,
    	///
	    SPRITE_SGIX = 0x8148,
    	///
	    SPRITE_TRANSLATION_SGIX = 0x814B,
    	///
	    STENCIL_BITS = 0x0D57,
    	///
	    STENCIL_CLEAR_VALUE = 0x0B91,
    	///
	    STENCIL_FAIL = 0x0B94,
    	///
	    STENCIL_FUNC = 0x0B92,
    	///
	    STENCIL_PASS_DEPTH_FAIL = 0x0B95,
    	///
	    STENCIL_PASS_DEPTH_PASS = 0x0B96,
    	///
	    STENCIL_REF = 0x0B97,
    	///
	    STENCIL_TEST = 0x0B90,
    	///
	    STENCIL_VALUE_MASK = 0x0B93,
    	///
	    STENCIL_WRITEMASK = 0x0B98,
    	///
	    STEREO = 0x0C33,
    	///
	    SUBPIXEL_BITS = 0x0D50,
    	///
	    TEXTURE_1D = 0x0DE0,
    	///
	    TEXTURE_2D = 0x0DE1,
    	///
	    TEXTURE_3D_BINDING_EXT = 0x806A,
    	///
	    TEXTURE_3D_EXT = 0x806F,
    	///
	    TEXTURE_4D_BINDING_SGIS = 0x814F,
    	///
	    TEXTURE_4D_SGIS = 0x8134,
    	///
	    TEXTURE_BINDING_1D = 0x8068,
    	///
	    TEXTURE_BINDING_2D = 0x8069,
    	///
	    TEXTURE_BINDING_3D = 0x806A,
    	///
	    TEXTURE_COLOR_TABLE_SGI = 0x80BC,
    	///
	    TEXTURE_COORD_ARRAY = 0x8078,
    	///
	    TEXTURE_COORD_ARRAY_COUNT_EXT = 0x808B,
    	///
	    TEXTURE_COORD_ARRAY_SIZE = 0x8088,
    	///
	    TEXTURE_COORD_ARRAY_STRIDE = 0x808A,
    	///
	    TEXTURE_COORD_ARRAY_TYPE = 0x8089,
    	///
	    TEXTURE_GEN_Q = 0x0C63,
    	///
	    TEXTURE_GEN_R = 0x0C62,
    	///
	    TEXTURE_GEN_S = 0x0C60,
    	///
	    TEXTURE_GEN_T = 0x0C61,
    	///
	    TEXTURE_MATRIX = 0x0BA8,
    	///
	    TEXTURE_STACK_DEPTH = 0x0BA5,
    	///
	    UNPACK_ALIGNMENT = 0x0CF5,
    	///
	    UNPACK_CMYK_HINT_EXT = 0x800F,
    	///
	    UNPACK_IMAGE_DEPTH_SGIS = 0x8133,
    	///
	    UNPACK_IMAGE_HEIGHT_EXT = 0x806E,
    	///
	    UNPACK_LSB_FIRST = 0x0CF1,
    	///
	    UNPACK_RESAMPLE_SGIX = 0x842F,
    	///
	    UNPACK_ROW_LENGTH = 0x0CF2,
    	///
	    UNPACK_SKIP_IMAGES_EXT = 0x806D,
    	///
	    UNPACK_SKIP_PIXELS = 0x0CF4,
    	///
	    UNPACK_SKIP_ROWS = 0x0CF3,
    	///
	    UNPACK_SKIP_VOLUMES_SGIS = 0x8132,
    	///
	    UNPACK_SUBSAMPLE_RATE_SGIX = 0x85A1,
    	///
	    UNPACK_SWAP_BYTES = 0x0CF0,
    	///
	    VERTEX_ARRAY = 0x8074,
    	///
	    VERTEX_ARRAY_COUNT_EXT = 0x807D,
    	///
	    VERTEX_ARRAY_SIZE = 0x807A,
    	///
	    VERTEX_ARRAY_STRIDE = 0x807C,
    	///
	    VERTEX_ARRAY_TYPE = 0x807B,
    	///
	    VERTEX_PRECLIP_HINT_SGIX = 0x83EF,
    	///
	    VERTEX_PRECLIP_SGIX = 0x83EE,
    	///
	    VIEWPORT = 0x0BA2,
    	///
	    ZOOM_X = 0x0D16,
    	///
	    ZOOM_Y = 0x0D17
	}

	///
	enum GetPointervPName {
    	///
	    COLOR_ARRAY_POINTER = 0x8090,
    	///
	    COLOR_ARRAY_POINTER_EXT = 0x8090,
    	///
	    EDGE_FLAG_ARRAY_POINTER = 0x8093,
    	///
	    EDGE_FLAG_ARRAY_POINTER_EXT = 0x8093,
    	///
	    FEEDBACK_BUFFER_POINTER = 0x0DF0,
    	///
	    INDEX_ARRAY_POINTER = 0x8091,
    	///
	    INDEX_ARRAY_POINTER_EXT = 0x8091,
    	///
	    INSTRUMENT_BUFFER_POINTER_SGIX = 0x8180,
    	///
	    NORMAL_ARRAY_POINTER = 0x808F,
    	///
	    NORMAL_ARRAY_POINTER_EXT = 0x808F,
    	///
	    SELECTION_BUFFER_POINTER = 0x0DF3,
    	///
	    TEXTURE_COORD_ARRAY_POINTER = 0x8092,
    	///
	    TEXTURE_COORD_ARRAY_POINTER_EXT = 0x8092,
    	///
	    VERTEX_ARRAY_POINTER = 0x808E,
    	///
	    VERTEX_ARRAY_POINTER_EXT = 0x808E
	}

	///
	enum GetTextureParameter {
    	///
	    DETAIL_TEXTURE_FUNC_POINTS_SGIS = 0x809C,
    	///
	    DETAIL_TEXTURE_LEVEL_SGIS = 0x809A,
    	///
	    DETAIL_TEXTURE_MODE_SGIS = 0x809B,
    	///
	    DUAL_TEXTURE_SELECT_SGIS = 0x8124,
    	///
	    GENERATE_MIPMAP_SGIS = 0x8191,
    	///
	    POST_TEXTURE_FILTER_BIAS_SGIX = 0x8179,
    	///
	    POST_TEXTURE_FILTER_SCALE_SGIX = 0x817A,
    	///
	    QUAD_TEXTURE_SELECT_SGIS = 0x8125,
    	///
	    SHADOW_AMBIENT_SGIX = 0x80BF,
    	///
	    SHARPEN_TEXTURE_FUNC_POINTS_SGIS = 0x80B0,
    	///
	    TEXTURE_4DSIZE_SGIS = 0x8136,
    	///
	    TEXTURE_ALPHA_SIZE = 0x805F,
    	///
	    TEXTURE_BASE_LEVEL_SGIS = 0x813C,
    	///
	    TEXTURE_BLUE_SIZE = 0x805E,
    	///
	    TEXTURE_BORDER = 0x1005,
    	///
	    TEXTURE_BORDER_COLOR = 0x1004,
    	///
	    TEXTURE_BORDER_COLOR_NV = 0x1004,
    	///
	    TEXTURE_CLIPMAP_CENTER_SGIX = 0x8171,
    	///
	    TEXTURE_CLIPMAP_DEPTH_SGIX = 0x8176,
    	///
	    TEXTURE_CLIPMAP_FRAME_SGIX = 0x8172,
    	///
	    TEXTURE_CLIPMAP_LOD_OFFSET_SGIX = 0x8175,
    	///
	    TEXTURE_CLIPMAP_OFFSET_SGIX = 0x8173,
    	///
	    TEXTURE_CLIPMAP_VIRTUAL_DEPTH_SGIX = 0x8174,
    	///
	    TEXTURE_COMPARE_OPERATOR_SGIX = 0x819B,
    	///
	    TEXTURE_COMPARE_SGIX = 0x819A,
    	///
	    TEXTURE_COMPONENTS = 0x1003,
    	///
	    TEXTURE_DEPTH_EXT = 0x8071,
    	///
	    TEXTURE_FILTER4_SIZE_SGIS = 0x8147,
    	///
	    TEXTURE_GEQUAL_R_SGIX = 0x819D,
    	///
	    TEXTURE_GREEN_SIZE = 0x805D,
    	///
	    TEXTURE_HEIGHT = 0x1001,
    	///
	    TEXTURE_INTENSITY_SIZE = 0x8061,
    	///
	    TEXTURE_INTERNAL_FORMAT = 0x1003,
    	///
	    TEXTURE_LEQUAL_R_SGIX = 0x819C,
    	///
	    TEXTURE_LOD_BIAS_R_SGIX = 0x8190,
    	///
	    TEXTURE_LOD_BIAS_S_SGIX = 0x818E,
    	///
	    TEXTURE_LOD_BIAS_T_SGIX = 0x818F,
    	///
	    TEXTURE_LUMINANCE_SIZE = 0x8060,
    	///
	    TEXTURE_MAG_FILTER = 0x2800,
    	///
	    TEXTURE_MAX_CLAMP_R_SGIX = 0x836B,
    	///
	    TEXTURE_MAX_CLAMP_S_SGIX = 0x8369,
    	///
	    TEXTURE_MAX_CLAMP_T_SGIX = 0x836A,
    	///
	    TEXTURE_MAX_LEVEL_SGIS = 0x813D,
    	///
	    TEXTURE_MAX_LOD_SGIS = 0x813B,
    	///
	    TEXTURE_MIN_FILTER = 0x2801,
    	///
	    TEXTURE_MIN_LOD_SGIS = 0x813A,
    	///
	    TEXTURE_PRIORITY = 0x8066,
    	///
	    TEXTURE_RED_SIZE = 0x805C,
    	///
	    TEXTURE_RESIDENT = 0x8067,
    	///
	    TEXTURE_WIDTH = 0x1000,
    	///
	    TEXTURE_WRAP_Q_SGIS = 0x8137,
    	///
	    TEXTURE_WRAP_R_EXT = 0x8072,
    	///
	    TEXTURE_WRAP_S = 0x2802,
    	///
	    TEXTURE_WRAP_T = 0x2803
	}

	///
	enum HintMode {
    	///
	    DONT_CARE = 0x1100,
    	///
	    FASTEST = 0x1101,
    	///
	    NICEST = 0x1102
	}

	///
	enum HintTarget {
    	///
	    ALLOW_DRAW_FRG_HINT_PGI = 0x1A210,
    	///
	    ALLOW_DRAW_MEM_HINT_PGI = 0x1A211,
    	///
	    ALLOW_DRAW_OBJ_HINT_PGI = 0x1A20E,
    	///
	    ALLOW_DRAW_WIN_HINT_PGI = 0x1A20F,
    	///
	    ALWAYS_FAST_HINT_PGI = 0x1A20C,
    	///
	    ALWAYS_SOFT_HINT_PGI = 0x1A20D,
    	///
	    BACK_NORMALS_HINT_PGI = 0x1A223,
    	///
	    BINNING_CONTROL_HINT_QCOM = 0x8FB0,
    	///
	    CLIP_FAR_HINT_PGI = 0x1A221,
    	///
	    CLIP_NEAR_HINT_PGI = 0x1A220,
    	///
	    CLIP_VOLUME_CLIPPING_HINT_EXT = 0x80F0,
    	///
	    CONSERVE_MEMORY_HINT_PGI = 0x1A1FD,
    	///
	    CONVOLUTION_HINT_SGIX = 0x8316,
    	///
	    FOG_HINT = 0x0C54,
    	///
	    FRAGMENT_SHADER_DERIVATIVE_HINT = 0x8B8B,
    	///
	    FRAGMENT_SHADER_DERIVATIVE_HINT_ARB = 0x8B8B,
    	///
	    FRAGMENT_SHADER_DERIVATIVE_HINT_OES = 0x8B8B,
    	///
	    FULL_STIPPLE_HINT_PGI = 0x1A219,
    	///
	    GENERATE_MIPMAP_HINT = 0x8192,
    	///
	    GENERATE_MIPMAP_HINT_SGIS = 0x8192,
    	///
	    LINE_QUALITY_HINT_SGIX = 0x835B,
    	///
	    LINE_SMOOTH_HINT = 0x0C52,
    	///
	    MATERIAL_SIDE_HINT_PGI = 0x1A22C,
    	///
	    MAX_VERTEX_HINT_PGI = 0x1A22D,
    	///
	    MULTISAMPLE_FILTER_HINT_NV = 0x8534,
    	///
	    NATIVE_GRAPHICS_BEGIN_HINT_PGI = 0x1A203,
    	///
	    NATIVE_GRAPHICS_END_HINT_PGI = 0x1A204,
    	///
	    PACK_CMYK_HINT_EXT = 0x800E,
    	///
	    PERSPECTIVE_CORRECTION_HINT = 0x0C50,
    	///
	    PHONG_HINT_WIN = 0x80EB,
    	///
	    POINT_SMOOTH_HINT = 0x0C51,
    	///
	    POLYGON_SMOOTH_HINT = 0x0C53,
    	///
	    PREFER_DOUBLEBUFFER_HINT_PGI = 0x1A1F8,
    	///
	    PROGRAM_BINARY_RETRIEVABLE_HINT = 0x8257,
    	///
	    RECLAIM_MEMORY_HINT_PGI = 0x1A1FE,
    	///
	    SCALEBIAS_HINT_SGIX = 0x8322,
    	///
	    STRICT_DEPTHFUNC_HINT_PGI = 0x1A216,
    	///
	    STRICT_LIGHTING_HINT_PGI = 0x1A217,
    	///
	    STRICT_SCISSOR_HINT_PGI = 0x1A218,
    	///
	    TEXTURE_COMPRESSION_HINT = 0x84EF,
    	///
	    TEXTURE_COMPRESSION_HINT_ARB = 0x84EF,
    	///
	    TEXTURE_MULTI_BUFFER_HINT_SGIX = 0x812E,
    	///
	    TEXTURE_STORAGE_HINT_APPLE = 0x85BC,
    	///
	    TRANSFORM_HINT_APPLE = 0x85B1,
    	///
	    UNPACK_CMYK_HINT_EXT = 0x800F,
    	///
	    VERTEX_ARRAY_STORAGE_HINT_APPLE = 0x851F,
    	///
	    VERTEX_CONSISTENT_HINT_PGI = 0x1A22B,
    	///
	    VERTEX_DATA_HINT_PGI = 0x1A22A,
    	///
	    VERTEX_PRECLIP_HINT_SGIX = 0x83EF,
    	///
	    VERTEX_PRECLIP_SGIX = 0x83EE,
    	///
	    WIDE_LINE_HINT_PGI = 0x1A222
	}

	///
	enum HistogramTargetEXT {
    	///
	    HISTOGRAM = 0x8024,
    	///
	    HISTOGRAM_EXT = 0x8024,
    	///
	    PROXY_HISTOGRAM = 0x8025,
    	///
	    PROXY_HISTOGRAM_EXT = 0x8025
	}

	///
	enum IndexPointerType {
    	///
	    DOUBLE = 0x140A,
    	///
	    FLOAT = 0x1406,
    	///
	    INT = 0x1404,
    	///
	    SHORT = 0x1402
	}

	///
	enum InterleavedArrayFormat {
    	///
	    C3F_V3F = 0x2A24,
    	///
	    C4F_N3F_V3F = 0x2A26,
    	///
	    C4UB_V2F = 0x2A22,
    	///
	    C4UB_V3F = 0x2A23,
    	///
	    N3F_V3F = 0x2A25,
    	///
	    T2F_C3F_V3F = 0x2A2A,
    	///
	    T2F_C4F_N3F_V3F = 0x2A2C,
    	///
	    T2F_C4UB_V3F = 0x2A29,
    	///
	    T2F_N3F_V3F = 0x2A2B,
    	///
	    T2F_V3F = 0x2A27,
    	///
	    T4F_C4F_N3F_V4F = 0x2A2D,
    	///
	    T4F_V4F = 0x2A28,
    	///
	    V2F = 0x2A20,
    	///
	    V3F = 0x2A21
	}

	///
	enum LightEnvModeSGIX {
    	///
	    ADD = 0x0104,
    	///
	    MODULATE = 0x2100,
    	///
	    REPLACE = 0x1E01
	}

	///
	enum LightEnvParameterSGIX {
    	///
	    LIGHT_ENV_MODE_SGIX = 0x8407
	}

	///
	enum LightModelColorControl {
    	///
	    SEPARATE_SPECULAR_COLOR = 0x81FA,
    	///
	    SEPARATE_SPECULAR_COLOR_EXT = 0x81FA,
    	///
	    SINGLE_COLOR = 0x81F9,
    	///
	    SINGLE_COLOR_EXT = 0x81F9
	}

	///
	enum LightModelParameter {
    	///
	    LIGHT_MODEL_AMBIENT = 0x0B53,
    	///
	    LIGHT_MODEL_COLOR_CONTROL = 0x81F8,
    	///
	    LIGHT_MODEL_COLOR_CONTROL_EXT = 0x81F8,
    	///
	    LIGHT_MODEL_LOCAL_VIEWER = 0x0B51,
    	///
	    LIGHT_MODEL_TWO_SIDE = 0x0B52
	}

	///
	enum LightName {
    	///
	    FRAGMENT_LIGHT0_SGIX = 0x840C,
    	///
	    FRAGMENT_LIGHT1_SGIX = 0x840D,
    	///
	    FRAGMENT_LIGHT2_SGIX = 0x840E,
    	///
	    FRAGMENT_LIGHT3_SGIX = 0x840F,
    	///
	    FRAGMENT_LIGHT4_SGIX = 0x8410,
    	///
	    FRAGMENT_LIGHT5_SGIX = 0x8411,
    	///
	    FRAGMENT_LIGHT6_SGIX = 0x8412,
    	///
	    FRAGMENT_LIGHT7_SGIX = 0x8413,
    	///
	    LIGHT0 = 0x4000,
    	///
	    LIGHT1 = 0x4001,
    	///
	    LIGHT2 = 0x4002,
    	///
	    LIGHT3 = 0x4003,
    	///
	    LIGHT4 = 0x4004,
    	///
	    LIGHT5 = 0x4005,
    	///
	    LIGHT6 = 0x4006,
    	///
	    LIGHT7 = 0x4007
	}

	///
	enum LightParameter {
    	///
	    AMBIENT = 0x1200,
    	///
	    CONSTANT_ATTENUATION = 0x1207,
    	///
	    DIFFUSE = 0x1201,
    	///
	    LINEAR_ATTENUATION = 0x1208,
    	///
	    POSITION = 0x1203,
    	///
	    QUADRATIC_ATTENUATION = 0x1209,
    	///
	    SPECULAR = 0x1202,
    	///
	    SPOT_CUTOFF = 0x1206,
    	///
	    SPOT_DIRECTION = 0x1204,
    	///
	    SPOT_EXPONENT = 0x1205
	}

	///
	enum ListMode {
    	///
	    COMPILE = 0x1300,
    	///
	    COMPILE_AND_EXECUTE = 0x1301
	}

	///
	enum ListNameType {
    	///
	    BYTES_2 = 0x1407,
    	///
	    BYTES_3 = 0x1408,
    	///
	    BYTES_4 = 0x1409,
    	///
	    BYTE = 0x1400,
    	///
	    FLOAT = 0x1406,
    	///
	    INT = 0x1404,
    	///
	    SHORT = 0x1402,
    	///
	    UNSIGNED_BYTE = 0x1401,
    	///
	    UNSIGNED_INT = 0x1405,
    	///
	    UNSIGNED_SHORT = 0x1403
	}

	///
	enum ListParameterName {
    	///
	    LIST_PRIORITY_SGIX = 0x8182
	}

	///
	enum LogicOp {
    	///
	    AND = 0x1501,
    	///
	    AND_INVERTED = 0x1504,
    	///
	    AND_REVERSE = 0x1502,
    	///
	    CLEAR = 0x1500,
    	///
	    COPY = 0x1503,
    	///
	    COPY_INVERTED = 0x150C,
    	///
	    EQUIV = 0x1509,
    	///
	    INVERT = 0x150A,
    	///
	    NAND = 0x150E,
    	///
	    NOOP = 0x1505,
    	///
	    NOR = 0x1508,
    	///
	    OR = 0x1507,
    	///
	    OR_INVERTED = 0x150D,
    	///
	    OR_REVERSE = 0x150B,
    	///
	    SET = 0x150F,
    	///
	    XOR = 0x1506
	}

	///
	@Bitmaskable
	enum MapBufferUsageMask {
    	///
	    CLIENT_STORAGE_BIT = 0x0200,
    	///
	    DYNAMIC_STORAGE_BIT = 0x0100,
    	///
	    MAP_COHERENT_BIT = 0x0080,
    	///
	    MAP_FLUSH_EXPLICIT_BIT = 0x0010,
    	///
	    MAP_FLUSH_EXPLICIT_BIT_EXT = 0x0010,
    	///
	    MAP_INVALIDATE_BUFFER_BIT = 0x0008,
    	///
	    MAP_INVALIDATE_BUFFER_BIT_EXT = 0x0008,
    	///
	    MAP_INVALIDATE_RANGE_BIT = 0x0004,
    	///
	    MAP_INVALIDATE_RANGE_BIT_EXT = 0x0004,
    	///
	    MAP_PERSISTENT_BIT = 0x0040,
    	///
	    MAP_READ_BIT = 0x0001,
    	///
	    MAP_READ_BIT_EXT = 0x0001,
    	///
	    MAP_UNSYNCHRONIZED_BIT = 0x0020,
    	///
	    MAP_UNSYNCHRONIZED_BIT_EXT = 0x0020,
    	///
	    MAP_WRITE_BIT = 0x0002,
    	///
	    MAP_WRITE_BIT_EXT = 0x0002
	}

	///
	enum MapTarget {
    	///
	    GEOMETRY_DEFORMATION_SGIX = 0x8194,
    	///
	    MAP1_COLOR_4 = 0x0D90,
    	///
	    MAP1_INDEX = 0x0D91,
    	///
	    MAP1_NORMAL = 0x0D92,
    	///
	    MAP1_TEXTURE_COORD_1 = 0x0D93,
    	///
	    MAP1_TEXTURE_COORD_2 = 0x0D94,
    	///
	    MAP1_TEXTURE_COORD_3 = 0x0D95,
    	///
	    MAP1_TEXTURE_COORD_4 = 0x0D96,
    	///
	    MAP1_VERTEX_3 = 0x0D97,
    	///
	    MAP1_VERTEX_4 = 0x0D98,
    	///
	    MAP2_COLOR_4 = 0x0DB0,
    	///
	    MAP2_INDEX = 0x0DB1,
    	///
	    MAP2_NORMAL = 0x0DB2,
    	///
	    MAP2_TEXTURE_COORD_1 = 0x0DB3,
    	///
	    MAP2_TEXTURE_COORD_2 = 0x0DB4,
    	///
	    MAP2_TEXTURE_COORD_3 = 0x0DB5,
    	///
	    MAP2_TEXTURE_COORD_4 = 0x0DB6,
    	///
	    MAP2_VERTEX_3 = 0x0DB7,
    	///
	    MAP2_VERTEX_4 = 0x0DB8,
    	///
	    TEXTURE_DEFORMATION_SGIX = 0x8195
	}

	///
	enum MapTextureFormatINTEL {
    	///
	    LAYOUT_DEFAULT_INTEL = 0,
    	///
	    LAYOUT_LINEAR_CPU_CACHED_INTEL = 2,
    	///
	    LAYOUT_LINEAR_INTEL = 1
	}

	///
	enum MaterialFace {
    	///
	    BACK = 0x0405,
    	///
	    FRONT = 0x0404,
    	///
	    FRONT_AND_BACK = 0x0408
	}

	///
	enum MaterialParameter {
    	///
	    AMBIENT = 0x1200,
    	///
	    AMBIENT_AND_DIFFUSE = 0x1602,
    	///
	    COLOR_INDEXES = 0x1603,
    	///
	    DIFFUSE = 0x1201,
    	///
	    EMISSION = 0x1600,
    	///
	    SHININESS = 0x1601,
    	///
	    SPECULAR = 0x1202
	}

	///
	enum MatrixMode {
    	///
	    MODELVIEW = 0x1700,
    	///
	    MODELVIEW0_EXT = 0x1700,
    	///
	    PROJECTION = 0x1701,
    	///
	    TEXTURE = 0x1702
	}

	///
	@Bitmaskable
	enum MemoryBarrierMask {
    	///
	    ALL_BARRIER_BITS = 0xFFFFFFFF,
    	///
	    ALL_BARRIER_BITS_EXT = 0xFFFFFFFF,
    	///
	    ATOMIC_COUNTER_BARRIER_BIT = 0x00001000,
    	///
	    ATOMIC_COUNTER_BARRIER_BIT_EXT = 0x00001000,
    	///
	    BUFFER_UPDATE_BARRIER_BIT = 0x00000200,
    	///
	    BUFFER_UPDATE_BARRIER_BIT_EXT = 0x00000200,
    	///
	    CLIENT_MAPPED_BUFFER_BARRIER_BIT = 0x00004000,
    	///
	    COMMAND_BARRIER_BIT = 0x00000040,
    	///
	    COMMAND_BARRIER_BIT_EXT = 0x00000040,
    	///
	    ELEMENT_ARRAY_BARRIER_BIT = 0x00000002,
    	///
	    ELEMENT_ARRAY_BARRIER_BIT_EXT = 0x00000002,
    	///
	    FRAMEBUFFER_BARRIER_BIT = 0x00000400,
    	///
	    FRAMEBUFFER_BARRIER_BIT_EXT = 0x00000400,
    	///
	    PIXEL_BUFFER_BARRIER_BIT = 0x00000080,
    	///
	    PIXEL_BUFFER_BARRIER_BIT_EXT = 0x00000080,
    	///
	    QUERY_BUFFER_BARRIER_BIT = 0x00008000,
    	///
	    SHADER_GLOBAL_ACCESS_BARRIER_BIT_NV = 0x00000010,
    	///
	    SHADER_IMAGE_ACCESS_BARRIER_BIT = 0x00000020,
    	///
	    SHADER_IMAGE_ACCESS_BARRIER_BIT_EXT = 0x00000020,
    	///
	    SHADER_STORAGE_BARRIER_BIT = 0x00002000,
    	///
	    TEXTURE_FETCH_BARRIER_BIT = 0x00000008,
    	///
	    TEXTURE_FETCH_BARRIER_BIT_EXT = 0x00000008,
    	///
	    TEXTURE_UPDATE_BARRIER_BIT = 0x00000100,
    	///
	    TEXTURE_UPDATE_BARRIER_BIT_EXT = 0x00000100,
    	///
	    TRANSFORM_FEEDBACK_BARRIER_BIT = 0x00000800,
    	///
	    TRANSFORM_FEEDBACK_BARRIER_BIT_EXT = 0x00000800,
    	///
	    UNIFORM_BARRIER_BIT = 0x00000004,
    	///
	    UNIFORM_BARRIER_BIT_EXT = 0x00000004,
    	///
	    VERTEX_ATTRIB_ARRAY_BARRIER_BIT = 0x00000001,
    	///
	    VERTEX_ATTRIB_ARRAY_BARRIER_BIT_EXT = 0x00000001
	}

	///
	enum MeshMode1 {
    	///
	    LINE = 0x1B01,
    	///
	    POINT = 0x1B00
	}

	///
	enum MeshMode2 {
    	///
	    FILL = 0x1B02,
    	///
	    LINE = 0x1B01,
    	///
	    POINT = 0x1B00
	}

	///
	enum MinmaxTargetEXT {
    	///
	    MINMAX = 0x802E,
    	///
	    MINMAX_EXT = 0x802E
	}

	///
	enum NormalPointerType {
    	///
	    BYTE = 0x1400,
    	///
	    DOUBLE = 0x140A,
    	///
	    FLOAT = 0x1406,
    	///
	    INT = 0x1404,
    	///
	    SHORT = 0x1402
	}

	///
	enum PixelCopyType {
    	///
	    COLOR = 0x1800,
    	///
	    COLOR_EXT = 0x1800,
    	///
	    DEPTH = 0x1801,
    	///
	    DEPTH_EXT = 0x1801,
    	///
	    STENCIL = 0x1802,
    	///
	    STENCIL_EXT = 0x1802
	}

	///
	enum PixelFormat {
    	///
	    ABGR_EXT = 0x8000,
    	///
	    ALPHA = 0x1906,
    	///
	    BLUE = 0x1905,
    	///
	    CMYKA_EXT = 0x800D,
    	///
	    CMYK_EXT = 0x800C,
    	///
	    COLOR_INDEX = 0x1900,
    	///
	    DEPTH_COMPONENT = 0x1902,
    	///
	    GREEN = 0x1904,
    	///
	    LUMINANCE = 0x1909,
    	///
	    LUMINANCE_ALPHA = 0x190A,
    	///
	    RED = 0x1903,
    	///
	    RED_EXT = 0x1903,
    	///
	    RGB = 0x1907,
    	///
	    RGBA = 0x1908,
    	///
	    STENCIL_INDEX = 0x1901,
    	///
	    UNSIGNED_INT = 0x1405,
    	///
	    UNSIGNED_SHORT = 0x1403,
    	///
	    YCRCB_422_SGIX = 0x81BB,
    	///
	    YCRCB_444_SGIX = 0x81BC
	}

	///
	enum InternalFormat {
    	///
	    ALPHA12 = 0x803D,
    	///
	    ALPHA16 = 0x803E,
    	///
	    ALPHA4 = 0x803B,
    	///
	    ALPHA8 = 0x803C,
    	///
	    DEPTH_COMPONENT16_SGIX = 0x81A5,
    	///
	    DEPTH_COMPONENT24_SGIX = 0x81A6,
    	///
	    DEPTH_COMPONENT32_SGIX = 0x81A7,
    	///
	    DUAL_ALPHA12_SGIS = 0x8112,
    	///
	    DUAL_ALPHA16_SGIS = 0x8113,
    	///
	    DUAL_ALPHA4_SGIS = 0x8110,
    	///
	    DUAL_ALPHA8_SGIS = 0x8111,
    	///
	    DUAL_INTENSITY12_SGIS = 0x811A,
    	///
	    DUAL_INTENSITY16_SGIS = 0x811B,
    	///
	    DUAL_INTENSITY4_SGIS = 0x8118,
    	///
	    DUAL_INTENSITY8_SGIS = 0x8119,
    	///
	    DUAL_LUMINANCE12_SGIS = 0x8116,
    	///
	    DUAL_LUMINANCE16_SGIS = 0x8117,
    	///
	    DUAL_LUMINANCE4_SGIS = 0x8114,
    	///
	    DUAL_LUMINANCE8_SGIS = 0x8115,
    	///
	    DUAL_LUMINANCE_ALPHA4_SGIS = 0x811C,
    	///
	    DUAL_LUMINANCE_ALPHA8_SGIS = 0x811D,
    	///
	    INTENSITY = 0x8049,
    	///
	    INTENSITY12 = 0x804C,
    	///
	    INTENSITY16 = 0x804D,
    	///
	    INTENSITY4 = 0x804A,
    	///
	    INTENSITY8 = 0x804B,
    	///
	    LUMINANCE12 = 0x8041,
    	///
	    LUMINANCE12_ALPHA12 = 0x8047,
    	///
	    LUMINANCE12_ALPHA4 = 0x8046,
    	///
	    LUMINANCE16 = 0x8042,
    	///
	    LUMINANCE16_ALPHA16 = 0x8048,
    	///
	    LUMINANCE4 = 0x803F,
    	///
	    LUMINANCE4_ALPHA4 = 0x8043,
    	///
	    LUMINANCE6_ALPHA2 = 0x8044,
    	///
	    LUMINANCE8 = 0x8040,
    	///
	    LUMINANCE8_ALPHA8 = 0x8045,
    	///
	    QUAD_ALPHA4_SGIS = 0x811E,
    	///
	    QUAD_ALPHA8_SGIS = 0x811F,
    	///
	    QUAD_INTENSITY4_SGIS = 0x8122,
    	///
	    QUAD_INTENSITY8_SGIS = 0x8123,
    	///
	    QUAD_LUMINANCE4_SGIS = 0x8120,
    	///
	    QUAD_LUMINANCE8_SGIS = 0x8121,
    	///
	    R3_G3_B2 = 0x2A10,
    	///
	    RGB10 = 0x8052,
    	///
	    RGB10_A2 = 0x8059,
    	///
	    RGB12 = 0x8053,
    	///
	    RGB16 = 0x8054,
    	///
	    RGB2_EXT = 0x804E,
    	///
	    RGB4 = 0x804F,
    	///
	    RGB5 = 0x8050,
    	///
	    RGB5_A1 = 0x8057,
    	///
	    RGB8 = 0x8051,
    	///
	    RGBA12 = 0x805A,
    	///
	    RGBA16 = 0x805B,
    	///
	    RGBA2 = 0x8055,
    	///
	    RGBA4 = 0x8056,
    	///
	    RGBA8 = 0x8058
	}

	///
	enum PixelMap {
    	///
	    PIXEL_MAP_A_TO_A = 0x0C79,
    	///
	    PIXEL_MAP_B_TO_B = 0x0C78,
    	///
	    PIXEL_MAP_G_TO_G = 0x0C77,
    	///
	    PIXEL_MAP_I_TO_A = 0x0C75,
    	///
	    PIXEL_MAP_I_TO_B = 0x0C74,
    	///
	    PIXEL_MAP_I_TO_G = 0x0C73,
    	///
	    PIXEL_MAP_I_TO_I = 0x0C70,
    	///
	    PIXEL_MAP_I_TO_R = 0x0C72,
    	///
	    PIXEL_MAP_R_TO_R = 0x0C76,
    	///
	    PIXEL_MAP_S_TO_S = 0x0C71
	}

	///
	enum PixelStoreParameter {
    	///
	    PACK_ALIGNMENT = 0x0D05,
    	///
	    PACK_IMAGE_DEPTH_SGIS = 0x8131,
    	///
	    PACK_IMAGE_HEIGHT = 0x806C,
    	///
	    PACK_IMAGE_HEIGHT_EXT = 0x806C,
    	///
	    PACK_LSB_FIRST = 0x0D01,
    	///
	    PACK_RESAMPLE_OML = 0x8984,
    	///
	    PACK_RESAMPLE_SGIX = 0x842E,
    	///
	    PACK_ROW_LENGTH = 0x0D02,
    	///
	    PACK_SKIP_IMAGES = 0x806B,
    	///
	    PACK_SKIP_IMAGES_EXT = 0x806B,
    	///
	    PACK_SKIP_PIXELS = 0x0D04,
    	///
	    PACK_SKIP_ROWS = 0x0D03,
    	///
	    PACK_SKIP_VOLUMES_SGIS = 0x8130,
    	///
	    PACK_SUBSAMPLE_RATE_SGIX = 0x85A0,
    	///
	    PACK_SWAP_BYTES = 0x0D00,
    	///
	    PIXEL_TILE_CACHE_SIZE_SGIX = 0x8145,
    	///
	    PIXEL_TILE_GRID_DEPTH_SGIX = 0x8144,
    	///
	    PIXEL_TILE_GRID_HEIGHT_SGIX = 0x8143,
    	///
	    PIXEL_TILE_GRID_WIDTH_SGIX = 0x8142,
    	///
	    PIXEL_TILE_HEIGHT_SGIX = 0x8141,
    	///
	    PIXEL_TILE_WIDTH_SGIX = 0x8140,
    	///
	    UNPACK_ALIGNMENT = 0x0CF5,
    	///
	    UNPACK_IMAGE_DEPTH_SGIS = 0x8133,
    	///
	    UNPACK_IMAGE_HEIGHT = 0x806E,
    	///
	    UNPACK_IMAGE_HEIGHT_EXT = 0x806E,
    	///
	    UNPACK_LSB_FIRST = 0x0CF1,
    	///
	    UNPACK_RESAMPLE_OML = 0x8985,
    	///
	    UNPACK_RESAMPLE_SGIX = 0x842F,
    	///
	    UNPACK_ROW_LENGTH = 0x0CF2,
    	///
	    UNPACK_ROW_LENGTH_EXT = 0x0CF2,
    	///
	    UNPACK_SKIP_IMAGES = 0x806D,
    	///
	    UNPACK_SKIP_IMAGES_EXT = 0x806D,
    	///
	    UNPACK_SKIP_PIXELS = 0x0CF4,
    	///
	    UNPACK_SKIP_PIXELS_EXT = 0x0CF4,
    	///
	    UNPACK_SKIP_ROWS = 0x0CF3,
    	///
	    UNPACK_SKIP_ROWS_EXT = 0x0CF3,
    	///
	    UNPACK_SKIP_VOLUMES_SGIS = 0x8132,
    	///
	    UNPACK_SUBSAMPLE_RATE_SGIX = 0x85A1,
    	///
	    UNPACK_SWAP_BYTES = 0x0CF0
	}

	///
	enum PixelStoreResampleMode {
    	///
	    RESAMPLE_DECIMATE_SGIX = 0x8430,
    	///
	    RESAMPLE_REPLICATE_SGIX = 0x8433,
    	///
	    RESAMPLE_ZERO_FILL_SGIX = 0x8434
	}

	///
	enum PixelStoreSubsampleRate {
    	///
	    PIXEL_SUBSAMPLE_2424_SGIX = 0x85A3,
    	///
	    PIXEL_SUBSAMPLE_4242_SGIX = 0x85A4,
    	///
	    PIXEL_SUBSAMPLE_4444_SGIX = 0x85A2
	}

	///
	enum PixelTexGenMode {
    	///
	    LUMINANCE = 0x1909,
    	///
	    LUMINANCE_ALPHA = 0x190A,
    	///
	    NONE = 0,
    	///
	    PIXEL_TEX_GEN_ALPHA_LS_SGIX = 0x8189,
    	///
	    PIXEL_TEX_GEN_ALPHA_MS_SGIX = 0x818A,
    	///
	    PIXEL_TEX_GEN_ALPHA_NO_REPLACE_SGIX = 0x8188,
    	///
	    PIXEL_TEX_GEN_ALPHA_REPLACE_SGIX = 0x8187,
    	///
	    RGB = 0x1907,
    	///
	    RGBA = 0x1908
	}

	///
	enum PixelTexGenParameterNameSGIS {
    	///
	    PIXEL_FRAGMENT_ALPHA_SOURCE_SGIS = 0x8355,
    	///
	    PIXEL_FRAGMENT_RGB_SOURCE_SGIS = 0x8354
	}

	///
	enum PixelTransferParameter {
    	///
	    ALPHA_BIAS = 0x0D1D,
    	///
	    ALPHA_SCALE = 0x0D1C,
    	///
	    BLUE_BIAS = 0x0D1B,
    	///
	    BLUE_SCALE = 0x0D1A,
    	///
	    DEPTH_BIAS = 0x0D1F,
    	///
	    DEPTH_SCALE = 0x0D1E,
    	///
	    GREEN_BIAS = 0x0D19,
    	///
	    GREEN_SCALE = 0x0D18,
    	///
	    INDEX_OFFSET = 0x0D13,
    	///
	    INDEX_SHIFT = 0x0D12,
    	///
	    MAP_COLOR = 0x0D10,
    	///
	    MAP_STENCIL = 0x0D11,
    	///
	    POST_COLOR_MATRIX_ALPHA_BIAS = 0x80BB,
    	///
	    POST_COLOR_MATRIX_ALPHA_BIAS_SGI = 0x80BB,
    	///
	    POST_COLOR_MATRIX_ALPHA_SCALE = 0x80B7,
    	///
	    POST_COLOR_MATRIX_ALPHA_SCALE_SGI = 0x80B7,
    	///
	    POST_COLOR_MATRIX_BLUE_BIAS = 0x80BA,
    	///
	    POST_COLOR_MATRIX_BLUE_BIAS_SGI = 0x80BA,
    	///
	    POST_COLOR_MATRIX_BLUE_SCALE = 0x80B6,
    	///
	    POST_COLOR_MATRIX_BLUE_SCALE_SGI = 0x80B6,
    	///
	    POST_COLOR_MATRIX_GREEN_BIAS = 0x80B9,
    	///
	    POST_COLOR_MATRIX_GREEN_BIAS_SGI = 0x80B9,
    	///
	    POST_COLOR_MATRIX_GREEN_SCALE = 0x80B5,
    	///
	    POST_COLOR_MATRIX_GREEN_SCALE_SGI = 0x80B5,
    	///
	    POST_COLOR_MATRIX_RED_BIAS = 0x80B8,
    	///
	    POST_COLOR_MATRIX_RED_BIAS_SGI = 0x80B8,
    	///
	    POST_COLOR_MATRIX_RED_SCALE = 0x80B4,
    	///
	    POST_COLOR_MATRIX_RED_SCALE_SGI = 0x80B4,
    	///
	    POST_CONVOLUTION_ALPHA_BIAS = 0x8023,
    	///
	    POST_CONVOLUTION_ALPHA_BIAS_EXT = 0x8023,
    	///
	    POST_CONVOLUTION_ALPHA_SCALE = 0x801F,
    	///
	    POST_CONVOLUTION_ALPHA_SCALE_EXT = 0x801F,
    	///
	    POST_CONVOLUTION_BLUE_BIAS = 0x8022,
    	///
	    POST_CONVOLUTION_BLUE_BIAS_EXT = 0x8022,
    	///
	    POST_CONVOLUTION_BLUE_SCALE = 0x801E,
    	///
	    POST_CONVOLUTION_BLUE_SCALE_EXT = 0x801E,
    	///
	    POST_CONVOLUTION_GREEN_BIAS = 0x8021,
    	///
	    POST_CONVOLUTION_GREEN_BIAS_EXT = 0x8021,
    	///
	    POST_CONVOLUTION_GREEN_SCALE = 0x801D,
    	///
	    POST_CONVOLUTION_GREEN_SCALE_EXT = 0x801D,
    	///
	    POST_CONVOLUTION_RED_BIAS = 0x8020,
    	///
	    POST_CONVOLUTION_RED_BIAS_EXT = 0x8020,
    	///
	    POST_CONVOLUTION_RED_SCALE = 0x801C,
    	///
	    POST_CONVOLUTION_RED_SCALE_EXT = 0x801C,
    	///
	    RED_BIAS = 0x0D15,
    	///
	    RED_SCALE = 0x0D14
	}

	///
	enum PixelType {
    	///
	    BITMAP = 0x1A00,
    	///
	    BYTE = 0x1400,
    	///
	    FLOAT = 0x1406,
    	///
	    INT = 0x1404,
    	///
	    SHORT = 0x1402,
    	///
	    UNSIGNED_BYTE = 0x1401,
    	///
	    UNSIGNED_BYTE_3_3_2 = 0x8032,
    	///
	    UNSIGNED_BYTE_3_3_2_EXT = 0x8032,
    	///
	    UNSIGNED_INT = 0x1405,
    	///
	    UNSIGNED_INT_10_10_10_2 = 0x8036,
    	///
	    UNSIGNED_INT_10_10_10_2_EXT = 0x8036,
    	///
	    UNSIGNED_INT_8_8_8_8 = 0x8035,
    	///
	    UNSIGNED_INT_8_8_8_8_EXT = 0x8035,
    	///
	    UNSIGNED_SHORT = 0x1403,
    	///
	    UNSIGNED_SHORT_4_4_4_4 = 0x8033,
    	///
	    UNSIGNED_SHORT_4_4_4_4_EXT = 0x8033,
    	///
	    UNSIGNED_SHORT_5_5_5_1 = 0x8034,
    	///
	    UNSIGNED_SHORT_5_5_5_1_EXT = 0x8034
	}

	///
	enum PointParameterNameSGIS {
    	///
	    DISTANCE_ATTENUATION_EXT = 0x8129,
    	///
	    DISTANCE_ATTENUATION_SGIS = 0x8129,
    	///
	    POINT_DISTANCE_ATTENUATION = 0x8129,
    	///
	    POINT_DISTANCE_ATTENUATION_ARB = 0x8129,
    	///
	    POINT_FADE_THRESHOLD_SIZE = 0x8128,
    	///
	    POINT_FADE_THRESHOLD_SIZE_ARB = 0x8128,
    	///
	    POINT_FADE_THRESHOLD_SIZE_EXT = 0x8128,
    	///
	    POINT_FADE_THRESHOLD_SIZE_SGIS = 0x8128,
    	///
	    POINT_SIZE_MAX = 0x8127,
    	///
	    POINT_SIZE_MAX_ARB = 0x8127,
    	///
	    POINT_SIZE_MAX_EXT = 0x8127,
    	///
	    POINT_SIZE_MAX_SGIS = 0x8127,
    	///
	    POINT_SIZE_MIN = 0x8126,
    	///
	    POINT_SIZE_MIN_ARB = 0x8126,
    	///
	    POINT_SIZE_MIN_EXT = 0x8126,
    	///
	    POINT_SIZE_MIN_SGIS = 0x8126
	}

	///
	enum PolygonMode {
    	///
	    FILL = 0x1B02,
    	///
	    LINE = 0x1B01,
    	///
	    POINT = 0x1B00
	}

	///
	enum PrimitiveType {
    	///
	    LINES = 0x0001,
    	///
	    LINES_ADJACENCY = 0x000A,
    	///
	    LINES_ADJACENCY_ARB = 0x000A,
    	///
	    LINES_ADJACENCY_EXT = 0x000A,
    	///
	    LINE_LOOP = 0x0002,
    	///
	    LINE_STRIP = 0x0003,
    	///
	    LINE_STRIP_ADJACENCY = 0x000B,
    	///
	    LINE_STRIP_ADJACENCY_ARB = 0x000B,
    	///
	    LINE_STRIP_ADJACENCY_EXT = 0x000B,
    	///
	    PATCHES = 0x000E,
    	///
	    PATCHES_EXT = 0x000E,
    	///
	    POINTS = 0x0000,
    	///
	    POLYGON = 0x0009,
    	///
	    QUADS = 0x0007,
    	///
	    QUADS_EXT = 0x0007,
    	///
	    QUAD_STRIP = 0x0008,
    	///
	    TRIANGLES = 0x0004,
    	///
	    TRIANGLES_ADJACENCY = 0x000C,
    	///
	    TRIANGLES_ADJACENCY_ARB = 0x000C,
    	///
	    TRIANGLES_ADJACENCY_EXT = 0x000C,
    	///
	    TRIANGLE_FAN = 0x0006,
    	///
	    TRIANGLE_STRIP = 0x0005,
    	///
	    TRIANGLE_STRIP_ADJACENCY = 0x000D,
    	///
	    TRIANGLE_STRIP_ADJACENCY_ARB = 0x000D,
    	///
	    TRIANGLE_STRIP_ADJACENCY_EXT = 0x000D
	}

	///
	@Bitmaskable
	enum OcclusionQueryEventMaskAMD {
    	///
	    QUERY_DEPTH_PASS_EVENT_BIT_AMD = 0x00000001,
    	///
	    QUERY_DEPTH_FAIL_EVENT_BIT_AMD = 0x00000002,
    	///
	    QUERY_STENCIL_FAIL_EVENT_BIT_AMD = 0x00000004,
    	///
	    QUERY_DEPTH_BOUNDS_FAIL_EVENT_BIT_AMD = 0x00000008,
    	///
	    QUERY_ALL_EVENT_BITS_AMD = 0xFFFFFFFF
	}

	///
	enum ReadBufferMode {
    	///
	    AUX0 = 0x0409,
    	///
	    AUX1 = 0x040A,
    	///
	    AUX2 = 0x040B,
    	///
	    AUX3 = 0x040C,
    	///
	    BACK = 0x0405,
    	///
	    BACK_LEFT = 0x0402,
    	///
	    BACK_RIGHT = 0x0403,
    	///
	    FRONT = 0x0404,
    	///
	    FRONT_LEFT = 0x0400,
    	///
	    FRONT_RIGHT = 0x0401,
    	///
	    LEFT = 0x0406,
    	///
	    RIGHT = 0x0407
	}

	///
	enum RenderingMode {
    	///
	    FEEDBACK = 0x1C01,
    	///
	    RENDER = 0x1C00,
    	///
	    SELECT = 0x1C02
	}

	///
	enum SamplePatternSGIS {
    	///
	    EXT_1PASS = 0x80A1,
    	///
	    SGIS_1PASS = 0x80A1,
    	///
	    EXT_2PASS_0 = 0x80A2,
    	///
	    SGIS_2PASS_0 = 0x80A2,
    	///
	    EXT_2PASS_1 = 0x80A3,
    	///
	    SGIS_2PASS_1 = 0x80A3,
    	///
	    EXT_4PASS_0 = 0x80A4,
    	///
	    SGIS_4PASS_0 = 0x80A4,
    	///
	    EXT_4PASS_1 = 0x80A5,
    	///
	    SGIS_4PASS_1 = 0x80A5,
    	///
	    EXT_4PASS_2 = 0x80A6,
    	///
	    SGIS_4PASS_2 = 0x80A6,
    	///
	    EXT_4PASS_3 = 0x80A7,
    	///
	    SGIS_4PASS_3 = 0x80A7
	}

	///
	enum SeparableTargetEXT {
    	///
	    SEPARABLE_2D = 0x8012,
    	///
	    SEPARABLE_2D_EXT = 0x8012
	}

	///
	enum ShadingModel {
    	///
	    FLAT = 0x1D00,
    	///
	    SMOOTH = 0x1D01
	}

	///
	enum StencilFunction {
    	///
	    ALWAYS = 0x0207,
    	///
	    EQUAL = 0x0202,
    	///
	    GEQUAL = 0x0206,
    	///
	    GREATER = 0x0204,
    	///
	    LEQUAL = 0x0203,
    	///
	    LESS = 0x0201,
    	///
	    NEVER = 0x0200,
    	///
	    NOTEQUAL = 0x0205
	}

	///
	enum StencilOp {
    	///
	    DECR = 0x1E03,
    	///
	    INCR = 0x1E02,
    	///
	    INVERT = 0x150A,
    	///
	    KEEP = 0x1E00,
    	///
	    REPLACE = 0x1E01,
    	///
	    ZERO = 0
	}

	///
	enum StringName {
    	///
	    EXTENSIONS = 0x1F03,
    	///
	    RENDERER = 0x1F01,
    	///
	    VENDOR = 0x1F00,
    	///
	    VERSION = 0x1F02
	}

	///
	enum TexCoordPointerType {
    	///
	    DOUBLE = 0x140A,
    	///
	    FLOAT = 0x1406,
    	///
	    INT = 0x1404,
    	///
	    SHORT = 0x1402
	}

	///
	enum TextureCoordName {
    	///
	    S = 0x2000,
    	///
	    T = 0x2001,
    	///
	    R = 0x2002,
    	///
	    Q = 0x2003
	}

	///
	enum TextureEnvMode {
    	///
	    ADD = 0x0104,
    	///
	    BLEND = 0x0BE2,
    	///
	    DECAL = 0x2101,
    	///
	    MODULATE = 0x2100,
    	///
	    REPLACE_EXT = 0x8062,
    	///
	    TEXTURE_ENV_BIAS_SGIX = 0x80BE
	}

	///
	enum TextureEnvParameter {
    	///
	    TEXTURE_ENV_COLOR = 0x2201,
    	///
	    TEXTURE_ENV_MODE = 0x2200
	}

	///
	enum TextureEnvTarget {
    	///
	    TEXTURE_ENV = 0x2300
	}

	///
	enum TextureFilterFuncSGIS {
    	///
	    FILTER4_SGIS = 0x8146
	}

	///
	enum TextureGenMode {
    	///
	    EYE_DISTANCE_TO_LINE_SGIS = 0x81F2,
    	///
	    EYE_DISTANCE_TO_POINT_SGIS = 0x81F0,
    	///
	    EYE_LINEAR = 0x2400,
    	///
	    OBJECT_DISTANCE_TO_LINE_SGIS = 0x81F3,
    	///
	    OBJECT_DISTANCE_TO_POINT_SGIS = 0x81F1,
    	///
	    OBJECT_LINEAR = 0x2401,
    	///
	    SPHERE_MAP = 0x2402
	}

	///
	enum TextureGenParameter {
    	///
	    EYE_LINE_SGIS = 0x81F6,
    	///
	    EYE_PLANE = 0x2502,
    	///
	    EYE_POINT_SGIS = 0x81F4,
    	///
	    OBJECT_LINE_SGIS = 0x81F7,
    	///
	    OBJECT_PLANE = 0x2501,
    	///
	    OBJECT_POINT_SGIS = 0x81F5,
    	///
	    TEXTURE_GEN_MODE = 0x2500
	}

	///
	enum TextureMagFilter {
    	///
	    FILTER4_SGIS = 0x8146,
    	///
	    LINEAR = 0x2601,
    	///
	    LINEAR_DETAIL_ALPHA_SGIS = 0x8098,
    	///
	    LINEAR_DETAIL_COLOR_SGIS = 0x8099,
    	///
	    LINEAR_DETAIL_SGIS = 0x8097,
    	///
	    LINEAR_SHARPEN_ALPHA_SGIS = 0x80AE,
    	///
	    LINEAR_SHARPEN_COLOR_SGIS = 0x80AF,
    	///
	    LINEAR_SHARPEN_SGIS = 0x80AD,
    	///
	    NEAREST = 0x2600,
    	///
	    PIXEL_TEX_GEN_Q_CEILING_SGIX = 0x8184,
    	///
	    PIXEL_TEX_GEN_Q_FLOOR_SGIX = 0x8186,
    	///
	    PIXEL_TEX_GEN_Q_ROUND_SGIX = 0x8185
	}

	///
	enum TextureMinFilter {
    	///
	    FILTER4_SGIS = 0x8146,
    	///
	    LINEAR = 0x2601,
    	///
	    LINEAR_CLIPMAP_LINEAR_SGIX = 0x8170,
    	///
	    LINEAR_CLIPMAP_NEAREST_SGIX = 0x844F,
    	///
	    LINEAR_MIPMAP_LINEAR = 0x2703,
    	///
	    LINEAR_MIPMAP_NEAREST = 0x2701,
    	///
	    NEAREST = 0x2600,
    	///
	    NEAREST_CLIPMAP_LINEAR_SGIX = 0x844E,
    	///
	    NEAREST_CLIPMAP_NEAREST_SGIX = 0x844D,
    	///
	    NEAREST_MIPMAP_LINEAR = 0x2702,
    	///
	    NEAREST_MIPMAP_NEAREST = 0x2700,
    	///
	    PIXEL_TEX_GEN_Q_CEILING_SGIX = 0x8184,
    	///
	    PIXEL_TEX_GEN_Q_FLOOR_SGIX = 0x8186,
    	///
	    PIXEL_TEX_GEN_Q_ROUND_SGIX = 0x8185
	}

	///
	enum TextureParameterName {
    	///
	    DETAIL_TEXTURE_LEVEL_SGIS = 0x809A,
    	///
	    DETAIL_TEXTURE_MODE_SGIS = 0x809B,
    	///
	    DUAL_TEXTURE_SELECT_SGIS = 0x8124,
    	///
	    GENERATE_MIPMAP = 0x8191,
    	///
	    GENERATE_MIPMAP_SGIS = 0x8191,
    	///
	    POST_TEXTURE_FILTER_BIAS_SGIX = 0x8179,
    	///
	    POST_TEXTURE_FILTER_SCALE_SGIX = 0x817A,
    	///
	    QUAD_TEXTURE_SELECT_SGIS = 0x8125,
    	///
	    SHADOW_AMBIENT_SGIX = 0x80BF,
    	///
	    TEXTURE_BORDER_COLOR = 0x1004,
    	///
	    TEXTURE_CLIPMAP_CENTER_SGIX = 0x8171,
    	///
	    TEXTURE_CLIPMAP_DEPTH_SGIX = 0x8176,
    	///
	    TEXTURE_CLIPMAP_FRAME_SGIX = 0x8172,
    	///
	    TEXTURE_CLIPMAP_LOD_OFFSET_SGIX = 0x8175,
    	///
	    TEXTURE_CLIPMAP_OFFSET_SGIX = 0x8173,
    	///
	    TEXTURE_CLIPMAP_VIRTUAL_DEPTH_SGIX = 0x8174,
    	///
	    TEXTURE_COMPARE_SGIX = 0x819A,
    	///
	    TEXTURE_LOD_BIAS_R_SGIX = 0x8190,
    	///
	    TEXTURE_LOD_BIAS_S_SGIX = 0x818E,
    	///
	    TEXTURE_LOD_BIAS_T_SGIX = 0x818F,
    	///
	    TEXTURE_MAG_FILTER = 0x2800,
    	///
	    TEXTURE_MAX_CLAMP_R_SGIX = 0x836B,
    	///
	    TEXTURE_MAX_CLAMP_S_SGIX = 0x8369,
    	///
	    TEXTURE_MAX_CLAMP_T_SGIX = 0x836A,
    	///
	    TEXTURE_MIN_FILTER = 0x2801,
    	///
	    TEXTURE_PRIORITY = 0x8066,
    	///
	    TEXTURE_PRIORITY_EXT = 0x8066,
    	///
	    TEXTURE_WRAP_Q_SGIS = 0x8137,
    	///
	    TEXTURE_WRAP_R = 0x8072,
    	///
	    TEXTURE_WRAP_R_EXT = 0x8072,
    	///
	    TEXTURE_WRAP_R_OES = 0x8072,
    	///
	    TEXTURE_WRAP_S = 0x2802,
    	///
	    TEXTURE_WRAP_T = 0x2803
	}

	///
	enum TextureTarget {
    	///
	    DETAIL_TEXTURE_2D_SGIS = 0x8095,
    	///
	    PROXY_TEXTURE_1D = 0x8063,
    	///
	    PROXY_TEXTURE_1D_EXT = 0x8063,
    	///
	    PROXY_TEXTURE_2D = 0x8064,
    	///
	    PROXY_TEXTURE_2D_EXT = 0x8064,
    	///
	    PROXY_TEXTURE_3D = 0x8070,
    	///
	    PROXY_TEXTURE_3D_EXT = 0x8070,
    	///
	    PROXY_TEXTURE_4D_SGIS = 0x8135,
    	///
	    TEXTURE_1D = 0x0DE0,
    	///
	    TEXTURE_2D = 0x0DE1,
    	///
	    TEXTURE_3D = 0x806F,
    	///
	    TEXTURE_3D_EXT = 0x806F,
    	///
	    TEXTURE_3D_OES = 0x806F,
    	///
	    TEXTURE_4D_SGIS = 0x8134,
    	///
	    TEXTURE_BASE_LEVEL = 0x813C,
    	///
	    TEXTURE_BASE_LEVEL_SGIS = 0x813C,
    	///
	    TEXTURE_MAX_LEVEL = 0x813D,
    	///
	    TEXTURE_MAX_LEVEL_SGIS = 0x813D,
    	///
	    TEXTURE_MAX_LOD = 0x813B,
    	///
	    TEXTURE_MAX_LOD_SGIS = 0x813B,
    	///
	    TEXTURE_MIN_LOD = 0x813A,
    	///
	    TEXTURE_MIN_LOD_SGIS = 0x813A
	}

	///
	enum TextureWrapMode {
    	///
	    CLAMP = 0x2900,
    	///
	    CLAMP_TO_BORDER = 0x812D,
    	///
	    CLAMP_TO_BORDER_ARB = 0x812D,
    	///
	    CLAMP_TO_BORDER_NV = 0x812D,
    	///
	    CLAMP_TO_BORDER_SGIS = 0x812D,
    	///
	    CLAMP_TO_EDGE = 0x812F,
    	///
	    CLAMP_TO_EDGE_SGIS = 0x812F,
    	///
	    REPEAT = 0x2901
	}

	///
	@Bitmaskable
	enum UseProgramStageMask {
    	///
	    VERTEX_SHADER_BIT = 0x00000001,
    	///
	    VERTEX_SHADER_BIT_EXT = 0x00000001,
    	///
	    FRAGMENT_SHADER_BIT = 0x00000002,
    	///
	    FRAGMENT_SHADER_BIT_EXT = 0x00000002,
    	///
	    GEOMETRY_SHADER_BIT = 0x00000004,
    	///
	    GEOMETRY_SHADER_BIT_EXT = 0x00000004,
    	///
	    TESS_CONTROL_SHADER_BIT = 0x00000008,
    	///
	    TESS_CONTROL_SHADER_BIT_EXT = 0x00000008,
    	///
	    TESS_EVALUATION_SHADER_BIT = 0x00000010,
    	///
	    TESS_EVALUATION_SHADER_BIT_EXT = 0x00000010,
    	///
	    COMPUTE_SHADER_BIT = 0x00000020,
    	///
	    ALL_SHADER_BITS = 0xFFFFFFFF,
    	///
	    ALL_SHADER_BITS_EXT = 0xFFFFFFFF
	}

	///
	enum VertexPointerType {
    	///
	    DOUBLE = 0x140A,
    	///
	    FLOAT = 0x1406,
    	///
	    INT = 0x1404,
    	///
	    SHORT = 0x1402
	}

    alias fn_glActiveShaderProgram = extern(System) void function(GLuint pipeline, GLuint program) @system @nogc nothrow;

    /++
     + glActiveShaderProgram: man4/glActiveShaderProgram.xml
     + 
     + $(D_INLINECODE glActiveShaderProgram) sets the linked program named by $(D_INLINECODE program) to be the active program for the program pipeline object $(D_INLINECODE pipeline). The active program in the active program pipeline object is the target of calls to $(D_INLINECODE glUniform) when no program has been made current through a call to $(D_INLINECODE glUseProgram).
     + 
     + Params:
     +     pipeline = Specifies the program pipeline object to set the active program object for.
     +     program  = Specifies the program object to set as the active program pipeline object $(D_INLINECODE pipeline).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenProgramPipelines), $(D_INLINECODE glDeleteProgramPipelines), $(D_INLINECODE glIsProgramPipeline), $(D_INLINECODE glUseProgram), $(D_INLINECODE glUniform)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glActiveShaderProgram glActiveShaderProgram;
    alias fn_glActiveTexture = extern(System) void function(GLenum texture) @system @nogc nothrow;

    /++
     + glActiveTexture: man4/glActiveTexture.xml
     + 
     + $(D_INLINECODE glActiveTexture) selects which texture unit subsequent texture state calls will affect.  The number of texture units an implementation supports is implementation dependent, but must be at least 80.
     + 
     + Params:
     +     texture = Specifies which texture unit to make active. The number of texture units is implementation dependent, but must be at least 80. $(D_INLINECODE texture) must be one of $(D_INLINECODE GL_TEXTURE), where ranges from zero to the value of $(D_INLINECODE GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS) minus one. The initial value is $(D_INLINECODE GL_TEXTURE0).
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenTextures), $(D_INLINECODE glBindTexture), $(D_INLINECODE glCompressedTexImage1D), $(D_INLINECODE glCompressedTexImage2D), $(D_INLINECODE glCompressedTexImage3D), $(D_INLINECODE glCompressedTexSubImage1D), $(D_INLINECODE glCompressedTexSubImage2D), $(D_INLINECODE glCompressedTexSubImage3D), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glDeleteTextures) $(D_INLINECODE glIsTexture), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage2DMultisample), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexImage3DMultisample), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter),
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glActiveTexture glActiveTexture;
    alias fn_glAttachShader = extern(System) void function(GLuint program, GLuint shader) @system @nogc nothrow;

    /++
     + glAttachShader: man4/glAttachShader.xml
     + 
     + In order to create a complete shader program, there must be a way to specify the list of things that will be linked together. Program objects provide this mechanism. Shaders that are to be linked together in a program object must first be attached to that program object. $(D_INLINECODE glAttachShader) attaches the shader object specified by $(D_INLINECODE shader) to the program object specified by $(D_INLINECODE program). This indicates that $(D_INLINECODE shader) will be included in link operations that will be performed on $(D_INLINECODE program). All operations that can be performed on a shader object are valid whether or not the shader object is attached to a program object. It is permissible to attach a shader object to a program object before source code has been loaded into the shader object or before the shader object has been compiled. It is permissible to attach multiple shader objects of the same type because each may contain a portion of the complete shader. It is also permissible to attach a shader object to more than one program object. If a shader object is deleted while it is attached to a program object, it will be flagged for deletion, and deletion will not occur until $(D_INLINECODE glDetachShader) is called to detach it from all program objects to which it is attached.
     + 
     + Params:
     +     program = Specifies the program object to which a shader object will be attached.
     +     shader  = Specifies the shader object that is to be attached.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCompileShader), $(D_INLINECODE glCreateShader), $(D_INLINECODE glDeleteShader), $(D_INLINECODE glDetachShader), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glShaderSource)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glAttachShader glAttachShader;
    alias fn_glBeginConditionalRender = extern(System) void function(GLuint id, GLenum mode) @system @nogc nothrow;

    /++
     + glBeginConditionalRender: man4/glBeginConditionalRender.xml
     + 
     + Conditional rendering is started using $(D_INLINECODE glBeginConditionalRender) and ended using $(D_INLINECODE glEndConditionalRender). During conditional rendering, all vertex array commands, as well as $(D_INLINECODE glClear) and $(D_INLINECODE glClearBuffer) have no effect if the ( $(D_INLINECODE GL_SAMPLES_PASSED) ) result of the query object $(D_INLINECODE id) is zero, or if the ( $(D_INLINECODE GL_ANY_SAMPLES_PASSED) ) result is $(D_INLINECODE GL_FALSE). The results of commands setting the current vertex state, such as $(D_INLINECODE glVertexAttrib) are undefined. If the ( $(D_INLINECODE GL_SAMPLES_PASSED) ) result is non-zero or if the ( $(D_INLINECODE GL_ANY_SAMPLES_PASSED) ) result is $(D_INLINECODE GL_TRUE), such commands are not discarded. The $(D_INLINECODE id) parameter to $(D_INLINECODE glBeginConditionalRender) must be the name of a query object previously returned from a call to $(D_INLINECODE glGenQueries). $(D_INLINECODE mode) specifies how the results of the query object are to be interpreted. If $(D_INLINECODE mode) is $(D_INLINECODE GL_QUERY_WAIT), the GL waits for the results of the query to be available and then uses the results to determine if subsequent rendering commands are discarded. If $(D_INLINECODE mode) is $(D_INLINECODE GL_QUERY_NO_WAIT), the GL may choose to unconditionally execute the subsequent rendering commands without waiting for the query to complete. If $(D_INLINECODE mode) is $(D_INLINECODE GL_QUERY_BY_REGION_WAIT), the GL will also wait for occlusion query results and discard rendering commands if the result of the occlusion query is zero. If the query result is non-zero, subsequent rendering commands are executed, but the GL may discard the results of the commands for any region of the framebuffer that did not contribute to the sample count in the specified occlusion query. Any such discarding is done in an implementation-dependent manner, but the rendering command results may not be discarded for any samples that contributed to the occlusion query sample count. If $(D_INLINECODE mode) is $(D_INLINECODE GL_QUERY_BY_REGION_NO_WAIT), the GL operates as in $(D_INLINECODE GL_QUERY_BY_REGION_WAIT), but may choose to unconditionally execute the subsequent rendering commands without waiting for the query to complete.
     + 
     + $(D_INLINECODE glBeginConditionalRender) and $(D_INLINECODE glEndConditionalRender) are available only if the GL version is 3.0 or greater. The $(D_INLINECODE GL_ANY_SAMPLES_PASSED) query result is available only if the GL version is 3.3 or greater.
     + 
     + Params:
     +     id   = Specifies the name of an occlusion query object whose results are used to determine if the rendering commands are discarded.
     +     mode = Specifies how $(D_INLINECODE glBeginConditionalRender) interprets the results of the occlusion query.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenQueries), $(D_INLINECODE glDeleteQueries), $(D_INLINECODE glBeginQuery)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glBeginConditionalRender glBeginConditionalRender;
    alias fn_glBeginQuery = extern(System) void function(GLenum target, GLuint id) @system @nogc nothrow;

    /++
     + glBeginQuery: man4/glBeginQuery.xml
     + 
     + $(D_INLINECODE glBeginQuery) and $(D_INLINECODE glEndQuery) delimit the boundaries of a query object. $(D_INLINECODE query) must be a name previously returned from a call to $(D_INLINECODE glGenQueries). If a query object with name $(D_INLINECODE id) does not yet exist it is created with the type determined by $(D_INLINECODE target). $(D_INLINECODE target) must be one of $(D_INLINECODE GL_SAMPLES_PASSED), $(D_INLINECODE GL_ANY_SAMPLES_PASSED), $(D_INLINECODE GL_PRIMITIVES_GENERATED), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN), or $(D_INLINECODE GL_TIME_ELAPSED). The behavior of the query object depends on its type and is as follows. If $(D_INLINECODE target) is $(D_INLINECODE GL_SAMPLES_PASSED), $(D_INLINECODE id) must be an unused name, or the name of an existing occlusion query object. When $(D_INLINECODE glBeginQuery) is executed, the query object's samples-passed counter is reset to 0.  Subsequent rendering will increment the counter for every sample that passes the depth test.  If the value of $(D_INLINECODE GL_SAMPLE_BUFFERS) is 0, then the samples-passed count is incremented by 1 for each fragment. If the value of $(D_INLINECODE GL_SAMPLE_BUFFERS) is 1, then the samples-passed count is incremented by the number of samples whose coverage bit is set. However, implementations, at their discression may instead increase the samples-passed count by the value of $(D_INLINECODE GL_SAMPLES) if any sample in the fragment is covered. When $(D_INLINECODE glEndQuery) is executed, the samples-passed counter is assigned to the query object's result value.  This value can be queried by calling $(D_INLINECODE glGetQueryObject) with $(D_INLINECODE pname) $(D_INLINECODE GL_QUERY_RESULT). If $(D_INLINECODE target) is $(D_INLINECODE GL_ANY_SAMPLES_PASSED) or $(D_INLINECODE GL_ANY_SAMPLES_PASSED_CONSERVATIVE), $(D_INLINECODE id) must be an unused name, or the name of an existing boolean occlusion query object. When $(D_INLINECODE glBeginQuery) is executed, the query object's samples-passed flag is reset to $(D_INLINECODE GL_FALSE). Subsequent rendering causes the flag to be set to $(D_INLINECODE GL_TRUE) if any sample passes the depth test in the case of $(D_INLINECODE GL_ANY_SAMPLES_PASSED), or if the implementation determines that any sample might pass the depth test in the case of $(D_INLINECODE GL_ANY_SAMPLES_PASSED_CONSERVATIVE). The implementation may be able to provide a more efficient test in the case of $(D_INLINECODE GL_ANY_SAMPLES_PASSED_CONSERVATIVE) if some false positives are acceptable to the application.  When $(D_INLINECODE glEndQuery) is executed, the samples-passed flag is assigned to the query object's result value.  This value can be queried by calling $(D_INLINECODE glGetQueryObject) with $(D_INLINECODE pname) $(D_INLINECODE GL_QUERY_RESULT). If $(D_INLINECODE target) is $(D_INLINECODE GL_PRIMITIVES_GENERATED), $(D_INLINECODE id) must be an unused name, or the name of an existing primitive query object previously bound to the $(D_INLINECODE GL_PRIMITIVES_GENERATED) query binding. When $(D_INLINECODE glBeginQuery) is executed, the query object's primitives-generated counter is reset to 0.  Subsequent rendering will increment the counter once for every vertex that is emitted from the geometry shader, or from the vertex shader if no geometry shader is present.  When $(D_INLINECODE glEndQuery) is executed, the primitives-generated counter is assigned to the query object's result value.  This value can be queried by calling $(D_INLINECODE glGetQueryObject) with $(D_INLINECODE pname) $(D_INLINECODE GL_QUERY_RESULT). If $(D_INLINECODE target) is $(D_INLINECODE GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN), $(D_INLINECODE id) must be an unused name, or the name of an existing primitive query object previously bound to the $(D_INLINECODE GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN) query binding. When $(D_INLINECODE glBeginQuery) is executed, the query object's primitives-written counter is reset to 0.  Subsequent rendering will increment the counter once for every vertex that is written into the bound transform feedback buffer(s).  If transform feedback mode is not activated between the call to $(D_INLINECODE glBeginQuery) and $(D_INLINECODE glEndQuery), the counter will not be incremented.  When $(D_INLINECODE glEndQuery) is executed, the primitives-written counter is assigned to the query object's result value.  This value can be queried by calling $(D_INLINECODE glGetQueryObject) with $(D_INLINECODE pname) $(D_INLINECODE GL_QUERY_RESULT). If $(D_INLINECODE target) is $(D_INLINECODE GL_TIME_ELAPSED), $(D_INLINECODE id) must be an unused name, or the name of an existing timer query object previously bound to the $(D_INLINECODE GL_TIME_ELAPSED) query binding. When $(D_INLINECODE glBeginQuery) is executed, the query object's time counter is reset to 0.  When $(D_INLINECODE glEndQuery) is executed, the elapsed server time that has passed since the call to $(D_INLINECODE glBeginQuery) is written into the query object's time counter.  This value can be queried by calling $(D_INLINECODE glGetQueryObject) with $(D_INLINECODE pname) $(D_INLINECODE GL_QUERY_RESULT). Querying the $(D_INLINECODE GL_QUERY_RESULT) implicitly flushes the GL pipeline until the rendering delimited by the query object has completed and the result is available. $(D_INLINECODE GL_QUERY_RESULT_AVAILABLE) can be queried to determine if the result is immediately available or if the rendering is not yet complete.
     + 
     + If the query target's count exceeds the maximum value representable in the number of available bits, as reported by $(D_INLINECODE glGetQueryiv) with $(D_INLINECODE target) set to the appropriate query target and $(D_INLINECODE pname) $(D_INLINECODE GL_QUERY_COUNTER_BITS), the count becomes undefined. An implementation may support 0 bits in its counter, in which case query results are always undefined and essentially useless. When $(D_INLINECODE GL_SAMPLE_BUFFERS) is 0, the samples-passed counter of an occlusion query will increment once for each fragment that passes the depth test.  When $(D_INLINECODE GL_SAMPLE_BUFFERS) is 1, an implementation may either increment the samples-passed counter individually for each sample of a fragment that passes the depth test, or it may choose to increment the counter for all samples of a fragment if any one of them passes the depth test. The query targets $(D_INLINECODE GL_ANY_SAMPLES_PASSED), and $(D_INLINECODE GL_TIME_ELAPSED) are availale only if the GL version is 3.3 or higher. The query target $(D_INLINECODE GL_ANY_SAMPLES_PASSED_CONSERVATIVE) is available only of the GL version is 4.3 or higher.
     + 
     + Params:
     +     target = Specifies the target type of query object established between $(D_INLINECODE glBeginQuery) and the subsequent $(D_INLINECODE glEndQuery). The symbolic constant must be one of $(D_INLINECODE GL_SAMPLES_PASSED), $(D_INLINECODE GL_ANY_SAMPLES_PASSED), $(D_INLINECODE GL_ANY_SAMPLES_PASSED_CONSERVATIVE), $(D_INLINECODE GL_PRIMITIVES_GENERATED), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN), or $(D_INLINECODE GL_TIME_ELAPSED).
     +     id     = Specifies the name of a query object.
     + 
     + Copyright:
     +     Copyright&copy; 2005 Addison-Wesley. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBeginQueryIndexed), $(D_INLINECODE glDeleteQueries), $(D_INLINECODE glEndQuery), $(D_INLINECODE glGenQueries), $(D_INLINECODE glGetQueryObject), $(D_INLINECODE glGetQueryiv), $(D_INLINECODE glIsQuery)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    fn_glBeginQuery glBeginQuery;
    alias fn_glBeginQueryIndexed = extern(System) void function(GLenum target, GLuint index, GLuint id) @system @nogc nothrow;

    /++
     + glBeginQueryIndexed: man4/glBeginQueryIndexed.xml
     + 
     + $(D_INLINECODE glBeginQueryIndexed) and $(D_INLINECODE glEndQueryIndexed) delimit the boundaries of a query object. $(D_INLINECODE query) must be a name previously returned from a call to $(D_INLINECODE glGenQueries). If a query object with name $(D_INLINECODE id) does not yet exist it is created with the type determined by $(D_INLINECODE target). $(D_INLINECODE target) must be one of $(D_INLINECODE GL_SAMPLES_PASSED), $(D_INLINECODE GL_ANY_SAMPLES_PASSED), $(D_INLINECODE GL_PRIMITIVES_GENERATED), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN), or $(D_INLINECODE GL_TIME_ELAPSED). The behavior of the query object depends on its type and is as follows. $(D_INLINECODE index) specifies the index of the query target and must be between a $(D_INLINECODE target) -specific maximum. If $(D_INLINECODE target) is $(D_INLINECODE GL_SAMPLES_PASSED), $(D_INLINECODE id) must be an unused name, or the name of an existing occlusion query object. When $(D_INLINECODE glBeginQueryIndexed) is executed, the query object's samples-passed counter is reset to 0.  Subsequent rendering will increment the counter for every sample that passes the depth test.  If the value of $(D_INLINECODE GL_SAMPLE_BUFFERS) is 0, then the samples-passed count is incremented by 1 for each fragment. If the value of $(D_INLINECODE GL_SAMPLE_BUFFERS) is 1, then the samples-passed count is incremented by the number of samples whose coverage bit is set. However, implementations, at their discression may instead increase the samples-passed count by the value of $(D_INLINECODE GL_SAMPLES) if any sample in the fragment is covered. When $(D_INLINECODE glEndQueryIndexed) is executed, the samples-passed counter is assigned to the query object's result value.  This value can be queried by calling $(D_INLINECODE glGetQueryObject) with $(D_INLINECODE pname) $(D_INLINECODE GL_QUERY_RESULT). When $(D_INLINECODE target) is $(D_INLINECODE GL_SAMPLES_PASSED), $(D_INLINECODE index) must be zero. If $(D_INLINECODE target) is $(D_INLINECODE GL_ANY_SAMPLES_PASSED), $(D_INLINECODE id) must be an unused name, or the name of an existing boolean occlusion query object. When $(D_INLINECODE glBeginQueryIndexed) is executed, the query object's samples-passed flag is reset to $(D_INLINECODE GL_FALSE). Subsequent rendering causes the flag to be set to $(D_INLINECODE GL_TRUE) if any sample passes the depth test.  When $(D_INLINECODE glEndQueryIndexed) is executed, the samples-passed flag is assigned to the query object's result value.  This value can be queried by calling $(D_INLINECODE glGetQueryObject) with $(D_INLINECODE pname) $(D_INLINECODE GL_QUERY_RESULT). When $(D_INLINECODE target) is $(D_INLINECODE GL_ANY_SAMPLES_PASSED), $(D_INLINECODE index) must be zero. If $(D_INLINECODE target) is $(D_INLINECODE GL_PRIMITIVES_GENERATED), $(D_INLINECODE id) must be an unused name, or the name of an existing primitive query object previously bound to the $(D_INLINECODE GL_PRIMITIVES_GENERATED) query binding. When $(D_INLINECODE glBeginQueryIndexed) is executed, the query object's primitives-generated counter is reset to 0.  Subsequent rendering will increment the counter once for every vertex that is emitted from the geometry shader to the stream given by $(D_INLINECODE index), or from the vertex shader if $(D_INLINECODE index) is zero and no geometry shader is present. When $(D_INLINECODE glEndQueryIndexed) is executed, the primitives-generated counter for stream $(D_INLINECODE index) is assigned to the query object's result value.  This value can be queried by calling $(D_INLINECODE glGetQueryObject) with $(D_INLINECODE pname) $(D_INLINECODE GL_QUERY_RESULT). When $(D_INLINECODE target) is $(D_INLINECODE GL_PRIMITIVES_GENERATED), $(D_INLINECODE index) must be less than the value of $(D_INLINECODE GL_MAX_VERTEX_STREAMS). If $(D_INLINECODE target) is $(D_INLINECODE GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN), $(D_INLINECODE id) must be an unused name, or the name of an existing primitive query object previously bound to the $(D_INLINECODE GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN) query binding. When $(D_INLINECODE glBeginQueryIndexed) is executed, the query object's primitives-written counter for the stream specified by $(D_INLINECODE index) is reset to 0.  Subsequent rendering will increment the counter once for every vertex that is written into the bound transform feedback buffer(s) for stream $(D_INLINECODE index).  If transform feedback mode is not activated between the call to $(D_INLINECODE glBeginQueryIndexed) and $(D_INLINECODE glEndQueryIndexed), the counter will not be incremented.  When $(D_INLINECODE glEndQueryIndexed) is executed, the primitives-written counter for stream $(D_INLINECODE index) is assigned to the query object's result value.  This value can be queried by calling $(D_INLINECODE glGetQueryObject) with $(D_INLINECODE pname) $(D_INLINECODE GL_QUERY_RESULT). When $(D_INLINECODE target) is $(D_INLINECODE GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN), $(D_INLINECODE index) must be less than the value of $(D_INLINECODE GL_MAX_VERTEX_STREAMS). If $(D_INLINECODE target) is $(D_INLINECODE GL_TIME_ELAPSED), $(D_INLINECODE id) must be an unused name, or the name of an existing timer query object previously bound to the $(D_INLINECODE GL_TIME_ELAPSED) query binding. When $(D_INLINECODE glBeginQueryIndexed) is executed, the query object's time counter is reset to 0.  When $(D_INLINECODE glEndQueryIndexed) is executed, the elapsed server time that has passed since the call to $(D_INLINECODE glBeginQueryIndexed) is written into the query object's time counter.  This value can be queried by calling $(D_INLINECODE glGetQueryObject) with $(D_INLINECODE pname) $(D_INLINECODE GL_QUERY_RESULT). When $(D_INLINECODE target) is $(D_INLINECODE GL_TIME_ELAPSED), $(D_INLINECODE index) must be zero. Querying the $(D_INLINECODE GL_QUERY_RESULT) implicitly flushes the GL pipeline until the rendering delimited by the query object has completed and the result is available. $(D_INLINECODE GL_QUERY_RESULT_AVAILABLE) can be queried to determine if the result is immediately available or if the rendering is not yet complete.
     + 
     + If the query target's count exceeds the maximum value representable in the number of available bits, as reported by $(D_INLINECODE glGetQueryiv) with $(D_INLINECODE target) set to the appropriate query target and $(D_INLINECODE pname) $(D_INLINECODE GL_QUERY_COUNTER_BITS), the count becomes undefined. An implementation may support 0 bits in its counter, in which case query results are always undefined and essentially useless. When $(D_INLINECODE GL_SAMPLE_BUFFERS) is 0, the samples-passed counter of an occlusion query will increment once for each fragment that passes the depth test.  When $(D_INLINECODE GL_SAMPLE_BUFFERS) is 1, an implementation may either increment the samples-passed counter individually for each sample of a fragment that passes the depth test, or it may choose to increment the counter for all samples of a fragment if any one of them passes the depth test. Calling $(D_INLINECODE glBeginQuery) or $(D_INLINECODE glEndQuery) is equivalent to calling $(D_INLINECODE glBeginQueryIndexed) or $(D_INLINECODE glEndQueryIndexed) with $(D_INLINECODE index) set to zero, respectively.
     + 
     + Params:
     +     target = Specifies the target type of query object established between $(D_INLINECODE glBeginQueryIndexed) and the subsequent $(D_INLINECODE glEndQueryIndexed). The symbolic constant must be one of $(D_INLINECODE GL_SAMPLES_PASSED), $(D_INLINECODE GL_ANY_SAMPLES_PASSED), $(D_INLINECODE GL_PRIMITIVES_GENERATED), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN), or $(D_INLINECODE GL_TIME_ELAPSED).
     +     index  = Specifies the index of the query target upon which to begin the query.
     +     id     = Specifies the name of a query object.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBeginQuery), $(D_INLINECODE glDeleteQueries), $(D_INLINECODE glEndQuery), $(D_INLINECODE glGenQueries), $(D_INLINECODE glGetQueryObject), $(D_INLINECODE glGetQueryiv), $(D_INLINECODE glIsQuery)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_transform_feedback3")
    fn_glBeginQueryIndexed glBeginQueryIndexed;
    alias fn_glBeginTransformFeedback = extern(System) void function(GLenum primitiveMode) @system @nogc nothrow;

    /++
     + glBeginTransformFeedback: man4/glBeginTransformFeedback.xml
     + 
     + Transform feedback mode captures the values of varying variables written by the vertex shader (or, if active, the geometry shader). Transform feedback is said to be active after a call to $(D_INLINECODE glBeginTransformFeedback) until a subsequent call to $(D_INLINECODE glEndTransformFeedback). Transform feedback commands must be paired. If no geometry shader is present, while transform feedback is active the $(D_INLINECODE mode) parameter to $(D_INLINECODE glDrawArrays) must match those specified in the following table: $(B Transform Feedback $(D_INLINECODE primitiveMode)) $(B Allowed Render Primitive $(D_INLINECODE modes)) $(D_INLINECODE GL_POINTS) $(D_INLINECODE GL_POINTS) $(D_INLINECODE GL_LINES) $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY) $(D_INLINECODE GL_TRIANGLES) $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY) If a geometry shader is present, the output primitive type from the geometry shader must match those provided in the following table: $(B Transform Feedback $(D_INLINECODE primitiveMode)) $(B Allowed Geometry Shader Output Primitive Type) $(D_INLINECODE GL_POINTS) $(D_INLINECODE points) $(D_INLINECODE GL_LINES) $(D_INLINECODE line_strip) $(D_INLINECODE GL_TRIANGLES) $(D_INLINECODE triangle_strip)
     + 
     + Geometry shaders, and the $(D_INLINECODE GL_TRIANGLES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY) and $(D_INLINECODE GL_LINE_STRIP_ADJACENCY) primtive modes are available only if the GL version is 3.2 or greater.
     + 
     + Params:
     +     primitiveMode = Specify the output type of the primitives that will be recorded into the buffer objects that are bound for transform feedback.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glBeginTransformFeedback glBeginTransformFeedback;
    alias fn_glBindAttribLocation = extern(System) void function(GLuint program, GLuint index, const( GLchar*) name) @system @nogc nothrow;

    /++
     + glBindAttribLocation: man4/glBindAttribLocation.xml
     + 
     + $(D_INLINECODE glBindAttribLocation) is used to associate a user-defined attribute variable in the program object specified by $(D_INLINECODE program) with a generic vertex attribute index. The name of the user-defined attribute variable is passed as a null terminated string in $(D_INLINECODE name). The generic vertex attribute index to be bound to this variable is specified by $(D_INLINECODE index). When $(D_INLINECODE program) is made part of current state, values provided via the generic vertex attribute $(D_INLINECODE index) will modify the value of the user-defined attribute variable specified by $(D_INLINECODE name). If $(D_INLINECODE name) refers to a matrix attribute variable, $(D_INLINECODE index) refers to the first column of the matrix. Other matrix columns are then automatically bound to locations $(D_INLINECODE index+1) for a matrix of type $(D_INLINECODE mat2); $(D_INLINECODE index+1) and $(D_INLINECODE index+2) for a matrix of type $(D_INLINECODE mat3); and $(D_INLINECODE index+1), $(D_INLINECODE index+2), and $(D_INLINECODE index+3) for a matrix of type $(D_INLINECODE mat4). This command makes it possible for vertex shaders to use descriptive names for attribute variables rather than generic variables that are numbered from zero to the value of $(D_INLINECODE GL_MAX_VERTEX_ATTRIBS) minus one. The values sent to each generic attribute index are part of current state. If a different program object is made current by calling $(D_INLINECODE glUseProgram), the generic vertex attributes are tracked in such a way that the same values will be observed by attributes in the new program object that are also bound to $(D_INLINECODE index). Attribute variable name-to-generic attribute index bindings for a program object can be explicitly assigned at any time by calling $(D_INLINECODE glBindAttribLocation). Attribute bindings do not go into effect until $(D_INLINECODE glLinkProgram) is called. After a program object has been linked successfully, the index values for generic attributes remain fixed (and their values can be queried) until the next link command occurs. Any attribute binding that occurs after the program object has been linked will not take effect until the next time the program object is linked.
     + 
     + $(D_INLINECODE glBindAttribLocation) can be called before any vertex shader objects are bound to the specified program object. It is also permissible to bind a generic attribute index to an attribute variable name that is never used in a vertex shader. If $(D_INLINECODE name) was bound previously, that information is lost. Thus you cannot bind one user-defined attribute variable to multiple indices, but you can bind multiple user-defined attribute variables to the same index. Applications are allowed to bind more than one user-defined attribute variable to the same generic vertex attribute index. This is called, and it is allowed only if just one of the aliased attributes is active in the executable program, or if no path through the shader consumes more than one attribute of a set of attributes aliased to the same location. The compiler and linker are allowed to assume that no aliasing is done and are free to employ optimizations that work only in the absence of aliasing. OpenGL implementations are not required to do error checking to detect aliasing. Active attributes that are not explicitly bound will be bound by the linker when $(D_INLINECODE glLinkProgram) is called. The locations assigned can be queried by calling $(D_INLINECODE glGetAttribLocation). OpenGL copies the $(D_INLINECODE name) string when $(D_INLINECODE glBindAttribLocation) is called, so an application may free its copy of the $(D_INLINECODE name) string immediately after the function returns. Generic attribute locations may be specified in the shader source text using a $(D_INLINECODE location) layout qualifier. In this case, the location of the attribute specified in the shader's source takes precedence and may be queried by calling $(D_INLINECODE glGetAttribLocation).
     + 
     + Params:
     +     program = Specifies the handle of the program object in which the association is to be made.
     +     index   = Specifies the index of the generic vertex attribute to be bound.
     +     name    = Specifies a null terminated string containing the name of the vertex shader attribute variable to which $(D_INLINECODE index) is to be bound.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDisableVertexAttribArray), $(D_INLINECODE glEnableVertexAttribArray), $(D_INLINECODE glUseProgram), $(D_INLINECODE glVertexAttrib), $(D_INLINECODE glVertexAttribPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glBindAttribLocation glBindAttribLocation;
    alias fn_glBindBuffer = extern(System) void function(GLenum target, GLuint buffer) @system @nogc nothrow;

    /++
     + glBindBuffer: man4/glBindBuffer.xml
     + 
     + $(D_INLINECODE glBindBuffer) binds a buffer object to the specified buffer binding point. Calling $(D_INLINECODE glBindBuffer) with $(D_INLINECODE target) set to one of the accepted symbolic constants and $(D_INLINECODE buffer) set to the name of a buffer object binds that buffer object name to the target. If no buffer object with name $(D_INLINECODE buffer) exists, one is created with that name. When a buffer object is bound to a target, the previous binding for that target is automatically broken. Buffer object names are unsigned integers. The value zero is reserved, but there is no default buffer object for each buffer object target. Instead, $(D_INLINECODE buffer) set to zero effectively unbinds any buffer object previously bound, and restores client memory usage for that buffer object target (if supported for that target). Buffer object names and the corresponding buffer object contents are local to the shared object space of the current GL rendering context; two rendering contexts share buffer object names only if they explicitly enable sharing between contexts through the appropriate GL windows interfaces functions. $(D_INLINECODE glGenBuffers) must be used to generate a set of unused buffer object names. The state of a buffer object immediately after it is first bound is an unmapped zero-sized memory buffer with $(D_INLINECODE GL_READ_WRITE) access and $(D_INLINECODE GL_STATIC_DRAW) usage. While a non-zero buffer object name is bound, GL operations on the target to which it is bound affect the bound buffer object, and queries of the target to which it is bound return state from the bound buffer object. While buffer object name zero is bound, as in the initial state, attempts to modify or query state on the target to which it is bound generates an $(D_INLINECODE GL_INVALID_OPERATION) error. When a non-zero buffer object is bound to the $(D_INLINECODE GL_ARRAY_BUFFER) target, the vertex array pointer parameter is interpreted as an offset within the buffer object measured in basic machine units. When a non-zero buffer object is bound to the $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) target, parameters for draws issued through $(D_INLINECODE glDrawArraysIndirect) and $(D_INLINECODE glDrawElementsIndirect) are sourced from the specified offset in that buffer object's data store. When a non-zero buffer object is bound to the $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) target, the parameters for compute dispatches issued through $(D_INLINECODE glDispatchComputeIndirect) are sourced from the specified offset in that buffer object's data store. While a non-zero buffer object is bound to the $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) target, the indices parameter of $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawElementsInstanced), $(D_INLINECODE glDrawElementsBaseVertex), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawRangeElementsBaseVertex), $(D_INLINECODE glMultiDrawElements), or $(D_INLINECODE glMultiDrawElementsBaseVertex) is interpreted as an offset within the buffer object measured in basic machine units. While a non-zero buffer object is bound to the $(D_INLINECODE GL_PIXEL_PACK_BUFFER) target, the following commands are affected: $(D_INLINECODE glGetCompressedTexImage), $(D_INLINECODE glGetTexImage), and $(D_INLINECODE glReadPixels). The pointer parameter is interpreted as an offset within the buffer object measured in basic machine units. While a non-zero buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target, the following commands are affected: $(D_INLINECODE glCompressedTexImage1D), $(D_INLINECODE glCompressedTexImage2D), $(D_INLINECODE glCompressedTexImage3D), $(D_INLINECODE glCompressedTexSubImage1D), $(D_INLINECODE glCompressedTexSubImage2D), $(D_INLINECODE glCompressedTexSubImage3D), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), and $(D_INLINECODE glTexSubImage3D). The pointer parameter is interpreted as an offset within the buffer object measured in basic machine units. The buffer targets $(D_INLINECODE GL_COPY_READ_BUFFER) and $(D_INLINECODE GL_COPY_WRITE_BUFFER) are provided to allow $(D_INLINECODE glCopyBufferSubData) to be used without disturbing the state of other bindings. However, $(D_INLINECODE glCopyBufferSubData) may be used with any pair of buffer binding points. The $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) buffer binding point may be passed to $(D_INLINECODE glBindBuffer), but will not directly affect transform feedback state. Instead, the indexed $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) bindings must be used through a call to $(D_INLINECODE glBindBufferBase) or $(D_INLINECODE glBindBufferRange). This will affect the generic $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) binding. Likewise, the $(D_INLINECODE GL_UNIFORM_BUFFER), $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) and $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) buffer binding points may be used, but do not directly affect uniform buffer, atomic counter buffer or shader storage buffer state, respectively. $(D_INLINECODE glBindBufferBase) or $(D_INLINECODE glBindBufferRange) must be used to bind a buffer to an indexed uniform buffer, atomic counter buffer or shader storage buffer binding point. The $(D_INLINECODE GL_QUERY_BUFFER) binding point is used to specify a buffer object that is to receive the results of query objects through calls to the $(D_INLINECODE glGetQueryObject) family of commands. A buffer object binding created with $(D_INLINECODE glBindBuffer) remains active until a different buffer object name is bound to the same target, or until the bound buffer object is deleted with $(D_INLINECODE glDeleteBuffers). Once created, a named buffer object may be re-bound to any target as often as needed. However, the GL implementation may make choices about how to optimize the storage of a buffer object based on its initial binding target.
     + 
     + The $(D_INLINECODE GL_COPY_READ_BUFFER), $(D_INLINECODE GL_UNIFORM_BUFFER) and $(D_INLINECODE GL_TEXTURE_BUFFER) targets are available only if the GL version is 3.1 or greater. The $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) target is available only if the GL version is 4.2 or greater. The $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) and $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) targets are available only if the GL version is 4.3 or greater. The $(D_INLINECODE GL_QUERY_BUFFER) target is available only if the GL version is 4.4 or greater.
     + 
     + Params:
     +     target = Specifies the target to which the buffer object is bound, which must be one of the buffer binding targets in the following table: $(B Buffer Binding Target) $(B Purpose) $(D_INLINECODE GL_ARRAY_BUFFER) Vertex attributes $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) Atomic counter storage $(D_INLINECODE GL_COPY_READ_BUFFER) Buffer copy source $(D_INLINECODE GL_COPY_WRITE_BUFFER) Buffer copy destination $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) Indirect compute dispatch commands $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) Indirect command arguments $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) Vertex array indices $(D_INLINECODE GL_PIXEL_PACK_BUFFER) Pixel read target $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) Texture data source $(D_INLINECODE GL_QUERY_BUFFER) Query result buffer $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) Read-write storage for shaders $(D_INLINECODE GL_TEXTURE_BUFFER) Texture data buffer $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) Transform feedback buffer $(D_INLINECODE GL_UNIFORM_BUFFER) Uniform block storage
     +     buffer = Specifies the name of a buffer object.
     + 
     + Copyright:
     +     Copyright&copy; 2005 Addison-Wesley. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenBuffers), $(D_INLINECODE glBindBufferBase), $(D_INLINECODE glBindBufferRange), $(D_INLINECODE glMapBuffer), $(D_INLINECODE glUnmapBuffer), $(D_INLINECODE glDeleteBuffers), $(D_INLINECODE glGet), $(D_INLINECODE glIsBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    fn_glBindBuffer glBindBuffer;
    alias fn_glBindBufferBase = extern(System) void function(GLenum target, GLuint index, GLuint buffer) @system @nogc nothrow;

    /++
     + glBindBufferBase: man4/glBindBufferBase.xml
     + 
     + $(D_INLINECODE glBindBufferBase) binds the buffer object $(D_INLINECODE buffer) to the binding point at index $(D_INLINECODE index) of the array of targets specified by $(D_INLINECODE target). Each $(D_INLINECODE target) represents an indexed array of buffer binding points, as well as a single general binding point that can be used by other buffer manipulation functions such as $(D_INLINECODE glBindBuffer) or $(D_INLINECODE glMapBuffer). In addition to binding $(D_INLINECODE buffer) to the indexed buffer binding target, $(D_INLINECODE glBindBufferBase) also binds $(D_INLINECODE buffer) to the generic buffer binding point specified by $(D_INLINECODE target).
     + 
     + Calling $(D_INLINECODE glBindBufferBase) is equivalent to calling $(D_INLINECODE glBindBufferRange) with $(D_INLINECODE offset) zero and $(D_INLINECODE size) equal to the size of the buffer. The $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) target is available only if the GL version is 4.2 or greater. The $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) target is available only if the GL version is 4.3 or greater.
     + 
     + Params:
     +     target = Specify the target of the bind operation. $(D_INLINECODE target) must be one of $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER), $(D_INLINECODE GL_UNIFORM_BUFFER) or $(D_INLINECODE GL_SHADER_STORAGE_BUFFER).
     +     index  = Specify the index of the binding point within the array specified by $(D_INLINECODE target).
     +     buffer = The name of a buffer object to bind to the specified binding point.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenBuffers), $(D_INLINECODE glDeleteBuffers), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glBindBufferRange), $(D_INLINECODE glMapBuffer), $(D_INLINECODE glUnmapBuffer),
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_uniform_buffer_object")
    fn_glBindBufferBase glBindBufferBase;
    alias fn_glBindBufferRange = extern(System) void function(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size) @system @nogc nothrow;

    /++
     + glBindBufferRange: man4/glBindBufferRange.xml
     + 
     + $(D_INLINECODE glBindBufferRange) binds a range the buffer object $(D_INLINECODE buffer) represented by $(D_INLINECODE offset) and $(D_INLINECODE size) to the binding point at index $(D_INLINECODE index) of the array of targets specified by $(D_INLINECODE target). Each $(D_INLINECODE target) represents an indexed array of buffer binding points, as well as a single general binding point that can be used by other buffer manipulation functions such as $(D_INLINECODE glBindBuffer) or $(D_INLINECODE glMapBuffer). In addition to binding a range of $(D_INLINECODE buffer) to the indexed buffer binding target, $(D_INLINECODE glBindBufferRange) also binds the range to the generic buffer binding point specified by $(D_INLINECODE target). $(D_INLINECODE offset) specifies the offset in basic machine units into the buffer object $(D_INLINECODE buffer) and $(D_INLINECODE size) specifies the amount of data that can be read from the buffer object while used as an indexed target.
     + 
     + The $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) target is available only if the GL version is 4.2 or greater. The $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) target is available only if the GL version is 4.3 or greater.
     + 
     + Params:
     +     target = Specify the target of the bind operation. $(D_INLINECODE target) must be one of $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER), $(D_INLINECODE GL_UNIFORM_BUFFER), or $(D_INLINECODE GL_SHADER_STORAGE_BUFFER).
     +     index  = Specify the index of the binding point within the array specified by $(D_INLINECODE target).
     +     buffer = The name of a buffer object to bind to the specified binding point.
     +     offset = The starting offset in basic machine units into the buffer object $(D_INLINECODE buffer).
     +     size   = The amount of data in machine units that can be read from the buffer object while used as an indexed target.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenBuffers), $(D_INLINECODE glDeleteBuffers), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glBindBufferBase), $(D_INLINECODE glMapBuffer), $(D_INLINECODE glUnmapBuffer),
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_uniform_buffer_object")
    fn_glBindBufferRange glBindBufferRange;
    alias fn_glBindBuffersBase = extern(System) void function(GLenum target, GLuint first, GLsizei count, const( GLuint*) buffers) @system @nogc nothrow;

    /++
     + glBindBuffersBase: man4/glBindBuffersBase.xml
     + 
     + $(D_INLINECODE glBindBuffersBase) binds a set of $(D_INLINECODE count) buffer objects whose names are given in the array $(D_INLINECODE buffers) to the $(D_INLINECODE count) consecutive binding points starting from index $(D_INLINECODE index) of the array of targets specified by $(D_INLINECODE target). If $(D_INLINECODE buffers) is $(D_INLINECODE null
     + ) then $(D_INLINECODE glBindBuffersBase) unbinds any buffers that are currently bound to the referenced binding points. Assuming no errors are generated, it is equivalent to the following pseudo-code, which calls $(D_INLINECODE glBindBufferBase) :
     + 
     + ---
     + for (i = 0; i &lt; count; i++) {
     +     if (buffers != NULL) {
     +         glBindBufferBase(target, first + i, buffers[i]);
     +     } else {
     +         glBindBufferBase(target, first + i, 0);
     +     }
     + }
     + ---
     + 
     + 
     + $(D_INLINECODE glBindBuffersBase) is available only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     target  = Specify the target of the bind operation. $(D_INLINECODE target) must be one of $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER), $(D_INLINECODE GL_UNIFORM_BUFFER) or $(D_INLINECODE GL_SHADER_STORAGE_BUFFER).
     +     index   = Specify the index of the first binding point within the array specified by $(D_INLINECODE target).
     +     count   = Specify the number of contiguous binding points to which to bind buffers.
     +     buffers = A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or $(D_INLINECODE null).
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenBuffers), $(D_INLINECODE glDeleteBuffers), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glBindBufferBase), $(D_INLINECODE glBindBufferRange), $(D_INLINECODE glBindBuffersRange), $(D_INLINECODE glMapBuffer), $(D_INLINECODE glUnmapBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P4)
    @OpenGL_Extension("GL_ARB_multi_bind")
    fn_glBindBuffersBase glBindBuffersBase;
    alias fn_glBindBuffersRange = extern(System) void function(GLenum target, GLuint first, GLsizei count, const( GLuint*) buffers, const( GLintptr*) offsets, const( GLintptr*) sizes) @system @nogc nothrow;

    /++
     + glBindBuffersRange: man4/glBindBuffersRange.xml
     + 
     + $(D_INLINECODE glBindBuffersRange) binds a set of $(D_INLINECODE count) ranges from buffer objects whose names are given in the array $(D_INLINECODE buffers) to the $(D_INLINECODE count) consecutive binding points starting from index $(D_INLINECODE index) of the array of targets specified by $(D_INLINECODE target). $(D_INLINECODE offsets) specifies the address of an array containing $(D_INLINECODE count) starting offsets within the buffers, and $(D_INLINECODE sizes) specifies the adderess of an array of $(D_INLINECODE count) sizes of the ranges. If $(D_INLINECODE buffers) is $(D_INLINECODE null
     + ) then $(D_INLINECODE offsets) and $(D_INLINECODE sizes) are ignored and $(D_INLINECODE glBindBuffersRange) unbinds any buffers that are currently bound to the referenced binding points. Assuming no errors are generated, it is equivalent to the following pseudo-code, which calls $(D_INLINECODE glBindBufferRange) :
     + 
     + ---
     + for (i = 0; i &lt; count; i++) {
     +     if (buffers != NULL) {
     +         glBindBufferRange(target, first + i, buffers[i], offsets[i], sizes[i]);
     +     } else {
     +         glBindBufferBase(target, first + i, 0);
     +     }
     + }
     + ---
     + 
     + 
     + $(D_INLINECODE glBindBuffersBase) is available only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     target  = Specify the target of the bind operation. $(D_INLINECODE target) must be one of $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER), $(D_INLINECODE GL_UNIFORM_BUFFER) or $(D_INLINECODE GL_SHADER_STORAGE_BUFFER).
     +     index   = Specify the index of the first binding point within the array specified by $(D_INLINECODE target).
     +     count   = Specify the number of contiguous binding points to which to bind buffers.
     +     buffers = A pointer to an array of names of buffer objects to bind to the targets on the specified binding point, or $(D_INLINECODE null).
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenBuffers), $(D_INLINECODE glDeleteBuffers), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glBindBufferBase), $(D_INLINECODE glBindBufferRange), $(D_INLINECODE glBindBuffersRange), $(D_INLINECODE glMapBuffer), $(D_INLINECODE glUnmapBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P4)
    @OpenGL_Extension("GL_ARB_multi_bind")
    fn_glBindBuffersRange glBindBuffersRange;
    alias fn_glBindFragDataLocation = extern(System) void function(GLuint program, GLuint colorNumber, const( char*) name) @system @nogc nothrow;

    /++
     + glBindFragDataLocation: man4/glBindFragDataLocation.xml
     + 
     + $(D_INLINECODE glBindFragDataLocation) explicitly specifies the binding of the user-defined varying out variable $(D_INLINECODE name) to fragment shader color number $(D_INLINECODE colorNumber) for program $(D_INLINECODE program). If $(D_INLINECODE name) was bound previously, its assigned binding is replaced with $(D_INLINECODE colorNumber). $(D_INLINECODE name) must be a null-terminated string. $(D_INLINECODE colorNumber) must be less than $(D_INLINECODE GL_MAX_DRAW_BUFFERS). The bindings specified by $(D_INLINECODE glBindFragDataLocation) have no effect until $(D_INLINECODE program) is next linked. Bindings may be specified at any time after $(D_INLINECODE program) has been created. Specifically, they may be specified before shader objects are attached to the program. Therefore, any name may be specified in $(D_INLINECODE name), including a name that is never used as a varying out variable in any fragment shader object. Names beginning with $(D_INLINECODE gl_) are reserved by the GL. In addition to the errors generated by $(D_INLINECODE glBindFragDataLocation), the program $(D_INLINECODE program) will fail to link if: $(OL $(LI The number of active outputs is greater than the value $(D_INLINECODE GL_MAX_DRAW_BUFFERS).) $(LI More than one varying out variable is bound to the same color number.))
     + 
     + Varying out varyings may have indexed locations assigned explicitly in the shader text using a $(D_INLINECODE location) layout qualifier. If a shader statically assigns a location to a varying out variable in the shader text, that location is used and any location assigned with $(D_INLINECODE glBindFragDataLocation) is ignored.
     + 
     + Params:
     +     program     = The name of the program containing varying out variable whose binding to modify
     +     colorNumber = The color number to bind the user-defined varying out variable to
     +     name        = The name of the user-defined varying out variable whose binding to modify
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCreateProgram), $(D_INLINECODE glGetFragDataLocation)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glBindFragDataLocation glBindFragDataLocation;
    alias fn_glBindFragDataLocationIndexed = extern(System) void function(GLuint program, GLuint colorNumber, GLuint index, const( char*) name) @system @nogc nothrow;

    /++
     + glBindFragDataLocationIndexed: man4/glBindFragDataLocationIndexed.xml
     + 
     + $(D_INLINECODE glBindFragDataLocationIndexed) specifies that the varying out variable $(D_INLINECODE name) in $(D_INLINECODE program) should be bound to fragment color $(D_INLINECODE colorNumber) when the program is next linked. $(D_INLINECODE index) may be zero or one to specify that the color be used as either the first or second color input to the blend equation, respectively. The bindings specified by $(D_INLINECODE glBindFragDataLocationIndexed) have no effect until $(D_INLINECODE program) is next linked. Bindings may be specified at any time after $(D_INLINECODE program) has been created. Specifically, they may be specified before shader objects are attached to the program. Therefore, any name may be specified in $(D_INLINECODE name), including a name that is never used as a varying out variable in any fragment shader object. Names beginning with $(D_INLINECODE gl_) are reserved by the GL. If $(D_INLINECODE name) was bound previously, its assigned binding is replaced with $(D_INLINECODE colorNumber) and $(D_INLINECODE index). $(D_INLINECODE name) must be a null-terminated string. $(D_INLINECODE index) must be less than or equal to one, and $(D_INLINECODE colorNumber) must be less than the value of $(D_INLINECODE GL_MAX_DRAW_BUFFERS) if $(D_INLINECODE index) is zero, and less than the value of $(D_INLINECODE GL_MAX_DUAL_SOURCE_DRAW_BUFFERS) if index is greater than or equal to one. In addition to the errors generated by $(D_INLINECODE glBindFragDataLocationIndexed), the program $(D_INLINECODE program) will fail to link if: $(OL $(LI The number of active outputs is greater than the value $(D_INLINECODE GL_MAX_DRAW_BUFFERS).) $(LI More than one varying out variable is bound to the same color number.))
     + 
     + Varying out varyings may have locations assigned explicitly in the shader text using a $(D_INLINECODE location) layout qualifier. If a shader statically assigns a location to a varying out variable in the shader text, that location is used and any location assigned with $(D_INLINECODE glBindFragDataLocation) is ignored.
     + 
     + Params:
     +     program     = The name of the program containing varying out variable whose binding to modify
     +     colorNumber = The color number to bind the user-defined varying out variable to
     +     index       = The index of the color input to bind the user-defined varying out variable to
     +     name        = The name of the user-defined varying out variable whose binding to modify
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCreateProgram), $(D_INLINECODE glLinkProgram) $(D_INLINECODE glGetFragDataLocation), $(D_INLINECODE glGetFragDataIndex) $(D_INLINECODE glBindFragDataLocation)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_blend_func_extended")
    fn_glBindFragDataLocationIndexed glBindFragDataLocationIndexed;
    alias fn_glBindFramebuffer = extern(System) void function(GLenum target, GLuint framebuffer) @system @nogc nothrow;

    /++
     + glBindFramebuffer: man4/glBindFramebuffer.xml
     + 
     + $(D_INLINECODE glBindFramebuffer) binds the framebuffer object with name $(D_INLINECODE framebuffer) to the framebuffer target specified by $(D_INLINECODE target). $(D_INLINECODE target) must be either $(D_INLINECODE GL_DRAW_FRAMEBUFFER), $(D_INLINECODE GL_READ_FRAMEBUFFER) or $(D_INLINECODE GL_FRAMEBUFFER). If a framebuffer object is bound to $(D_INLINECODE GL_DRAW_FRAMEBUFFER) or $(D_INLINECODE GL_READ_FRAMEBUFFER), it becomes the target for rendering or readback operations, respectively, until it is deleted or another framebuffer is bound to the corresponding bind point. Calling $(D_INLINECODE glBindFramebuffer) with $(D_INLINECODE target) set to $(D_INLINECODE GL_FRAMEBUFFER) binds $(D_INLINECODE framebuffer) to both the read and draw framebuffer targets. $(D_INLINECODE framebuffer) is the name of a framebuffer object previously returned from a call to $(D_INLINECODE glGenFramebuffers), or zero to break the existing binding of a framebuffer object to $(D_INLINECODE target).
     + 
     + Params:
     +     target      = Specifies the framebuffer target of the binding operation.
     +     framebuffer = Specifies the name of the framebuffer object to bind.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenFramebuffers), $(D_INLINECODE glFramebufferRenderbuffer), $(D_INLINECODE glFramebufferTexture), $(D_INLINECODE glFramebufferTexture1D), $(D_INLINECODE glFramebufferTexture2D), $(D_INLINECODE glFramebufferTexture3D), $(D_INLINECODE glFramebufferTextureLayer), $(D_INLINECODE glDeleteFramebuffers), $(D_INLINECODE glIsFramebuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    fn_glBindFramebuffer glBindFramebuffer;
    alias fn_glBindImageTexture = extern(System) void function(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format) @system @nogc nothrow;

    /++
     + glBindImageTexture: man4/glBindImageTexture.xml
     + 
     + $(D_INLINECODE glBindImageTexture) binds a single level of a texture to an image unit for the purpose of reading and writing it from shaders. $(D_INLINECODE unit) specifies the zero-based index of the image unit to which to bind the texture level. $(D_INLINECODE texture) specifies the name of an existing texture object to bind to the image unit. If $(D_INLINECODE texture) is zero, then any existing binding to the image unit is broken. $(D_INLINECODE level) specifies the level of the texture to bind to the image unit. If $(D_INLINECODE texture) is the name of a one-, two-, or three-dimensional array texture, a cube map or cube map array texture, or a two-dimensional multisample array texture, then it is possible to bind either the entire array, or only a single layer of the array to the image unit. In such cases, if $(D_INLINECODE layered) is $(D_INLINECODE GL_TRUE), the entire array is attached to the image unit and $(D_INLINECODE layer) is ignored. However, if $(D_INLINECODE layered) is $(D_INLINECODE GL_FALSE) then $(D_INLINECODE layer) specifies the layer of the array to attach to the image unit. $(D_INLINECODE access) specifies the access types to be performed by shaders and may be set to $(D_INLINECODE GL_READ_ONLY), $(D_INLINECODE GL_WRITE_ONLY), or $(D_INLINECODE GL_READ_WRITE) to indicate read-only, write-only or read-write access, respectively. Violation of the access type specified in $(D_INLINECODE access) (for example, if a shader writes to an image bound with $(D_INLINECODE access) set to $(D_INLINECODE GL_READ_ONLY) ) will lead to undefined results, possibly including program termination. $(D_INLINECODE format) specifies the format that is to be used when performing formatted stores into the image from shaders. $(D_INLINECODE format) must be compatible with the texture's internal format and must be one of the formats listed in the following table.<h3> Internal Image Formats</h3> $(B Image Unit Format) $(B Format Qualifier) $(D_INLINECODE GL_RGBA32F) $(D_INLINECODE rgba32f) $(D_INLINECODE GL_RGBA16F) $(D_INLINECODE rgba16f) $(D_INLINECODE GL_RG32F) $(D_INLINECODE rg32f) $(D_INLINECODE GL_RG16F) $(D_INLINECODE rg16f) $(D_INLINECODE GL_R11F_G11F_B10F) $(D_INLINECODE r11f_g11f_b10f) $(D_INLINECODE GL_R32F) $(D_INLINECODE r32f) $(D_INLINECODE GL_R16F) $(D_INLINECODE r16f) $(D_INLINECODE GL_RGBA32UI) $(D_INLINECODE rgba32ui) $(D_INLINECODE GL_RGBA16UI) $(D_INLINECODE rgba16ui) $(D_INLINECODE GL_RGB10_A2UI) $(D_INLINECODE rgb10_a2ui) $(D_INLINECODE GL_RGBA8UI) $(D_INLINECODE rgba8ui) $(D_INLINECODE GL_RG32UI) $(D_INLINECODE rg32ui) $(D_INLINECODE GL_RG16UI) $(D_INLINECODE rg16ui) $(D_INLINECODE GL_RG8UI) $(D_INLINECODE rg8ui) $(D_INLINECODE GL_R32UI) $(D_INLINECODE r32ui) $(D_INLINECODE GL_R16UI) $(D_INLINECODE r16ui) $(D_INLINECODE GL_R8UI) $(D_INLINECODE r8ui) $(D_INLINECODE GL_RGBA32I) $(D_INLINECODE rgba32i) $(D_INLINECODE GL_RGBA16I) $(D_INLINECODE rgba16i) $(D_INLINECODE GL_RGBA8I) $(D_INLINECODE rgba8i) $(D_INLINECODE GL_RG32I) $(D_INLINECODE rg32i) $(D_INLINECODE GL_RG16I) $(D_INLINECODE rg16i) $(D_INLINECODE GL_RG8I) $(D_INLINECODE rg8i) $(D_INLINECODE GL_R32I) $(D_INLINECODE r32i) $(D_INLINECODE GL_R16I) $(D_INLINECODE r16i) $(D_INLINECODE GL_R8I) $(D_INLINECODE r8i) $(D_INLINECODE GL_RGBA16) $(D_INLINECODE rgba16) $(D_INLINECODE GL_RGB10_A2) $(D_INLINECODE rgb10_a2) $(D_INLINECODE GL_RGBA8) $(D_INLINECODE rgba8) $(D_INLINECODE GL_RG16) $(D_INLINECODE rg16) $(D_INLINECODE GL_RG8) $(D_INLINECODE rg8) $(D_INLINECODE GL_R16) $(D_INLINECODE r16) $(D_INLINECODE GL_R8) $(D_INLINECODE r8) $(D_INLINECODE GL_RGBA16_SNORM) $(D_INLINECODE rgba16_snorm) $(D_INLINECODE GL_RGBA8_SNORM) $(D_INLINECODE rgba8_snorm) $(D_INLINECODE GL_RG16_SNORM) $(D_INLINECODE rg16_snorm) $(D_INLINECODE GL_RG8_SNORM) $(D_INLINECODE rg8_snorm) $(D_INLINECODE GL_R16_SNORM) $(D_INLINECODE r16_snorm) $(D_INLINECODE GL_R8_SNORM) $(D_INLINECODE r8_snorm) When a texture is bound to an image unit, the $(D_INLINECODE format) parameter for the image unit need not exactly match the texture internal format as long as the formats are considered compatible as defined in the OpenGL Specification. The matching criterion used for a given texture may be determined by calling $(D_INLINECODE glGetTexParameter) with $(D_INLINECODE value) set to $(D_INLINECODE GL_IMAGE_FORMAT_COMPATIBILITY_TYPE), with return values of $(D_INLINECODE GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE) and $(D_INLINECODE GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS), specifying matches by size and class, respectively.
     + 
     + The $(D_INLINECODE glBindImageTexture) is available only if the GL version is 4.2 or greater.
     + 
     + Params:
     +     unit    = Specifies the index of the image unit to which to bind the texture
     +     texture = Specifies the name of the texture to bind to the image unit.
     +     level   = Specifies the level of the texture that is to be bound.
     +     layered = Specifies whether a layered texture binding is to be established.
     +     layer   = If $(D_INLINECODE layered) is $(D_INLINECODE GL_FALSE), specifies the layer of $(D_INLINECODE texture) to be bound to the image unit. Ignored otherwise.
     +     access  = Specifies a token indicating the type of access that will be performed on the image.
     +     format  = Specifies the format that the elements of the image will be treated as for the purposes of formatted stores.
     + 
     + Copyright:
     +     Copyright&copy; 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenTextures), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexStorage1D), $(D_INLINECODE glTexStorage2D), $(D_INLINECODE glTexStorage3D), $(D_INLINECODE glBindTexture)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P2)
    @OpenGL_Extension("GL_ARB_shader_image_load_store")
    fn_glBindImageTexture glBindImageTexture;
    alias fn_glBindImageTextures = extern(System) void function(GLuint first, GLsizei count, const( GLuint*) textures) @system @nogc nothrow;

    /++
     + glBindImageTextures: man4/glBindImageTextures.xml
     + 
     + $(D_INLINECODE glBindImageTextures) binds images from an array of existing texture objects to a specified number of consecutive image units. $(D_INLINECODE count) specifies the number of texture objects whose names are stored in the array $(D_INLINECODE textures). That number of texture names are read from the array and bound to the $(D_INLINECODE count) consecutive texture units starting from $(D_INLINECODE first). If the name zero appears in the $(D_INLINECODE textures) array, any existing binding to the image unit is reset. Any non-zero entry in $(D_INLINECODE textures) must be the name of an existing texture object. When a non-zero entry in $(D_INLINECODE textures) is present, the image at level zero is bound, the binding is considered layered, with the first layer set to zero, and the image is bound for read-write access. The image unit format parameter is taken from the internal format of the image at level zero of the texture object. For cube map textures, the internal format of the positive X image of level zero is used. If $(D_INLINECODE textures) is $(D_INLINECODE null
     + ) then it is as if an appropriately sized array containing only zeros had been specified. $(D_INLINECODE glBindImageTextures) is equivalent to the following pseudo code:
     + 
     + ---
     + for (i = 0; i &lt; count; i++) {
     +     if (textures == NULL || textures[i] = 0) {
     +         glBindImageTexture(first + i, 0, 0, GL_FALSE, 0, GL_READ_ONLY, GL_R8);
     +     } else {
     +         glBindImageTexture(first + i, textures[i], 0, GL_TRUE, 0, GL_READ_WRITE, lookupInternalFormat(textures[i]));
     +     }
     + }
     + ---
     +  Each entry in $(D_INLINECODE textures) will be checked individually and if found to be invalid, the state for that image unit will not be changed and an error will be generated. However, the state for other texture image units referenced by the command will still be updated.
     + 
     + $(D_INLINECODE glBindImageTextures) is available only if the GL version is 4.4 or higher. Note that because $(D_INLINECODE glBindImageTextures) cannot create new textures (even if a name passed has been previously generated by call to $(D_INLINECODE glGenTextures) ), names pased to $(D_INLINECODE glBindTextures) must have been bound at least once previously via a call to $(D_INLINECODE glBindTexture).
     + 
     + Params:
     +     first    = Specifies the first image unit to which a texture is to be bound.
     +     count    = Specifies the number of textures to bind.
     +     textures = Specifies the address of an array of names of existing texture objects.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindTexture), $(D_INLINECODE glBindTextures), $(D_INLINECODE glDeleteTextures), $(D_INLINECODE glGenTextures), $(D_INLINECODE glGet), $(D_INLINECODE glGetTexParameter), $(D_INLINECODE glIsTexture), $(D_INLINECODE glTexStorage1D), $(D_INLINECODE glTexStorage2D), $(D_INLINECODE glTexStorage2DMultisample), $(D_INLINECODE glTexStorage3D), $(D_INLINECODE glTexStorage3DMultisample), $(D_INLINECODE glTexBuffer), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P4)
    @OpenGL_Extension("GL_ARB_multi_bind")
    fn_glBindImageTextures glBindImageTextures;
    alias fn_glBindProgramPipeline = extern(System) void function(GLuint pipeline) @system @nogc nothrow;

    /++
     + glBindProgramPipeline: man4/glBindProgramPipeline.xml
     + 
     + $(D_INLINECODE glBindProgramPipeline) binds a program pipeline object to the current context. $(D_INLINECODE pipeline) must be a name previously returned from a call to $(D_INLINECODE glGenProgramPipelines). If no program pipeline exists with name $(D_INLINECODE pipeline) then a new pipeline object is created with that name and initialized to the default state vector. When a program pipeline object is bound using $(D_INLINECODE glBindProgramPipeline), any previous binding is broken and is replaced with a binding to the specified pipeline object. If $(D_INLINECODE pipeline) is zero, the previous binding is broken and is not replaced, leaving no pipeline object bound. If no current program object has been established by $(D_INLINECODE glUseProgram), the program objects used for each stage and for uniform updates are taken from the bound program pipeline object, if any. If there is a current program object established by $(D_INLINECODE glUseProgram), the bound program pipeline object has no effect on rendering or uniform updates. When a bound program pipeline object is used for rendering, individual shader executables are taken from its program objects.
     + 
     + Params:
     +     pipeline = Specifies the name of the pipeline object to bind to the context.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCreateShader), $(D_INLINECODE glCreateProgram), $(D_INLINECODE glCompileShader), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glGenProgramPipelines), $(D_INLINECODE glDeleteProgramPipelines), $(D_INLINECODE glIsProgramPipeline)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glBindProgramPipeline glBindProgramPipeline;
    alias fn_glBindRenderbuffer = extern(System) void function(GLenum target, GLuint renderbuffer) @system @nogc nothrow;

    /++
     + glBindRenderbuffer: man4/glBindRenderbuffer.xml
     + 
     + $(D_INLINECODE glBindRenderbuffer) binds the renderbuffer object with name $(D_INLINECODE renderbuffer) to the renderbuffer target specified by $(D_INLINECODE target). $(D_INLINECODE target) must be $(D_INLINECODE GL_RENDERBUFFER). $(D_INLINECODE renderbuffer) is the name of a renderbuffer object previously returned from a call to $(D_INLINECODE glGenRenderbuffers), or zero to break the existing binding of a renderbuffer object to $(D_INLINECODE target).
     + 
     + Params:
     +     target       = Specifies the renderbuffer target of the binding operation. $(D_INLINECODE target) must be $(D_INLINECODE GL_RENDERBUFFER).
     +     renderbuffer = Specifies the name of the renderbuffer object to bind.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDeleteRenderbuffers), $(D_INLINECODE glGenRenderbuffers), $(D_INLINECODE glIsRenderbuffer), $(D_INLINECODE glRenderbufferStorage), $(D_INLINECODE glRenderbufferStorageMultisample)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    fn_glBindRenderbuffer glBindRenderbuffer;
    alias fn_glBindSampler = extern(System) void function(GLuint unit, GLuint sampler) @system @nogc nothrow;

    /++
     + glBindSampler: man4/glBindSampler.xml
     + 
     + $(D_INLINECODE glBindSampler) binds $(D_INLINECODE sampler) to the texture unit at index $(D_INLINECODE unit). $(D_INLINECODE sampler) must be zero or the name of a sampler object previously returned from a call to $(D_INLINECODE glGenSamplers). $(D_INLINECODE unit) must be less than the value of $(D_INLINECODE GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS). When a sampler object is bound to a texture unit, its state supersedes that of the texture object bound to that texture unit. If the sampler name zero is bound to a texture unit, the currently bound texture's sampler state becomes active. A single sampler object may be bound to multiple texture units simultaneously.
     + 
     + $(D_INLINECODE glBindSampler) is available only if the GL version is 3.3 or higher.
     + 
     + Params:
     +     unit    = Specifies the index of the texture unit to which the sampler is bound.
     +     sampler = Specifies the name of a sampler.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenSamplers), $(D_INLINECODE glDeleteSamplers), $(D_INLINECODE glGet), $(D_INLINECODE glSamplerParameter), $(D_INLINECODE glGetSamplerParameter), $(D_INLINECODE glGenTextures), $(D_INLINECODE glBindTexture), $(D_INLINECODE glDeleteTextures)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    fn_glBindSampler glBindSampler;
    alias fn_glBindSamplers = extern(System) void function(GLuint first, GLsizei count, const( GLuint*) samplers) @system @nogc nothrow;

    /++
     + glBindSamplers: man4/glBindSamplers.xml
     + 
     + $(D_INLINECODE glBindSamplers) binds samplers from an array of existing sampler objects to a specified number of consecutive sampler units. $(D_INLINECODE count) specifies the number of sampler objects whose names are stored in the array $(D_INLINECODE samplers). That number of sampler names is read from the array and bound to the $(D_INLINECODE count) consecutive sampler units starting from $(D_INLINECODE first). If the name zero appears in the $(D_INLINECODE samplers) array, any existing binding to the sampler unit is reset. Any non-zero entry in $(D_INLINECODE samplers) must be the name of an existing sampler object. When a non-zero entry in $(D_INLINECODE samplers) is present, that sampler object is bound to the corresponding sampler unit. If $(D_INLINECODE samplers) is $(D_INLINECODE null
     + ) then it is as if an appropriately sized array containing only zeros had been specified. $(D_INLINECODE glBindSamplers) is equivalent to the following pseudo code:
     + 
     + ---
     + for (i = 0; i &lt; count; i++) {
     +     if (samplers == NULL) {
     +         glBindSampler(first + i, 0);
     +     } else {
     +         glBindSampler(first + i, samplers[i]);
     +     }
     + }
     + ---
     +  Each entry in $(D_INLINECODE samplers) will be checked individually and if found to be invalid, the state for that sampler unit will not be changed and an error will be generated. However, the state for other sampler units referenced by the command will still be updated.
     + 
     + $(D_INLINECODE glBindSamplers) is available only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     first    = Specifies the first sampler unit to which a sampler object is to be bound.
     +     count    = Specifies the number of samplers to bind.
     +     samplers = Specifies the address of an array of names of existing sampler objects.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenSamplers), $(D_INLINECODE glBindSampler), $(D_INLINECODE glDeleteSamplers), $(D_INLINECODE glGet), $(D_INLINECODE glSamplerParameter), $(D_INLINECODE glGetSamplerParameter), $(D_INLINECODE glGenTextures), $(D_INLINECODE glBindTexture), $(D_INLINECODE glDeleteTextures)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P4)
    @OpenGL_Extension("GL_ARB_multi_bind")
    fn_glBindSamplers glBindSamplers;
    alias fn_glBindTexture = extern(System) void function(GLenum target, GLuint texture) @system @nogc nothrow;

    /++
     + glBindTexture: man4/glBindTexture.xml
     + 
     + $(D_INLINECODE glBindTexture) lets you create or use a named texture. Calling $(D_INLINECODE glBindTexture) with $(D_INLINECODE target) set to $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_RECTANGLE), $(D_INLINECODE GL_TEXTURE_CUBE_MAP), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY), $(D_INLINECODE GL_TEXTURE_BUFFER), $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE) or $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY) and $(D_INLINECODE texture) set to the name of the new texture binds the texture name to the target. When a texture is bound to a target, the previous binding for that target is automatically broken. Texture names are unsigned integers. The value zero is reserved to represent the default texture for each texture target. Texture names and the corresponding texture contents are local to the shared object space of the current GL rendering context; two rendering contexts share texture names only if they explicitly enable sharing between contexts through the appropriate GL windows interfaces functions. You must use $(D_INLINECODE glGenTextures) to generate a set of new texture names. When a texture is first bound, it assumes the specified target: A texture first bound to $(D_INLINECODE GL_TEXTURE_1D) becomes one-dimensional texture, a texture first bound to $(D_INLINECODE GL_TEXTURE_2D) becomes two-dimensional texture, a texture first bound to $(D_INLINECODE GL_TEXTURE_3D) becomes three-dimensional texture, a texture first bound to $(D_INLINECODE GL_TEXTURE_1D_ARRAY) becomes one-dimensional array texture, a texture first bound to $(D_INLINECODE GL_TEXTURE_2D_ARRAY) becomes two-dimensional array texture, a texture first bound to $(D_INLINECODE GL_TEXTURE_RECTANGLE) becomes rectangle texture, a texture first bound to $(D_INLINECODE GL_TEXTURE_CUBE_MAP) becomes a cube-mapped texture, a texture first bound to $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY) becomes a cube-mapped array texture, a texture first bound to $(D_INLINECODE GL_TEXTURE_BUFFER) becomes a buffer texture, a texture first bound to $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE) becomes a two-dimensional multisampled texture, and a texture first bound to $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY) becomes a two-dimensional multisampled array texture. The state of a one-dimensional texture immediately after it is first bound is equivalent to the state of the default $(D_INLINECODE GL_TEXTURE_1D) at GL initialization, and similarly for the other texture types. While a texture is bound, GL operations on the target to which it is bound affect the bound texture, and queries of the target to which it is bound return state from the bound texture. In effect, the texture targets become aliases for the textures currently bound to them, and the texture name zero refers to the default textures that were bound to them at initialization. A texture binding created with $(D_INLINECODE glBindTexture) remains active until a different texture is bound to the same target, or until the bound texture is deleted with $(D_INLINECODE glDeleteTextures). Once created, a named texture may be re-bound to its same original target as often as needed. It is usually much faster to use $(D_INLINECODE glBindTexture) to bind an existing named texture to one of the texture targets than it is to reload the texture image using $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D) or another similar function.
     + 
     + The $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE) and $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY) targets are available only if the GL version is 3.2 or higher.
     + 
     + Params:
     +     target  = Specifies the target to which the texture is bound. Must be one of $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_RECTANGLE), $(D_INLINECODE GL_TEXTURE_CUBE_MAP), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY), $(D_INLINECODE GL_TEXTURE_BUFFER), $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE) or $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY).
     +     texture = Specifies the name of a texture.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDeleteTextures), $(D_INLINECODE glGenTextures), $(D_INLINECODE glGet), $(D_INLINECODE glGetTexParameter), $(D_INLINECODE glIsTexture), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage2DMultisample), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexImage3DMultisample), $(D_INLINECODE glTexBuffer), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    fn_glBindTexture glBindTexture;
    alias fn_glBindTextures = extern(System) void function(GLuint first, GLsizei count, const( GLuint*) textures) @system @nogc nothrow;

    /++
     + glBindTextures: man4/glBindTextures.xml
     + 
     + $(D_INLINECODE glBindTextures) binds an array of existing texture objects to a specified number of consecutive texture units. $(D_INLINECODE count) specifies the number of texture objects whose names are stored in the array $(D_INLINECODE textures). That number of texture names are read from the array and bound to the $(D_INLINECODE count) consecutive texture units starting from $(D_INLINECODE first). The target, or type of texture is deduced from the texture object and each texture is bound to the corresponding target of the texture unit. If the name zero appears in the $(D_INLINECODE textures) array, any existing binding to any target of the texture unit is reset and the default texture for that target is bound in its place. Any non-zero entry in $(D_INLINECODE textures) must be the name of an existing texture object. If $(D_INLINECODE textures) is $(D_INLINECODE null
     + ) then it is as if an appropriately sized array containing only zeros had been specified. With the exception that the active texture selector maintains its current value, $(D_INLINECODE glBindTextures) is equivalent to the following pseudo code:
     + 
     + ---
     + for (i = 0; i &lt; count; i++) {
     +     GLuint texture;
     +     if (textures == NULL) {
     +         texture = 0;
     +     } else {
     +         texture = textures[i];
     +     }
     +     glActiveTexture(GL_TEXTURE0 + first + i);
     +     if (texture != 0) {
     +         GLenum target = /* target of textures[i] */;
     +         glBindTexture(target, textures[i]);
     +     } else {
     +         for (target in all supported targets) {
     +             glBindTexture(target, 0);
     +         }
     +     }
     + }
     + ---
     +  Each entry in $(D_INLINECODE textures) will be checked individually and if found to be invalid, the state for that texture unit will not be changed and an error will be generated. However, the state for other texture units referenced by the command will still be updated.
     + 
     + $(D_INLINECODE glBindTextures) is available only if the GL version is 4.4 or higher. Note that because $(D_INLINECODE glBindTextures) cannot create new textures (even if a name passed has been previously generated by call to $(D_INLINECODE glGenTextures) ), names pased to $(D_INLINECODE glBindTextures) must have been bound at least once previously via a call to $(D_INLINECODE glBindTexture).
     + 
     + Params:
     +     first    = Specifies the first texture unit to which a texture is to be bound.
     +     count    = Specifies the number of textures to bind.
     +     textures = Specifies the address of an array of names of existing texture objects.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindTexture), $(D_INLINECODE glDeleteTextures), $(D_INLINECODE glGenTextures), $(D_INLINECODE glGet), $(D_INLINECODE glGetTexParameter), $(D_INLINECODE glIsTexture), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage2DMultisample), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexImage3DMultisample), $(D_INLINECODE glTexBuffer), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P4)
    @OpenGL_Extension("GL_ARB_multi_bind")
    fn_glBindTextures glBindTextures;
    alias fn_glBindTextureUnit = extern(System) void function(GLuint unit, GLuint texture) @system @nogc nothrow;

    /++
     + glBindTextureUnit: man4/glBindTextureUnit.xml
     + 
     + $(D_INLINECODE glBindTextureUnit) binds an existing texture object to the texture unit numbered $(D_INLINECODE unit). $(D_INLINECODE texture) must be zero or the name of an existing texture object. When $(D_INLINECODE texture) is the name of an existing texture object, that object is bound to the target, in the corresponding texture unit, that was specified when the object was created. When $(D_INLINECODE texture) is zero, each of the targets enumerated at the beginning of this section is reset to its default texture for the corresponding texture image unit.
     + 
     + Params:
     +     unit    = Specifies the texture unit, to which the texture object should be bound to.
     +     texture = Specifies the name of a texture.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDeleteTextures), $(D_INLINECODE glGenTextures), $(D_INLINECODE glGet), $(D_INLINECODE glGetTexParameter), $(D_INLINECODE glIsTexture), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage2DMultisample), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexImage3DMultisample), $(D_INLINECODE glTexBuffer), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glBindTextureUnit glBindTextureUnit;
    alias fn_glBindTransformFeedback = extern(System) void function(GLenum target, GLuint id) @system @nogc nothrow;

    /++
     + glBindTransformFeedback: man4/glBindTransformFeedback.xml
     + 
     + $(D_INLINECODE glBindTransformFeedback) binds the transform feedback object with name $(D_INLINECODE id) to the current GL state. $(D_INLINECODE id) must be a name previously returned from a call to $(D_INLINECODE glGenTransformFeedbacks). If $(D_INLINECODE id) has not previously been bound, a new transform feedback object with name $(D_INLINECODE id) and initialized with with the default transform state vector is created. In the initial state, a default transform feedback object is bound and treated as a transform feedback object with a name of zero. If the name zero is subsequently bound, the default transform feedback object is again bound to the GL state. While a transform feedback buffer object is bound, GL operations on the target to which it is bound affect the bound transform feedback object, and queries of the target to which a transform feedback object is bound return state from the bound object. When buffer objects are bound for transform feedback, they are attached to the currently bound transform feedback object. Buffer objects are used for trans- form feedback only if they are attached to the currently bound transform feedback object.
     + 
     + Params:
     +     target = Specifies the target to which to bind the transform feedback object $(D_INLINECODE id). $(D_INLINECODE target) must be $(D_INLINECODE GL_TRANSFORM_FEEDBACK).
     +     id     = Specifies the name of a transform feedback object reserved by $(D_INLINECODE glGenTransformFeedbacks).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenTransformFeedbacks), $(D_INLINECODE glDeleteTransformFeedbacks), $(D_INLINECODE glIsTransformFeedback), $(D_INLINECODE glBeginTransformFeedback), $(D_INLINECODE glPauseTransformFeedback), $(D_INLINECODE glResumeTransformFeedback), $(D_INLINECODE glEndTransformFeedback)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_transform_feedback2")
    fn_glBindTransformFeedback glBindTransformFeedback;
    alias fn_glBindVertexArray = extern(System) void function(GLuint array) @system @nogc nothrow;

    /++
     + glBindVertexArray: man4/glBindVertexArray.xml
     + 
     + $(D_INLINECODE glBindVertexArray) binds the vertex array object with name $(D_INLINECODE array). $(D_INLINECODE array) is the name of a vertex array object previously returned from a call to $(D_INLINECODE glGenVertexArrays), or zero to break the existing vertex array object binding. If no vertex array object with name $(D_INLINECODE array) exists, one is created when $(D_INLINECODE array) is first bound. If the bind is successful no change is made to the state of the vertex array object, and any previous vertex array object binding is broken.
     + 
     + Params:
     +     array = Specifies the name of the vertex array to bind.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDeleteVertexArrays), $(D_INLINECODE glEnableVertexAttribArray), $(D_INLINECODE glGenVertexArrays), $(D_INLINECODE glIsVertexArray), $(D_INLINECODE glVertexAttribPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_vertex_array_object")
    fn_glBindVertexArray glBindVertexArray;
    alias fn_glBindVertexBuffer = extern(System) void function(GLuint bindingindex, GLuint buffer, GLintptr offset, GLintptr stride) @system @nogc nothrow;

    /++
     + glBindVertexBuffer: man4/glBindVertexBuffer.xml
     + 
     + $(D_INLINECODE glBindVertexBuffer) and $(D_INLINECODE glVertexArrayVertexBuffer) bind the buffer named $(D_INLINECODE buffer) to the vertex buffer binding point whose index is given by $(D_INLINECODE bindingindex). $(D_INLINECODE glBindVertexBuffer) modifies the binding of the currently bound vertex array object, whereas $(D_INLINECODE glVertexArrayVertexBuffer) allows the caller to specify ID of the vertex array object with an argument named $(D_INLINECODE vaobj), for which the binding should be modified. $(D_INLINECODE offset) and $(D_INLINECODE stride) specify the offset of the first element within the buffer and the distance between elements within the buffer, respectively, and are both measured in basic machine units. $(D_INLINECODE bindingindex) must be less than the value of $(D_INLINECODE GL_MAX_VERTEX_ATTRIB_BINDINGS). $(D_INLINECODE offset) and $(D_INLINECODE stride) must be greater than or equal to zero. If $(D_INLINECODE buffer) is zero, then any buffer currently bound to the specified binding point is unbound. If $(D_INLINECODE buffer) is not the name of an existing buffer object, the GL first creates a new state vector, initialized with a zero-sized memory buffer and comprising all the state and with the same initial values as in case of $(D_INLINECODE glBindBuffer). $(D_INLINECODE buffer) is then attached to the specified $(D_INLINECODE bindingindex) of the vertex array object.
     + 
     + Params:
     +     vaobj        = Specifies the name of the vertex array object to be used by $(D_INLINECODE glVertexArrayVertexBuffer) function.
     +     bindingindex = The index of the vertex buffer binding point to which to bind the buffer.
     +     buffer       = The name of a buffer to bind to the vertex buffer binding point.
     +     offset       = The offset of the first element of the buffer.
     +     stride       = The distance between elements within the buffer.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glVertexAttribBinding), $(D_INLINECODE glVertexAttribFormat), $(D_INLINECODE glVertexAttribPointer), $(D_INLINECODE glVertexBindingDivisor).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_vertex_attrib_binding")
    fn_glBindVertexBuffer glBindVertexBuffer;
    alias fn_glVertexArrayVertexBuffer = extern(System) void function(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glVertexArrayVertexBuffer glVertexArrayVertexBuffer;
    alias fn_glBindVertexBuffers = extern(System) void function(GLuint first, GLsizei count, const( GLuint*) buffers, const( GLuintptr*) offsets, const( GLsizei*) strides) @system @nogc nothrow;

    /++
     + glBindVertexBuffers: man4/glBindVertexBuffers.xml
     + 
     + $(D_INLINECODE glBindVertexBuffers) and $(D_INLINECODE glVertexArrayVertexBuffers) bind storage from an array of existing buffer objects to a specified number of consecutive vertex buffer binding points units in a vertex array object. For $(D_INLINECODE glBindVertexBuffers), the vertex array object is the currently bound vertex array object. For $(D_INLINECODE glVertexArrayVertexBuffers), $(D_INLINECODE vaobj) is the name of the vertex array object. $(D_INLINECODE count) existing buffer objects are bound to vertex buffer binding points numbered $first$ through $first + count - 1$. If $(D_INLINECODE buffers) is not null, it
     +  specifies an array of
     +  $(D_INLINECODE count) values, each of which must be zero or the name of an existing buffer object. $(D_INLINECODE offsets) and $(D_INLINECODE strides) specify arrays of $(D_INLINECODE count) values indicating the offset of the first element and stride between elements in each buffer, respectively. If $(D_INLINECODE buffers) is null, each
     +  affected vertex buffer binding point from $first$ through $first
     +  + count - 1$ will be reset to have no bound buffer object. In
     +  this case, the offsets and strides associated with the binding
     +  points are set to default values, ignoring
     +  $(D_INLINECODE offsets) and $(D_INLINECODE strides). $(D_INLINECODE glBindVertexBuffers) is equivalent (assuming no errors are generated) to:
     + 
     + ---
     + for (i = 0; i &lt; count; i++) {
     +     if (buffers == NULL) {
     +         glBindVertexBuffer(first + i, 0, 0, 16);
     +     } else {
     +         glBindVertexBuffer(first + i, buffers[i], offsets[i], strides[i]);
     +     }
     + }
     + ---
     +  except that buffers will not be created if they do not exist. $(D_INLINECODE glVertexArrayVertexBuffers) is equivalent to the pseudocode above, but replacing $(D_INLINECODE glBindVertexBuffers) (args) with $(D_INLINECODE glVertexArrayVertexBuffers) (vaobj, args). The values specified in $(D_INLINECODE buffers), $(D_INLINECODE offsets), and $(D_INLINECODE strides) will be checked separately for each vertex buffer binding point. When a value for a specific vertex buffer binding point is invalid, the state for that binding point will be unchanged and an error will be generated. However, state for other vertex buffer binding points will still be changed if their corresponding values are valid.
     + 
     + Params:
     +     vaobj   = Specifies the name of the vertex array object for $(D_INLINECODE glVertexArrayVertexBuffers).
     +     first   = Specifies the first vertex buffer binding point to which a buffer object is to be bound.
     +     count   = Specifies the number of buffers to bind.
     +     buffers = Specifies the address of an array of names of existing buffer objects.
     +     offsets = Specifies the address of an array of offsets to associate with the binding points.
     +     buffers = Specifies the address of an array of strides to associate with the binding points.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenBuffers), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glDeleteBuffers) $(D_INLINECODE glDeleteTextures)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P4)
    @OpenGL_Extension("GL_ARB_multi_bind")
    fn_glBindVertexBuffers glBindVertexBuffers;
    alias fn_glVertexArrayVertexBuffers = extern(System) void function(GLuint vaobj, GLuint first, GLsizei count, const( GLuint*) buffers, const( GLintptr*) offsets, const( GLsizei*) strides) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glVertexArrayVertexBuffers glVertexArrayVertexBuffers;
    alias fn_glBlendColor = extern(System) void function(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) @system @nogc nothrow;

    /++
     + glBlendColor: man4/glBlendColor.xml
     + 
     + The $(D_INLINECODE GL_BLEND_COLOR) may be used to calculate the source and destination blending factors. The color components are clamped to the range 0 1 before being stored. See $(D_INLINECODE glBlendFunc) for a complete description of the blending operations. Initially the $(D_INLINECODE GL_BLEND_COLOR) is set to (0, 0, 0, 0).
     + 
     + The type of the $(D_INLINECODE red), $(D_INLINECODE green), $(D_INLINECODE blue), and $(D_INLINECODE alpha) parameters was changed from GLclampf to GLfloat. This change is transparent to user code and is described in detail on the $(D_INLINECODE removedTypes) page.
     + 
     + Params:
     +     red = specify the components of $(D_INLINECODE GL_BLEND_COLOR)
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBlendEquation), $(D_INLINECODE glBlendFunc), $(D_INLINECODE glGetString), $(D_INLINECODE removedTypes)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    @OpenGL_Extension("GL_ARB_imaging")
    fn_glBlendColor glBlendColor;
    alias fn_glBlendEquation = extern(System) void function(GLenum mode) @system @nogc nothrow;

    /++
     + glBlendEquation: man4/glBlendEquation.xml
     + 
     + The blend equations determine how a new pixel (the ''source'' color) is combined with a pixel already in the framebuffer (the ''destination'' color).  This function sets both the RGB blend equation and the alpha blend equation to a single equation. $(D_INLINECODE glBlendEquationi) specifies the blend equation for a single draw buffer whereas $(D_INLINECODE glBlendEquation) sets the blend equation for all draw buffers. These equations use the source and destination blend factors specified by either $(D_INLINECODE glBlendFunc) or $(D_INLINECODE glBlendFuncSeparate). See $(D_INLINECODE glBlendFunc) or $(D_INLINECODE glBlendFuncSeparate) for a description of the various blend factors. In the equations that follow, source and destination color components are referred to as R s G s B s A s and R d G d B d A d, respectively. The result color is referred to as R r G r B r A r. The source and destination blend factors are denoted s R s G s B s A and d R d G d B d A, respectively. For these equations all color components are understood to have values in the range 0 1. $(B Mode) $(B RGB Components) $(B Alpha Component) $(D_INLINECODE GL_FUNC_ADD) Rr = R s &it; s R + R d &it; d R Gr = G s &it; s G + G d &it; d G Br = B s &it; s B + B d &it; d B Ar = A s &it; s A + A d &it; d A $(D_INLINECODE GL_FUNC_SUBTRACT) Rr = R s &it; s R - R d &it; d R Gr = G s &it; s G - G d &it; d G Br = B s &it; s B - B d &it; d B Ar = A s &it; s A - A d &it; d A $(D_INLINECODE GL_FUNC_REVERSE_SUBTRACT) Rr = R d &it; d R - R s &it; s R Gr = G d &it; d G - G s &it; s G Br = B d &it; d B - B s &it; s B Ar = A d &it; d A - A s &it; s A $(D_INLINECODE GL_MIN) Rr = min &af; R s R d Gr = min &af; G s G d Br = min &af; B s B d Ar = min &af; A s A d $(D_INLINECODE GL_MAX) Rr = max &af; R s R d Gr = max &af; G s G d Br = max &af; B s B d Ar = max &af; A s A d The results of these equations are clamped to the range 0 1. The $(D_INLINECODE GL_MIN) and $(D_INLINECODE GL_MAX) equations are useful for applications that analyze image data (image thresholding against a constant color, for example). The $(D_INLINECODE GL_FUNC_ADD) equation is useful for antialiasing and transparency, among other things. Initially, both the RGB blend equation and the alpha blend equation are set to $(D_INLINECODE GL_FUNC_ADD).
     + 
     + The $(D_INLINECODE GL_MIN), and $(D_INLINECODE GL_MAX) equations do not use the source or destination factors, only the source and destination colors.
     + 
     + Params:
     +     buf  = for $(D_INLINECODE glBlendEquationi), specifies the index of the draw buffer for which to set the blend equation.
     +     mode = specifies how source and destination colors are combined. It must be $(D_INLINECODE GL_FUNC_ADD), $(D_INLINECODE GL_FUNC_SUBTRACT), $(D_INLINECODE GL_FUNC_REVERSE_SUBTRACT), $(D_INLINECODE GL_MIN), $(D_INLINECODE GL_MAX).
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBlendColor), $(D_INLINECODE glBlendFunc) $(D_INLINECODE glBlendFuncSeparate)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    @OpenGL_Extension("GL_ARB_imaging")
    fn_glBlendEquation glBlendEquation;
    alias fn_glBlendEquationi = extern(System) void function(GLuint buf, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    fn_glBlendEquationi glBlendEquationi;
    alias fn_glBlendEquationSeparate = extern(System) void function(GLenum modeRGB, GLenum modeAlpha) @system @nogc nothrow;

    /++
     + glBlendEquationSeparate: man4/glBlendEquationSeparate.xml
     + 
     + The blend equations determines how a new pixel (the ''source'' color) is combined with a pixel already in the framebuffer (the ''destination'' color).  These functions specify one blend equation for the RGB-color components and one blend equation for the alpha component. $(D_INLINECODE glBlendEquationSeparatei) specifies the blend equations for a single draw buffer whereas $(D_INLINECODE glBlendEquationSeparate) sets the blend equations for all draw buffers. The blend equations use the source and destination blend factors specified by either $(D_INLINECODE glBlendFunc) or $(D_INLINECODE glBlendFuncSeparate). See $(D_INLINECODE glBlendFunc) or $(D_INLINECODE glBlendFuncSeparate) for a description of the various blend factors. In the equations that follow, source and destination color components are referred to as R s G s B s A s and R d G d B d A d, respectively. The result color is referred to as R r G r B r A r. The source and destination blend factors are denoted s R s G s B s A and d R d G d B d A, respectively. For these equations all color components are understood to have values in the range 0 1. $(B Mode) $(B RGB Components) $(B Alpha Component) $(D_INLINECODE GL_FUNC_ADD) Rr = R s &it; s R + R d &it; d R Gr = G s &it; s G + G d &it; d G Br = B s &it; s B + B d &it; d B Ar = A s &it; s A + A d &it; d A $(D_INLINECODE GL_FUNC_SUBTRACT) Rr = R s &it; s R - R d &it; d R Gr = G s &it; s G - G d &it; d G Br = B s &it; s B - B d &it; d B Ar = A s &it; s A - A d &it; d A $(D_INLINECODE GL_FUNC_REVERSE_SUBTRACT) Rr = R d &it; d R - R s &it; s R Gr = G d &it; d G - G s &it; s G Br = B d &it; d B - B s &it; s B Ar = A d &it; d A - A s &it; s A $(D_INLINECODE GL_MIN) Rr = min &af; R s R d Gr = min &af; G s G d Br = min &af; B s B d Ar = min &af; A s A d $(D_INLINECODE GL_MAX) Rr = max &af; R s R d Gr = max &af; G s G d Br = max &af; B s B d Ar = max &af; A s A d The results of these equations are clamped to the range 0 1. The $(D_INLINECODE GL_MIN) and $(D_INLINECODE GL_MAX) equations are useful for applications that analyze image data (image thresholding against a constant color, for example). The $(D_INLINECODE GL_FUNC_ADD) equation is useful for antialiasing and transparency, among other things. Initially, both the RGB blend equation and the alpha blend equation are set to $(D_INLINECODE GL_FUNC_ADD).
     + 
     + The $(D_INLINECODE GL_MIN), and $(D_INLINECODE GL_MAX) equations do not use the source or destination factors, only the source and destination colors.
     + 
     + Params:
     +     buf       = for $(D_INLINECODE glBlendEquationSeparatei), specifies the index of the draw buffer for which to set the blend equations.
     +     modeRGB   = specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be $(D_INLINECODE GL_FUNC_ADD), $(D_INLINECODE GL_FUNC_SUBTRACT), $(D_INLINECODE GL_FUNC_REVERSE_SUBTRACT), $(D_INLINECODE GL_MIN), $(D_INLINECODE GL_MAX).
     +     modeAlpha = specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be $(D_INLINECODE GL_FUNC_ADD), $(D_INLINECODE GL_FUNC_SUBTRACT), $(D_INLINECODE GL_FUNC_REVERSE_SUBTRACT), $(D_INLINECODE GL_MIN), $(D_INLINECODE GL_MAX).
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetString), $(D_INLINECODE glBlendColor), $(D_INLINECODE glBlendFunc), $(D_INLINECODE glBlendFuncSeparate)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glBlendEquationSeparate glBlendEquationSeparate;
    alias fn_glBlendEquationSeparatei = extern(System) void function(GLuint buf, GLenum modeRGB, GLenum modeAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    fn_glBlendEquationSeparatei glBlendEquationSeparatei;
    alias fn_glBlendFunc = extern(System) void function(GLenum sfactor, GLenum dfactor) @system @nogc nothrow;

    /++
     + glBlendFunc: man4/glBlendFunc.xml
     + 
     + Pixels can be drawn using a function that blends the incoming (source) RGBA values with the RGBA values that are already in the frame buffer (the destination values). Blending is initially disabled. Use $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_BLEND) to enable and disable blending. $(D_INLINECODE glBlendFunc) defines the operation of blending for all draw buffers when it is enabled. $(D_INLINECODE glBlendFunci) defines the operation of blending for a single draw buffer specified by $(D_INLINECODE buf) when enabled for that draw buffer. $(D_INLINECODE sfactor) specifies which method is used to scale the source color components. $(D_INLINECODE dfactor) specifies which method is used to scale the destination color components. Both parameters must be one of the following symbolic constants: $(D_INLINECODE GL_ZERO), $(D_INLINECODE GL_ONE), $(D_INLINECODE GL_SRC_COLOR), $(D_INLINECODE GL_ONE_MINUS_SRC_COLOR), $(D_INLINECODE GL_DST_COLOR), $(D_INLINECODE GL_ONE_MINUS_DST_COLOR), $(D_INLINECODE GL_SRC_ALPHA), $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA), $(D_INLINECODE GL_DST_ALPHA), $(D_INLINECODE GL_ONE_MINUS_DST_ALPHA), $(D_INLINECODE GL_CONSTANT_COLOR), $(D_INLINECODE GL_ONE_MINUS_CONSTANT_COLOR), $(D_INLINECODE GL_CONSTANT_ALPHA), $(D_INLINECODE GL_ONE_MINUS_CONSTANT_ALPHA), $(D_INLINECODE GL_SRC_ALPHA_SATURATE), $(D_INLINECODE GL_SRC1_COLOR), $(D_INLINECODE GL_ONE_MINUS_SRC1_COLOR), $(D_INLINECODE GL_SRC1_ALPHA), and $(D_INLINECODE GL_ONE_MINUS_SRC1_ALPHA). The possible methods are described in the following table. Each method defines four scale factors, one each for red, green, blue, and alpha. In the table and in subsequent equations, first source, second source and destination color components are referred to as R s0 G s0 B s0 A s0, R s1 G s1 B s1 A s1 and R d G d B d A d, respectively. The color specified by $(D_INLINECODE glBlendColor) is referred to as R c G c B c A c. They are understood to have integer values between 0 and k R k G k B k A, where k c = 2 m c - 1 and m R m G m B m A is the number of red, green, blue, and alpha bitplanes. Source and destination scale factors are referred to as s R s G s B s A and d R d G d B d A. The scale factors described in the table, denoted f R f G f B f A, represent either source or destination factors. All scale factors have range 0 1. $(B Parameter) f R f G f B f A $(D_INLINECODE GL_ZERO) 0 0 0 0 $(D_INLINECODE GL_ONE) 1 1 1 1 $(D_INLINECODE GL_SRC_COLOR) R s0 k R G s0 k G B s0 k B A s0 k A $(D_INLINECODE GL_ONE_MINUS_SRC_COLOR) 1 1 1 1 - R s0 k R G s0 k G B s0 k B A s0 k A $(D_INLINECODE GL_DST_COLOR) R d k R G d k G B d k B A d k A $(D_INLINECODE GL_ONE_MINUS_DST_COLOR) 1 1 1 1 - R d k R G d k G B d k B A d k A $(D_INLINECODE GL_SRC_ALPHA) A s0 k A A s0 k A A s0 k A A s0 k A $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA) 1 1 1 1 - A s0 k A A s0 k A A s0 k A A s0 k A $(D_INLINECODE GL_DST_ALPHA) A d k A A d k A A d k A A d k A $(D_INLINECODE GL_ONE_MINUS_DST_ALPHA) 1 1 1 1 - A d k A A d k A A d k A A d k A $(D_INLINECODE GL_CONSTANT_COLOR) R c G c B c A c $(D_INLINECODE GL_ONE_MINUS_CONSTANT_COLOR) 1 1 1 1 - R c G c B c A c $(D_INLINECODE GL_CONSTANT_ALPHA) A c A c A c A c $(D_INLINECODE GL_ONE_MINUS_CONSTANT_ALPHA) 1 1 1 1 - A c A c A c A c $(D_INLINECODE GL_SRC_ALPHA_SATURATE) i i i 1 $(D_INLINECODE GL_SRC1_COLOR) R s1 k R G s1 k G B s1 k B A s1 k A $(D_INLINECODE GL_ONE_MINUS_SRC1_COLOR) 1 1 1 1 - R s1 k R G s1 k G B s1 k B A s1 k A $(D_INLINECODE GL_SRC1_ALPHA) A s1 k A A s1 k A A s1 k A A s1 k A $(D_INLINECODE GL_ONE_MINUS_SRC1_ALPHA) 1 1 1 1 - A s1 k A A s1 k A A s1 k A A s1 k A In the table, i = min &af; A s k A - A d k A To determine the blended RGBA values of a pixel, the system uses the following equations: R d = min &af; k R R s &it; s R + R d &it; d R G d = min &af; k G G s &it; s G + G d &it; d G B d = min &af; k B B s &it; s B + B d &it; d B A d = min &af; k A A s &it; s A + A d &it; d A Despite the apparent precision of the above equations, blending arithmetic is not exactly specified, because blending operates with imprecise integer color values. However, a blend factor that should be equal to 1 is guaranteed not to modify its multiplicand, and a blend factor equal to 0 reduces its multiplicand to 0. For example, when $(D_INLINECODE sfactor) is $(D_INLINECODE GL_SRC_ALPHA), $(D_INLINECODE dfactor) is $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA), and A s is equal to k A, the equations reduce to simple replacement: R d = R s G d = G s B d = B s A d = A s
     + 
     + Incoming (source) alpha is correctly thought of as a material opacity, ranging from 1.0 ( K A ), representing complete opacity, to 0.0 (0), representing complete transparency. When more than one color buffer is enabled for drawing, the GL performs blending separately for each enabled buffer, using the contents of that buffer for destination color. (See $(D_INLINECODE glDrawBuffer).) When dual source blending is enabled (i.e., one of the blend factors requiring the second color input is used), the maximum number of enabled draw buffers is given by $(D_INLINECODE GL_MAX_DUAL_SOURCE_DRAW_BUFFERS), which may be lower than $(D_INLINECODE GL_MAX_DRAW_BUFFERS).
     + 
     + Params:
     +     buf     = For $(D_INLINECODE glBlendFunci), specifies the index of the draw buffer for which to set the blend function.
     +     sfactor = Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is $(D_INLINECODE GL_ONE).
     +     dfactor = Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: $(D_INLINECODE GL_ZERO), $(D_INLINECODE GL_ONE), $(D_INLINECODE GL_SRC_COLOR), $(D_INLINECODE GL_ONE_MINUS_SRC_COLOR), $(D_INLINECODE GL_DST_COLOR), $(D_INLINECODE GL_ONE_MINUS_DST_COLOR), $(D_INLINECODE GL_SRC_ALPHA), $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA), $(D_INLINECODE GL_DST_ALPHA), $(D_INLINECODE GL_ONE_MINUS_DST_ALPHA). $(D_INLINECODE GL_CONSTANT_COLOR), $(D_INLINECODE GL_ONE_MINUS_CONSTANT_COLOR), $(D_INLINECODE GL_CONSTANT_ALPHA), and $(D_INLINECODE GL_ONE_MINUS_CONSTANT_ALPHA). The initial value is $(D_INLINECODE GL_ZERO).
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBlendColor), $(D_INLINECODE glBlendEquation), $(D_INLINECODE glBlendFuncSeparate), $(D_INLINECODE glClear), $(D_INLINECODE glDrawBuffer), $(D_INLINECODE glEnable), $(D_INLINECODE glLogicOp), $(D_INLINECODE glStencilFunc)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glBlendFunc glBlendFunc;
    alias fn_glBlendFunci = extern(System) void function(GLuint buf, GLenum sfactor, GLenum dfactor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    fn_glBlendFunci glBlendFunci;
    alias fn_glBlendFuncSeparate = extern(System) void function(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) @system @nogc nothrow;

    /++
     + glBlendFuncSeparate: man4/glBlendFuncSeparate.xml
     + 
     + Pixels can be drawn using a function that blends the incoming (source) RGBA values with the RGBA values that are already in the frame buffer (the destination values). Blending is initially disabled. Use $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_BLEND) to enable and disable blending. $(D_INLINECODE glBlendFuncSeparate) defines the operation of blending for all draw buffers when it is enabled. $(D_INLINECODE glBlendFuncSeparatei) defines the operation of blending for a single draw buffer specified by $(D_INLINECODE buf) when enabled for that draw buffer. $(D_INLINECODE srcRGB) specifies which method is used to scale the source RGB-color components. $(D_INLINECODE dstRGB) specifies which method is used to scale the destination RGB-color components. Likewise, $(D_INLINECODE srcAlpha) specifies which method is used to scale the source alpha color component, and $(D_INLINECODE dstAlpha) specifies which method is used to scale the destination alpha component. The possible methods are described in the following table. Each method defines four scale factors, one each for red, green, blue, and alpha. In the table and in subsequent equations, first source, second source and destination color components are referred to as R s0 G s0 B s0 A s0, R s1 G s1 B s1 A s1, and R d G d B d A d, respectively. The color specified by $(D_INLINECODE glBlendColor) is referred to as R c G c B c A c. They are understood to have integer values between 0 and k R k G k B k A, where k c = 2 m c - 1 and m R m G m B m A is the number of red, green, blue, and alpha bitplanes. Source and destination scale factors are referred to as s R s G s B s A and d R d G d B d A. All scale factors have range 0 1. $(B Parameter) $(B RGB Factor) $(B Alpha Factor) $(D_INLINECODE GL_ZERO) 0 0 0 0 $(D_INLINECODE GL_ONE) 1 1 1 1 $(D_INLINECODE GL_SRC_COLOR) R s0 k R G s0 k G B s0 k B A s0 k A $(D_INLINECODE GL_ONE_MINUS_SRC_COLOR) 1 1 1 1 - R s0 k R G s0 k G B s0 k B 1 - A s0 k A $(D_INLINECODE GL_DST_COLOR) R d k R G d k G B d k B A d k A $(D_INLINECODE GL_ONE_MINUS_DST_COLOR) 1 1 1 - R d k R G d k G B d k B 1 - A d k A $(D_INLINECODE GL_SRC_ALPHA) A s0 k A A s0 k A A s0 k A A s0 k A $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA) 1 1 1 - A s0 k A A s0 k A A s0 k A 1 - A s0 k A $(D_INLINECODE GL_DST_ALPHA) A d k A A d k A A d k A A d k A $(D_INLINECODE GL_ONE_MINUS_DST_ALPHA) 1 1 1 - A d k A A d k A A d k A 1 - A d k A $(D_INLINECODE GL_CONSTANT_COLOR) R c G c B c A c $(D_INLINECODE GL_ONE_MINUS_CONSTANT_COLOR) 1 1 1 - R c G c B c 1 - A c $(D_INLINECODE GL_CONSTANT_ALPHA) A c A c A c A c $(D_INLINECODE GL_ONE_MINUS_CONSTANT_ALPHA) 1 1 1 - A c A c A c 1 - A c $(D_INLINECODE GL_SRC_ALPHA_SATURATE) i i i 1 $(D_INLINECODE GL_SRC1_COLOR) R s1 k R G s1 k G B s1 k B A s1 k A $(D_INLINECODE GL_ONE_MINUS_SRC_COLOR) 1 1 1 1 - R s1 k R G s1 k G B s1 k B 1 - A s1 k A $(D_INLINECODE GL_SRC1_ALPHA) A s1 k A A s1 k A A s1 k A A s1 k A $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA) 1 1 1 - A s1 k A A s1 k A A s1 k A 1 - A s1 k A In the table, i = min &af; A s 1 - A d To determine the blended RGBA values of a pixel, the system uses the following equations: R d = min &af; k R R s &it; s R + R d &it; d R G d = min &af; k G G s &it; s G + G d &it; d G B d = min &af; k B B s &it; s B + B d &it; d B A d = min &af; k A A s &it; s A + A d &it; d A Despite the apparent precision of the above equations, blending arithmetic is not exactly specified, because blending operates with imprecise integer color values.  However, a blend factor that should be equal to 1 is guaranteed not to modify its multiplicand, and a blend factor equal to 0 reduces its multiplicand to 0.  For example, when $(D_INLINECODE srcRGB) is $(D_INLINECODE GL_SRC_ALPHA), $(D_INLINECODE dstRGB) is $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA), and A s is equal to k A, the equations reduce to simple replacement: R d = R s G d = G s B d = B s A d = A s
     + 
     + Incoming (source) alpha is correctly thought of as a material opacity, ranging from 1.0 ( K A ), representing complete opacity, to 0.0 (0), representing complete transparency. When more than one color buffer is enabled for drawing, the GL performs blending separately for each enabled buffer, using the contents of that buffer for destination color. (See $(D_INLINECODE glDrawBuffer).) When dual source blending is enabled (i.e., one of the blend factors requiring the second color input is used), the maximum number of enabled draw buffers is given by $(D_INLINECODE GL_MAX_DUAL_SOURCE_DRAW_BUFFERS), which may be lower than $(D_INLINECODE GL_MAX_DRAW_BUFFERS).
     + 
     + Params:
     +     buf      = For $(D_INLINECODE glBlendFuncSeparatei), specifies the index of the draw buffer for which to set the blend functions.
     +     srcRGB   = Specifies how the red, green, and blue blending factors are computed. The initial value is $(D_INLINECODE GL_ONE).
     +     dstRGB   = Specifies how the red, green, and blue destination blending factors are computed. The initial value is $(D_INLINECODE GL_ZERO).
     +     srcAlpha = Specified how the alpha source blending factor is computed. The initial value is $(D_INLINECODE GL_ONE).
     +     dstAlpha = Specified how the alpha destination blending factor is computed. The initial value is $(D_INLINECODE GL_ZERO).
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBlendColor), $(D_INLINECODE glBlendFunc), $(D_INLINECODE glBlendEquation), $(D_INLINECODE glClear), $(D_INLINECODE glDrawBuffer), $(D_INLINECODE glEnable), $(D_INLINECODE glLogicOp), $(D_INLINECODE glStencilFunc)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glBlendFuncSeparate glBlendFuncSeparate;
    alias fn_glBlendFuncSeparatei = extern(System) void function(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    fn_glBlendFuncSeparatei glBlendFuncSeparatei;
    alias fn_glBlitFramebuffer = extern(System) void function(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) @system @nogc nothrow;

    /++
     + glBlitFramebuffer: man4/glBlitFramebuffer.xml
     + 
     + $(D_INLINECODE glBlitFramebuffer) and $(D_INLINECODE glBlitNamedFramebuffer) transfer a rectangle of pixel values from one region of a read framebuffer to another region of a draw framebuffer. For $(D_INLINECODE glBlitFramebuffer), the read and draw framebuffers are those bound to the $(D_INLINECODE GL_READ_FRAMEBUFFER) and $(D_INLINECODE GL_DRAW_FRAMEBUFFER) targets respectively. For $(D_INLINECODE glBlitNamedFramebuffer), $(D_INLINECODE readFramebuffer) and $(D_INLINECODE drawFramebuffer) are the names of the read read and draw framebuffer objects respectively. If $(D_INLINECODE readFramebuffer) or $(D_INLINECODE drawFramebuffer) is zero, then the default read or draw framebuffer respectively is used. $(D_INLINECODE mask) is the bitwise OR of a number of values indicating which buffers are to be copied. The values are $(D_INLINECODE GL_COLOR_BUFFER_BIT), $(D_INLINECODE GL_DEPTH_BUFFER_BIT), and $(D_INLINECODE GL_STENCIL_BUFFER_BIT). The pixels corresponding to these buffers are copied from the source rectangle bounded by the locations ( $(D_INLINECODE srcX0), $(D_INLINECODE srcY0) ) and ( $(D_INLINECODE srcX1), $(D_INLINECODE srcY1) ) to the destination rectangle bounded by the locations ( $(D_INLINECODE dstX0), $(D_INLINECODE dstY0) ) and ( $(D_INLINECODE dstX1), $(D_INLINECODE dstY1) ). The lower bounds of the rectangle are inclusive, while the upper bounds are exclusive. The actual region taken from the read framebuffer is limited to the intersection of the source buffers being transferred, which may include the color buffer selected by the read buffer, the depth buffer, and/or the stencil buffer depending on mask. The actual region written to the draw framebuffer is limited to the intersection of the destination buffers being written, which may include multiple draw buffers, the depth buffer, and/or the stencil buffer depending on mask. Whether or not the source or destination regions are altered due to these limits, the scaling and offset applied to pixels being transferred is performed as though no such limits were present. If the sizes of the source and destination rectangles are not equal, $(D_INLINECODE filter) specifies the interpolation method that will be applied to resize the source image , and must be $(D_INLINECODE GL_NEAREST) or $(D_INLINECODE GL_LINEAR). $(D_INLINECODE GL_LINEAR) is only a valid interpolation method for the color buffer. If $(D_INLINECODE filter) is not $(D_INLINECODE GL_NEAREST) and $(D_INLINECODE mask) includes $(D_INLINECODE GL_DEPTH_BUFFER_BIT) or $(D_INLINECODE GL_STENCIL_BUFFER_BIT), no data is transferred and a $(D_INLINECODE GL_INVALID_OPERATION) error is generated. If $(D_INLINECODE filter) is $(D_INLINECODE GL_LINEAR) and the source rectangle would require sampling outside the bounds of the source framebuffer, values are read as if the $(D_INLINECODE GL_CLAMP_TO_EDGE) texture wrapping mode were applied. When the color buffer is transferred, values are taken from the read buffer of the specified read framebuffer and written to each of the draw buffers of the specified draw framebuffer. If the source and destination rectangles overlap or are the same, and the read and draw buffers are the same, the result of the operation is undefined.
     + 
     + Params:
     +     readFramebuffer = Specifies the name of the source framebuffer object for $(D_INLINECODE glBlitNamedFramebuffer).
     +     drawFramebuffer = Specifies the name of the destination framebuffer object for $(D_INLINECODE glBlitNamedFramebuffer).
     +     srcX0           = Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
     +     dstX0           = Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
     +     mask            = The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are $(D_INLINECODE GL_COLOR_BUFFER_BIT), $(D_INLINECODE GL_DEPTH_BUFFER_BIT) and $(D_INLINECODE GL_STENCIL_BUFFER_BIT).
     +     filter          = Specifies the interpolation to be applied if the image is stretched. Must be $(D_INLINECODE GL_NEAREST) or $(D_INLINECODE GL_LINEAR).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glReadPixels) $(D_INLINECODE glCheckFramebufferStatus), $(D_INLINECODE glGenFramebuffers) $(D_INLINECODE glBindFramebuffer) $(D_INLINECODE glDeleteFramebuffers)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    fn_glBlitFramebuffer glBlitFramebuffer;
    alias fn_glBlitNamedFramebuffer = extern(System) void function(GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glBlitNamedFramebuffer glBlitNamedFramebuffer;
    alias fn_glBufferData = extern(System) void function(GLenum target, GLsizeiptr size, const( GLvoid*) data, GLenum usage) @system @nogc nothrow;

    /++
     + glBufferData: man4/glBufferData.xml
     + 
     + $(D_INLINECODE glBufferData) and $(D_INLINECODE glNamedBufferData) create a new data store for a buffer object. In case of $(D_INLINECODE glBufferData), the buffer object currently bound to $(D_INLINECODE target) is used. For $(D_INLINECODE glNamedBufferData), a buffer object associated with ID specified by the caller in $(D_INLINECODE buffer) will be used instead. While creating the new storage, any pre-existing data store is deleted. The new data store is created with the specified $(D_INLINECODE size) in bytes and $(D_INLINECODE usage). If $(D_INLINECODE data) is not $(D_INLINECODE null
     + ), the data store is initialized with data from this pointer. In its initial state, the new data store is not mapped, it has a $(D_INLINECODE null
     + ) mapped pointer, and its mapped access is $(D_INLINECODE GL_READ_WRITE). $(D_INLINECODE usage) is a hint to the GL implementation as to how a buffer object's data store will be accessed. This enables the GL implementation to make more intelligent decisions that may significantly impact buffer object performance. It does not, however, constrain the actual usage of the data store. $(D_INLINECODE usage) can be broken down into two parts: first, the frequency of access (modification and usage), and second, the nature of that access. The frequency of access may be one of these: The nature of access may be one of these:
     + 
     + If $(D_INLINECODE data) is $(D_INLINECODE null
     + ), a data store of the specified size is still created, but its contents remain uninitialized and thus undefined. Clients must align data elements consistently with the requirements of the client platform, with an additional base-level requirement that an offset within a buffer to a datum comprising N bytes be a multiple of N. The $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) target is available only if the GL version is 4.2 or greater. The $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) and $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) targets are available only if the GL version is 4.3 or greater. The $(D_INLINECODE GL_QUERY_BUFFER) target is available only if the GL version is 4.4 or greater.
     + 
     + Params:
     +     target = Specifies the target to which the buffer object is bound for $(D_INLINECODE glBufferData), which must be one of the buffer binding targets in the following table: $(B Buffer Binding Target) $(B Purpose) $(D_INLINECODE GL_ARRAY_BUFFER) Vertex attributes $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) Atomic counter storage $(D_INLINECODE GL_COPY_READ_BUFFER) Buffer copy source $(D_INLINECODE GL_COPY_WRITE_BUFFER) Buffer copy destination $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) Indirect compute dispatch commands $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) Indirect command arguments $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) Vertex array indices $(D_INLINECODE GL_PIXEL_PACK_BUFFER) Pixel read target $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) Texture data source $(D_INLINECODE GL_QUERY_BUFFER) Query result buffer $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) Read-write storage for shaders $(D_INLINECODE GL_TEXTURE_BUFFER) Texture data buffer $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) Transform feedback buffer $(D_INLINECODE GL_UNIFORM_BUFFER) Uniform block storage
     +     buffer = Specifies the name of the buffer object for $(D_INLINECODE glNamedBufferData) function.
     +     size   = Specifies the size in bytes of the buffer object's new data store.
     +     data   = Specifies a pointer to data that will be copied into the data store for initialization, or $(D_INLINECODE null) if no data is to be copied.
     +     usage  = Specifies the expected usage pattern of the data store. The symbolic constant must be $(D_INLINECODE GL_STREAM_DRAW), $(D_INLINECODE GL_STREAM_READ), $(D_INLINECODE GL_STREAM_COPY), $(D_INLINECODE GL_STATIC_DRAW), $(D_INLINECODE GL_STATIC_READ), $(D_INLINECODE GL_STATIC_COPY), $(D_INLINECODE GL_DYNAMIC_DRAW), $(D_INLINECODE GL_DYNAMIC_READ), or $(D_INLINECODE GL_DYNAMIC_COPY).
     + 
     + Copyright:
     +     Copyright&copy; 2005 Addison-Wesley. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBuffer), $(D_INLINECODE glBufferSubData), $(D_INLINECODE glMapBuffer), $(D_INLINECODE glUnmapBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    fn_glBufferData glBufferData;
    alias fn_glNamedBufferData = extern(System) void function(GLuint buffer, GLsizei size, const( void*) data, GLenum usage) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glNamedBufferData glNamedBufferData;
    alias fn_glBufferStorage = extern(System) void function(GLenum target, GLsizeiptr size, const( GLvoid*) data, GLbitfield flags) @system @nogc nothrow;

    /++
     + glBufferStorage: man4/glBufferStorage.xml
     + 
     + $(D_INLINECODE glBufferStorage) and $(D_INLINECODE glNamedBufferStorage) create a new immutable data store. For $(D_INLINECODE glBufferStorage), the buffer object currently bound to $(D_INLINECODE target) will be initialized. For $(D_INLINECODE glNamedBufferStorage), $(D_INLINECODE buffer) is the name of the buffer object that will be configured. The size of the data store is specified by $(D_INLINECODE size). If an initial data is available, its address may be supplied in $(D_INLINECODE data). Otherwise, to create an uninitialized data store, $(D_INLINECODE data) should be $(D_INLINECODE null
     + ). The $(D_INLINECODE flags) parameters specifies the intended usage of the buffer's data store. It must be a bitwise combination of a subset of the following flags: The allowed combinations of flags are subject to certain restrictions. They are as follows: $(OL $(LI If $(D_INLINECODE flags) contains $(D_INLINECODE GL_MAP_PERSISTENT_BIT), it must also contain at least one of $(D_INLINECODE GL_MAP_READ_BIT) or $(D_INLINECODE GL_MAP_WRITE_BIT).) $(LI If $(D_INLINECODE flags) contains $(D_INLINECODE GL_MAP_COHERENT_BIT), it must also contain $(D_INLINECODE GL_MAP_PERSISTENT_BIT).))
     + 
     + $(D_INLINECODE glBufferStorage) is available only if the GL version is 4.4 or greater. $(D_INLINECODE glNamedBufferStorage) is available only if the GL version is 4.5 or greater. If $(D_INLINECODE data) is $(D_INLINECODE null
     + ), a data store of the specified size is still created, but its contents remain uninitialized and thus undefined.
     + 
     + Params:
     +     target = Specifies the target to which the buffer object is bound for $(D_INLINECODE glBufferStorage), which must be one of the buffer binding targets in the following table: $(B Buffer Binding Target) $(B Purpose) $(D_INLINECODE GL_ARRAY_BUFFER) Vertex attributes $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) Atomic counter storage $(D_INLINECODE GL_COPY_READ_BUFFER) Buffer copy source $(D_INLINECODE GL_COPY_WRITE_BUFFER) Buffer copy destination $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) Indirect compute dispatch commands $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) Indirect command arguments $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) Vertex array indices $(D_INLINECODE GL_PIXEL_PACK_BUFFER) Pixel read target $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) Texture data source $(D_INLINECODE GL_QUERY_BUFFER) Query result buffer $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) Read-write storage for shaders $(D_INLINECODE GL_TEXTURE_BUFFER) Texture data buffer $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) Transform feedback buffer $(D_INLINECODE GL_UNIFORM_BUFFER) Uniform block storage
     +     buffer = Specifies the name of the buffer object for $(D_INLINECODE glNamedBufferStorage) function.
     +     size   = Specifies the size in bytes of the buffer object's new data store.
     +     data   = Specifies a pointer to data that will be copied into the data store for initialization, or $(D_INLINECODE null) if no data is to be copied.
     +     flags  = Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. $(D_INLINECODE GL_DYNAMIC_STORAGE_BIT), $(D_INLINECODE GL_MAP_READ_BIT) $(D_INLINECODE GL_MAP_WRITE_BIT), $(D_INLINECODE GL_MAP_PERSISTENT_BIT), $(D_INLINECODE GL_MAP_COHERENT_BIT), and $(D_INLINECODE GL_CLIENT_STORAGE_BIT).
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBuffer), $(D_INLINECODE glBufferSubData), $(D_INLINECODE glMapBuffer), $(D_INLINECODE glUnmapBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P4)
    @OpenGL_Extension("GL_ARB_buffer_storage")
    fn_glBufferStorage glBufferStorage;
    alias fn_glNamedBufferStorage = extern(System) void function(GLuint buffer, GLsizei size, const( void*) data, GLbitfield flags) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glNamedBufferStorage glNamedBufferStorage;
    alias fn_glBufferSubData = extern(System) void function(GLenum target, GLintptr offset, GLsizeiptr size, const( GLvoid*) data) @system @nogc nothrow;

    /++
     + glBufferSubData: man4/glBufferSubData.xml
     + 
     + $(D_INLINECODE glBufferSubData) and $(D_INLINECODE glNamedBufferSubData) redefine some or all of the data store for the specified buffer object. Data starting at byte offset $(D_INLINECODE offset) and extending for $(D_INLINECODE size) bytes is copied to the data store from the memory pointed to by $(D_INLINECODE data). $(D_INLINECODE offset) and $(D_INLINECODE size) must define a range lying entirely within the buffer object's data store.
     + 
     + When replacing the entire data store, consider using $(D_INLINECODE glBufferSubData) rather than completely recreating the data store with $(D_INLINECODE glBufferData). This avoids the cost of reallocating the data store. Consider using multiple buffer objects to avoid stalling the rendering pipeline during data store updates. If any rendering in the pipeline makes reference to data in the buffer object being updated by $(D_INLINECODE glBufferSubData), especially from the specific region being updated, that rendering must drain from the pipeline before the data store can be updated. Clients must align data elements consistent with the requirements of the client platform, with an additional base-level requirement that an offset within a buffer to a datum comprising $N$ bytes be a multiple of $N$. The $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) target is available only if the GL version is 4.2 or greater. The $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) and $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) targets are available only if the GL version is 4.3 or greater. The $(D_INLINECODE GL_QUERY_BUFFER) target is available only if the GL version is 4.4 or greater.
     + 
     + Params:
     +     target = Specifies the target to which the buffer object is bound for $(D_INLINECODE glBufferSubData), which must be one of the buffer binding targets in the following table: $(B Buffer Binding Target) $(B Purpose) $(D_INLINECODE GL_ARRAY_BUFFER) Vertex attributes $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) Atomic counter storage $(D_INLINECODE GL_COPY_READ_BUFFER) Buffer copy source $(D_INLINECODE GL_COPY_WRITE_BUFFER) Buffer copy destination $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) Indirect compute dispatch commands $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) Indirect command arguments $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) Vertex array indices $(D_INLINECODE GL_PIXEL_PACK_BUFFER) Pixel read target $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) Texture data source $(D_INLINECODE GL_QUERY_BUFFER) Query result buffer $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) Read-write storage for shaders $(D_INLINECODE GL_TEXTURE_BUFFER) Texture data buffer $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) Transform feedback buffer $(D_INLINECODE GL_UNIFORM_BUFFER) Uniform block storage
     +     buffer = Specifies the name of the buffer object for $(D_INLINECODE glNamedBufferSubData).
     +     offset = Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
     +     size   = Specifies the size in bytes of the data store region being replaced.
     +     data   = Specifies a pointer to the new data that will be copied into the data store.
     + 
     + Copyright:
     +     Copyright&copy; 2005 Addison-Wesley. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBuffer), $(D_INLINECODE glBufferData), $(D_INLINECODE glMapBuffer), $(D_INLINECODE glMapBufferRange), $(D_INLINECODE glUnmapBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    fn_glBufferSubData glBufferSubData;
    alias fn_glNamedBufferSubData = extern(System) void function(GLuint buffer, GLintptr offset, GLsizei size, const( void*) data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glNamedBufferSubData glNamedBufferSubData;
    alias fn_glCheckFramebufferStatus = extern(System) GLenum function(GLenum target) @system @nogc nothrow;

    /++
     + glCheckFramebufferStatus: man4/glCheckFramebufferStatus.xml
     + 
     + $(D_INLINECODE glCheckFramebufferStatus) and $(D_INLINECODE glCheckNamedFramebufferStatus) return the completeness status of a framebuffer object when treated as a read or draw framebuffer, depending on the value of $(D_INLINECODE target). For $(D_INLINECODE glCheckFramebufferStatus), the framebuffer checked is that bound to $(D_INLINECODE target), which must be $(D_INLINECODE GL_DRAW_FRAMEBUFFER), $(D_INLINECODE GL_READ_FRAMEBUFFER) or $(D_INLINECODE GL_FRAMEBUFFER). $(D_INLINECODE GL_FRAMEBUFFER) is equivalent to $(D_INLINECODE GL_DRAW_FRAMEBUFFER). For $(D_INLINECODE glCheckNamedFramebufferStatus), $(D_INLINECODE framebuffer) is zero or the name of the framebuffer object to check. If $(D_INLINECODE framebuffer) is zero, then the status of the default read or draw framebuffer, as determined by $(D_INLINECODE target), is returned. The return value is $(D_INLINECODE GL_FRAMEBUFFER_COMPLETE) if the specified framebuffer is complete. Otherwise, the return value is determined as follows: $(OL $(LI $(D_INLINECODE GL_FRAMEBUFFER_UNDEFINED) is returned if the specified framebuffer is the default read or draw framebuffer, but the default framebuffer does not exist.) $(LI $(D_INLINECODE GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT) is returned if any of the framebuffer attachment points are framebuffer incomplete.) $(LI $(D_INLINECODE GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT) is returned if the framebuffer does not have at least one image attached to it.) $(LI $(D_INLINECODE GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER) is returned if the value of $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE) is $(D_INLINECODE GL_NONE) for any color attachment point(s) named by $(D_INLINECODE GL_DRAW_BUFFERi).) $(LI $(D_INLINECODE GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER) is returned if $(D_INLINECODE GL_READ_BUFFER) is not $(D_INLINECODE GL_NONE) and the value of $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE) is $(D_INLINECODE GL_NONE) for the color attachment point named by $(D_INLINECODE GL_READ_BUFFER).) $(LI $(D_INLINECODE GL_FRAMEBUFFER_UNSUPPORTED) is returned if the combination of internal formats of the attached images violates an implementation-dependent set of restrictions.) $(LI $(D_INLINECODE GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE) is returned if the value of $(D_INLINECODE GL_RENDERBUFFER_SAMPLES) is not the same for all attached renderbuffers; if the value of $(D_INLINECODE GL_TEXTURE_SAMPLES) is the not same for all attached textures; or, if the attached images are a mix of renderbuffers and textures, the value of $(D_INLINECODE GL_RENDERBUFFER_SAMPLES) does not match the value of $(D_INLINECODE GL_TEXTURE_SAMPLES).) $(LI $(D_INLINECODE GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE) is also returned if the value of $(D_INLINECODE GL_TEXTURE_FIXED_SAMPLE_LOCATIONS) is not the same for all attached textures; or, if the attached images are a mix of renderbuffers and textures, the value of $(D_INLINECODE GL_TEXTURE_FIXED_SAMPLE_LOCATIONS) is not $(D_INLINECODE GL_TRUE) for all attached textures.) $(LI $(D_INLINECODE GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS) is returned if any framebuffer attachment is layered, and any populated attachment is not layered, or if all populated color attachments are not from textures of the same target.)) Additionally, if an error occurs, zero is returned.
     + 
     + Params:
     +     target      = Specify the target to which the framebuffer is bound for $(D_INLINECODE glCheckFramebufferStatus), and the target against which framebuffer completeness of $(D_INLINECODE framebuffer) is checked for $(D_INLINECODE glCheckNamedFramebufferStatus).
     +     framebuffer = Specifies the name of the framebuffer object for $(D_INLINECODE glCheckNamedFramebufferStatus)
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenFramebuffers), $(D_INLINECODE glDeleteFramebuffers) $(D_INLINECODE glBindFramebuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    fn_glCheckFramebufferStatus glCheckFramebufferStatus;
    alias fn_glCheckNamedFramebufferStatus = extern(System) GLenum function(GLuint framebuffer, GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glCheckNamedFramebufferStatus glCheckNamedFramebufferStatus;
    alias fn_glClampColor = extern(System) void function(GLenum target, GLenum clamp) @system @nogc nothrow;

    /++
     + glClampColor: man4/glClampColor.xml
     + 
     + $(D_INLINECODE glClampColor) controls color clamping that is performed during $(D_INLINECODE glReadPixels). $(D_INLINECODE target) must be $(D_INLINECODE GL_CLAMP_READ_COLOR). If $(D_INLINECODE clamp) is $(D_INLINECODE GL_TRUE), read color clamping is enabled; if $(D_INLINECODE clamp) is $(D_INLINECODE GL_FALSE), read color clamping is disabled. If $(D_INLINECODE clamp) is $(D_INLINECODE GL_FIXED_ONLY), read color clamping is enabled only if the selected read buffer has fixed point components and disabled otherwise.
     + 
     + Params:
     +     target = Target for color clamping. $(D_INLINECODE target) must be $(D_INLINECODE GL_CLAMP_READ_COLOR).
     +     clamp  = Specifies whether to apply color clamping. $(D_INLINECODE clamp) must be $(D_INLINECODE GL_TRUE) or $(D_INLINECODE GL_FALSE).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glClampColor glClampColor;
    alias fn_glClear = extern(System) void function(GLbitfield mask) @system @nogc nothrow;

    /++
     + glClear: man4/glClear.xml
     + 
     + $(D_INLINECODE glClear) sets the bitplane area of the window to values previously selected by $(D_INLINECODE glClearColor), $(D_INLINECODE glClearDepth), and $(D_INLINECODE glClearStencil). Multiple color buffers can be cleared simultaneously by selecting more than one buffer at a time using $(D_INLINECODE glDrawBuffer). The pixel ownership test, the scissor test, dithering, and the buffer writemasks affect the operation of $(D_INLINECODE glClear). The scissor box bounds the cleared region. Alpha function, blend function, logical operation, stenciling, texture mapping, and depth-buffering are ignored by $(D_INLINECODE glClear). $(D_INLINECODE glClear) takes a single argument that is the bitwise OR of several values indicating which buffer is to be cleared. The values are as follows: The value to which each buffer is cleared depends on the setting of the clear value for that buffer.
     + 
     + If a buffer is not present, then a $(D_INLINECODE glClear) directed at that buffer has no effect.
     + 
     + Params:
     +     mask = Bitwise OR of masks that indicate the buffers to be cleared. The three masks are $(D_INLINECODE GL_COLOR_BUFFER_BIT), $(D_INLINECODE GL_DEPTH_BUFFER_BIT), and $(D_INLINECODE GL_STENCIL_BUFFER_BIT).
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glClearColor), $(D_INLINECODE glClearDepth), $(D_INLINECODE glClearStencil), $(D_INLINECODE glColorMask), $(D_INLINECODE glDepthMask), $(D_INLINECODE glDrawBuffer), $(D_INLINECODE glScissor), $(D_INLINECODE glStencilMask)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glClear glClear;
    alias fn_glClearBufferiv = extern(System) void function(GLenum buffer, GLint drawbuffer, const( GLint*) value) @system @nogc nothrow;

    /++
     + glClearBuffer: man4/glClearBuffer.xml
     + 
     + These commands clear a specified buffer of a framebuffer to specified value(s). For $(D_INLINECODE glClearBuffer*), the framebuffer is the currently bound draw framebuffer object. For $(D_INLINECODE glClearNamedFramebuffer*), $(D_INLINECODE framebuffer) is zero, indicating the default draw framebuffer, or the name of a framebuffer object. $(D_INLINECODE buffer) and $(D_INLINECODE drawbuffer) identify the buffer to clear. If $(D_INLINECODE buffer) is $(D_INLINECODE GL_COLOR), a particular draw buffer $(D_INLINECODE GL_DRAW_BUFFER) $(D_INLINECODE i) is specified by passing $(D_INLINECODE i) as $(D_INLINECODE drawbuffer), and $(D_INLINECODE value) points to a four-element vector specifying the R, G, B and A color to clear that draw buffer to. If the value of $(D_INLINECODE GL_DRAW_BUFFER) $(D_INLINECODE i) is $(D_INLINECODE GL_NONE), the command has no effect. Otherwise, the value of $(D_INLINECODE GL_DRAW_BUFFER) $(D_INLINECODE i) identifies one or more color buffers, each of which is cleared to the same value. Clamping and type conversion for fixed-point color buffers are performed in the same fashion as for $(D_INLINECODE glClearColor). The $(D_INLINECODE *fv), $(D_INLINECODE *iv) and $(D_INLINECODE *uiv) forms of these commands should be used to clear fixed- and floating-point, signed integer, and unsigned integer color buffers respectively. If $(D_INLINECODE buffer) is $(D_INLINECODE GL_DEPTH), $(D_INLINECODE drawbuffer) must be zero, and $(D_INLINECODE value) points to a single value to clear the depth buffer to. Clamping and type conversion for fixed-point depth buffers are performed in the same fashion as for $(D_INLINECODE glClearDepth). Only the $(D_INLINECODE *fv) forms of these commands should be used to clear depth buffers; other forms do not accept a $(D_INLINECODE buffer) of $(D_INLINECODE GL_DEPTH). If $(D_INLINECODE buffer) is $(D_INLINECODE GL_STENCIL), $(D_INLINECODE drawbuffer) must be zero, and $(D_INLINECODE value) points to a single value to clear the stencil buffer to. Masking is performed in the same fashion as for $(D_INLINECODE glClearStencil). Only the $(D_INLINECODE *iv) forms of these commands should be used to clear stencil buffers; be used to clear stencil buffers; other forms do not accept a $(D_INLINECODE buffer) of $(D_INLINECODE GL_STENCIL). $(D_INLINECODE glClearBufferfi) and $(D_INLINECODE glClearNamedFramebufferfi) are used to clear the depth and stencil buffers simultaneously. $(D_INLINECODE buffer) must be $(D_INLINECODE GL_DEPTH_STENCIL) and $(D_INLINECODE drawbuffer) must be zero. $(D_INLINECODE depth) and $(D_INLINECODE stencil) are the values to clear the depth and stencil buffers to, respectively. Clamping and type conversion of $(D_INLINECODE depth) for fixed-point depth buffers are performed in the same fashion as for $(D_INLINECODE glClearDepth). Masking of $(D_INLINECODE stencil) for stencil buffers is performed in the same fashion as for $(D_INLINECODE glClearStencil). These commands are equivalent to clearing the depth and stencil buffers separately, but may be faster when a buffer of internal format $(D_INLINECODE GL_DEPTH_STENCIL) is being cleared. The same per-fragment and masking operations defined for $(D_INLINECODE glClear) are applied. The result of these commands is undefined if no conversion between the type of the specified $(D_INLINECODE value) and the type of the buffer being cleared is defined (for example, if $(D_INLINECODE glClearBufferiv) is called for a fixed- or floating-point buffer, or if $(D_INLINECODE glClearBufferfv) is called for a signed or unsigned integer buffer). This is not an error.
     + 
     + Params:
     +     framebuffer = Specifies the name of the framebuffer object for $(D_INLINECODE glClearNamedFramebuffer*).
     +     buffer      = Specify the buffer to clear.
     +     drawbuffer  = Specify a particular draw buffer to clear.
     +     value       = A pointer to the value or values to clear the buffer to.
     +     depth       = The value to clear the depth buffer to.
     +     stencil     = The value to clear the stencil buffer to.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glClearColor), $(D_INLINECODE glClearDepth), $(D_INLINECODE glClearStencil), $(D_INLINECODE glClear)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glClearBufferiv glClearBufferiv;
    alias fn_glClearBufferuiv = extern(System) void function(GLenum buffer, GLint drawbuffer, const( GLuint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glClearBufferuiv glClearBufferuiv;
    alias fn_glClearBufferfv = extern(System) void function(GLenum buffer, GLint drawbuffer, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glClearBufferfv glClearBufferfv;
    alias fn_glClearBufferfi = extern(System) void function(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glClearBufferfi glClearBufferfi;
    alias fn_glClearNamedFramebufferiv = extern(System) void function(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const( GLint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glClearNamedFramebufferiv glClearNamedFramebufferiv;
    alias fn_glClearNamedFramebufferuiv = extern(System) void function(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const( GLuint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glClearNamedFramebufferuiv glClearNamedFramebufferuiv;
    alias fn_glClearNamedFramebufferfv = extern(System) void function(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glClearNamedFramebufferfv glClearNamedFramebufferfv;
    alias fn_glClearNamedFramebufferfi = extern(System) void function(GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glClearNamedFramebufferfi glClearNamedFramebufferfi;
    alias fn_glClearBufferData = extern(System) void function(GLenum target, GLenum internalformat, GLenum format, GLenum type, const( void*) data) @system @nogc nothrow;

    /++
     + glClearBufferData: man4/glClearBufferData.xml
     + 
     + $(D_INLINECODE glClearBufferData) and $(D_INLINECODE glClearNamedBufferData) fill the entirety of a buffer object's data store with data from client memory. Data, initially supplied in a format specified by $(D_INLINECODE format) in data type $(D_INLINECODE type) is read from the memory address given by $(D_INLINECODE data) and converted into the internal representation given by $(D_INLINECODE internalformat), which must be one of the following sized internal formats: $(B Component) $(B Sized Internal Format) $(B Base Type) $(B Components) $(B Norm) 0 1 2 3 $(D_INLINECODE GL_R8) ubyte 1 YES R 0 0 1 $(D_INLINECODE GL_R16) ushort 1 YES R 0 0 1 $(D_INLINECODE GL_R16F) half 1 NO R 0 0 1 $(D_INLINECODE GL_R32F) float 1 NO R 0 0 1 $(D_INLINECODE GL_R8I) byte 1 NO R 0 0 1 $(D_INLINECODE GL_R16I) short 1 NO R 0 0 1 $(D_INLINECODE GL_R32I) int 1 NO R 0 0 1 $(D_INLINECODE GL_R8UI) ubyte 1 NO R 0 0 1 $(D_INLINECODE GL_R16UI) ushort 1 NO R 0 0 1 $(D_INLINECODE GL_R32UI) uint 1 NO R 0 0 1 $(D_INLINECODE GL_RG8) ubyte 2 YES R G 0 1 $(D_INLINECODE GL_RG16) ushort 2 YES R G 0 1 $(D_INLINECODE GL_RG16F) half 2 NO R G 0 1 $(D_INLINECODE GL_RG32F) float 2 NO R G 0 1 $(D_INLINECODE GL_RG8I) byte 2 NO R G 0 1 $(D_INLINECODE GL_RG16I) short 2 NO R G 0 1 $(D_INLINECODE GL_RG32I) int 2 NO R G 0 1 $(D_INLINECODE GL_RG8UI) ubyte 2 NO R G 0 1 $(D_INLINECODE GL_RG16UI) ushort 2 NO R G 0 1 $(D_INLINECODE GL_RG32UI) uint 2 NO R G 0 1 $(D_INLINECODE GL_RGB32F) float 3 NO R G B 1 $(D_INLINECODE GL_RGB32I) int 3 NO R G B 1 $(D_INLINECODE GL_RGB32UI) uint 3 NO R G B 1 $(D_INLINECODE GL_RGBA8) uint 4 YES R G B A $(D_INLINECODE GL_RGBA16) short 4 YES R G B A $(D_INLINECODE GL_RGBA16F) half 4 NO R G B A $(D_INLINECODE GL_RGBA32F) float 4 NO R G B A $(D_INLINECODE GL_RGBA8I) byte 4 NO R G B A $(D_INLINECODE GL_RGBA16I) short 4 NO R G B A $(D_INLINECODE GL_RGBA32I) int 4 NO R G B A $(D_INLINECODE GL_RGBA8UI) ubyte 4 NO R G B A $(D_INLINECODE GL_RGBA16UI) ushort 4 NO R G B A $(D_INLINECODE GL_RGBA32UI) uint 4 NO R G B A This converted data is then replicated throughout the buffer object's data store. If $(D_INLINECODE data) is null,
     +  then the buffer's data store is filled with zeros.
     + 
     + Params:
     +     target         = Specifies the target to which the buffer object is bound for $(D_INLINECODE glClearBufferData), which must must be one of the buffer binding targets in the following table: $(B Buffer Binding Target) $(B Purpose) $(D_INLINECODE GL_ARRAY_BUFFER) Vertex attributes $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) Atomic counter storage $(D_INLINECODE GL_COPY_READ_BUFFER) Buffer copy source $(D_INLINECODE GL_COPY_WRITE_BUFFER) Buffer copy destination $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) Indirect compute dispatch commands $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) Indirect command arguments $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) Vertex array indices $(D_INLINECODE GL_PIXEL_PACK_BUFFER) Pixel read target $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) Texture data source $(D_INLINECODE GL_QUERY_BUFFER) Query result buffer $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) Read-write storage for shaders $(D_INLINECODE GL_TEXTURE_BUFFER) Texture data buffer $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) Transform feedback buffer $(D_INLINECODE GL_UNIFORM_BUFFER) Uniform block storage
     +     buffer         = Specifies the name of the buffer object for $(D_INLINECODE glClearNamedBufferData).
     +     internalformat = The internal format with which the data will be stored in the buffer object.
     +     format         = The format of the data in memory addressed by $(D_INLINECODE data).
     +     type           = The type of the data in memory addressed by $(D_INLINECODE data).
     +     data           = The address of a memory location storing the data to be replicated into the buffer's data store.
     + 
     + Copyright:
     +     Copyright&copy; 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glClearBufferSubData).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_clear_buffer_object")
    fn_glClearBufferData glClearBufferData;
    alias fn_glClearNamedBufferData = extern(System) void function(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const( void*) data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glClearNamedBufferData glClearNamedBufferData;
    alias fn_glClearBufferSubData = extern(System) void function(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const( void*) data) @system @nogc nothrow;

    /++
     + glClearBufferSubData: man4/glClearBufferSubData.xml
     + 
     + $(D_INLINECODE glClearBufferSubData) and $(D_INLINECODE glClearNamedBufferSubData) fill a specified region of a buffer object's data store with data from client memory. $(D_INLINECODE offset) and $(D_INLINECODE size) specify the extent of the region within the data store of the buffer object to fill with data. Data, initially supplied in a format specified by $(D_INLINECODE format) in data type $(D_INLINECODE type) is read from the memory address given by $(D_INLINECODE data) and converted into the internal representation given by $(D_INLINECODE internalformat), which must be one of the following sized internal formats: $(B Component) $(B Sized Internal Format) $(B Base Type) $(B Components) $(B Norm) 0 1 2 3 $(D_INLINECODE GL_R8) ubyte 1 YES R 0 0 1 $(D_INLINECODE GL_R16) ushort 1 YES R 0 0 1 $(D_INLINECODE GL_R16F) half 1 NO R 0 0 1 $(D_INLINECODE GL_R32F) float 1 NO R 0 0 1 $(D_INLINECODE GL_R8I) byte 1 NO R 0 0 1 $(D_INLINECODE GL_R16I) short 1 NO R 0 0 1 $(D_INLINECODE GL_R32I) int 1 NO R 0 0 1 $(D_INLINECODE GL_R8UI) ubyte 1 NO R 0 0 1 $(D_INLINECODE GL_R16UI) ushort 1 NO R 0 0 1 $(D_INLINECODE GL_R32UI) uint 1 NO R 0 0 1 $(D_INLINECODE GL_RG8) ubyte 2 YES R G 0 1 $(D_INLINECODE GL_RG16) ushort 2 YES R G 0 1 $(D_INLINECODE GL_RG16F) half 2 NO R G 0 1 $(D_INLINECODE GL_RG32F) float 2 NO R G 0 1 $(D_INLINECODE GL_RG8I) byte 2 NO R G 0 1 $(D_INLINECODE GL_RG16I) short 2 NO R G 0 1 $(D_INLINECODE GL_RG32I) int 2 NO R G 0 1 $(D_INLINECODE GL_RG8UI) ubyte 2 NO R G 0 1 $(D_INLINECODE GL_RG16UI) ushort 2 NO R G 0 1 $(D_INLINECODE GL_RG32UI) uint 2 NO R G 0 1 $(D_INLINECODE GL_RGB32F) float 3 NO R G B 1 $(D_INLINECODE GL_RGB32I) int 3 NO R G B 1 $(D_INLINECODE GL_RGB32UI) uint 3 NO R G B 1 $(D_INLINECODE GL_RGBA8) uint 4 YES R G B A $(D_INLINECODE GL_RGBA16) short 4 YES R G B A $(D_INLINECODE GL_RGBA16F) half 4 NO R G B A $(D_INLINECODE GL_RGBA32F) float 4 NO R G B A $(D_INLINECODE GL_RGBA8I) byte 4 NO R G B A $(D_INLINECODE GL_RGBA16I) short 4 NO R G B A $(D_INLINECODE GL_RGBA32I) int 4 NO R G B A $(D_INLINECODE GL_RGBA8UI) ubyte 4 NO R G B A $(D_INLINECODE GL_RGBA16UI) ushort 4 NO R G B A $(D_INLINECODE GL_RGBA32UI) uint 4 NO R G B A This converted data is then replicated throughout the specified region of the buffer object's data store. If $(D_INLINECODE data) is null, then the subrange of the
     +  buffer's data store is filled with zeros.
     + 
     + Params:
     +     target         = Specifies the target to which the buffer object is bound for $(D_INLINECODE glClearBufferSubData), which must be one of the buffer binding targets in the following table: $(B Buffer Binding Target) $(B Purpose) $(D_INLINECODE GL_ARRAY_BUFFER) Vertex attributes $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) Atomic counter storage $(D_INLINECODE GL_COPY_READ_BUFFER) Buffer copy source $(D_INLINECODE GL_COPY_WRITE_BUFFER) Buffer copy destination $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) Indirect compute dispatch commands $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) Indirect command arguments $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) Vertex array indices $(D_INLINECODE GL_PIXEL_PACK_BUFFER) Pixel read target $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) Texture data source $(D_INLINECODE GL_QUERY_BUFFER) Query result buffer $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) Read-write storage for shaders $(D_INLINECODE GL_TEXTURE_BUFFER) Texture data buffer $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) Transform feedback buffer $(D_INLINECODE GL_UNIFORM_BUFFER) Uniform block storage
     +     buffer         = Specifies the name of the buffer object for $(D_INLINECODE glClearNamedBufferSubData).
     +     internalformat = The internal format with which the data will be stored in the buffer object.
     +     offset         = The offset in basic machine units into the buffer object's data store at which to start filling.
     +     size           = The size in basic machine units of the range of the data store to fill.
     +     format         = The format of the data in memory addressed by $(D_INLINECODE data).
     +     type           = The type of the data in memory addressed by $(D_INLINECODE data).
     +     data           = The address of a memory location storing the data to be replicated into the buffer's data store.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glClearBufferData).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_clear_buffer_object")
    fn_glClearBufferSubData glClearBufferSubData;
    alias fn_glClearNamedBufferSubData = extern(System) void function(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizei size, GLenum format, GLenum type, const( void*) data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glClearNamedBufferSubData glClearNamedBufferSubData;
    alias fn_glClearColor = extern(System) void function(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) @system @nogc nothrow;

    /++
     + glClearColor: man4/glClearColor.xml
     + 
     + $(D_INLINECODE glClearColor) specifies the red, green, blue, and alpha values used by $(D_INLINECODE glClear) to clear the color buffers. Values specified by $(D_INLINECODE glClearColor) are clamped to the range 0 1.
     + 
     + The type of the $(D_INLINECODE red), $(D_INLINECODE green), $(D_INLINECODE blue), and $(D_INLINECODE alpha) parameters was changed from GLclampf to GLfloat. This change is transparent to user code and is described in detail on the $(D_INLINECODE removedTypes) page.
     + 
     + Params:
     +     red = Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glClear), $(D_INLINECODE removedTypes)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glClearColor glClearColor;
    alias fn_glClearDepth = extern(System) void function(GLdouble depth) @system @nogc nothrow;

    /++
     + glClearDepth: man4/glClearDepth.xml
     + 
     + $(D_INLINECODE glClearDepth) specifies the depth value used by $(D_INLINECODE glClear) to clear the depth buffer. Values specified by $(D_INLINECODE glClearDepth) are clamped to the range 0 1.
     + 
     + The type of the $(D_INLINECODE depth) parameter was changed from GLclampf to GLfloat for $(D_INLINECODE glClearDepthf) and from GLclampd to GLdouble for $(D_INLINECODE glClearDepth). This change is transparent to user code and is described in detail on the $(D_INLINECODE removedTypes) page.
     + 
     + Params:
     +     depth = Specifies the depth value used when the depth buffer is cleared. The initial value is 1.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glClear), $(D_INLINECODE removedTypes)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glClearDepth glClearDepth;
    alias fn_glClearDepthf = extern(System) void function(GLfloat depth) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_ES2_compatibility")
    fn_glClearDepthf glClearDepthf;
    alias fn_glClearStencil = extern(System) void function(GLint s) @system @nogc nothrow;

    /++
     + glClearStencil: man4/glClearStencil.xml
     + 
     + $(D_INLINECODE glClearStencil) specifies the index used by $(D_INLINECODE glClear) to clear the stencil buffer. $(D_INLINECODE s) is masked with 2 m - 1, where m is the number of bits in the stencil buffer.
     + 
     + Params:
     +     s = Specifies the index used when the stencil buffer is cleared. The initial value is 0.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glClear), $(D_INLINECODE glStencilFunc), $(D_INLINECODE glStencilFuncSeparate), $(D_INLINECODE glStencilMask), $(D_INLINECODE glStencilMaskSeparate), $(D_INLINECODE glStencilOp), $(D_INLINECODE glStencilOpSeparate)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glClearStencil glClearStencil;
    alias fn_glClearTexImage = extern(System) void function(GLuint texture, GLint level, GLenum format, GLenum type, const( void*) data) @system @nogc nothrow;

    /++
     + glClearTexImage: man4/glClearTexImage.xml
     + 
     + $(D_INLINECODE glClearTexImage) fills all an image contained in a texture with an application supplied value. $(D_INLINECODE texture) must be the name of an existing texture. Further, $(D_INLINECODE texture) may not be the name of a buffer texture, nor may its internal format be compressed. $(D_INLINECODE format) and $(D_INLINECODE type) specify the format and type of the source data and are interpreted as they are for $(D_INLINECODE glTexImage3D). Textures with a base internal format of $(D_INLINECODE GL_DEPTH_COMPONENT), $(D_INLINECODE GL_STENCIL_INDEX), or $(D_INLINECODE GL_DEPTH_STENCIL) require depth component, stencil, or depth-stencil component data respectively. Textures with other base internal formats require RGBA formats. Textures with integer internal formats require integer data. $(D_INLINECODE data) is a pointer to an array of between one and four components of texel data that will be used as the source for the constant fill value. The elements of data are converted by the GL into the internal format of the texture image (that was specified when the level was defined by any of the $(D_INLINECODE glTexImage*), $(D_INLINECODE glTexStorage*) or $(D_INLINECODE glCopyTexImage*) commands), and then used to fill the specified range of the destination texture level. If $(D_INLINECODE data) is $(D_INLINECODE null
     + ), then the pointer is ignored and the sub-range of the texture image is filled with zeros. If texture is a multisample texture, all the samples in a texel are cleared to the value specified by data.
     + 
     + $(D_INLINECODE glClearTexImage) is available only if the GL version is 4.4 or greater.
     + 
     + Params:
     +     texture = The name of an existing texture object containing the image to be cleared.
     +     level   = The level of $(D_INLINECODE texture) containing the region to be cleared.
     +     format  = The format of the data whose address in memory is given by $(D_INLINECODE data).
     +     type    = The type of the data whose address in memory is given by $(D_INLINECODE data).
     +     data    = The address in memory of the data to be used to clear the specified region.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glClearTexSubImage), $(D_INLINECODE glTexStorage1D), $(D_INLINECODE glTexStorage2D), $(D_INLINECODE glTexStorage3D), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P4)
    @OpenGL_Extension("GL_ARB_clear_texture")
    fn_glClearTexImage glClearTexImage;
    alias fn_glClearTexSubImage = extern(System) void function(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const( void*) data) @system @nogc nothrow;

    /++
     + glClearTexSubImage: man4/glClearTexSubImage.xml
     + 
     + $(D_INLINECODE glClearTexSubImage) fills all or part of an image contained in a texture with an application supplied value. $(D_INLINECODE texture) must be the name of an existing texture. Further, $(D_INLINECODE texture) may not be the name of a buffer texture, nor may its internal format be compressed. Arguments $(D_INLINECODE xoffset), $(D_INLINECODE yoffset), and $(D_INLINECODE zoffset) specify the lower left texel coordinates of a width-wide by height-high by depth-deep rectangular subregion of the texel array. For one-dimensional array textures, $(D_INLINECODE yoffset) is interpreted as the first layer to be cleared and $(D_INLINECODE height) is the number of layers to clear. For two-dimensional array textures, $(D_INLINECODE zoffset) is interpreted as the first layer to be cleared and $(D_INLINECODE depth) is the number of layers to clear. Cube map textures are treated as an array of six slices in the z-dimension, where the value of $(D_INLINECODE zoffset) is interpreted as specifying the cube map face for the corresponding layer and $(D_INLINECODE depth) is the number of faces to clear. For cube map array textures, $(D_INLINECODE zoffset) is the first layer-face to clear, and $(D_INLINECODE depth) is the number of layer-faces to clear. Each layer-face is translated into an array layer and a cube map face as described in the OpenGL Specification. Negative values of $(D_INLINECODE xoffset), $(D_INLINECODE yoffset), and $(D_INLINECODE zoffset) correspond to the coordinates of border texels. Taking ws, hs, ds, wb, hb, and db to be the specified $(D_INLINECODE width), $(D_INLINECODE height), $(D_INLINECODE depth), and the border width, border height, and border depth of the texel array and taking x, y, z, w, h, and d to be the $(D_INLINECODE xoffset), $(D_INLINECODE yoffset), $(D_INLINECODE zoffset), $(D_INLINECODE width), $(D_INLINECODE height), and $(D_INLINECODE depth) argument values, any of the following relationships generates a $(D_INLINECODE GL_INVALID_OPERATION) error: $(OL $(LI x &lt; w b) $(LI x + w &gt; w s - w b) $(LI y &lt; - h b) $(LI y + h &gt; h s - h b) $(LI z &lt; - d b) $(LI z + d &gt; d s - d b)) For texture types that do not have certain dimensions, this command treats those dimensions as having a size of 1. For example, to clear a portion of a two-dimensional texture, use $(D_INLINECODE zoffset) equal to zero and $(D_INLINECODE depth) equal to one. $(D_INLINECODE format) and $(D_INLINECODE type) specify the format and type of the source data and are interpreted as they are for $(D_INLINECODE glTexImage3D). Textures with a base internal format of $(D_INLINECODE GL_DEPTH_COMPONENT), $(D_INLINECODE GL_STENCIL_INDEX), or $(D_INLINECODE GL_DEPTH_STENCIL) require depth component, stencil, or depth-stencil component data respectively. Textures with other base internal formats require RGBA formats. Textures with integer internal formats require integer data. $(D_INLINECODE data) is a pointer to an array of between one and four components of texel data that will be used as the source for the constant fill value. The elements of data are converted by the GL into the internal format of the texture image (that was specified when the level was defined by any of the $(D_INLINECODE glTexImage*), $(D_INLINECODE glTexStorage*) or $(D_INLINECODE glCopyTexImage*) commands), and then used to fill the specified range of the destination texture level. If $(D_INLINECODE data) is $(D_INLINECODE null
     + ), then the pointer is ignored and the sub-range of the texture image is filled with zeros. If texture is a multisample texture, all the samples in a texel are cleared to the value specified by data.
     + 
     + $(D_INLINECODE glClearTexSubImage) is available only if the GL version is 4.4 or greater.
     + 
     + Params:
     +     texture = The name of an existing texture object containing the image to be cleared.
     +     level   = The level of $(D_INLINECODE texture) containing the region to be cleared.
     +     xoffset = The coordinate of the left edge of the region to be cleared.
     +     yoffset = The coordinate of the lower edge of the region to be cleared.
     +     zoffset = The coordinate of the front of the region to be cleared.
     +     width   = The width of the region to be cleared.
     +     height  = The height of the region to be cleared.
     +     depth   = The depth of the region to be cleared.
     +     format  = The format of the data whose address in memory is given by $(D_INLINECODE data).
     +     type    = The type of the data whose address in memory is given by $(D_INLINECODE data).
     +     data    = The address in memory of the data to be used to clear the specified region.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glClearTexImage), $(D_INLINECODE glTexStorage1D), $(D_INLINECODE glTexStorage2D), $(D_INLINECODE glTexStorage3D), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P4)
    @OpenGL_Extension("GL_ARB_clear_texture")
    fn_glClearTexSubImage glClearTexSubImage;
    alias fn_glClientWaitSync = extern(System) GLenum function(GLsync sync, GLbitfield flags, GLuint64 timeout) @system @nogc nothrow;

    /++
     + glClientWaitSync: man4/glClientWaitSync.xml
     + 
     + $(D_INLINECODE glClientWaitSync) causes the client to block and wait for the sync object specified by $(D_INLINECODE sync) to become signaled. If $(D_INLINECODE sync) is signaled when $(D_INLINECODE glClientWaitSync) is called, $(D_INLINECODE glClientWaitSync) returns immediately, otherwise it will block and wait for up to $(D_INLINECODE timeout) nanoseconds for $(D_INLINECODE sync) to become signaled. The return value is one of four status values: $(OL $(LI $(D_INLINECODE GL_ALREADY_SIGNALED) indicates that $(D_INLINECODE sync) was signaled at the time that $(D_INLINECODE glClientWaitSync) was called.) $(LI $(D_INLINECODE GL_TIMEOUT_EXPIRED) indicates that at least $(D_INLINECODE timeout) nanoseconds passed and $(D_INLINECODE sync) did not become signaled.) $(LI $(D_INLINECODE GL_CONDITION_SATISFIED) indicates that $(D_INLINECODE sync) was signaled before the timeout expired.) $(LI $(D_INLINECODE GL_WAIT_FAILED) indicates that an error occurred. Additionally, an OpenGL error will be generated.))
     + 
     + $(D_INLINECODE glClientWaitSync) is available only if the GL version is 3.2 or greater.
     + 
     + Params:
     +     sync    = The sync object whose status to wait on.
     +     flags   = A bitfield controlling the command flushing behavior. $(D_INLINECODE flags) may be $(D_INLINECODE GL_SYNC_FLUSH_COMMANDS_BIT).
     +     timeout = The timeout, specified in nanoseconds, for which the implementation should wait for $(D_INLINECODE sync) to become signaled.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glFenceSync), $(D_INLINECODE glIsSync) $(D_INLINECODE glWaitSync)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_sync")
    fn_glClientWaitSync glClientWaitSync;
    alias fn_glClipControl = extern(System) void function(GLenum origin, GLenum depth) @system @nogc nothrow;

    /++
     + glClipControl: man4/glClipControl.xml
     + 
     + $(D_INLINECODE glClipControl) controls the clipping volume behavior and the clip coordinate to window coordinate transformation behavior. The view volume is defined by $$z_{min} \leq z_c \leq w_c$$ where $z_{min} = -w_c$ when $(D_INLINECODE depth) is $(D_INLINECODE GL_NEGATIVE_ONE_TO_ONE), and $z_{min} = 0$ when $(D_INLINECODE depth) is $(D_INLINECODE GL_ZERO_TO_ONE). The normalized device coordinate $y_d$ is given by $$y_d = { { f \times y_c } \over w_c }$$ where $f = 1$ when $(D_INLINECODE origin) is $(D_INLINECODE GL_LOWER_LEFT), and $f = -1$ when $(D_INLINECODE origin) is $(D_INLINECODE GL_UPPER_LEFT). The window coordinate $z_w$ is given by $$z_w = s \times z_d + b$$ where $s = { { f - n } \over 2 }$ and $b = { {n + f} \over 2 }$ when $(D_INLINECODE depth) is $(D_INLINECODE GL_NEGATIVE_ONE_TO_ONE), and $s = f - n$ and $b = n$ when $(D_INLINECODE depth) is $(D_INLINECODE GL_ZERO_TO_ONE). $n$ and $f$ are the near and far depth range values set with $(D_INLINECODE glDepthRange). Finally, the polygon area computation defined by $(D_INLINECODE gl_FrontFacing) to determine if a polygon is front- or back-facing has its sign negated when $(D_INLINECODE origin) is $(D_INLINECODE GL_UPPER_LEFT).
     + 
     + The default GL clip volume definition is for a $(D_INLINECODE origin) of $(D_INLINECODE GL_LOWER_LEFT) and a $(D_INLINECODE depth) of $(D_INLINECODE GL_NEGATIVE_ONE_TO_ONE). An $(D_INLINECODE origin) of $(D_INLINECODE GL_UPPER_LEFT) and a $(D_INLINECODE depth) of $(D_INLINECODE GL_ZERO_TO_ONE) corresponds to Direct3D's clip volume definition. An $(D_INLINECODE origin) of $(D_INLINECODE GL_UPPER_LEFT) and a $(D_INLINECODE depth) of $(D_INLINECODE GL_NEGATIVE_ONE_TO_ONE) corresponds to the upper-left origin of the window coordinate system of Microsoft Windows and the X Window System. There is extensive discussion of the uses and further consequences of the different clip volume settings in the $(D_INLINECODE GL_ARB_clip_control) extension specification in the OpenGL Registry at URL $(LINK2 http://www.opengl.org/registry/, http://www.opengl.org/registry/).
     + 
     + Params:
     +     origin = Specifies the clip control origin. Must be one of $(D_INLINECODE GL_LOWER_LEFT) or $(D_INLINECODE GL_UPPER_LEFT).
     +     depth  = Specifies the clip control depth mode. Must be one of $(D_INLINECODE GL_NEGATIVE_ONE_TO_ONE) or $(D_INLINECODE GL_ZERO_TO_ONE).
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE gl_ClipDistance), $(D_INLINECODE gl_CullDistance), $(D_INLINECODE gl_FrontFacing), $(D_INLINECODE glDepthRange).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_clip_control")
    fn_glClipControl glClipControl;
    alias fn_glColorMask = extern(System) void function(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha) @system @nogc nothrow;

    /++
     + glColorMask: man4/glColorMask.xml
     + 
     + $(D_INLINECODE glColorMask) and $(D_INLINECODE glColorMaski) specify whether the individual color components in the frame buffer can or cannot be written. $(D_INLINECODE glColorMaski) sets the mask for a specific draw buffer, whereas $(D_INLINECODE glColorMask) sets the mask for all draw buffers. If $(D_INLINECODE red) is $(D_INLINECODE GL_FALSE), for example, no change is made to the red component of any pixel in any of the color buffers, regardless of the drawing operation attempted. Changes to individual bits of components cannot be controlled. Rather, changes are either enabled or disabled for entire color components.
     + 
     + Params:
     +     buf = For $(D_INLINECODE glColorMaski), specifies the index of the draw buffer whose color mask to set.
     +     red = Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all $(D_INLINECODE GL_TRUE), indicating that the color components are written.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glClear), $(D_INLINECODE glDepthMask), $(D_INLINECODE glStencilMask)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glColorMask glColorMask;
    alias fn_glCompileShader = extern(System) void function(GLuint shader) @system @nogc nothrow;

    /++
     + glCompileShader: man4/glCompileShader.xml
     + 
     + $(D_INLINECODE glCompileShader) compiles the source code strings that have been stored in the shader object specified by $(D_INLINECODE shader). The compilation status will be stored as part of the shader object's state. This value will be set to $(D_INLINECODE GL_TRUE) if the shader was compiled without errors and is ready for use, and $(D_INLINECODE GL_FALSE) otherwise. It can be queried by calling $(D_INLINECODE glGetShader) with arguments $(D_INLINECODE shader) and $(D_INLINECODE GL_COMPILE_STATUS). Compilation of a shader can fail for a number of reasons as specified by the OpenGL Shading Language Specification. Whether or not the compilation was successful, information about the compilation can be obtained from the shader object's information log by calling $(D_INLINECODE glGetShaderInfoLog).
     + 
     + Params:
     +     shader = Specifies the shader object to be compiled.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCreateShader), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glShaderSource)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glCompileShader glCompileShader;
    alias fn_glCompressedTexImage1D = extern(System) void function(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const( GLvoid*) data) @system @nogc nothrow;

    /++
     + glCompressedTexImage1D: man4/glCompressedTexImage1D.xml
     + 
     + Texturing allows elements of an image array to be read by shaders. $(D_INLINECODE glCompressedTexImage1D) loads a previously defined, and retrieved, compressed one-dimensional texture image if $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_1D) (see $(D_INLINECODE glTexImage1D) ). If $(D_INLINECODE target) is $(D_INLINECODE GL_PROXY_TEXTURE_1D), no data is read from $(D_INLINECODE data), but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities.  If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see $(D_INLINECODE glGetError) ). To query for an entire mipmap array, use an image array level greater than or equal to 1. $(D_INLINECODE internalformat) must be an extension-specified compressed-texture format. When a texture is loaded with $(D_INLINECODE glTexImage1D) using a generic compressed  texture format (e.g., $(D_INLINECODE GL_COMPRESSED_RGB) ) the GL selects from one of its extensions supporting compressed textures.  In order to load the compressed texture image using $(D_INLINECODE glCompressedTexImage1D), query the compressed texture image's size and format using $(D_INLINECODE glGetTexLevelParameter). If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store. If the compressed data are arranged into fixed-size blocks of texels, the pixel storage modes can be used to select a sub-rectangle from a larger containing rectangle. These pixel storage modes operate in the same way as they do for $(D_INLINECODE glTexImage1D). In the following description, denote by b s, b w, b h, and b d the values of pixel storage modes $(D_INLINECODE GL_UNPACK_COMPRESSED_BLOCK_SIZE), $(D_INLINECODE GL_UNPACK_COMPRESSED_BLOCK_WIDTH), $(D_INLINECODE GL_UNPACK_COMPRESSED_BLOCK_HEIGHT), and $(D_INLINECODE GL_UNPACK_COMPRESSED_BLOCK_DEPTH), respectively. b s is the compressed block size in bytes; b w, b h, and b d are the compressed block width, height, and depth in pixels. By default the pixel storage modes $(D_INLINECODE GL_UNPACK_ROW_LENGTH), $(D_INLINECODE GL_UNPACK_SKIP_ROWS), $(D_INLINECODE GL_UNPACK_SKIP_PIXELS), $(D_INLINECODE GL_UNPACK_IMAGE_HEIGHT) and $(D_INLINECODE GL_UNPACK_SKIP_IMAGES) are ignored for compressed images. To enable $(D_INLINECODE GL_UNPACK_SKIP_PIXELS) and $(D_INLINECODE GL_UNPACK_ROW_LENGTH), b s and b w must both be non-zero. To also enable $(D_INLINECODE GL_UNPACK_SKIP_ROWS) and $(D_INLINECODE GL_UNPACK_IMAGE_HEIGHT), b h must be non-zero. To also enable $(D_INLINECODE GL_UNPACK_SKIP_IMAGES), b d must be non-zero. All parameters must be consistent with the compressed format to produce the desired results. When selecting a sub-rectangle from a compressed image, $(OL $(LI the value of $(D_INLINECODE GL_UNPACK_SKIP_PIXELS) must be a multiple of b w)) $(D_INLINECODE imageSize) must be equal to: b s &times; width b w
     + 
     + Params:
     +     target         = Specifies the target texture. Must be $(D_INLINECODE GL_TEXTURE_1D) or $(D_INLINECODE GL_PROXY_TEXTURE_1D).
     +     level          = Specifies the level-of-detail number. Level 0 is the base image level. Level is the th mipmap reduction image.
     +     internalformat = Specifies the format of the compressed image data stored at address $(D_INLINECODE data).
     +     width          = Specifies the width of the texture image. All implementations support texture images that are at least 64 texels wide. The height of the 1D texture image is 1.
     +     border         = This value must be 0.
     +     imageSize      = Specifies the number of unsigned bytes of image data starting at the address specified by $(D_INLINECODE data).
     +     data           = Specifies a pointer to the compressed image data in memory.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2011-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glCompressedTexImage2D), $(D_INLINECODE glCompressedTexImage3D), $(D_INLINECODE glCompressedTexSubImage1D), $(D_INLINECODE glCompressedTexSubImage2D), $(D_INLINECODE glCompressedTexSubImage3D), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glPixelStore), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glCompressedTexImage1D glCompressedTexImage1D;
    alias fn_glCompressedTexImage2D = extern(System) void function(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const( GLvoid*) data) @system @nogc nothrow;

    /++
     + glCompressedTexImage2D: man4/glCompressedTexImage2D.xml
     + 
     + Texturing allows elements of an image array to be read by shaders. $(D_INLINECODE glCompressedTexImage2D) loads a previously defined, and retrieved, compressed two-dimensional texture image if $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_2D), or one of the cube map faces such as $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X). (see $(D_INLINECODE glTexImage2D) ). If $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE data) is treated as an array of compressed 1D textures. If $(D_INLINECODE target) is $(D_INLINECODE GL_PROXY_TEXTURE_2D), $(D_INLINECODE GL_PROXY_TEXTURE_1D_ARRAY) or $(D_INLINECODE GL_PROXY_TEXTURE_CUBE_MAP), no data is read from $(D_INLINECODE data), but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities.  If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see $(D_INLINECODE glGetError) ). To query for an entire mipmap array, use an image array level greater than or equal to 1. $(D_INLINECODE internalformat) must be a known compressed image format (such as $(D_INLINECODE GL_RGTC) ) or an extension-specified compressed-texture format. When a texture is loaded with $(D_INLINECODE glTexImage2D) using a generic compressed texture format (e.g., $(D_INLINECODE GL_COMPRESSED_RGB) ), the GL selects from one of its extensions supporting compressed textures.  In order to load the compressed texture image using $(D_INLINECODE glCompressedTexImage2D), query the compressed texture image's size and format using $(D_INLINECODE glGetTexLevelParameter). If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store. If the compressed data are arranged into fixed-size blocks of texels, the pixel storage modes can be used to select a sub-rectangle from a larger containing rectangle. These pixel storage modes operate in the same way as they do for $(D_INLINECODE glTexImage2D). In the following description, denote by b s, b w, b h, and b d, the values of pixel storage modes $(D_INLINECODE GL_UNPACK_COMPRESSED_BLOCK_SIZE), $(D_INLINECODE GL_UNPACK_COMPRESSED_BLOCK_WIDTH), $(D_INLINECODE GL_UNPACK_COMPRESSED_BLOCK_HEIGHT), and $(D_INLINECODE GL_UNPACK_COMPRESSED_BLOCK_DEPTH), respectively. b s is the compressed block size in bytes; b w, b h, and b d are the compressed block width, height, and depth in pixels. By default the pixel storage modes $(D_INLINECODE GL_UNPACK_ROW_LENGTH), $(D_INLINECODE GL_UNPACK_SKIP_ROWS), $(D_INLINECODE GL_UNPACK_SKIP_PIXELS), $(D_INLINECODE GL_UNPACK_IMAGE_HEIGHT) and $(D_INLINECODE GL_UNPACK_SKIP_IMAGES) are ignored for compressed images. To enable $(D_INLINECODE GL_UNPACK_SKIP_PIXELS) and $(D_INLINECODE GL_UNPACK_ROW_LENGTH), b s and b w must both be non-zero. To also enable $(D_INLINECODE GL_UNPACK_SKIP_ROWS) and $(D_INLINECODE GL_UNPACK_IMAGE_HEIGHT), b h must be non-zero. To also enable $(D_INLINECODE GL_UNPACK_SKIP_IMAGES), b d must be non-zero. All parameters must be consistent with the compressed format to produce the desired results. When selecting a sub-rectangle from a compressed image: $(OL $(LI The value of $(D_INLINECODE GL_UNPACK_SKIP_PIXELS) must be a multiple of b w;) $(LI the value of $(D_INLINECODE GL_UNPACK_SKIP_ROWS) must be a multiple of b w.)) $(D_INLINECODE imageSize) must be equal to: b s &times; width b w &times; height b h
     + 
     + The specific compressed internal formats $(D_INLINECODE GL_COMPRESSED_RGB8_ETC2), $(D_INLINECODE GL_COMPRESSED_SRGB8_ETC2), $(D_INLINECODE GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2), $(D_INLINECODE GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2), $(D_INLINECODE GL_COMPRESSED_RGBA8_ETC2_EAC), $(D_INLINECODE GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC), $(D_INLINECODE GL_COMPRESSED_R11_EAC), $(D_INLINECODE GL_COMPRESSED_SIGNED_R11_EAC), $(D_INLINECODE GL_COMPRESSED_RG11_EAC), and $(D_INLINECODE GL_COMPRESSED_SIGNED_RG11_EAC) are available only if the GL version is 4.3 or higher.
     + 
     + Params:
     +     target         = Specifies the target texture. Must be $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_PROXY_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_PROXY_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Z), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Z), or $(D_INLINECODE GL_PROXY_TEXTURE_CUBE_MAP).
     +     level          = Specifies the level-of-detail number. Level 0 is the base image level. Level is the th mipmap reduction image.
     +     internalformat = Specifies the format of the compressed image data stored at address $(D_INLINECODE data).
     +     width          = Specifies the width of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels wide.
     +     height         = Specifies the height of the texture image. All implementations support 2D texture and cube map texture images that are at least 16384 texels high.
     +     border         = This value must be 0.
     +     imageSize      = Specifies the number of unsigned bytes of image data starting at the address specified by $(D_INLINECODE data).
     +     data           = Specifies a pointer to the compressed image data in memory.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2011-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glCompressedTexImage1D), $(D_INLINECODE glCompressedTexImage3D), $(D_INLINECODE glCompressedTexSubImage1D), $(D_INLINECODE glCompressedTexSubImage2D), $(D_INLINECODE glCompressedTexSubImage3D), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glPixelStore), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glCompressedTexImage2D glCompressedTexImage2D;
    alias fn_glCompressedTexImage3D = extern(System) void function(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const( GLvoid*) data) @system @nogc nothrow;

    /++
     + glCompressedTexImage3D: man4/glCompressedTexImage3D.xml
     + 
     + Texturing allows elements of an image array to be read by shaders. $(D_INLINECODE glCompressedTexImage3D) loads a previously defined, and retrieved, compressed three-dimensional texture image if $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_3D) (see $(D_INLINECODE glTexImage3D) ). If $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE data) is treated as an array of compressed 2D textures. If $(D_INLINECODE target) is $(D_INLINECODE GL_PROXY_TEXTURE_3D) or $(D_INLINECODE GL_PROXY_TEXTURE_2D_ARRAY), no data is read from $(D_INLINECODE data), but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities.  If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see $(D_INLINECODE glGetError) ). To query for an entire mipmap array, use an image array level greater than or equal to 1. $(D_INLINECODE internalformat) must be a known compressed image format (such as $(D_INLINECODE GL_RGTC) ) or an extension-specified compressed-texture format. When a texture is loaded with $(D_INLINECODE glTexImage2D) using a generic compressed texture format (e.g., $(D_INLINECODE GL_COMPRESSED_RGB) ), the GL selects from one of its extensions supporting compressed textures.  In order to load the compressed texture image using $(D_INLINECODE glCompressedTexImage3D), query the compressed texture image's size and format using $(D_INLINECODE glGetTexLevelParameter). If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store. If the compressed data are arranged into fixed-size blocks of texels, the pixel storage modes can be used to select a sub-rectangle from a larger containing rectangle. These pixel storage modes operate in the same way as they do for $(D_INLINECODE glTexImage1D). In the following description, denote by b s, b w, b h, and b d the values of pixel storage modes $(D_INLINECODE GL_UNPACK_COMPRESSED_BLOCK_SIZE), $(D_INLINECODE GL_UNPACK_COMPRESSED_BLOCK_WIDTH), $(D_INLINECODE GL_UNPACK_COMPRESSED_BLOCK_HEIGHT), and $(D_INLINECODE GL_UNPACK_COMPRESSED_BLOCK_DEPTH), respectively. b s is the compressed block size in bytes; b w, b h, and b d are the compressed block width, height, and depth in pixels. By default the pixel storage modes $(D_INLINECODE GL_UNPACK_ROW_LENGTH), $(D_INLINECODE GL_UNPACK_SKIP_ROWS), $(D_INLINECODE GL_UNPACK_SKIP_PIXELS), $(D_INLINECODE GL_UNPACK_IMAGE_HEIGHT) and $(D_INLINECODE GL_UNPACK_SKIP_IMAGES) are ignored for compressed images. To enable $(D_INLINECODE GL_UNPACK_SKIP_PIXELS) and $(D_INLINECODE GL_UNPACK_ROW_LENGTH), b s and b w must both be non-zero. To also enable $(D_INLINECODE GL_UNPACK_SKIP_ROWS) and $(D_INLINECODE GL_UNPACK_IMAGE_HEIGHT), b h must be non-zero. To also enable $(D_INLINECODE GL_UNPACK_SKIP_IMAGES), b d must be non-zero. All parameters must be consistent with the compressed format to produce the desired results. When selecting a sub-rectangle from a compressed image: $(OL $(LI the value of $(D_INLINECODE GL_UNPACK_SKIP_PIXELS) must be a multiple of b w;) $(LI the value of $(D_INLINECODE GL_UNPACK_SKIP_ROWS) must be a multiple of b w;) $(LI the value of $(D_INLINECODE GL_UNPACK_SKIP_IMAGES) must be a multiple of b w.)) $(D_INLINECODE imageSize) must be equal to: b s &times; width b w &times; height b h &times; depth b d
     + 
     + Params:
     +     target         = Specifies the target texture. Must be $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_PROXY_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_2D_ARRAY) or $(D_INLINECODE GL_PROXY_TEXTURE_2D_ARRAY).
     +     level          = Specifies the level-of-detail number. Level 0 is the base image level. Level is the th mipmap reduction image.
     +     internalformat = Specifies the format of the compressed image data stored at address $(D_INLINECODE data).
     +     width          = Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
     +     height         = Specifies the height of the texture image. All implementations support 3D texture images that are at least 16 texels high.
     +     depth          = Specifies the depth of the texture image. All implementations support 3D texture images that are at least 16 texels deep.
     +     border         = This value must be 0.
     +     imageSize      = Specifies the number of unsigned bytes of image data starting at the address specified by $(D_INLINECODE data).
     +     data           = Specifies a pointer to the compressed image data in memory.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2011-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glCompressedTexImage1D), $(D_INLINECODE glCompressedTexImage2D), $(D_INLINECODE glCompressedTexSubImage1D), $(D_INLINECODE glCompressedTexSubImage2D), $(D_INLINECODE glCompressedTexSubImage3D), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glPixelStore), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glCompressedTexImage3D glCompressedTexImage3D;
    alias fn_glCompressedTexSubImage1D = extern(System) void function(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const( GLvoid*) data) @system @nogc nothrow;

    /++
     + glCompressedTexSubImage1D: man4/glCompressedTexSubImage1D.xml
     + 
     + Texturing allows elements of an image array to be read by shaders. $(D_INLINECODE glCompressedTexSubImage1D) and $(D_INLINECODE glCompressedTextureSubImage1D) redefine a contiguous subregion of an existing one-dimensional texture image. The texels referenced by $(D_INLINECODE data) replace the portion of the existing texture array with x indices $(D_INLINECODE xoffset) and xoffset + width - 1, inclusive.  This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with width of 0, but such a specification has no effect. $(D_INLINECODE internalformat) must be a known compressed image format (such as $(D_INLINECODE GL_RGTC) ) or an extension-specified compressed-texture format. The $(D_INLINECODE format) of the compressed texture image is selected by the GL implementation that compressed it (see $(D_INLINECODE glTexImage1D) ), and should be queried at the time the texture was compressed with $(D_INLINECODE glGetTexLevelParameter). If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store.
     + 
     + Params:
     +     target    = Specifies the target, to which the texture is bound, for $(D_INLINECODE glCompressedTexSubImage1D) function. Must be $(D_INLINECODE GL_TEXTURE_1D).
     +     texture   = Specifies the texture object name for $(D_INLINECODE glCompressedTextureSubImage1D) function.
     +     level     = Specifies the level-of-detail number. Level 0 is the base image level. Level is the th mipmap reduction image.
     +     xoffset   = Specifies a texel offset in the x direction within the texture array.
     +     width     = Specifies the width of the texture subimage.
     +     format    = Specifies the format of the compressed image data stored at address $(D_INLINECODE data).
     +     imageSize = Specifies the number of unsigned bytes of image data starting at the address specified by $(D_INLINECODE data).
     +     data      = Specifies a pointer to the compressed image data in memory.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glCompressedTexImage1D), $(D_INLINECODE glCompressedTexImage2D), $(D_INLINECODE glCompressedTexImage3D), $(D_INLINECODE glCompressedTexSubImage2D), $(D_INLINECODE glCompressedTexSubImage3D), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glPixelStore), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glCompressedTexSubImage1D glCompressedTexSubImage1D;
    alias fn_glCompressedTextureSubImage1D = extern(System) void function(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const( void*) data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glCompressedTextureSubImage1D glCompressedTextureSubImage1D;
    alias fn_glCompressedTexSubImage2D = extern(System) void function(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const( GLvoid*) data) @system @nogc nothrow;

    /++
     + glCompressedTexSubImage2D: man4/glCompressedTexSubImage2D.xml
     + 
     + Texturing allows elements of an image array to be read by shaders. $(D_INLINECODE glCompressedTexSubImage2D) and $(D_INLINECODE glCompressedTextureSubImage2D) redefine a contiguous subregion of an existing two-dimensional texture image. The texels referenced by $(D_INLINECODE data) replace the portion of the existing texture array with x indices $(D_INLINECODE xoffset) and xoffset + width - 1, and the y indices $(D_INLINECODE yoffset) and yoffset + height - 1, inclusive. This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with width of 0, but such a specification has no effect. $(D_INLINECODE internalformat) must be a known compressed image format (such as $(D_INLINECODE GL_RGTC) ) or an extension-specified compressed-texture format. The $(D_INLINECODE format) of the compressed texture image is selected by the GL implementation that compressed it (see $(D_INLINECODE glTexImage2D) ) and should be queried at the time the texture was compressed with $(D_INLINECODE glGetTexLevelParameter). If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store.
     + 
     + Params:
     +     target    = Specifies the target to which the texture is bound for $(D_INLINECODE glCompressedTexSubImage2D) function. Must be $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Z), or $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Z).
     +     texture   = Specifies the texture object name for $(D_INLINECODE glCompressedTextureSubImage2D) function.
     +     level     = Specifies the level-of-detail number. Level 0 is the base image level. Level is the th mipmap reduction image.
     +     xoffset   = Specifies a texel offset in the x direction within the texture array.
     +     yoffset   = Specifies a texel offset in the y direction within the texture array.
     +     width     = Specifies the width of the texture subimage.
     +     height    = Specifies the height of the texture subimage.
     +     format    = Specifies the format of the compressed image data stored at address $(D_INLINECODE data).
     +     imageSize = Specifies the number of unsigned bytes of image data starting at the address specified by $(D_INLINECODE data).
     +     data      = Specifies a pointer to the compressed image data in memory.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glCompressedTexImage1D), $(D_INLINECODE glCompressedTexImage2D), $(D_INLINECODE glCompressedTexImage3D), $(D_INLINECODE glCompressedTexSubImage1D), $(D_INLINECODE glCompressedTexSubImage3D), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glPixelStore), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glCompressedTexSubImage2D glCompressedTexSubImage2D;
    alias fn_glCompressedTextureSubImage2D = extern(System) void function(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const( void*) data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glCompressedTextureSubImage2D glCompressedTextureSubImage2D;
    alias fn_glCompressedTexSubImage3D = extern(System) void function(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const( GLvoid*) data) @system @nogc nothrow;

    /++
     + glCompressedTexSubImage3D: man4/glCompressedTexSubImage3D.xml
     + 
     + Texturing allows elements of an image array to be read by shaders. $(D_INLINECODE glCompressedTexSubImage3D) and $(D_INLINECODE glCompressedTextureSubImage3D) redefine a contiguous subregion of an existing three-dimensional texture image. The texels referenced by $(D_INLINECODE data) replace the portion of the existing texture array with x indices $(D_INLINECODE xoffset) and xoffset + width - 1, and the y indices $(D_INLINECODE yoffset) and yoffset + height - 1, and the z indices $(D_INLINECODE zoffset) and zoffset + depth - 1, inclusive.  This region may not include any texels outside the range of the texture array as it was originally specified.  It is not an error to specify a subtexture with width of 0, but such a specification has no effect. $(D_INLINECODE internalformat) must be a known compressed image format (such as $(D_INLINECODE GL_RGTC) ) or an extension-specified compressed-texture format. The $(D_INLINECODE format) of the compressed texture image is selected by the GL implementation that compressed it (see $(D_INLINECODE glTexImage3D) ) and should be queried at the time the texture was compressed with $(D_INLINECODE glGetTexLevelParameter). If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store.
     + 
     + Params:
     +     target    = Specifies the target to which the texture is bound for $(D_INLINECODE glCompressedTexSubImage3D) function. Must be $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_3D), or $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY).
     +     texture   = Specifies the texture object name for $(D_INLINECODE glCompressedTextureSubImage3D) function.
     +     level     = Specifies the level-of-detail number. Level 0 is the base image level. Level is the th mipmap reduction image.
     +     xoffset   = Specifies a texel offset in the x direction within the texture array.
     +     yoffset   = Specifies a texel offset in the y direction within the texture array.
     +     width     = Specifies the width of the texture subimage.
     +     height    = Specifies the height of the texture subimage.
     +     depth     = Specifies the depth of the texture subimage.
     +     format    = Specifies the format of the compressed image data stored at address $(D_INLINECODE data).
     +     imageSize = Specifies the number of unsigned bytes of image data starting at the address specified by $(D_INLINECODE data).
     +     data      = Specifies a pointer to the compressed image data in memory.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glCompressedTexImage1D), $(D_INLINECODE glCompressedTexImage2D), $(D_INLINECODE glCompressedTexImage3D), $(D_INLINECODE glCompressedTexSubImage1D), $(D_INLINECODE glCompressedTexSubImage2D), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glPixelStore), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glCompressedTexSubImage3D glCompressedTexSubImage3D;
    alias fn_glCompressedTextureSubImage3D = extern(System) void function(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const( void*) data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glCompressedTextureSubImage3D glCompressedTextureSubImage3D;
    alias fn_glCopyBufferSubData = extern(System) void function(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) @system @nogc nothrow;

    /++
     + glCopyBufferSubData: man4/glCopyBufferSubData.xml
     + 
     + $(D_INLINECODE glCopyBufferSubData) and $(D_INLINECODE glCopyNamedBufferSubData) copy part of the data store attached to a source buffer object to the data store attached to a destination buffer object. The number of basic machine units indicated by $(D_INLINECODE size) is copied from the source at offset $(D_INLINECODE readOffset) to the destination at $(D_INLINECODE writeOffset). $(D_INLINECODE readOffset), $(D_INLINECODE writeOffset) and $(D_INLINECODE size) are in terms of basic machine units. For $(D_INLINECODE glCopyBufferSubData), $(D_INLINECODE readTarget) and $(D_INLINECODE writeTarget) specify the targets to which the source and destination buffer objects are bound, and must each be one of the buffer binding targets in the following table: $(B Buffer Binding Target) $(B Purpose) $(D_INLINECODE GL_ARRAY_BUFFER) Vertex attributes $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) Atomic counter storage $(D_INLINECODE GL_COPY_READ_BUFFER) Buffer copy source $(D_INLINECODE GL_COPY_WRITE_BUFFER) Buffer copy destination $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) Indirect compute dispatch commands $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) Indirect command arguments $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) Vertex array indices $(D_INLINECODE GL_PIXEL_PACK_BUFFER) Pixel read target $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) Texture data source $(D_INLINECODE GL_QUERY_BUFFER) Query result buffer $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) Read-write storage for shaders $(D_INLINECODE GL_TEXTURE_BUFFER) Texture data buffer $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) Transform feedback buffer $(D_INLINECODE GL_UNIFORM_BUFFER) Uniform block storage Any of these targets may be used, but the targets $(D_INLINECODE GL_COPY_READ_BUFFER) and $(D_INLINECODE GL_COPY_WRITE_BUFFER) are provided specifically to allow copies between buffers without disturbing other GL state. $(D_INLINECODE readOffset), $(D_INLINECODE writeOffset) and $(D_INLINECODE size) must all be greater than or equal to zero. Furthermore, $readOffset+size$ must not exceeed the size of the source buffer object, and $writeOffset+size$ must not exceeed the size of the buffer bound to $(D_INLINECODE writeTarget). If the source and destination are the same buffer object, then the source and destination ranges must not overlap.
     + 
     + The $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) and $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) targets are available only if the GL version is 4.3 or greater. The $(D_INLINECODE GL_QUERY_BUFFER) target is available only if the GL version is 4.4 or greater.
     + 
     + Params:
     +     readTarget  = Specifies the target to which the source buffer object is bound for $(D_INLINECODE glCopyBufferSubData)
     +     writeTarget = Specifies the target to which the destination buffer object is bound for $(D_INLINECODE glCopyBufferSubData).
     +     readBuffer  = Specifies the name of the source buffer object for $(D_INLINECODE glCopyNamedBufferSubData).
     +     writeBuffer = Specifies the name of the destination buffer object for $(D_INLINECODE glCopyNamedBufferSubData).
     +     readOffset  = Specifies the offset, in basic machine units, within the data store of the source buffer object at which data will be read.
     +     writeOffset = Specifies the offset, in basic machine units, within the data store of the destination buffer object at which data will be written.
     +     size        = Specifies the size, in basic machine units, of the data to be copied from the source buffer object to the destination buffer object.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenBuffers), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glBufferData), $(D_INLINECODE glBufferSubData), $(D_INLINECODE glGetBufferSubData), $(D_INLINECODE glMapBuffer), $(D_INLINECODE glMapBufferRange)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P1)
    @OpenGL_Extension("GL_ARB_copy_buffer")
    fn_glCopyBufferSubData glCopyBufferSubData;
    alias fn_glCopyNamedBufferSubData = extern(System) void function(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizei size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glCopyNamedBufferSubData glCopyNamedBufferSubData;
    alias fn_glCopyImageSubData = extern(System) void function(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth) @system @nogc nothrow;

    /++
     + glCopyImageSubData: man4/glCopyImageSubData.xml
     + 
     + $(D_INLINECODE glCopyImageSubData) may be used to copy data from one image (i.e. texture or renderbuffer) to another. $(D_INLINECODE glCopyImageSubData) does not perform general-purpose conversions such as scaling, resizing, blending, color-space, or format conversions. It should be considered to operate in a manner similar to a CPU memcpy. CopyImageSubData can copy between images with different internal formats, provided the formats are compatible. $(D_INLINECODE glCopyImageSubData) also allows copying between certain types of compressed and uncompressed internal formats. This copy does not perform on-the-fly compression or decompression. When copying from an uncompressed internal format to a compressed internal format, each texel of uncompressed data becomes a single block of compressed data. When copying from a compressed internal format to an uncompressed internal format, a block of compressed data becomes a single texel of uncompressed data. The texel size of the uncompressed format must be the same size the block size of the compressed formats. Thus it is permitted to copy between a 128-bit uncompressed format and a compressed format which uses 8-bit 4x4 blocks, or between a 64-bit uncompressed format and a compressed format which uses 4-bit 4x4 blocks. The source object is identified by $(D_INLINECODE srcName) and $(D_INLINECODE srcTarget) and the destination object is identified by $(D_INLINECODE dstName) and $(D_INLINECODE dstTarget). The interpretation of the name depends on the value of the corresponding $(D_INLINECODE target) parameter. If $(D_INLINECODE target) is $(D_INLINECODE GL_RENDERBUFFER), the name is interpreted as the name of a renderbuffer object.  If the target parameter is a texture target, the name is interpreted as a texture object.  All non-proxy texture targets are accepted, with the exception of $(D_INLINECODE GL_TEXTURE_BUFFER) and the cubemap face selectors. $(D_INLINECODE srcLevel) and $(D_INLINECODE dstLevel) identify the source and destination level of detail.  For textures, this must be a valid level of detail in the texture object.  For renderbuffers, this value must be zero. $(D_INLINECODE srcX), $(D_INLINECODE srcY), and $(D_INLINECODE srcZ) specify the lower left texel coordinates of a $(D_INLINECODE srcWidth) -wide by $(D_INLINECODE srcHeight) -high by $(D_INLINECODE srcDepth) -deep rectangular subregion of the source texel array. Similarly, $(D_INLINECODE dstX), $(D_INLINECODE dstY) and $(D_INLINECODE dstZ) specify the coordinates of a subregion of the destination texel array.  The source and destination subregions must be contained entirely within the specified level of the corresponding image objects. The dimensions are always specified in texels, even for compressed texture formats. However, it should be noted that if only one of the source and destination textures is compressed then the number of texels touched in the compressed image will be a factor of the block size larger than in the uncompressed image. Slices of a $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY) $(D_INLINECODE GL_TEXTURE_3D) and faces of $(D_INLINECODE GL_TEXTURE_CUBE_MAP) are all compatible provided they share a compatible internal format, and multiple slices or faces may be copied between these objects with a single call by specifying the starting slice with $(D_INLINECODE srcZ) and $(D_INLINECODE dstZ), and the number of slices to be copied with $(D_INLINECODE srcDepth).  Cubemap textures always have six faces which are selected by a zero-based face index. For the purposes of CopyImageSubData, two internal formats are considered compatible if any of the following conditions are met: $(OL $(LI the formats are the same,) $(LI the formats are considered compatible according to the compatibility rules used for texture views as defined in section 3.9.X. In particular, if both internal formats are listed in the same entry of Table 3.X.2, they are considered compatible, or) $(LI one format is compressed and the other is uncompressed and Table 4.X.1 lists the two formats in the same row.)) If the formats are not compatible, an INVALID_OPERATION error is generated.<h3> Sized Internal Formats</h3> $(B Texel / Block Size) $(B Uncompressed Internal Format) $(B Compressed Internal Format(s)) 64-bit $(D_INLINECODE GL_RGBA32UI), $(D_INLINECODE GL_RGBA32I), $(D_INLINECODE GL_RGBA32F) $(D_INLINECODE GL_COMPRESSED_RGBA_S3TC_DXT3_EXT), $(D_INLINECODE GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT), $(D_INLINECODE GL_COMPRESSED_RGBA_S3TC_DXT5_EXT), $(D_INLINECODE GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT), $(D_INLINECODE GL_COMPRESSED_RG_RGTC2), $(D_INLINECODE GL_COMPRESSED_SIGNED_RG_RGTC2), $(D_INLINECODE GL_COMPRESSED_RGBA_BPTC_UNORM), $(D_INLINECODE GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM), $(D_INLINECODE GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT), $(D_INLINECODE GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT) 128-bit $(D_INLINECODE GL_RGBA16UI), $(D_INLINECODE GL_RGBA16I), $(D_INLINECODE GL_RGBA16F), $(D_INLINECODE GL_RG32F), $(D_INLINECODE GL_RG32UI), $(D_INLINECODE GL_RG32I), $(D_INLINECODE GL_RGBA16), $(D_INLINECODE GL_RGBA16_SNORM) $(D_INLINECODE GL_COMPRESSED_RGB_S3TC_DXT1_EXT), $(D_INLINECODE GL_COMPRESSED_SRGB_S3TC_DXT1_EXT), $(D_INLINECODE GL_COMPRESSED_RGBA_S3TC_DXT1_EXT), $(D_INLINECODE GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT), $(D_INLINECODE GL_COMPRESSED_RED_RGTC1), $(D_INLINECODE GL_COMPRESSED_SIGNED_RED_RGTC1)
     + 
     + Params:
     +     srcName   = The name of a texture or renderbuffer object from which to copy.
     +     srcTarget = The target representing the namespace of the source name $(D_INLINECODE srcName).
     +     srcLevel  = The mipmap level to read from the source.
     +     srcX      = The X coordinate of the left edge of the souce region to copy.
     +     srcY      = The Y coordinate of the top edge of the souce region to copy.
     +     srcZ      = The Z coordinate of the near edge of the souce region to copy.
     +     dstName   = The name of a texture or renderbuffer object to which to copy.
     +     dstTarget = The target representing the namespace of the destination name $(D_INLINECODE dstName).
     +     dstX      = The X coordinate of the left edge of the destination region.
     +     dstY      = The Y coordinate of the top edge of the destination region.
     +     dstZ      = The Z coordinate of the near edge of the destination region.
     +     srcWidth  = The width of the region to be copied.
     +     srcHeight = The height of the region to be copied.
     +     srcDepth  = The depth of the region to be copied.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDispatchComputeIndirect).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_copy_image")
    fn_glCopyImageSubData glCopyImageSubData;
    alias fn_glCopyTexImage1D = extern(System) void function(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) @system @nogc nothrow;

    /++
     + glCopyTexImage1D: man4/glCopyTexImage1D.xml
     + 
     + $(D_INLINECODE glCopyTexImage1D) defines a one-dimensional texture image with pixels from the current $(D_INLINECODE GL_READ_BUFFER). The screen-aligned pixel row with left corner at x y and with a length of width defines the texture array at the mipmap level specified by $(D_INLINECODE level). $(D_INLINECODE internalformat) specifies the internal format of the texture array. The pixels in the row are processed exactly as if $(D_INLINECODE glReadPixels) had been called, but the process stops just before final conversion. At this point all pixel component values are clamped to the range 0 1 and then converted to the texture's internal format for storage in the texel array. Pixel ordering is such that lower x screen coordinates correspond to lower texture coordinates. If any of the pixels within the specified row of the current $(D_INLINECODE GL_READ_BUFFER) are outside the window associated with the current rendering context, then the values obtained for those pixels are undefined. $(D_INLINECODE glCopyTexImage1D) defines a one-dimensional texture image with pixels from the current $(D_INLINECODE GL_READ_BUFFER). When $(D_INLINECODE internalformat) is one of the sRGB  types, the GL does not automatically convert the source pixels to the sRGB color space.  In this case, the $(D_INLINECODE glPixelMap) function can be used to accomplish the conversion.
     + 
     + 1, 2, 3, and 4 are not accepted values for $(D_INLINECODE internalformat). An image with 0 width indicates a null texture.
     +  $(D_INLINECODE GL_STENCIL_INDEX8) is accepted for $(D_INLINECODE internalformat) only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     target         = Specifies the target texture. Must be $(D_INLINECODE GL_TEXTURE_1D).
     +     level          = Specifies the level-of-detail number. Level 0 is the base image level. Level is the th mipmap reduction image.
     +     internalformat = Specifies the internal format of the texture. Must be one of the following symbolic constants: $(D_INLINECODE GL_COMPRESSED_RED), $(D_INLINECODE GL_COMPRESSED_RG), $(D_INLINECODE GL_COMPRESSED_RGB), $(D_INLINECODE GL_COMPRESSED_RGBA). $(D_INLINECODE GL_COMPRESSED_SRGB), $(D_INLINECODE GL_COMPRESSED_SRGB_ALPHA). $(D_INLINECODE GL_DEPTH_COMPONENT), $(D_INLINECODE GL_DEPTH_COMPONENT16), $(D_INLINECODE GL_DEPTH_COMPONENT24), $(D_INLINECODE GL_DEPTH_COMPONENT32), $(D_INLINECODE GL_STENCIL_INDEX8), $(D_INLINECODE GL_RED), $(D_INLINECODE GL_RG), $(D_INLINECODE GL_RGB), $(D_INLINECODE GL_R3_G3_B2), $(D_INLINECODE GL_RGB4), $(D_INLINECODE GL_RGB5), $(D_INLINECODE GL_RGB8), $(D_INLINECODE GL_RGB10), $(D_INLINECODE GL_RGB12), $(D_INLINECODE GL_RGB16), $(D_INLINECODE GL_RGBA), $(D_INLINECODE GL_RGBA2), $(D_INLINECODE GL_RGBA4), $(D_INLINECODE GL_RGB5_A1), $(D_INLINECODE GL_RGBA8), $(D_INLINECODE GL_RGB10_A2), $(D_INLINECODE GL_RGBA12), $(D_INLINECODE GL_RGBA16), $(D_INLINECODE GL_SRGB), $(D_INLINECODE GL_SRGB8), $(D_INLINECODE GL_SRGB_ALPHA), or $(D_INLINECODE GL_SRGB8_ALPHA8).
     +     x              = Specify the window coordinates of the left corner of the row of pixels to be copied.
     +     width          = Specifies the width of the texture image. The height of the texture image is 1.
     +     border         = Must be 0.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2012-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glPixelStore), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    fn_glCopyTexImage1D glCopyTexImage1D;
    alias fn_glCopyTexImage2D = extern(System) void function(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) @system @nogc nothrow;

    /++
     + glCopyTexImage2D: man4/glCopyTexImage2D.xml
     + 
     + $(D_INLINECODE glCopyTexImage2D) defines a two-dimensional texture image, or cube-map texture image with pixels from the current $(D_INLINECODE GL_READ_BUFFER). The screen-aligned pixel rectangle with lower left corner at ( $(D_INLINECODE x), $(D_INLINECODE y) ) and with a width of width and a height of height defines the texture array at the mipmap level specified by $(D_INLINECODE level). $(D_INLINECODE internalformat) specifies the internal format of the texture array. The pixels in the rectangle are processed exactly as if $(D_INLINECODE glReadPixels) had been called, but the process stops just before final conversion. At this point all pixel component values are clamped to the range 0 1 and then converted to the texture's internal format for storage in the texel array. Pixel ordering is such that lower x and y screen coordinates correspond to lower s and t texture coordinates. If any of the pixels within the specified rectangle of the current $(D_INLINECODE GL_READ_BUFFER) are outside the window associated with the current rendering context, then the values obtained for those pixels are undefined. When $(D_INLINECODE internalformat) is one of the sRGB  types, the GL does not automatically convert the source pixels to the sRGB color space.  In this case, the $(D_INLINECODE glPixelMap) function can be used to accomplish the conversion.
     + 
     + 1, 2, 3, and 4 are not accepted values for $(D_INLINECODE internalformat). An image with height or width of 0 indicates a null texture.
     +  $(D_INLINECODE GL_STENCIL_INDEX8) is accepted for $(D_INLINECODE internalformat) only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     target         = Specifies the target texture. Must be $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Z), or $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Z).
     +     level          = Specifies the level-of-detail number. Level 0 is the base image level. Level is the th mipmap reduction image.
     +     internalformat = Specifies the internal format of the texture. Must be one of the following symbolic constants: $(D_INLINECODE GL_COMPRESSED_RED), $(D_INLINECODE GL_COMPRESSED_RG), $(D_INLINECODE GL_COMPRESSED_RGB), $(D_INLINECODE GL_COMPRESSED_RGBA). $(D_INLINECODE GL_COMPRESSED_SRGB), $(D_INLINECODE GL_COMPRESSED_SRGB_ALPHA). $(D_INLINECODE GL_DEPTH_COMPONENT), $(D_INLINECODE GL_DEPTH_COMPONENT16), $(D_INLINECODE GL_DEPTH_COMPONENT24), $(D_INLINECODE GL_DEPTH_COMPONENT32), $(D_INLINECODE GL_STENCIL_INDEX8), $(D_INLINECODE GL_RED), $(D_INLINECODE GL_RG), $(D_INLINECODE GL_RGB), $(D_INLINECODE GL_R3_G3_B2), $(D_INLINECODE GL_RGB4), $(D_INLINECODE GL_RGB5), $(D_INLINECODE GL_RGB8), $(D_INLINECODE GL_RGB10), $(D_INLINECODE GL_RGB12), $(D_INLINECODE GL_RGB16), $(D_INLINECODE GL_RGBA), $(D_INLINECODE GL_RGBA2), $(D_INLINECODE GL_RGBA4), $(D_INLINECODE GL_RGB5_A1), $(D_INLINECODE GL_RGBA8), $(D_INLINECODE GL_RGB10_A2), $(D_INLINECODE GL_RGBA12), $(D_INLINECODE GL_RGBA16), $(D_INLINECODE GL_SRGB), $(D_INLINECODE GL_SRGB8), $(D_INLINECODE GL_SRGB_ALPHA), or $(D_INLINECODE GL_SRGB8_ALPHA8).
     +     x              = Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
     +     width          = Specifies the width of the texture image.
     +     height         = Specifies the height of the texture image.
     +     border         = Must be 0.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2012-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glPixelStore), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    fn_glCopyTexImage2D glCopyTexImage2D;
    alias fn_glCopyTexSubImage1D = extern(System) void function(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) @system @nogc nothrow;

    /++
     + glCopyTexSubImage1D: man4/glCopyTexSubImage1D.xml
     + 
     + $(D_INLINECODE glCopyTexSubImage1D) and $(D_INLINECODE glCopyTextureSubImage1D) replace a portion of a one-dimensional texture image with pixels from the current $(D_INLINECODE GL_READ_BUFFER) (rather than from main memory, as is the case for $(D_INLINECODE glTexSubImage1D) ). For $(D_INLINECODE glCopyTexSubImage1D), the texture object that is bound to $(D_INLINECODE target) will be used for the process. For $(D_INLINECODE glCopyTextureSubImage1D), $(D_INLINECODE texture) tells which texture object should be used for the purpose of the call. The screen-aligned pixel row with left corner at ( $(D_INLINECODE x),\ $(D_INLINECODE y) ), and with length $(D_INLINECODE width) replaces the portion of the texture array with x indices $(D_INLINECODE xoffset) through xoffset + width - 1, inclusive. The destination in the texture array may not include any texels outside the texture array as it was originally specified. The pixels in the row are processed exactly as if $(D_INLINECODE glReadPixels) had been called, but the process stops just before final conversion. At this point, all pixel component values are clamped to the range 0 1 and then converted to the texture's internal format for storage in the texel array. It is not an error to specify a subtexture with zero width, but such a specification has no effect. If any of the pixels within the specified row of the current $(D_INLINECODE GL_READ_BUFFER) are outside the read window associated with the current rendering context, then the values obtained for those pixels are undefined. No change is made to the or parameters of the specified texture array or to texel values outside the specified subregion.
     + 
     + The $(D_INLINECODE glPixelStore) mode affects texture images.
     + 
     + Params:
     +     target  = Specifies the target to which the texture object is bound for $(D_INLINECODE glCopyTexSubImage1D) function. Must be $(D_INLINECODE GL_TEXTURE_1D).
     +     texture = Specifies the texture object name for $(D_INLINECODE glCopyTextureSubImage1D) function.
     +     level   = Specifies the level-of-detail number. Level 0 is the base image level. Level is the th mipmap reduction image.
     +     xoffset = Specifies the texel offset within the texture array.
     +     x       = Specify the window coordinates of the left corner of the row of pixels to be copied.
     +     width   = Specifies the width of the texture subimage.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2012-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glPixelStore), $(D_INLINECODE glReadBuffer), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexParameter), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    fn_glCopyTexSubImage1D glCopyTexSubImage1D;
    alias fn_glCopyTextureSubImage1D = extern(System) void function(GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glCopyTextureSubImage1D glCopyTextureSubImage1D;
    alias fn_glCopyTexSubImage2D = extern(System) void function(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;

    /++
     + glCopyTexSubImage2D: man4/glCopyTexSubImage2D.xml
     + 
     + $(D_INLINECODE glCopyTexSubImage2D) and $(D_INLINECODE glCopyTextureSubImage2D) replace a rectangular portion of a two-dimensional texture image, cube-map texture image, rectangular image, or a linear portion of a number of slices of a one-dimensional array texture with pixels from the current $(D_INLINECODE GL_READ_BUFFER) (rather than from main memory, as is the case for $(D_INLINECODE glTexSubImage2D) ). The screen-aligned pixel rectangle with lower left corner at x y and with width $(D_INLINECODE width) and height $(D_INLINECODE height) replaces the portion of the texture array with x indices $(D_INLINECODE xoffset) through xoffset + width - 1, inclusive, and y indices $(D_INLINECODE yoffset) through yoffset + height - 1, inclusive, at the mipmap level specified by $(D_INLINECODE level). The pixels in the rectangle are processed exactly as if $(D_INLINECODE glReadPixels) had been called, but the process stops just before final conversion. At this point, all pixel component values are clamped to the range $[0,1]$ and then converted to the texture's internal format for storage in the texel array. The destination rectangle in the texture array may not include any texels outside the texture array as it was originally specified. It is not an error to specify a subtexture with zero width or height, but such a specification has no effect. When $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_1D_ARRAY) then the y coordinate and height are treated as the start slice and number of slices to modify. If any of the pixels within the specified rectangle of the current $(D_INLINECODE GL_READ_BUFFER) are outside the read window associated with the current rendering context, then the values obtained for those pixels are undefined. No change is made to the,, or, parameters of the specified texture array or to texel values outside the specified subregion.
     + 
     + $(D_INLINECODE glPixelStore) modes affect texture images.
     + 
     + Params:
     +     target  = Specifies the target to which the texture object is bound for $(D_INLINECODE glCopyTexSubImage2D) function. Must be $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Z), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Z), or $(D_INLINECODE GL_TEXTURE_RECTANGLE).
     +     texture = Specifies the texture object name for $(D_INLINECODE glCopyTextureSubImage2D) function.
     +     level   = Specifies the level-of-detail number. Level 0 is the base image level. Level is the th mipmap reduction image.
     +     xoffset = Specifies a texel offset in the x direction within the texture array.
     +     yoffset = Specifies a texel offset in the y direction within the texture array.
     +     x       = Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
     +     width   = Specifies the width of the texture subimage.
     +     height  = Specifies the height of the texture subimage.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2012-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glPixelStore), $(D_INLINECODE glReadBuffer), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexParameter), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    fn_glCopyTexSubImage2D glCopyTexSubImage2D;
    alias fn_glCopyTextureSubImage2D = extern(System) void function(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glCopyTextureSubImage2D glCopyTextureSubImage2D;
    alias fn_glCopyTexSubImage3D = extern(System) void function(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;

    /++
     + glCopyTexSubImage3D: man4/glCopyTexSubImage3D.xml
     + 
     + $(D_INLINECODE glCopyTexSubImage3D) and $(D_INLINECODE glCopyTextureSubImage3D) functions replace a rectangular portion of a three-dimensional or two-dimensional array texture image with pixels from the current $(D_INLINECODE GL_READ_BUFFER) (rather than from main memory, as is the case for $(D_INLINECODE glTexSubImage3D) ). The screen-aligned pixel rectangle with lower left corner at ( $(D_INLINECODE x), $(D_INLINECODE y) ) and with width $(D_INLINECODE width) and height $(D_INLINECODE height) replaces the portion of the texture array with x indices $(D_INLINECODE xoffset) through xoffset + width - 1, inclusive, and y indices $(D_INLINECODE yoffset) through yoffset + height - 1, inclusive, at z index $(D_INLINECODE zoffset) and at the mipmap level specified by $(D_INLINECODE level). The pixels in the rectangle are processed exactly as if $(D_INLINECODE glReadPixels) had been called, but the process stops just before final conversion. At this point, all pixel component values are clamped to the range 0 1 and then converted to the texture's internal format for storage in the texel array. The destination rectangle in the texture array may not include any texels outside the texture array as it was originally specified. It is not an error to specify a subtexture with zero width or height, but such a specification has no effect. If any of the pixels within the specified rectangle of the current $(D_INLINECODE GL_READ_BUFFER) are outside the read window associated with the current rendering context, then the values obtained for those pixels are undefined. No change is made to the,,,, or parameters of the specified texture array or to texel values outside the specified subregion.
     + 
     + $(D_INLINECODE glPixelStore) modes affect texture images.
     + 
     + Params:
     +     target  = Specifies the target to which the texture object is bound for $(D_INLINECODE glCopyTexSubImage3D) function. Must be $(D_INLINECODE GL_TEXTURE_3D) or $(D_INLINECODE GL_TEXTURE_2D_ARRAY).
     +     texture = Specifies the texture object name for $(D_INLINECODE glCopyTextureSubImage3D) function.
     +     level   = Specifies the level-of-detail number. Level 0 is the base image level. Level is the th mipmap reduction image.
     +     xoffset = Specifies a texel offset in the x direction within the texture array.
     +     yoffset = Specifies a texel offset in the y direction within the texture array.
     +     zoffset = Specifies a texel offset in the z direction within the texture array.
     +     x       = Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
     +     width   = Specifies the width of the texture subimage.
     +     height  = Specifies the height of the texture subimage.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2012-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glPixelStore), $(D_INLINECODE glReadBuffer), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexParameter), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P2)
    fn_glCopyTexSubImage3D glCopyTexSubImage3D;
    alias fn_glCopyTextureSubImage3D = extern(System) void function(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glCopyTextureSubImage3D glCopyTextureSubImage3D;
    alias fn_glCreateBuffers = extern(System) void function(GLsizei n, GLuint* buffers) @system @nogc nothrow;

    /++
     + glCreateBuffers: man4/glCreateBuffers.xml
     + 
     + $(D_INLINECODE glCreateBuffers) returns $(D_INLINECODE n) previously unused buffer names in $(D_INLINECODE buffers), each representing a new buffer object initialized as if it had been bound to an unspecified target.
     + 
     + Params:
     +     n       = Specifies the number of buffer objects to create.
     +     buffers = Specifies an array in which names of the new buffer objects are stored.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenBuffers), $(D_INLINECODE glBindBufferBase), $(D_INLINECODE glBindBufferRange), $(D_INLINECODE glMapBuffer), $(D_INLINECODE glUnmapBuffer), $(D_INLINECODE glDeleteBuffers), $(D_INLINECODE glGet), $(D_INLINECODE glIsBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glCreateBuffers glCreateBuffers;
    alias fn_glCreateFramebuffers = extern(System) void function(GLsizei n, GLuint* ids) @system @nogc nothrow;

    /++
     + glCreateFramebuffers: man4/glCreateFramebuffers.xml
     + 
     + $(D_INLINECODE glCreateFramebuffers) returns $(D_INLINECODE n) previously unused framebuffer names in $(D_INLINECODE framebuffers), each representing a new framebuffer object initialized to the default state.
     + 
     + Params:
     +     n            = Number of framebuffer objects to create.
     +     framebuffers = Specifies an array in which names of the new framebuffer objects are stored.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenFramebuffers), $(D_INLINECODE glBindFramebuffer), $(D_INLINECODE glFramebufferRenderbuffer), $(D_INLINECODE glFramebufferTexture), $(D_INLINECODE glFramebufferTexture1D), $(D_INLINECODE glFramebufferTexture2D), $(D_INLINECODE glFramebufferTexture3D), $(D_INLINECODE glFramebufferTextureLayer), $(D_INLINECODE glDeleteFramebuffers), $(D_INLINECODE glIsFramebuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glCreateFramebuffers glCreateFramebuffers;
    alias fn_glCreateProgram = extern(System) GLuint function() @system @nogc nothrow;

    /++
     + glCreateProgram: man4/glCreateProgram.xml
     + 
     + $(D_INLINECODE glCreateProgram) creates an empty program object and returns a non-zero value by which it can be referenced. A program object is an object to which shader objects can be attached. This provides a mechanism to specify the shader objects that will be linked to create a program. It also provides a means for checking the compatibility of the shaders that will be used to create a program (for instance, checking the compatibility between a vertex shader and a fragment shader). When no longer needed as part of a program object, shader objects can be detached. One or more executables are created in a program object by successfully attaching shader objects to it with $(D_INLINECODE glAttachShader), successfully compiling the shader objects with $(D_INLINECODE glCompileShader), and successfully linking the program object with $(D_INLINECODE glLinkProgram). These executables are made part of current state when $(D_INLINECODE glUseProgram) is called. Program objects can be deleted by calling $(D_INLINECODE glDeleteProgram). The memory associated with the program object will be deleted when it is no longer part of current rendering state for any context.
     + 
     + Like buffer and texture objects, the name space for program objects may be shared across a set of contexts, as long as the server sides of the contexts share the same address space. If the name space is shared across contexts, any attached objects and the data associated with those attached objects are shared as well. Applications are responsible for providing the synchronization across API calls when objects are accessed from different execution threads.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAttachShader), $(D_INLINECODE glBindAttribLocation), $(D_INLINECODE glCreateShader), $(D_INLINECODE glDeleteProgram), $(D_INLINECODE glDetachShader), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glUniform), $(D_INLINECODE glUseProgram), $(D_INLINECODE glValidateProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glCreateProgram glCreateProgram;
    alias fn_glCreateProgramPipelines = extern(System) void function(GLsizei n, GLuint* pipelines) @system @nogc nothrow;

    /++
     + glCreateProgramPipelines: man4/glCreateProgramPipelines.xml
     + 
     + $(D_INLINECODE glCreateProgramPipelines) returns $(D_INLINECODE n) previously unused program pipeline names in $(D_INLINECODE pipelines), each representing a new program pipeline object initialized to the default state.
     + 
     + Params:
     +     n         = Number of program pipeline objects to create.
     +     pipelines = Specifies an array in which names of the new program pipeline objects are stored.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindProgramPipeline), $(D_INLINECODE glCreateShader), $(D_INLINECODE glCreateProgram), $(D_INLINECODE glCompileShader), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glGenProgramPipelines), $(D_INLINECODE glDeleteProgramPipelines), $(D_INLINECODE glIsProgramPipeline)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glCreateProgramPipelines glCreateProgramPipelines;
    alias fn_glCreateQueries = extern(System) void function(GLenum target, GLsizei n, GLuint* ids) @system @nogc nothrow;

    /++
     + glCreateQueries: man4/glCreateQueries.xml
     + 
     + $(D_INLINECODE glCreateQueries) returns $(D_INLINECODE n) previously unused query object names in $(D_INLINECODE ids), each representing a new query object with the specified $(D_INLINECODE target). $(D_INLINECODE target) may be one of $(D_INLINECODE GL_SAMPLES_PASSED), $(D_INLINECODE GL_ANY_SAMPLES_PASSED), $(D_INLINECODE GL_ANY_SAMPLES_PASSED_CONSERVATIVE), $(D_INLINECODE GL_TIME_ELAPSED), $(D_INLINECODE GL_TIMESTAMP), $(D_INLINECODE GL_PRIMITIVES_GENERATED) or $(D_INLINECODE GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN).
     + 
     + Params:
     +     target = Specifies the target of each created query object.
     +     n      = Number of query objects to create.
     +     ids    = Specifies an array in which names of the new query objects are stored.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBeginQuery), $(D_INLINECODE glBeginQueryIndexed), $(D_INLINECODE glDeleteQueries), $(D_INLINECODE glEndQuery), $(D_INLINECODE glGenQueries), $(D_INLINECODE glGetQueryObject), $(D_INLINECODE glGetQueryiv), $(D_INLINECODE glIsQuery)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glCreateQueries glCreateQueries;
    alias fn_glCreateRenderbuffers = extern(System) void function(GLsizei n, GLuint* renderbuffers) @system @nogc nothrow;

    /++
     + glCreateRenderbuffers: man4/glCreateRenderbuffers.xml
     + 
     + $(D_INLINECODE glCreateRenderbuffers) returns $(D_INLINECODE n) previously unused renderbuffer object names in $(D_INLINECODE renderbuffers), each representing a new renderbuffer object initialized to the default state.
     + 
     + Params:
     +     n             = Number of renderbuffer objects to create.
     +     renderbuffers = Specifies an array in which names of the new renderbuffer objects are stored.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindRenderbuffer), $(D_INLINECODE glDeleteRenderbuffers), $(D_INLINECODE glGenRenderbuffers), $(D_INLINECODE glIsRenderbuffer), $(D_INLINECODE glRenderbufferStorage), $(D_INLINECODE glRenderbufferStorageMultisample)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glCreateRenderbuffers glCreateRenderbuffers;
    alias fn_glCreateSamplers = extern(System) void function(GLsizei n, GLuint* samplers) @system @nogc nothrow;

    /++
     + glCreateSamplers: man4/glCreateSamplers.xml
     + 
     + $(D_INLINECODE glCreateSamplers) returns $(D_INLINECODE n) previously unused sampler names in $(D_INLINECODE samplers), each representing a new sampler object initialized to the default state.
     + 
     + Params:
     +     n        = Number of sampler objects to create.
     +     samplers = Specifies an array in which names of the new sampler objects are stored.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindSampler), $(D_INLINECODE glBindTexture), $(D_INLINECODE glDeleteSamplers), $(D_INLINECODE glDeleteTextures), $(D_INLINECODE glGenSamplers), $(D_INLINECODE glGenTextures), $(D_INLINECODE glGet), $(D_INLINECODE glGetSamplerParameter), $(D_INLINECODE glSamplerParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glCreateSamplers glCreateSamplers;
    alias fn_glCreateShader = extern(System) GLuint function(GLenum shaderType) @system @nogc nothrow;

    /++
     + glCreateShader: man4/glCreateShader.xml
     + 
     + $(D_INLINECODE glCreateShader) creates an empty shader object and returns a non-zero value by which it can be referenced. A shader object is used to maintain the source code strings that define a shader. $(D_INLINECODE shaderType) indicates the type of shader to be created. Five types of shader are supported. A shader of type $(D_INLINECODE GL_COMPUTE_SHADER) is a shader that is intended to run on the programmable compute processor. A shader of type $(D_INLINECODE GL_VERTEX_SHADER) is a shader that is intended to run on the programmable vertex processor. A shader of type $(D_INLINECODE GL_TESS_CONTROL_SHADER) is a shader that is intended to run on the programmable tessellation processor in the control stage. A shader of type $(D_INLINECODE GL_TESS_EVALUATION_SHADER) is a shader that is intended to run on the programmable tessellation processor in the evaluation stage. A shader of type $(D_INLINECODE GL_GEOMETRY_SHADER) is a shader that is intended to run on the programmable geometry processor. A shader of type $(D_INLINECODE GL_FRAGMENT_SHADER) is a shader that is intended to run on the programmable fragment processor. When created, a shader object's $(D_INLINECODE GL_SHADER_TYPE) parameter is set to either $(D_INLINECODE GL_COMPUTE_SHADER), $(D_INLINECODE GL_VERTEX_SHADER), $(D_INLINECODE GL_TESS_CONTROL_SHADER), $(D_INLINECODE GL_TESS_EVALUATION_SHADER), $(D_INLINECODE GL_GEOMETRY_SHADER) or $(D_INLINECODE GL_FRAGMENT_SHADER), depending on the value of $(D_INLINECODE shaderType).
     + 
     + Like buffer and texture objects, the name space for shader objects may be shared across a set of contexts, as long as the server sides of the contexts share the same address space. If the name space is shared across contexts, any attached objects and the data associated with those attached objects are shared as well. Applications are responsible for providing the synchronization across API calls when objects are accessed from different execution threads. $(D_INLINECODE GL_COMPUTE_SHADER) is available only if the GL version is 4.3 or higher.
     + 
     + Params:
     +     shaderType = Specifies the type of shader to be created. Must be one of $(D_INLINECODE GL_COMPUTE_SHADER), $(D_INLINECODE GL_VERTEX_SHADER), $(D_INLINECODE GL_TESS_CONTROL_SHADER), $(D_INLINECODE GL_TESS_EVALUATION_SHADER), $(D_INLINECODE GL_GEOMETRY_SHADER), or $(D_INLINECODE GL_FRAGMENT_SHADER).
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAttachShader), $(D_INLINECODE glCompileShader), $(D_INLINECODE glDeleteShader), $(D_INLINECODE glDetachShader), $(D_INLINECODE glShaderSource)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glCreateShader glCreateShader;
    alias fn_glCreateShaderProgramv = extern(System) GLuint function(GLenum type, GLsizei count, const( char**) strings) @system @nogc nothrow;

    /++
     + glCreateShaderProgram: man4/glCreateShaderProgram.xml
     + 
     + $(D_INLINECODE glCreateShaderProgram) creates a program object containing compiled and linked shaders for a single stage specified by $(D_INLINECODE type). $(D_INLINECODE strings) refers to an array of $(D_INLINECODE count) strings from which to create the shader executables. $(D_INLINECODE glCreateShaderProgram) is equivalent (assuming no errors are generated) to:
     + 
     + ---
     + const GLuint shader = glCreateShader(type);
     + if (shader) {
     +     glShaderSource(shader, count, strings, NULL);
     +     glCompileShader(shader);
     +     const GLuint program = glCreateProgram();
     +     if (program) {
     +         GLint compiled = GL_FALSE;
     +         glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;compiled);
     +         glProgramParameteri(program, GL_PROGRAM_SEPARABLE, GL_TRUE);
     +         if (compiled) {
     +             glAttachShader(program, shader);
     +             glLinkProgram(program);
     +             glDetachShader(program, shader);
     +         }
     +         /* append-shader-info-log-to-program-info-log */
     +     }
     +     glDeleteShader(shader);
     +     return program;
     + } else {
     +     return 0;
     + }
     + ---
     +  The program object created by $(D_INLINECODE glCreateShaderProgram) has its $(D_INLINECODE GL_PROGRAM_SEPARABLE) status set to $(D_INLINECODE GL_TRUE).
     + 
     + Params:
     +     type    = Specifies the type of shader to create.
     +     count   = Specifies the number of source code strings in the array $(D_INLINECODE strings).
     +     strings = Specifies the address of an array of pointers to source code strings from which to create the program object.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCreateShader), $(D_INLINECODE glCreateProgram), $(D_INLINECODE glCompileShader), $(D_INLINECODE glLinkProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glCreateShaderProgramv glCreateShaderProgramv;
    alias fn_glCreateTextures = extern(System) void function(GLenum target, GLsizei n, GLuint* textures) @system @nogc nothrow;

    /++
     + glCreateTextures: man4/glCreateTextures.xml
     + 
     + $(D_INLINECODE glCreateTextures) returns $(D_INLINECODE n) previously unused texture names in $(D_INLINECODE textures), each representing a new texture object of the dimensionality and type specified by $(D_INLINECODE target) and initialized to the default values for that texture type. $(D_INLINECODE target) must be one of $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_RECTANGLE), $(D_INLINECODE GL_TEXTURE_CUBE_MAP), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY), $(D_INLINECODE GL_TEXTURE_BUFFER), $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE) or $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY).
     + 
     + Params:
     +     target   = Specifies the effective texture target of each created texture.
     +     n        = Number of texture objects to create.
     +     textures = Specifies an array in which names of the new texture objects are stored.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindTexture), $(D_INLINECODE glDeleteTextures), $(D_INLINECODE glGenTextures), $(D_INLINECODE glGet), $(D_INLINECODE glGetTexParameter), $(D_INLINECODE glIsTexture), $(D_INLINECODE glTexBuffer), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage2DMultisample), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexImage3DMultisample), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glCreateTextures glCreateTextures;
    alias fn_glCreateTransformFeedbacks = extern(System) void function(GLsizei n, GLuint* ids) @system @nogc nothrow;

    /++
     + glCreateTransformFeedbacks: man4/glCreateTransformFeedbacks.xml
     + 
     + $(D_INLINECODE glCreateTransformFeedbacks) returns $(D_INLINECODE n) previously unused transform feedback object names in $(D_INLINECODE ids), each representing a new transform feedback object initialized to the default state.
     + 
     + Params:
     +     n   = Number of transform feedback objects to create.
     +     ids = Specifies an array in which names of the new transform feedback objects are stored.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBeginTransformFeedback), $(D_INLINECODE glBindTransformFeedback), $(D_INLINECODE glDeleteTransformFeedbacks), $(D_INLINECODE glEndTransformFeedback), $(D_INLINECODE glGenTransformFeedbacks), $(D_INLINECODE glIsTransformFeedback), $(D_INLINECODE glPauseTransformFeedback), $(D_INLINECODE glResumeTransformFeedback)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glCreateTransformFeedbacks glCreateTransformFeedbacks;
    alias fn_glCreateVertexArrays = extern(System) void function(GLsizei n, GLuint* arrays) @system @nogc nothrow;

    /++
     + glCreateVertexArrays: man4/glCreateVertexArrays.xml
     + 
     + $(D_INLINECODE glCreateVertexArrays) returns $(D_INLINECODE n) previously unused vertex array object names in $(D_INLINECODE arrays), each representing a new vertex array object initialized to the default state.
     + 
     + Params:
     +     n      = Number of vertex array objects to create.
     +     arrays = Specifies an array in which names of the new vertex array objects are stored.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindVertexArray), $(D_INLINECODE glDeleteVertexArrays) $(D_INLINECODE glEnableVertexAttribArray) $(D_INLINECODE glGenVertexArrays), $(D_INLINECODE glIsVertexArray), $(D_INLINECODE glVertexAttribPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glCreateVertexArrays glCreateVertexArrays;
    alias fn_glCullFace = extern(System) void function(GLenum mode) @system @nogc nothrow;

    /++
     + glCullFace: man4/glCullFace.xml
     + 
     + $(D_INLINECODE glCullFace) specifies whether front- or back-facing facets are culled (as specified by ) when facet culling is enabled. Facet culling is initially disabled. To enable and disable facet culling, call the $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) commands with the argument $(D_INLINECODE GL_CULL_FACE). Facets include triangles, quadrilaterals, polygons, and rectangles. $(D_INLINECODE glFrontFace) specifies which of the clockwise and counterclockwise facets are front-facing and back-facing. See $(D_INLINECODE glFrontFace).
     + 
     + If $(D_INLINECODE mode) is $(D_INLINECODE GL_FRONT_AND_BACK), no facets are drawn, but other primitives such as points and lines are drawn.
     + 
     + Params:
     +     mode = Specifies whether front- or back-facing facets are candidates for culling. Symbolic constants $(D_INLINECODE GL_FRONT), $(D_INLINECODE GL_BACK), and $(D_INLINECODE GL_FRONT_AND_BACK) are accepted. The initial value is $(D_INLINECODE GL_BACK).
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glEnable), $(D_INLINECODE glFrontFace)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glCullFace glCullFace;
    alias fn_glDebugMessageCallback = extern(System) void function(GLDEBUGPROC callback, void* userParam) @system @nogc nothrow;

    /++
     + glDebugMessageCallback: man4/glDebugMessageCallback.xml
     + 
     + $(D_INLINECODE glDebugMessageCallback) sets the current debug output callback function to the function whose address is given in $(D_INLINECODE callback). The callback function should have the following prototype (in C), or be otherwise compatible with such a prototype:
     + 
     + ---
     + typedef void (APIENTRY *DEBUGPROC)(GLenum source,
     +         GLenum type,
     +         GLuint id,
     +         GLenum severity,
     +         GLsizei length,
     +         const GLchar *message,
     +         void *userParam);
     + ---
     +  This function is defined to have the same calling convention as the GL API functions. In most cases this is defined as $(D_INLINECODE APIENTRY), although it will vary depending on platform, language and compiler. Each time a debug message is generated the debug callback function will be invoked with $(D_INLINECODE source), $(D_INLINECODE type), $(D_INLINECODE id), and $(D_INLINECODE severity) associated with the message, and $(D_INLINECODE length) set to the length of debug message whose character string is in the array pointed to by $(D_INLINECODE message) $(D_INLINECODE userParam) will be set to the value passed in the $(D_INLINECODE userParam) parameter to the most recent call to $(D_INLINECODE glDebugMessageCallback).
     + 
     + When the GL is in use remotely, the server may not be able to call functions in the client's address space. In such cases, the callback function may not be invoked and the user should retrieve debug messages from the context's debug message log by calling $(D_INLINECODE glGetDebugMessageLog).
     + 
     + Params:
     +     callback  = The address of a callback function that will be called when a debug message is generated.
     +     userParam = A user supplied pointer that will be passed on each invocation of $(D_INLINECODE callback).
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDebugMessageControl), $(D_INLINECODE glDebugMessageInsert), $(D_INLINECODE glGetDebugMessageLog).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_KHR_debug")
    fn_glDebugMessageCallback glDebugMessageCallback;
    alias fn_glDebugMessageControl = extern(System) void function(GLenum source, GLenum type, GLenum severity, GLsizei count, const( GLuint*) ids, GLboolean enabled) @system @nogc nothrow;

    /++
     + glDebugMessageControl: man4/glDebugMessageControl.xml
     + 
     + $(D_INLINECODE glDebugMessageControl) controls the reporting of debug messages generated by a debug context. The parameters $(D_INLINECODE source), $(D_INLINECODE type) and $(D_INLINECODE severity) form a filter to select messages from the pool of potential messages generated by the GL. $(D_INLINECODE source) may be $(D_INLINECODE GL_DEBUG_SOURCE_API), $(D_INLINECODE GL_DEBUG_SOURCE_WINDOW_SYSTEM_), $(D_INLINECODE GL_DEBUG_SOURCE_SHADER_COMPILER), $(D_INLINECODE GL_DEBUG_SOURCE_THIRD_PARTY), $(D_INLINECODE GL_DEBUG_SOURCE_APPLICATION), $(D_INLINECODE GL_DEBUG_SOURCE_OTHER) to select messages generated by usage of the GL API, the window system, the shader compiler, third party tools or libraries, explicitly by the application or by some other source, respectively. It may also take the value $(D_INLINECODE GL_DONT_CARE). If $(D_INLINECODE source) is not $(D_INLINECODE GL_DONT_CARE) then only messages whose source matches $(D_INLINECODE source) will be referenced. $(D_INLINECODE type) may be one of $(D_INLINECODE GL_DEBUG_TYPE_ERROR), $(D_INLINECODE GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR), $(D_INLINECODE GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR), $(D_INLINECODE GL_DEBUG_TYPE_PORTABILITY), $(D_INLINECODE GL_DEBUG_TYPE_PERFORMANCE), $(D_INLINECODE GL_DEBUG_TYPE_MARKER), $(D_INLINECODE GL_DEBUG_TYPE_PUSH_GROUP), $(D_INLINECODE GL_DEBUG_TYPE_POP_GROUP), or $(D_INLINECODE GL_DEBUG_TYPE_OTHER) to indicate the type of messages describing GL errors, attempted use of deprecated features, triggering of undefined behavior, portability issues, performance notifications, markers, group push and pop events, and other types of messages, respectively. It may also take the value $(D_INLINECODE GL_DONT_CARE). If $(D_INLINECODE type) is not $(D_INLINECODE GL_DONT_CARE) then only messages whose type matches $(D_INLINECODE type) will be referenced. $(D_INLINECODE severity) may be one of $(D_INLINECODE GL_DEBUG_SEVERITY_LOW), $(D_INLINECODE GL_DEBUG_SEVERITY_MEDIUM), or $(D_INLINECODE GL_DEBUG_SEVERITY_HIGH) to select messages of low, medium or high severity messages or to $(D_INLINECODE GL_DEBUG_SEVERITY_NOTIFICATION) for notifications. It may also take the value $(D_INLINECODE GL_DONT_CARE). If $(D_INLINECODE severity) is not $(D_INLINECODE GL_DONT_CARE) then only messages whose severity matches $(D_INLINECODE severity) will be referenced. $(D_INLINECODE ids) contains a list of $(D_INLINECODE count) message identifiers to select specific messages from the pool of available messages. If $(D_INLINECODE count) is zero then the value of $(D_INLINECODE ids) is ignored. Otherwise, only messages appearing in this list are selected. In this case, $(D_INLINECODE source) and $(D_INLINECODE type) may not be $(D_INLINECODE GL_DONT_CARE) and $(D_INLINECODE severity) must be $(D_INLINECODE GL_DONT_CARE). If $(D_INLINECODE enabled) is $(D_INLINECODE GL_TRUE) then messages that match the filter formed by $(D_INLINECODE source), $(D_INLINECODE type), $(D_INLINECODE severity) and $(D_INLINECODE ids) are enabled. Otherwise, those messages are disabled.
     + 
     + Although debug messages may be enabled in a non-debug context, the quantity and detail of such messages may be substantially inferior to those in a debug context. In particular, a valid implementation of the debug message queue in a non-debug context may produce no messages at all. $(D_INLINECODE GL_DEBUG_TYPE_MARKER), $(D_INLINECODE GL_DEBUG_TYPE_PUSH_GROUP), $(D_INLINECODE GL_DEBUG_TYPE_POP_GROUP), and $(D_INLINECODE GL_DEBUG_SEVERITY_NOTIFICATION) are available only if the GL version is 4.3 or higher.
     + 
     + Params:
     +     source   = The source of debug messages to enable or disable.
     +     type     = The type of debug messages to enable or disable.
     +     severity = The severity of debug messages to enable or disable.
     +     count    = The length of the array $(D_INLINECODE ids).
     +     ids      = The address of an array of unsigned integers contianing the ids of the messages to enable or disable.
     +     enabled  = A Boolean flag determining whether the selected messages should be enabled or disabled.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDebugMessageInsert), $(D_INLINECODE glDebugMessageCallback), $(D_INLINECODE glGetDebugMessageLog).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_KHR_debug")
    fn_glDebugMessageControl glDebugMessageControl;
    alias fn_glDebugMessageInsert = extern(System) void function(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const( char*) message) @system @nogc nothrow;

    /++
     + glDebugMessageInsert: man4/glDebugMessageInsert.xml
     + 
     + $(D_INLINECODE glDebugMessageInsert) inserts a user-supplied message into the debug output queue. $(D_INLINECODE source) specifies the source that will be used to classify the message and must be $(D_INLINECODE GL_DEBUG_SOURCE_APPLICATION) or $(D_INLINECODE GL_DEBUG_SOURCE_THIRD_PARTY). All other sources are reserved for use by the GL implementation. $(D_INLINECODE type) indicates the type of the message to be inserted and may be one of $(D_INLINECODE GL_DEBUG_TYPE_ERROR), $(D_INLINECODE GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR), $(D_INLINECODE GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR), $(D_INLINECODE GL_DEBUG_TYPE_PORTABILITY), $(D_INLINECODE GL_DEBUG_TYPE_PERFORMANCE), $(D_INLINECODE GL_DEBUG_TYPE_MARKER), $(D_INLINECODE GL_DEBUG_TYPE_PUSH_GROUP), $(D_INLINECODE GL_DEBUG_TYPE_POP_GROUP), or $(D_INLINECODE GL_DEBUG_TYPE_OTHER). $(D_INLINECODE severity) indicates the severity of the message and may be $(D_INLINECODE GL_DEBUG_SEVERITY_LOW), $(D_INLINECODE GL_DEBUG_SEVERITY_MEDIUM), $(D_INLINECODE GL_DEBUG_SEVERITY_HIGH) or $(D_INLINECODE GL_DEBUG_SEVERITY_NOTIFICATION). $(D_INLINECODE id) is available for application defined use and may be any value. This value will be recorded and used to identify the message. $(D_INLINECODE length) contains a count of the characters in the character array whose address is given in $(D_INLINECODE message). If $(D_INLINECODE length) is negative then $(D_INLINECODE message) is treated as a null-terminated string. The length of the message, whether specified explicitly or implicitly, must be less than or equal to the implementation defined constant $(D_INLINECODE GL_MAX_DEBUG_MESSAGE_LENGTH).
     + 
     + $(D_INLINECODE GL_DEBUG_TYPE_MARKER), $(D_INLINECODE GL_DEBUG_TYPE_PUSH_GROUP), $(D_INLINECODE GL_DEBUG_TYPE_POP_GROUP), and $(D_INLINECODE GL_DEBUG_SEVERITY_NOTIFICATION) are available only if the GL version is 4.3 or higher.
     + 
     + Params:
     +     source   = The source of the debug message to insert.
     +     type     = The type of the debug message insert.
     +     id       = The user-supplied identifier of the message to insert.
     +     severity = The severity of the debug messages to insert.
     +     length   = The length string contained in the character array whose address is given by $(D_INLINECODE message).
     +     message  = The address of a character array containing the message to insert.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDebugMessageControl), $(D_INLINECODE glDebugMessageCallback), $(D_INLINECODE glGetDebugMessageLog).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_KHR_debug")
    fn_glDebugMessageInsert glDebugMessageInsert;
    alias fn_glDeleteBuffers = extern(System) void function(GLsizei n, const( GLuint*) buffers) @system @nogc nothrow;

    /++
     + glDeleteBuffers: man4/glDeleteBuffers.xml
     + 
     + $(D_INLINECODE glDeleteBuffers) deletes $(D_INLINECODE n) buffer objects named by the elements of the array $(D_INLINECODE buffers). After a buffer object is deleted, it has no contents, and its name is free for reuse (for example by $(D_INLINECODE glGenBuffers) ). If a buffer object that is currently bound is deleted, the binding reverts to 0 (the absence of any buffer object). $(D_INLINECODE glDeleteBuffers) silently ignores 0's and names that do not correspond to existing buffer objects.
     + 
     + Params:
     +     n       = Specifies the number of buffer objects to be deleted.
     +     buffers = Specifies an array of buffer objects to be deleted.
     + 
     + Copyright:
     +     Copyright&copy; 2005 Addison-Wesley. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBuffer), $(D_INLINECODE glGenBuffers), $(D_INLINECODE glGet)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    fn_glDeleteBuffers glDeleteBuffers;
    alias fn_glDeleteFramebuffers = extern(System) void function(GLsizei n, GLuint* framebuffers) @system @nogc nothrow;

    /++
     + glDeleteFramebuffers: man4/glDeleteFramebuffers.xml
     + 
     + $(D_INLINECODE glDeleteFramebuffers) deletes the $(D_INLINECODE n) framebuffer objects whose names are stored in the array addressed by $(D_INLINECODE framebuffers). The name zero is reserved by the GL and is silently ignored, should it occur in $(D_INLINECODE framebuffers), as are other unused names. Once a framebuffer object is deleted, its name is again unused and it has no attachments. If a framebuffer that is currently bound to one or more of the targets $(D_INLINECODE GL_DRAW_FRAMEBUFFER) or $(D_INLINECODE GL_READ_FRAMEBUFFER) is deleted, it is as though $(D_INLINECODE glBindFramebuffer) had been executed with the corresponding $(D_INLINECODE target) and $(D_INLINECODE framebuffer) zero.
     + 
     + Params:
     +     n            = Specifies the number of framebuffer objects to be deleted.
     +     framebuffers = A pointer to an array containing $(D_INLINECODE n) framebuffer objects to be deleted.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenFramebuffers), $(D_INLINECODE glBindFramebuffer), $(D_INLINECODE glCheckFramebufferStatus)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    fn_glDeleteFramebuffers glDeleteFramebuffers;
    alias fn_glDeleteProgram = extern(System) void function(GLuint program) @system @nogc nothrow;

    /++
     + glDeleteProgram: man4/glDeleteProgram.xml
     + 
     + $(D_INLINECODE glDeleteProgram) frees the memory and invalidates the name associated with the program object specified by $(D_INLINECODE program.) This command effectively undoes the effects of a call to $(D_INLINECODE glCreateProgram). If a program object is in use as part of current rendering state, it will be flagged for deletion, but it will not be deleted until it is no longer part of current state for any rendering context. If a program object to be deleted has shader objects attached to it, those shader objects will be automatically detached but not deleted unless they have already been flagged for deletion by a previous call to $(D_INLINECODE glDeleteShader). A value of 0 for $(D_INLINECODE program) will be silently ignored. To determine whether a program object has been flagged for deletion, call $(D_INLINECODE glGetProgram) with arguments $(D_INLINECODE program) and $(D_INLINECODE GL_DELETE_STATUS).
     + 
     + Params:
     +     program = Specifies the program object to be deleted.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCreateShader), $(D_INLINECODE glDetachShader), $(D_INLINECODE glUseProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glDeleteProgram glDeleteProgram;
    alias fn_glDeleteProgramPipelines = extern(System) void function(GLsizei n, const( GLuint*) pipelines) @system @nogc nothrow;

    /++
     + glDeleteProgramPipelines: man4/glDeleteProgramPipelines.xml
     + 
     + $(D_INLINECODE glDeleteProgramPipelines) deletes the $(D_INLINECODE n) program pipeline objects whose names are stored in the array $(D_INLINECODE pipelines). Unused names in $(D_INLINECODE pipelines) are ignored, as is the name zero. After a program pipeline object is deleted, its name is again unused and it has no contents. If program pipeline object that is currently bound is deleted, the binding for that object reverts to zero and no program pipeline object becomes current.
     + 
     + Params:
     +     n         = Specifies the number of program pipeline objects to delete.
     +     pipelines = Specifies an array of names of program pipeline objects to delete.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenProgramPipelines), $(D_INLINECODE glBindProgramPipeline), $(D_INLINECODE glIsProgramPipeline), $(D_INLINECODE glUseProgramStages), $(D_INLINECODE glUseProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glDeleteProgramPipelines glDeleteProgramPipelines;
    alias fn_glDeleteQueries = extern(System) void function(GLsizei n, const( GLuint*) ids) @system @nogc nothrow;

    /++
     + glDeleteQueries: man4/glDeleteQueries.xml
     + 
     + $(D_INLINECODE glDeleteQueries) deletes $(D_INLINECODE n) query objects named by the elements of the array $(D_INLINECODE ids). After a query object is deleted, it has no contents, and its name is free for reuse (for example by $(D_INLINECODE glGenQueries) ). $(D_INLINECODE glDeleteQueries) silently ignores 0's and names that do not correspond to existing query objects.
     + 
     + Params:
     +     n   = Specifies the number of query objects to be deleted.
     +     ids = Specifies an array of query objects to be deleted.
     + 
     + Copyright:
     +     Copyright&copy; 2005 Addison-Wesley. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBeginQuery), $(D_INLINECODE glEndQuery), $(D_INLINECODE glGenQueries), $(D_INLINECODE glGetQueryiv), $(D_INLINECODE glGetQueryObject)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    fn_glDeleteQueries glDeleteQueries;
    alias fn_glDeleteRenderbuffers = extern(System) void function(GLsizei n, GLuint* renderbuffers) @system @nogc nothrow;

    /++
     + glDeleteRenderbuffers: man4/glDeleteRenderbuffers.xml
     + 
     + $(D_INLINECODE glDeleteRenderbuffers) deletes the $(D_INLINECODE n) renderbuffer objects whose names are stored in the array addressed by $(D_INLINECODE renderbuffers). The name zero is reserved by the GL and is silently ignored, should it occur in $(D_INLINECODE renderbuffers), as are other unused names. Once a renderbuffer object is deleted, its name is again unused and it has no contents. If a renderbuffer that is currently bound to the target $(D_INLINECODE GL_RENDERBUFFER) is deleted, it is as though $(D_INLINECODE glBindRenderbuffer) had been executed with a $(D_INLINECODE target) of $(D_INLINECODE GL_RENDERBUFFER) and a $(D_INLINECODE name) of zero. If a renderbuffer object is attached to one or more attachment points in the currently bound framebuffer, then it as if $(D_INLINECODE glFramebufferRenderbuffer) had been called, with a $(D_INLINECODE renderbuffer) of zero for each attachment point to which this image was attached in the currently bound framebuffer. In other words, this renderbuffer object is first detached from all attachment ponits in the currently bound framebuffer. Note that the renderbuffer image is specifically detached from any non-bound framebuffers.
     + 
     + Params:
     +     n             = Specifies the number of renderbuffer objects to be deleted.
     +     renderbuffers = A pointer to an array containing $(D_INLINECODE n) renderbuffer objects to be deleted.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenRenderbuffers), $(D_INLINECODE glFramebufferRenderbuffer), $(D_INLINECODE glRenderbufferStorage), $(D_INLINECODE glRenderbufferStorageMultisample)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    fn_glDeleteRenderbuffers glDeleteRenderbuffers;
    alias fn_glDeleteSamplers = extern(System) void function(GLsizei n, const( GLuint*) samplers) @system @nogc nothrow;

    /++
     + glDeleteSamplers: man4/glDeleteSamplers.xml
     + 
     + $(D_INLINECODE glDeleteSamplers) deletes $(D_INLINECODE n) sampler objects named by the elements of the array $(D_INLINECODE samplers). After a sampler object is deleted, its name is again unused. If a sampler object that is currently bound to a sampler unit is deleted, it is as though $(D_INLINECODE glBindSampler) is called with unit set to the unit the sampler is bound to and sampler zero. Unused names in samplers are silently ignored, as is the reserved name zero.
     + 
     + $(D_INLINECODE glDeleteSamplers) is available only if the GL version is 3.3 or higher.
     + 
     + Params:
     +     n        = Specifies the number of sampler objects to be deleted.
     +     samplers = Specifies an array of sampler objects to be deleted.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenSamplers), $(D_INLINECODE glBindSampler), $(D_INLINECODE glDeleteSamplers), $(D_INLINECODE glIsSampler)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    fn_glDeleteSamplers glDeleteSamplers;
    alias fn_glDeleteShader = extern(System) void function(GLuint shader) @system @nogc nothrow;

    /++
     + glDeleteShader: man4/glDeleteShader.xml
     + 
     + $(D_INLINECODE glDeleteShader) frees the memory and invalidates the name associated with the shader object specified by $(D_INLINECODE shader). This command effectively undoes the effects of a call to $(D_INLINECODE glCreateShader). If a shader object to be deleted is attached to a program object, it will be flagged for deletion, but it will not be deleted until it is no longer attached to any program object, for any rendering context (i.e., it must be detached from wherever it was attached before it will be deleted). A value of 0 for $(D_INLINECODE shader) will be silently ignored. To determine whether an object has been flagged for deletion, call $(D_INLINECODE glGetShader) with arguments $(D_INLINECODE shader) and $(D_INLINECODE GL_DELETE_STATUS).
     + 
     + Params:
     +     shader = Specifies the shader object to be deleted.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCreateProgram), $(D_INLINECODE glCreateShader), $(D_INLINECODE glDetachShader), $(D_INLINECODE glUseProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glDeleteShader glDeleteShader;
    alias fn_glDeleteSync = extern(System) void function(GLsync sync) @system @nogc nothrow;

    /++
     + glDeleteSync: man4/glDeleteSync.xml
     + 
     + $(D_INLINECODE glDeleteSync) deletes the sync object specified by $(D_INLINECODE sync). If the fence command corresponding to the specified sync object has completed, or if no $(D_INLINECODE glWaitSync) or $(D_INLINECODE glClientWaitSync) commands are blocking on $(D_INLINECODE sync), the object is deleted immediately. Otherwise, $(D_INLINECODE sync) is flagged for deletion and will be deleted when it is no longer associated with any fence command and is no longer blocking any $(D_INLINECODE glWaitSync) or $(D_INLINECODE glClientWaitSync) command. In either case, after $(D_INLINECODE glDeleteSync) returns, the name $(D_INLINECODE sync) is invalid and can no longer be used to refer to the sync object. $(D_INLINECODE glDeleteSync) will silently ignore a $(D_INLINECODE sync) value of zero.
     + 
     + $(D_INLINECODE glSync) is only supported if the GL version is 3.2 or greater, or if the $(D_INLINECODE ARB_sync) extension is supported.
     + 
     + Params:
     +     sync = The sync object to be deleted.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glFenceSync), $(D_INLINECODE glWaitSync), $(D_INLINECODE glClientWaitSync)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_sync")
    fn_glDeleteSync glDeleteSync;
    alias fn_glDeleteTextures = extern(System) void function(GLsizei n, const( GLuint*) textures) @system @nogc nothrow;

    /++
     + glDeleteTextures: man4/glDeleteTextures.xml
     + 
     + $(D_INLINECODE glDeleteTextures) deletes $(D_INLINECODE n) textures named by the elements of the array $(D_INLINECODE textures). After a texture is deleted, it has no contents or dimensionality, and its name is free for reuse (for example by $(D_INLINECODE glGenTextures) ). If a texture that is currently bound is deleted, the binding reverts to 0 (the default texture). $(D_INLINECODE glDeleteTextures) silently ignores 0's and names that do not correspond to existing textures.
     + 
     + Params:
     +     n        = Specifies the number of textures to be deleted.
     +     textures = Specifies an array of textures to be deleted.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindTexture), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glGenTextures), $(D_INLINECODE glGet), $(D_INLINECODE glGetTexParameter), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    fn_glDeleteTextures glDeleteTextures;
    alias fn_glDeleteTransformFeedbacks = extern(System) void function(GLsizei n, const( GLuint*) ids) @system @nogc nothrow;

    /++
     + glDeleteTransformFeedbacks: man4/glDeleteTransformFeedbacks.xml
     + 
     + $(D_INLINECODE glDeleteTransformFeedbacks) deletes the $(D_INLINECODE n) transform feedback objects whose names are stored in the array $(D_INLINECODE ids). Unused names in $(D_INLINECODE ids) are ignored, as is the name zero. After a transform feedback object is deleted, its name is again unused and it has no contents. If an active transform feedback object is deleted, its name immediately becomes unused, but the underlying object is not deleted until it is no longer active.
     + 
     + Params:
     +     n   = Specifies the number of transform feedback objects to delete.
     +     ids = Specifies an array of names of transform feedback objects to delete.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenTransformFeedbacks), $(D_INLINECODE glBindTransformFeedback), $(D_INLINECODE glIsTransformFeedback), $(D_INLINECODE glBeginTransformFeedback), $(D_INLINECODE glPauseTransformFeedback), $(D_INLINECODE glResumeTransformFeedback), $(D_INLINECODE glEndTransformFeedback)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_transform_feedback2")
    fn_glDeleteTransformFeedbacks glDeleteTransformFeedbacks;
    alias fn_glDeleteVertexArrays = extern(System) void function(GLsizei n, const( GLuint*) arrays) @system @nogc nothrow;

    /++
     + glDeleteVertexArrays: man4/glDeleteVertexArrays.xml
     + 
     + $(D_INLINECODE glDeleteVertexArrays) deletes $(D_INLINECODE n) vertex array objects whose names are stored in the array addressed by $(D_INLINECODE arrays). Once a vertex array object is deleted it has no contents and its name is again unused. If a vertex array object that is currently bound is deleted, the binding for that object reverts to zero and the default vertex array becomes current. Unused names in $(D_INLINECODE arrays) are silently ignored, as is the value zero.
     + 
     + Params:
     +     n      = Specifies the number of vertex array objects to be deleted.
     +     arrays = Specifies the address of an array containing the $(D_INLINECODE n) names of the objects to be deleted.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenVertexArrays), $(D_INLINECODE glIsVertexArray), $(D_INLINECODE glBindVertexArray)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_vertex_array_object")
    fn_glDeleteVertexArrays glDeleteVertexArrays;
    alias fn_glDepthFunc = extern(System) void function(GLenum func) @system @nogc nothrow;

    /++
     + glDepthFunc: man4/glDepthFunc.xml
     + 
     + $(D_INLINECODE glDepthFunc) specifies the function used to compare each incoming pixel depth value with the depth value present in the depth buffer. The comparison is performed only if depth testing is enabled. (See $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) of $(D_INLINECODE GL_DEPTH_TEST).) $(D_INLINECODE func) specifies the conditions under which the pixel will be drawn. The comparison functions are as follows: The initial value of $(D_INLINECODE func) is $(D_INLINECODE GL_LESS). Initially, depth testing is disabled.  If depth testing is disabled or if no depth buffer exists, it is as if the depth test always passes.
     + 
     + Even if the depth buffer exists and the depth mask is non-zero, the depth buffer is not updated if the depth test is disabled. In order to unconditionally write to the depth buffer, the depth test should be enabled and set to $(D_INLINECODE GL_ALWAYS).
     + 
     + Params:
     +     func = Specifies the depth comparison function. Symbolic constants $(D_INLINECODE GL_NEVER), $(D_INLINECODE GL_LESS), $(D_INLINECODE GL_EQUAL), $(D_INLINECODE GL_LEQUAL), $(D_INLINECODE GL_GREATER), $(D_INLINECODE GL_NOTEQUAL), $(D_INLINECODE GL_GEQUAL), and $(D_INLINECODE GL_ALWAYS) are accepted. The initial value is $(D_INLINECODE GL_LESS).
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDepthRange), $(D_INLINECODE glEnable), $(D_INLINECODE glPolygonOffset)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glDepthFunc glDepthFunc;
    alias fn_glDepthMask = extern(System) void function(GLboolean flag) @system @nogc nothrow;

    /++
     + glDepthMask: man4/glDepthMask.xml
     + 
     + $(D_INLINECODE glDepthMask) specifies whether the depth buffer is enabled for writing. If $(D_INLINECODE flag) is $(D_INLINECODE GL_FALSE), depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled.
     + 
     + Even if the depth buffer exists and the depth mask is non-zero, the depth buffer is not updated if the depth test is disabled. In order to unconditionally write to the depth buffer, the depth test should be enabled and set to $(D_INLINECODE GL_ALWAYS) (see $(D_INLINECODE glDepthFunc) ).
     + 
     + Params:
     +     flag = Specifies whether the depth buffer is enabled for writing. If $(D_INLINECODE flag) is $(D_INLINECODE GL_FALSE), depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorMask), $(D_INLINECODE glDepthFunc), $(D_INLINECODE glDepthRange), $(D_INLINECODE glStencilMask)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glDepthMask glDepthMask;
    alias fn_glDepthRange = extern(System) void function(GLdouble nearVal, GLdouble farVal) @system @nogc nothrow;

    /++
     + glDepthRange: man4/glDepthRange.xml
     + 
     + After clipping and division by, depth coordinates range from -1 to 1, corresponding to the near and far clipping planes. $(D_INLINECODE glDepthRange) specifies a linear mapping of the normalized depth coordinates in this range to window depth coordinates. Regardless of the actual depth buffer implementation, window coordinate depth values are treated as though they range from 0 through 1 (like color components). Thus, the values accepted by $(D_INLINECODE glDepthRange) are both clamped to this range before they are accepted. The setting of (0,1) maps the near plane to 0 and the far plane to 1. With this mapping, the depth buffer range is fully utilized.
     + 
     + It is not necessary that $(D_INLINECODE nearVal) be less than $(D_INLINECODE farVal). Reverse mappings such as nearVal = 1, and farVal = 0 are acceptable. The type of the $(D_INLINECODE nearVal) and $(D_INLINECODE farVal) parameters was changed from GLclampf to GLfloat for $(D_INLINECODE glDepthRangef) and from GLclampd to GLdouble for $(D_INLINECODE glDepthRange). This change is transparent to user code and is described in detail on the $(D_INLINECODE removedTypes) page.
     + 
     + Params:
     +     nearVal = Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0.
     +     farVal  = Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDepthFunc), $(D_INLINECODE glPolygonOffset), $(D_INLINECODE glViewport), $(D_INLINECODE removedTypes)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glDepthRange glDepthRange;
    alias fn_glDepthRangef = extern(System) void function(GLfloat nearVal, GLfloat farVal) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_ES2_compatibility")
    fn_glDepthRangef glDepthRangef;
    alias fn_glDepthRangeArrayv = extern(System) void function(GLuint first, GLsizei count, const( GLdouble*) v) @system @nogc nothrow;

    /++
     + glDepthRangeArray: man4/glDepthRangeArray.xml
     + 
     + After clipping and division by, depth coordinates range from -1 to 1, corresponding to the near and far clipping planes. Each viewport has an independent depth range specified as a linear mapping of the normalized depth coordinates in this range to window depth coordinates. Regardless of the actual depth buffer implementation, window coordinate depth values are treated as though they range from 0 through 1 (like color components). $(D_INLINECODE glDepthRangeArray) specifies a linear mapping of the normalized depth coordinates in this range to window depth coordinates for each viewport in the range [ $(D_INLINECODE first), $(D_INLINECODE first) + $(D_INLINECODE count) ). Thus, the values accepted by $(D_INLINECODE glDepthRangeArray) are both clamped to this range before they are accepted. The $(D_INLINECODE first) parameter specifies the index of the first viewport whose depth range to modify and must be less than the value of $(D_INLINECODE GL_MAX_VIEWPORTS). $(D_INLINECODE count) specifies the number of viewports whose depth range to modify. $(D_INLINECODE first) + $(D_INLINECODE count) must be less than or equal to the value of $(D_INLINECODE GL_MAX_VIEWPORTS). $(D_INLINECODE v) specifies the address of an array of pairs of double precision floating point values representing the near and far values of the depth range for each viewport, in that order. The setting of (0,1) maps the near plane to 0 and the far plane to 1. With this mapping, the depth buffer range is fully utilized.
     + 
     + It is not necessary that the near plane distance be less than the far plane distance. Reverse mappings such as near = 1, and far = 0 are acceptable. The type of the $(D_INLINECODE v) parameter was changed from GLclampd to GLdouble. This change is transparent to user code and is described in detail on the $(D_INLINECODE removedTypes) page.
     + 
     + Params:
     +     first = Specifies the index of the first viewport whose depth range to update.
     +     count = Specifies the number of viewports whose depth range to update.
     +     v     = Specifies the address of an array containing the near and far values for the depth range of each modified viewport.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDepthFunc), $(D_INLINECODE glDepthRange), $(D_INLINECODE glDepthRangeIndexed), $(D_INLINECODE glPolygonOffset), $(D_INLINECODE glViewportArray), $(D_INLINECODE glViewport), $(D_INLINECODE removedTypes)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_viewport_array")
    fn_glDepthRangeArrayv glDepthRangeArrayv;
    alias fn_glDepthRangeIndexed = extern(System) void function(GLuint index, GLdouble nearVal, GLdouble farVal) @system @nogc nothrow;

    /++
     + glDepthRangeIndexed: man4/glDepthRangeIndexed.xml
     + 
     + After clipping and division by, depth coordinates range from -1 to 1, corresponding to the near and far clipping planes. Each viewport has an independent depth range specified as a linear mapping of the normalized depth coordinates in this range to window depth coordinates. Regardless of the actual depth buffer implementation, window coordinate depth values are treated as though they range from 0 through 1 (like color components). $(D_INLINECODE glDepthRangeIndexed) specifies a linear mapping of the normalized depth coordinates in this range to window depth coordinates for a specified viewport. Thus, the values accepted by $(D_INLINECODE glDepthRangeIndexed) are both clamped to this range before they are accepted. The $(D_INLINECODE index) parameter specifies the index of first viewport whose depth range to modify and must be less than the value of $(D_INLINECODE GL_MAX_VIEWPORTS). $(D_INLINECODE nearVal) and $(D_INLINECODE farVal) specify near and far values of the depth range for the specified viewport, respectively. The setting of (0,1) maps the near plane to 0 and the far plane to 1. With this mapping, the depth buffer range is fully utilized.
     + 
     + It is not necessary that the near plane distance be less than the far plane distance. Reverse mappings such as nearVal = 1, and farVal = 0 are acceptable. The type of the $(D_INLINECODE nearVal) and $(D_INLINECODE farVal) parameters was changed from GLclampd to GLdouble. This change is transparent to user code and is described in detail on the $(D_INLINECODE removedTypes) page.
     + 
     + Params:
     +     index   = Specifies the index of the viewport whose depth range to update.
     +     nearVal = Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0.
     +     farVal  = Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDepthFunc), $(D_INLINECODE glDepthRange), $(D_INLINECODE glDepthRangeArray), $(D_INLINECODE glPolygonOffset), $(D_INLINECODE glViewportArray), $(D_INLINECODE glViewport), $(D_INLINECODE removedTypes)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_viewport_array")
    fn_glDepthRangeIndexed glDepthRangeIndexed;
    alias fn_glDetachShader = extern(System) void function(GLuint program, GLuint shader) @system @nogc nothrow;

    /++
     + glDetachShader: man4/glDetachShader.xml
     + 
     + $(D_INLINECODE glDetachShader) detaches the shader object specified by $(D_INLINECODE shader) from the program object specified by $(D_INLINECODE program). This command can be used to undo the effect of the command $(D_INLINECODE glAttachShader). If $(D_INLINECODE shader) has already been flagged for deletion by a call to $(D_INLINECODE glDeleteShader) and it is not attached to any other program object, it will be deleted after it has been detached.
     + 
     + Params:
     +     program = Specifies the program object from which to detach the shader object.
     +     shader  = Specifies the shader object to be detached.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAttachShader)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glDetachShader glDetachShader;
    alias fn_glEnable = extern(System) void function(GLenum cap) @system @nogc nothrow;

    /++
     + glDisable: man4/glEnable.xml
     + 
     + $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) enable and disable various capabilities. Use $(D_INLINECODE glIsEnabled) or $(D_INLINECODE glGet) to determine the current setting of any capability. The initial value for each capability with the exception of $(D_INLINECODE GL_DITHER) and $(D_INLINECODE GL_MULTISAMPLE) is $(D_INLINECODE GL_FALSE). The initial value for $(D_INLINECODE GL_DITHER) and $(D_INLINECODE GL_MULTISAMPLE) is $(D_INLINECODE GL_TRUE). Both $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) take a single argument, $(D_INLINECODE cap), which can assume one of the following values: Some of the GL's capabilities are indexed. $(D_INLINECODE glEnablei) and $(D_INLINECODE glDisablei) enable and disable indexed capabilities.
     + 
     + $(D_INLINECODE GL_PRIMITIVE_RESTART) is available only if the GL version is 3.1 or greater. $(D_INLINECODE GL_TEXTURE_CUBE_MAP_SEAMLESS) is available only if the GL version is 3.2 or greater. $(D_INLINECODE GL_PRIMITIVE_RESTART_FIXED_INDEX) is available only if the GL version is 4.3 or greater. $(D_INLINECODE GL_DEBUG_OUTPUT) and $(D_INLINECODE GL_DEBUG_OUTPUT_SYNCHRONOUS) are available only if the GL version is 4.3 or greater. Any token accepted by $(D_INLINECODE glEnable) or $(D_INLINECODE glDisable) is also accepted by $(D_INLINECODE glEnablei) and $(D_INLINECODE glDisablei), but if the capability is not indexed, the maximum value that $(D_INLINECODE index) may take is zero. In general, passing an indexed capability to $(D_INLINECODE glEnable) or $(D_INLINECODE glDisable) will enable or disable that capability for all indices, resepectively.
     + 
     + Params:
     +     cap   = Specifies a symbolic constant indicating a GL capability.
     +     index = Specifies the index of the switch to disable (for $(D_INLINECODE glEnablei) and $(D_INLINECODE glDisablei) only).
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2011-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glBlendFunc), $(D_INLINECODE glCullFace), $(D_INLINECODE glDepthFunc), $(D_INLINECODE glDepthRange), $(D_INLINECODE glGet), $(D_INLINECODE glIsEnabled), $(D_INLINECODE glLineWidth), $(D_INLINECODE glLogicOp), $(D_INLINECODE glPointSize), $(D_INLINECODE glPolygonMode), $(D_INLINECODE glPolygonOffset), $(D_INLINECODE glSampleCoverage), $(D_INLINECODE glScissor), $(D_INLINECODE glStencilFunc), $(D_INLINECODE glStencilOp), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glEnable glEnable;
    alias fn_glEnableVertexAttribArray = extern(System) void function(GLuint index) @system @nogc nothrow;

    /++
     + glDisableVertexArrayAttrib: man4/glEnableVertexAttribArray.xml
     + 
     + $(D_INLINECODE glEnableVertexAttribArray) and $(D_INLINECODE glEnableVertexArrayAttrib) enable the generic vertex attribute array specified by $(D_INLINECODE index). $(D_INLINECODE glEnableVertexAttribArray) uses currently bound vertex array object for the operation, whereas $(D_INLINECODE glEnableVertexArrayAttrib) updates state of the vertex array object with ID $(D_INLINECODE vaobj). $(D_INLINECODE glDisableVertexAttribArray) and $(D_INLINECODE glDisableVertexArrayAttrib) disable the generic vertex attribute array specified by $(D_INLINECODE index). $(D_INLINECODE glDisableVertexAttribArray) uses currently bound vertex array object for the operation, whereas $(D_INLINECODE glDisableVertexArrayAttrib) updates state of the vertex array object with ID $(D_INLINECODE vaobj). By default, all client-side capabilities are disabled, including all generic vertex attribute arrays. If enabled, the values in the generic vertex attribute array will be accessed and used for rendering when calls are made to vertex array commands such as $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glMultiDrawElements), or $(D_INLINECODE glMultiDrawArrays).
     + 
     + Params:
     +     vaobj = Specifies the name of the vertex array object for $(D_INLINECODE glDisableVertexArrayAttrib) and $(D_INLINECODE glEnableVertexArrayAttrib) functions.
     +     index = Specifies the index of the generic vertex attribute to be enabled or disabled.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindAttribLocation), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glMultiDrawElements), $(D_INLINECODE glVertexAttrib), $(D_INLINECODE glVertexAttribPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glEnableVertexAttribArray glEnableVertexAttribArray;
    alias fn_glDisableVertexAttribArray = extern(System) void function(GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glDisableVertexAttribArray glDisableVertexAttribArray;
    alias fn_glEnableVertexArrayAttrib = extern(System) void function(GLuint vaobj, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glEnableVertexArrayAttrib glEnableVertexArrayAttrib;
    alias fn_glDisableVertexArrayAttrib = extern(System) void function(GLuint vaobj, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glDisableVertexArrayAttrib glDisableVertexArrayAttrib;
    alias fn_glDispatchCompute = extern(System) void function(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z) @system @nogc nothrow;

    /++
     + glDispatchCompute: man4/glDispatchCompute.xml
     + 
     + $(D_INLINECODE glDispatchCompute) launches one or more compute work groups. Each work group is processed by the active program object for the compute shader stage. While the individual shader invocations within a work group are executed as a unit, work groups are executed completely independently and in unspecified order. $(D_INLINECODE num_groups_x), $(D_INLINECODE num_groups_y) and $(D_INLINECODE num_groups_z) specify the number of local work groups that will be dispatched in the X, Y and Z dimensions, respectively.
     + 
     + Params:
     +     num_groups_x = The number of work groups to be launched in the X dimension.
     +     num_groups_y = The number of work groups to be launched in the Y dimension.
     +     num_groups_z = The number of work groups to be launched in the Z dimension.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDispatchComputeIndirect).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_compute_shader")
    fn_glDispatchCompute glDispatchCompute;
    alias fn_glDispatchComputeIndirect = extern(System) void function(GLintptr indirect) @system @nogc nothrow;

    /++
     + glDispatchComputeIndirect: man4/glDispatchComputeIndirect.xml
     + 
     + $(D_INLINECODE glDispatchComputeIndirect) launches one or more compute work groups using parameters stored in the buffer object currently bound to the $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) target. Each work group is processed by the active program object for the compute shader stage. While the individual shader invocations within a work group are executed as a unit, work groups are executed completely independently and in unspecified order. $(D_INLINECODE indirect) contains the offset into the data store of the buffer object bound to the $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) target at which the parameters are stored. The parameters addressed by $(D_INLINECODE indirect) are packed a structure, which takes the form (in C):
     + 
     + ---
     + typedef  struct {
     +     uint  num_groups_x;
     +     uint  num_groups_y;
     +     uint  num_groups_z;
     + } DispatchIndirectCommand;
     + ---
     +  A call to $(D_INLINECODE glDispatchComputeIndirect) is equivalent, assuming no errors are generated, to:
     + 
     + ---
     + cmd = (const DispatchIndirectCommand  *)indirect;
     + glDispatchComputeIndirect(cmd-&gt;num_groups_x, cmd-&gt;num_groups_y, cmd-&gt;num_groups_z);
     + ---
     +  Unlike $(D_INLINECODE glDispatchCompute), no error is generated if any of the $(D_INLINECODE num_groups_x), $(D_INLINECODE num_groups_y) or $(D_INLINECODE num_groups_z) members of the $(D_INLINECODE DispatchIndirectCommand) is larger than the value of $(D_INLINECODE GL_MAX_COMPUTE_WORK_GROUP_COUNT) for the corresponding dimension. In such circumstances, behavior is undefined and may lead to application termination.
     + 
     + Params:
     +     indirect = The offset into the buffer object currently bound to the $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) buffer target at which the dispatch parameters are stored.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDispatchCompute).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_compute_shader")
    fn_glDispatchComputeIndirect glDispatchComputeIndirect;
    alias fn_glDrawArrays = extern(System) void function(GLenum mode, GLint first, GLsizei count) @system @nogc nothrow;

    /++
     + glDrawArrays: man4/glDrawArrays.xml
     + 
     + $(D_INLINECODE glDrawArrays) specifies multiple geometric primitives with very few subroutine calls. Instead of calling a GL procedure to pass each individual vertex, normal, texture coordinate, edge flag, or color, you can prespecify separate arrays of vertices, normals, and colors and use them to construct a sequence of primitives with a single call to $(D_INLINECODE glDrawArrays). When $(D_INLINECODE glDrawArrays) is called, it uses $(D_INLINECODE count) sequential elements from each enabled array to construct a sequence of geometric primitives, beginning with element $(D_INLINECODE first). $(D_INLINECODE mode) specifies what kind of primitives are constructed and how the array elements construct those primitives. Vertex attributes that are modified by $(D_INLINECODE glDrawArrays) have an unspecified value after $(D_INLINECODE glDrawArrays) returns. Attributes that aren't modified remain well defined.
     + 
     + $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY) and $(D_INLINECODE GL_TRIANGLES_ADJACENCY) are available only if the GL version is 3.2 or greater.
     + 
     + Params:
     +     mode  = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY) and $(D_INLINECODE GL_PATCHES) are accepted.
     +     first = Specifies the starting index in the enabled arrays.
     +     count = Specifies the number of indices to be rendered.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawArraysInstanced), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements),
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    fn_glDrawArrays glDrawArrays;
    alias fn_glDrawArraysIndirect = extern(System) void function(GLenum mode, const( void*) indirect) @system @nogc nothrow;

    /++
     + glDrawArraysIndirect: man4/glDrawArraysIndirect.xml
     + 
     + $(D_INLINECODE glDrawArraysIndirect) specifies multiple geometric primitives with very few subroutine calls. $(D_INLINECODE glDrawArraysIndirect) behaves similarly to $(D_INLINECODE glDrawArraysInstancedBaseInstance), execept that the parameters to $(D_INLINECODE glDrawArraysInstancedBaseInstance) are stored in memory at the address given by $(D_INLINECODE indirect). The parameters addressed by $(D_INLINECODE indirect) are packed into a structure that takes the form (in C):
     + 
     + ---
     + typedef  struct {
     +     uint  count;
     +     uint  primCount;
     +     uint  first;
     +     uint  baseInstance;
     + } DrawArraysIndirectCommand;
     + 
     + const DrawArraysIndirectCommand *cmd = (const DrawArraysIndirectCommand *)indirect;
     + glDrawArraysInstancedBaseInstance(mode, cmd-&gt;first, cmd-&gt;count, cmd-&gt;primCount, cmd-&gt;baseInstance);
     + ---
     +  If a buffer is bound to the $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) binding at the time of a call to $(D_INLINECODE glDrawArraysIndirect), $(D_INLINECODE indirect) is interpreted as an offset, in basic machine units, into that buffer and the parameter data is read from the buffer rather than from client memory. In contrast to $(D_INLINECODE glDrawArraysInstancedBaseInstance), the $(D_INLINECODE first) member of the parameter structure is unsigned, and out-of-range indices do not generate an error. Vertex attributes that are modified by $(D_INLINECODE glDrawArraysIndirect) have an unspecified value after $(D_INLINECODE glDrawArraysIndirect) returns. Attributes that aren't modified remain well defined.
     + 
     + The $(D_INLINECODE baseInstance) member of the $(D_INLINECODE DrawArraysIndirectCommand) structure is defined only if the GL version is 4.2 or greater. For versions of the GL less than 4.2, this parameter is present but is reserved and should be set to zero. On earlier versions of the GL, behavior is undefined if it is non-zero.
     + 
     + Params:
     +     mode     = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY), and $(D_INLINECODE GL_PATCHES) are accepted.
     +     indirect = Specifies the address of a structure containing the draw parameters.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawArraysInstanced), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements),
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_draw_indirect")
    fn_glDrawArraysIndirect glDrawArraysIndirect;
    alias fn_glDrawArraysInstanced = extern(System) void function(GLenum mode, GLint first, GLsizei count, GLsizei primcount) @system @nogc nothrow;

    /++
     + glDrawArraysInstanced: man4/glDrawArraysInstanced.xml
     + 
     + $(D_INLINECODE glDrawArraysInstanced) behaves identically to $(D_INLINECODE glDrawArrays) except that $(D_INLINECODE primcount) instances of the range of elements are executed and the value of the internal counter $(D_INLINECODE instanceID) advances for each iteration. $(D_INLINECODE instanceID) is an internal 32-bit integer counter that may be read by a vertex shader as $(D_INLINECODE gl_InstanceID). $(D_INLINECODE glDrawArraysInstanced) has the same effect as:
     + 
     + ---
     + if ( mode or count is invalid )
     +     generate appropriate error
     + else {
     +     for (int i = 0; i &lt; primcount ; i++) {
     +         instanceID = i;
     +         glDrawArrays(mode, first, count);
     +     }
     +     instanceID = 0;
     + }
     + ---
     + 
     + Params:
     +     mode      = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES) $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY) and $(D_INLINECODE GL_PATCHES) are accepted.
     +     first     = Specifies the starting index in the enabled arrays.
     +     count     = Specifies the number of indices to be rendered.
     +     primcount = Specifies the number of instances of the specified range of indices to be rendered.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElementsInstanced)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P1)
    fn_glDrawArraysInstanced glDrawArraysInstanced;
    alias fn_glDrawArraysInstancedBaseInstance = extern(System) void function(GLenum mode, GLint first, GLsizei count, GLsizei primcount, GLuint baseinstance) @system @nogc nothrow;

    /++
     + glDrawArraysInstancedBaseInstance: man4/glDrawArraysInstancedBaseInstance.xml
     + 
     + $(D_INLINECODE glDrawArraysInstancedBaseInstance) behaves identically to $(D_INLINECODE glDrawArrays) except that $(D_INLINECODE primcount) instances of the range of elements are executed and the value of the internal counter $(D_INLINECODE instanceID) advances for each iteration. $(D_INLINECODE instanceID) is an internal 32-bit integer counter that may be read by a vertex shader as $(D_INLINECODE gl_InstanceID). $(D_INLINECODE glDrawArraysInstancedBaseInstance) has the same effect as:
     + 
     + ---
     + if ( mode or count is invalid )
     +     generate appropriate error
     + else {
     +     for (int i = 0; i &lt; primcount ; i++) {
     +         instanceID = i;
     +         glDrawArrays(mode, first, count);
     +     }
     +     instanceID = 0;
     + }
     + ---
     +  Specific vertex attributes may be classified as through the use of $(D_INLINECODE glVertexAttribDivisor). Instanced vertex attributes supply per-instance vertex data to the vertex shader. The index of the vertex fetched from the enabled instanced vertex attribute arrays is calculated as: gl _ InstanceID divisor &plus; baseInstance. Note that $(D_INLINECODE baseinstance) does not affect the shader-visible value of $(D_INLINECODE gl_InstanceID).
     + 
     + Params:
     +     mode         = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES) $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY) and $(D_INLINECODE GL_PATCHES) are accepted.
     +     first        = Specifies the starting index in the enabled arrays.
     +     count        = Specifies the number of indices to be rendered.
     +     primcount    = Specifies the number of instances of the specified range of indices to be rendered.
     +     baseinstance = Specifies the base instance for use in fetching instanced vertex attributes.
     + 
     + Copyright:
     +     Copyright&copy; 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElementsInstanced)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P2)
    @OpenGL_Extension("GL_ARB_base_instance")
    fn_glDrawArraysInstancedBaseInstance glDrawArraysInstancedBaseInstance;
    alias fn_glDrawBuffer = extern(System) void function(GLenum buf) @system @nogc nothrow;

    /++
     + glDrawBuffer: man4/glDrawBuffer.xml
     + 
     + When colors are written to the frame buffer, they are written into the color buffers specified by $(D_INLINECODE glDrawBuffer). One of the following values can be used for default framebuffer: If more than one color buffer is selected for drawing, then blending or logical operations are computed and applied independently for each color buffer and can produce different results in each buffer. Monoscopic contexts include only buffers, and stereoscopic contexts include both and buffers. Likewise, single-buffered contexts include only buffers, and double-buffered contexts include both and buffers. The context is selected at GL initialization. For framebuffer objects, $(D_INLINECODE GL_COLOR_ATTACHMENT$m$) and $(D_INLINECODE GL_NONE) enums are accepted, where $(D_INLINECODE $m$) is a value between 0 and $(D_INLINECODE GL_MAX_COLOR_ATTACHMENTS). glDrawBuffer will set the draw buffer for fragment colors other than zero to $(D_INLINECODE GL_NONE).
     + 
     + Params:
     +     framebuffer = Specifies the name of the framebuffer object for $(D_INLINECODE glNamedFramebufferDrawBuffer) function. Must be zero or the name of a framebuffer object.
     +     buf         = For default framebuffer, the argument specifies up to four color buffers to be drawn into. Symbolic constants $(D_INLINECODE GL_NONE), $(D_INLINECODE GL_FRONT_LEFT), $(D_INLINECODE GL_FRONT_RIGHT), $(D_INLINECODE GL_BACK_LEFT), $(D_INLINECODE GL_BACK_RIGHT), $(D_INLINECODE GL_FRONT), $(D_INLINECODE GL_BACK), $(D_INLINECODE GL_LEFT), $(D_INLINECODE GL_RIGHT), and $(D_INLINECODE GL_FRONT_AND_BACK) are accepted. The initial value is $(D_INLINECODE GL_FRONT) for single-buffered contexts, and $(D_INLINECODE GL_BACK) for double-buffered contexts. For framebuffer objects, $(D_INLINECODE GL_COLOR_ATTACHMENT$m$) and $(D_INLINECODE GL_NONE) enums are accepted, where $(D_INLINECODE $m$) is a value between 0 and $(D_INLINECODE GL_MAX_COLOR_ATTACHMENTS).
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBlendFunc), $(D_INLINECODE glColorMask), $(D_INLINECODE glDrawBuffers), $(D_INLINECODE glLogicOp), $(D_INLINECODE glReadBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glDrawBuffer glDrawBuffer;
    alias fn_glNamedFramebufferDrawBuffer = extern(System) void function(GLuint framebuffer, GLenum buf) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glNamedFramebufferDrawBuffer glNamedFramebufferDrawBuffer;
    alias fn_glDrawBuffers = extern(System) void function(GLsizei n, const( GLenum*) bufs) @system @nogc nothrow;

    /++
     + glDrawBuffers: man4/glDrawBuffers.xml
     + 
     + $(D_INLINECODE glDrawBuffers) and $(D_INLINECODE glNamedFramebufferDrawBuffers) define an array of buffers into which outputs from the fragment shader data will be written. If a fragment shader writes a value to one or more user defined output variables, then the value of each variable will be written into the buffer specified at a location within $(D_INLINECODE bufs) corresponding to the location assigned to that user defined output. The draw buffer used for user defined outputs assigned to locations greater than or equal to $(D_INLINECODE n) is implicitly set to $(D_INLINECODE GL_NONE) and any data written to such an output is discarded. For $(D_INLINECODE glDrawBuffers), the framebuffer object that is bound to the $(D_INLINECODE GL_DRAW_FRAMEBUFFER) binding will be used. For $(D_INLINECODE glNamedFramebufferDrawBuffers), $(D_INLINECODE framebuffer) is the name of the framebuffer object. If $(D_INLINECODE framebuffer) is zero, then the default framebuffer is affected. The symbolic constants contained in $(D_INLINECODE bufs) may be any of the following: Except for $(D_INLINECODE GL_NONE), the preceding symbolic constants may not appear more than once in $(D_INLINECODE bufs). The maximum number of draw buffers supported is implementation dependent and can be queried by calling $(D_INLINECODE glGet) with the argument $(D_INLINECODE GL_MAX_DRAW_BUFFERS).
     + 
     + The symbolic constants $(D_INLINECODE GL_FRONT), $(D_INLINECODE GL_BACK), $(D_INLINECODE GL_LEFT), $(D_INLINECODE GL_RIGHT), and $(D_INLINECODE GL_FRONT_AND_BACK) are not allowed in the $(D_INLINECODE bufs) array since they may refer to multiple buffers. If a fragment shader does not write to a user defined output variable, the values of the fragment colors following shader execution are undefined. For each fragment generated in this situation, a different value may be written into each of the buffers specified by $(D_INLINECODE bufs).
     + 
     + Params:
     +     framebuffer = Specifies the name of the framebuffer object for $(D_INLINECODE glNamedFramebufferDrawBuffers).
     +     n           = Specifies the number of buffers in $(D_INLINECODE bufs).
     +     bufs        = Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBlendFunc), $(D_INLINECODE glColorMask), $(D_INLINECODE glDrawBuffers), $(D_INLINECODE glLogicOp), $(D_INLINECODE glReadBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glDrawBuffers glDrawBuffers;
    alias fn_glNamedFramebufferDrawBuffers = extern(System) void function(GLuint framebuffer, GLsizei n, const( GLenum*) bufs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glNamedFramebufferDrawBuffers glNamedFramebufferDrawBuffers;
    alias fn_glDrawElements = extern(System) void function(GLenum mode, GLsizei count, GLenum type, const( GLvoid*) indices) @system @nogc nothrow;

    /++
     + glDrawElements: man4/glDrawElements.xml
     + 
     + $(D_INLINECODE glDrawElements) specifies multiple geometric primitives with very few subroutine calls. Instead of calling a GL function to pass each individual vertex, normal, texture coordinate, edge flag, or color, you can prespecify separate arrays of vertices, normals, and so on, and use them to construct a sequence of primitives with a single call to $(D_INLINECODE glDrawElements). When $(D_INLINECODE glDrawElements) is called, it uses $(D_INLINECODE count) sequential elements from an enabled array, starting at $(D_INLINECODE indices) to construct a sequence of geometric primitives. $(D_INLINECODE mode) specifies what kind of primitives are constructed and how the array elements construct these primitives. If more than one array is enabled, each is used. Vertex attributes that are modified by $(D_INLINECODE glDrawElements) have an unspecified value after $(D_INLINECODE glDrawElements) returns.  Attributes that aren't modified maintain their previous values.
     + 
     + $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY) and $(D_INLINECODE GL_TRIANGLES_ADJACENCY) are available only if the GL version is 3.2 or greater.
     + 
     + Params:
     +     mode    = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY) and $(D_INLINECODE GL_PATCHES) are accepted.
     +     count   = Specifies the number of elements to be rendered.
     +     type    = Specifies the type of the values in $(D_INLINECODE indices). Must be one of $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), or $(D_INLINECODE GL_UNSIGNED_INT).
     +     indices = Specifies a pointer to the location where the indices are stored.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElementsInstanced), $(D_INLINECODE glDrawElementsBaseVertex), $(D_INLINECODE glDrawRangeElements)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    fn_glDrawElements glDrawElements;
    alias fn_glDrawElementsBaseVertex = extern(System) void function(GLenum mode, GLsizei count, GLenum type, GLvoid* indices, GLint basevertex) @system @nogc nothrow;

    /++
     + glDrawElementsBaseVertex: man4/glDrawElementsBaseVertex.xml
     + 
     + $(D_INLINECODE glDrawElementsBaseVertex) behaves identically to $(D_INLINECODE glDrawElements) except that the th element transferred by the corresponding draw call will be taken from element $(D_INLINECODE indices) [i] + $(D_INLINECODE basevertex) of each enabled array. If the resulting value is larger than the maximum value representable by $(D_INLINECODE type), it is as if the calculation were upconverted to 32-bit unsigned integers (with wrapping on overflow conditions). The operation is undefined if the sum would be negative.
     + 
     + $(D_INLINECODE glDrawElementsBaseVertex) is only supported if the GL version is 3.2 or greater, or if the $(D_INLINECODE ARB_draw_elements_base_vertex) extension is supported.
     + 
     + Params:
     +     mode       = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY) and $(D_INLINECODE GL_PATCHES) are accepted.
     +     count      = Specifies the number of elements to be rendered.
     +     type       = Specifies the type of the values in indices. Must be one of $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), or $(D_INLINECODE GL_UNSIGNED_INT).
     +     indices    = Specifies a pointer to the location where the indices are stored.
     +     basevertex = Specifies a constant that should be added to each element of $(D_INLINECODE indices) when chosing elements from the enabled vertex arrays.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawRangeElementsBaseVertex), $(D_INLINECODE glDrawElementsInstanced), $(D_INLINECODE glDrawElementsInstancedBaseVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_draw_elements_base_vertex")
    fn_glDrawElementsBaseVertex glDrawElementsBaseVertex;
    alias fn_glDrawElementsIndirect = extern(System) void function(GLenum mode, GLenum type, const( void*) indirect) @system @nogc nothrow;

    /++
     + glDrawElementsIndirect: man4/glDrawElementsIndirect.xml
     + 
     + $(D_INLINECODE glDrawElementsIndirect) specifies multiple indexed geometric primitives with very few subroutine calls. $(D_INLINECODE glDrawElementsIndirect) behaves similarly to $(D_INLINECODE glDrawElementsInstancedBaseVertexBaseInstance), execpt that the parameters to $(D_INLINECODE glDrawElementsInstancedBaseVertexBaseInstance) are stored in memory at the address given by $(D_INLINECODE indirect). The parameters addressed by $(D_INLINECODE indirect) are packed into a structure that takes the form (in C):
     + 
     + ---
     + typedef  struct {
     +     uint  count;
     +     uint  primCount;
     +     uint  firstIndex;
     +     uint  baseVertex;
     +     uint  baseInstance;
     + } DrawElementsIndirectCommand;
     + ---
     +  $(D_INLINECODE glDrawElementsIndirect) is equivalent to:
     + 
     + ---
     + void glDrawElementsIndirect(GLenum mode, GLenum type, const void * indirect) {
     +     const DrawElementsIndirectCommand *cmd  = (const DrawElementsIndirectCommand *)indirect;
     +     glDrawElementsInstancedBaseVertexBaseInstance(mode,
     +                                                   cmd-&gt;count,
     +                                                   type,
     +                                                   cmd-&gt;firstIndex + size-of-type,
     +                                                   cmd-&gt;primCount,
     +                                                   cmd-&gt;baseVertex,
     +                                                   cmd-&gt;baseInstance);
     + }
     + ---
     +  If a buffer is bound to the $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) binding at the time of a call to $(D_INLINECODE glDrawElementsIndirect), $(D_INLINECODE indirect) is interpreted as an offset, in basic machine units, into that buffer and the parameter data is read from the buffer rather than from client memory. Note that indices stored in client memory are not supported. If no buffer is bound to the $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) binding, an error will be generated. The results of the operation are undefined if the $(D_INLINECODE reservedMustBeZero) member of the parameter structure is non-zero. However, no error is generated in this case. Vertex attributes that are modified by $(D_INLINECODE glDrawElementsIndirect) have an unspecified value after $(D_INLINECODE glDrawElementsIndirect) returns. Attributes that aren't modified remain well defined.
     + 
     + The $(D_INLINECODE baseInstance) member of the $(D_INLINECODE DrawElementsIndirectCommand) structure is defined only if the GL version is 4.2 or greater. For versions of the GL less than 4.2, this parameter is present but is reserved and should be set to zero. On earlier versions of the GL, behavior is undefined if it is non-zero.
     + 
     + Params:
     +     mode     = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY), and $(D_INLINECODE GL_PATCHES) are accepted.
     +     type     = Specifies the type of data in the buffer bound to the $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) binding.
     +     indirect = Specifies the address of a structure containing the draw parameters.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawArraysInstanced), $(D_INLINECODE glDrawArraysIndirect), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements),
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_draw_indirect")
    fn_glDrawElementsIndirect glDrawElementsIndirect;
    alias fn_glDrawElementsInstanced = extern(System) void function(GLenum mode, GLsizei count, GLenum type, const( void*) indices, GLsizei primcount) @system @nogc nothrow;

    /++
     + glDrawElementsInstanced: man4/glDrawElementsInstanced.xml
     + 
     + $(D_INLINECODE glDrawElementsInstanced) behaves identically to $(D_INLINECODE glDrawElements) except that $(D_INLINECODE primcount) instances of the set of elements are executed and the value of the internal counter $(D_INLINECODE instanceID) advances for each iteration. $(D_INLINECODE instanceID) is an internal 32-bit integer counter that may be read by a vertex shader as $(D_INLINECODE gl_InstanceID). $(D_INLINECODE glDrawElementsInstanced) has the same effect as:
     + 
     + ---
     + if (mode, count, or type is invalid )
     +     generate appropriate error
     + else {
     +     for (int i = 0; i &lt; primcount ; i++) {
     +         instanceID = i;
     +         glDrawElements(mode, count, type, indices);
     +     }
     +     instanceID = 0;
     + }
     + ---
     + 
     + 
     + $(D_INLINECODE glDrawElementsInstanced) is available only if the GL version is 3.1 or greater. $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY) and $(D_INLINECODE GL_TRIANGLES_ADJACENCY) are available only if the GL version is 3.2 or greater.
     + 
     + Params:
     +     mode      = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY) and $(D_INLINECODE GL_PATCHES) are accepted.
     +     count     = Specifies the number of elements to be rendered.
     +     type      = Specifies the type of the values in $(D_INLINECODE indices). Must be one of $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), or $(D_INLINECODE GL_UNSIGNED_INT).
     +     indices   = Specifies a pointer to the location where the indices are stored.
     +     primcount = Specifies the number of instances of the specified range of indices to be rendered.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawArraysInstanced)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P1)
    fn_glDrawElementsInstanced glDrawElementsInstanced;
    alias fn_glDrawElementsInstancedBaseInstance = extern(System) void function(GLenum mode, GLsizei count, GLenum type, const( void*) indices, GLsizei primcount, GLuint baseinstance) @system @nogc nothrow;

    /++
     + glDrawElementsInstancedBaseInstance: man4/glDrawElementsInstancedBaseInstance.xml
     + 
     + $(D_INLINECODE glDrawElementsInstancedBaseInstance) behaves identically to $(D_INLINECODE glDrawElements) except that $(D_INLINECODE primcount) instances of the set of elements are executed and the value of the internal counter $(D_INLINECODE instanceID) advances for each iteration. $(D_INLINECODE instanceID) is an internal 32-bit integer counter that may be read by a vertex shader as $(D_INLINECODE gl_InstanceID). $(D_INLINECODE glDrawElementsInstancedBaseInstance) has the same effect as:
     + 
     + ---
     + if (mode, count, or type is invalid )
     +     generate appropriate error
     + else {
     +     for (int i = 0; i &lt; primcount ; i++) {
     +         instanceID = i;
     +         glDrawElements(mode, count, type, indices);
     +     }
     +     instanceID = 0;
     + }
     + ---
     +  Specific vertex attributes may be classified as through the use of $(D_INLINECODE glVertexAttribDivisor). Instanced vertex attributes supply per-instance vertex data to the vertex shader. The index of the vertex fetched from the enabled instanced vertex attribute arrays is calculated as gl _ InstanceID divisor &plus; baseInstance. Note that $(D_INLINECODE baseinstance) does not affect the shader-visible value of $(D_INLINECODE gl_InstanceID).
     + 
     + $(D_INLINECODE glDrawElementsInstancedBaseInstance) is available only if the GL version is 4.2 or greater. $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY) and $(D_INLINECODE GL_TRIANGLES_ADJACENCY) are available only if the GL version is 3.2 or greater.
     + 
     + Params:
     +     mode         = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY) and $(D_INLINECODE GL_PATCHES) are accepted.
     +     count        = Specifies the number of elements to be rendered.
     +     type         = Specifies the type of the values in $(D_INLINECODE indices). Must be one of $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), or $(D_INLINECODE GL_UNSIGNED_INT).
     +     indices      = Specifies a pointer to the location where the indices are stored.
     +     primcount    = Specifies the number of instances of the specified range of indices to be rendered.
     +     baseinstance = Specifies the base instance for use in fetching instanced vertex attributes.
     + 
     + Copyright:
     +     Copyright&copy; 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawArraysInstanced)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P2)
    @OpenGL_Extension("GL_ARB_base_instance")
    fn_glDrawElementsInstancedBaseInstance glDrawElementsInstancedBaseInstance;
    alias fn_glDrawElementsInstancedBaseVertex = extern(System) void function(GLenum mode, GLsizei count, GLenum type, GLvoid* indices, GLsizei primcount, GLint basevertex) @system @nogc nothrow;

    /++
     + glDrawElementsInstancedBaseVertex: man4/glDrawElementsInstancedBaseVertex.xml
     + 
     + $(D_INLINECODE glDrawElementsInstancedBaseVertex) behaves identically to $(D_INLINECODE glDrawElementsInstanced) except that the th element transferred by the corresponding draw call will be taken from element $(D_INLINECODE indices) [i] + $(D_INLINECODE basevertex) of each enabled array. If the resulting value is larger than the maximum value representable by $(D_INLINECODE type), it is as if the calculation were upconverted to 32-bit unsigned integers (with wrapping on overflow conditions). The operation is undefined if the sum would be negative.
     + 
     + $(D_INLINECODE glDrawElementsInstancedBaseVertex) is only supported if the GL version is 3.2 or greater.
     + 
     + Params:
     +     mode       = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY) and $(D_INLINECODE GL_PATCHES) are accepted.
     +     count      = Specifies the number of elements to be rendered.
     +     type       = Specifies the type of the values in indices. Must be one of $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), or $(D_INLINECODE GL_UNSIGNED_INT).
     +     indices    = Specifies a pointer to the location where the indices are stored.
     +     primcount  = Specifies the number of instances of the indexed geometry that should be drawn.
     +     basevertex = Specifies a constant that should be added to each element of $(D_INLINECODE indices) when chosing elements from the enabled vertex arrays.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawRangeElementsBaseVertex), $(D_INLINECODE glDrawElementsInstanced), $(D_INLINECODE glDrawElementsInstancedBaseVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_draw_elements_base_vertex")
    fn_glDrawElementsInstancedBaseVertex glDrawElementsInstancedBaseVertex;
    alias fn_glDrawElementsInstancedBaseVertexBaseInstance = extern(System) void function(GLenum mode, GLsizei count, GLenum type, GLvoid* indices, GLsizei primcount, GLint basevertex, GLuint baseinstance) @system @nogc nothrow;

    /++
     + glDrawElementsInstancedBaseVertexBaseInstance: man4/glDrawElementsInstancedBaseVertexBaseInstance.xml
     + 
     + $(D_INLINECODE glDrawElementsInstancedBaseVertexBaseInstance) behaves identically to $(D_INLINECODE glDrawElementsInstanced) except that the th element transferred by the corresponding draw call will be taken from element $(D_INLINECODE indices) [i] + $(D_INLINECODE basevertex) of each enabled array. If the resulting value is larger than the maximum value representable by $(D_INLINECODE type), it is as if the calculation were upconverted to 32-bit unsigned integers (with wrapping on overflow conditions). The operation is undefined if the sum would be negative. The $(D_INLINECODE basevertex) has no effect on the shader-visible value of $(D_INLINECODE gl_VertexID). Specific vertex attributes may be classified as through the use of $(D_INLINECODE glVertexAttribDivisor). Instanced vertex attributes supply per-instance vertex data to the vertex shader. The index of the vertex fetched from the enabled instanced vertex attribute arrays is calculated as gl _ InstanceID divisor &plus; baseInstance. Note that $(D_INLINECODE baseinstance) does not affect the shader-visible value of $(D_INLINECODE gl_InstanceID).
     + 
     + $(D_INLINECODE glDrawElementsInstancedBaseVertex) is only supported if the GL version is 3.2 or greater.
     + 
     + Params:
     +     mode         = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY) and $(D_INLINECODE GL_PATCHES) are accepted.
     +     count        = Specifies the number of elements to be rendered.
     +     type         = Specifies the type of the values in indices. Must be one of $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), or $(D_INLINECODE GL_UNSIGNED_INT).
     +     indices      = Specifies a pointer to the location where the indices are stored.
     +     primcount    = Specifies the number of instances of the indexed geometry that should be drawn.
     +     basevertex   = Specifies a constant that should be added to each element of $(D_INLINECODE indices) when chosing elements from the enabled vertex arrays.
     +     baseinstance = Specifies the base instance for use in fetching instanced vertex attributes.
     + 
     + Copyright:
     +     Copyright&copy; 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawRangeElementsBaseVertex), $(D_INLINECODE glDrawElementsInstanced), $(D_INLINECODE glDrawElementsInstancedBaseVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P2)
    @OpenGL_Extension("GL_ARB_base_instance")
    fn_glDrawElementsInstancedBaseVertexBaseInstance glDrawElementsInstancedBaseVertexBaseInstance;
    alias fn_glDrawRangeElements = extern(System) void function(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const( GLvoid*) indices) @system @nogc nothrow;

    /++
     + glDrawRangeElements: man4/glDrawRangeElements.xml
     + 
     + $(D_INLINECODE glDrawRangeElements) is a restricted form of $(D_INLINECODE glDrawElements). $(D_INLINECODE mode), $(D_INLINECODE start), $(D_INLINECODE end), and $(D_INLINECODE count) match the corresponding arguments to $(D_INLINECODE glDrawElements), with the additional constraint that all values in the arrays $(D_INLINECODE count) must lie between $(D_INLINECODE start) and $(D_INLINECODE end), inclusive. Implementations denote recommended maximum amounts of vertex and index data, which may be queried by calling $(D_INLINECODE glGet) with argument $(D_INLINECODE GL_MAX_ELEMENTS_VERTICES) and $(D_INLINECODE GL_MAX_ELEMENTS_INDICES). If end - start + 1 is greater than the value of $(D_INLINECODE GL_MAX_ELEMENTS_VERTICES), or if $(D_INLINECODE count) is greater than the value of $(D_INLINECODE GL_MAX_ELEMENTS_INDICES), then the call may operate at reduced performance.  There is no requirement that all vertices in the range start end be referenced.  However, the implementation may partially process unused vertices, reducing performance from what could be achieved with an optimal index set. When $(D_INLINECODE glDrawRangeElements) is called, it uses $(D_INLINECODE count) sequential elements from an enabled array, starting at $(D_INLINECODE start) to construct a sequence of geometric primitives. $(D_INLINECODE mode) specifies what kind of primitives are constructed, and how the array elements construct these primitives. If more than one array is enabled, each is used. Vertex attributes that are modified by $(D_INLINECODE glDrawRangeElements) have an unspecified value after $(D_INLINECODE glDrawRangeElements) returns. Attributes that aren't modified maintain their previous values.
     + 
     + $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY) and $(D_INLINECODE GL_TRIANGLES_ADJACENCY) are available only if the GL version is 3.2 or greater.
     + 
     + Params:
     +     mode    = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY) and $(D_INLINECODE GL_PATCHES) are accepted.
     +     start   = Specifies the minimum array index contained in $(D_INLINECODE indices).
     +     end     = Specifies the maximum array index contained in $(D_INLINECODE indices).
     +     count   = Specifies the number of elements to be rendered.
     +     type    = Specifies the type of the values in $(D_INLINECODE indices). Must be one of $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), or $(D_INLINECODE GL_UNSIGNED_INT).
     +     indices = Specifies a pointer to the location where the indices are stored.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawElementsBaseVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P2)
    fn_glDrawRangeElements glDrawRangeElements;
    alias fn_glDrawRangeElementsBaseVertex = extern(System) void function(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, GLvoid* indices, GLint basevertex) @system @nogc nothrow;

    /++
     + glDrawRangeElementsBaseVertex: man4/glDrawRangeElementsBaseVertex.xml
     + 
     + $(D_INLINECODE glDrawRangeElementsBaseVertex) is a restricted form of $(D_INLINECODE glDrawElementsBaseVertex). $(D_INLINECODE mode), $(D_INLINECODE start), $(D_INLINECODE end), $(D_INLINECODE count) and $(D_INLINECODE basevertex) match the corresponding arguments to $(D_INLINECODE glDrawElementsBaseVertex), with the additional constraint that all values in the array $(D_INLINECODE indices) must lie between $(D_INLINECODE start) and $(D_INLINECODE end), inclusive, prior to adding $(D_INLINECODE basevertex). Index values lying outside the range [ $(D_INLINECODE start), $(D_INLINECODE end) ] are treated in the same way as $(D_INLINECODE glDrawElementsBaseVertex). The th element transferred by the corresponding draw call will be taken from element $(D_INLINECODE indices) [i] + $(D_INLINECODE basevertex) of each enabled array. If the resulting value is larger than the maximum value representable by $(D_INLINECODE type), it is as if the calculation were upconverted to 32-bit unsigned integers (with wrapping on overflow conditions). The operation is undefined if the sum would be negative.
     + 
     + Params:
     +     mode       = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY) and $(D_INLINECODE GL_PATCHES) are accepted.
     +     start      = Specifies the minimum array index contained in $(D_INLINECODE indices).
     +     end        = Specifies the maximum array index contained in $(D_INLINECODE indices).
     +     count      = Specifies the number of elements to be rendered.
     +     type       = Specifies the type of the values in indices. Must be one of $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), or $(D_INLINECODE GL_UNSIGNED_INT).
     +     indices    = Specifies a pointer to the location where the indices are stored.
     +     basevertex = Specifies a constant that should be added to each element of $(D_INLINECODE indices) when chosing elements from the enabled vertex arrays.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawElementsBaseVertex), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawElementsInstanced), $(D_INLINECODE glDrawElementsInstancedBaseVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_draw_elements_base_vertex")
    fn_glDrawRangeElementsBaseVertex glDrawRangeElementsBaseVertex;
    alias fn_glDrawTransformFeedback = extern(System) void function(GLenum mode, GLuint id) @system @nogc nothrow;

    /++
     + glDrawTransformFeedback: man4/glDrawTransformFeedback.xml
     + 
     + $(D_INLINECODE glDrawTransformFeedback) draws primitives of a type specified by $(D_INLINECODE mode) using a count retrieved from the transform feedback specified by $(D_INLINECODE id). Calling $(D_INLINECODE glDrawTransformFeedback) is equivalent to calling $(D_INLINECODE glDrawArrays) with $(D_INLINECODE mode) as specified, $(D_INLINECODE first) set to zero, and $(D_INLINECODE count) set to the number of vertices captured on vertex stream zero the last time transform feedback was active on the transform feedback object named by $(D_INLINECODE id).
     + 
     + Params:
     +     mode = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY), and $(D_INLINECODE GL_PATCHES) are accepted.
     +     id   = Specifies the name of a transform feedback object from which to retrieve a primitive count.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawArraysInstanced), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawTransformFeedbackStream)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_transform_feedback2")
    fn_glDrawTransformFeedback glDrawTransformFeedback;
    alias fn_glDrawTransformFeedbackInstanced = extern(System) void function(GLenum mode, GLuint id, GLsizei primcount) @system @nogc nothrow;

    /++
     + glDrawTransformFeedbackInstanced: man4/glDrawTransformFeedbackInstanced.xml
     + 
     + $(D_INLINECODE glDrawTransformFeedbackInstanced) draws multiple copies of a range of primitives of a type specified by $(D_INLINECODE mode) using a count retrieved from the transform feedback stream specified by $(D_INLINECODE stream) of the transform feedback object specified by $(D_INLINECODE id). Calling $(D_INLINECODE glDrawTransformFeedbackInstanced) is equivalent to calling $(D_INLINECODE glDrawArraysInstanced) with $(D_INLINECODE mode) and $(D_INLINECODE primcount) as specified, $(D_INLINECODE first) set to zero, and $(D_INLINECODE count) set to the number of vertices captured on vertex stream zero the last time transform feedback was active on the transform feedback object named by $(D_INLINECODE id). Calling $(D_INLINECODE glDrawTransformFeedbackInstanced) is equivalent to calling $(D_INLINECODE glDrawTransformFeedbackStreamInstanced) with $(D_INLINECODE stream) set to zero.
     + 
     + Params:
     +     mode      = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY), and $(D_INLINECODE GL_PATCHES) are accepted.
     +     id        = Specifies the name of a transform feedback object from which to retrieve a primitive count.
     +     primcount = Specifies the number of instances of the geometry to render.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawArraysInstanced), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawTransformFeedback), $(D_INLINECODE glDrawTransformFeedbackStreamInstanced).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P2)
    @OpenGL_Extension("GL_ARB_transform_feedback_instanced")
    fn_glDrawTransformFeedbackInstanced glDrawTransformFeedbackInstanced;
    alias fn_glDrawTransformFeedbackStream = extern(System) void function(GLenum mode, GLuint id, GLuint stream) @system @nogc nothrow;

    /++
     + glDrawTransformFeedbackStream: man4/glDrawTransformFeedbackStream.xml
     + 
     + $(D_INLINECODE glDrawTransformFeedbackStream) draws primitives of a type specified by $(D_INLINECODE mode) using a count retrieved from the transform feedback stream specified by $(D_INLINECODE stream) of the transform feedback object specified by $(D_INLINECODE id). Calling $(D_INLINECODE glDrawTransformFeedbackStream) is equivalent to calling $(D_INLINECODE glDrawArrays) with $(D_INLINECODE mode) as specified, $(D_INLINECODE first) set to zero, and $(D_INLINECODE count) set to the number of vertices captured on vertex stream $(D_INLINECODE stream) the last time transform feedback was active on the transform feedback object named by $(D_INLINECODE id). Calling $(D_INLINECODE glDrawTransformFeedback) is equivalent to calling $(D_INLINECODE glDrawTransformFeedbackStream) with $(D_INLINECODE stream) set to zero.
     + 
     + Params:
     +     mode   = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY), and $(D_INLINECODE GL_PATCHES) are accepted.
     +     id     = Specifies the name of a transform feedback object from which to retrieve a primitive count.
     +     stream = Specifies the index of the transform feedback stream from which to retrieve a primitive count.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawArraysInstanced), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawTransformFeedback)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_transform_feedback3")
    fn_glDrawTransformFeedbackStream glDrawTransformFeedbackStream;
    alias fn_glDrawTransformFeedbackStreamInstanced = extern(System) void function(GLenum mode, GLuint id, GLuint stream, GLsizei primcount) @system @nogc nothrow;

    /++
     + glDrawTransformFeedbackStreamInstanced: man4/glDrawTransformFeedbackStreamInstanced.xml
     + 
     + $(D_INLINECODE glDrawTransformFeedbackStreamInstanced) draws multiple copies of a range of primitives of a type specified by $(D_INLINECODE mode) using a count retrieved from the transform feedback stream specified by $(D_INLINECODE stream) of the transform feedback object specified by $(D_INLINECODE id). Calling $(D_INLINECODE glDrawTransformFeedbackStreamInstanced) is equivalent to calling $(D_INLINECODE glDrawArraysInstanced) with $(D_INLINECODE mode) and $(D_INLINECODE primcount) as specified, $(D_INLINECODE first) set to zero, and $(D_INLINECODE count) set to the number of vertices captured on vertex stream $(D_INLINECODE stream) the last time transform feedback was active on the transform feedback object named by $(D_INLINECODE id). Calling $(D_INLINECODE glDrawTransformFeedbackInstanced) is equivalent to calling $(D_INLINECODE glDrawTransformFeedbackStreamInstanced) with $(D_INLINECODE stream) set to zero.
     + 
     + Params:
     +     mode      = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY), and $(D_INLINECODE GL_PATCHES) are accepted.
     +     id        = Specifies the name of a transform feedback object from which to retrieve a primitive count.
     +     stream    = Specifies the index of the transform feedback stream from which to retrieve a primitive count.
     +     primcount = Specifies the number of instances of the geometry to render.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawArraysInstanced), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawTransformFeedback), $(D_INLINECODE glDrawTransformFeedbackStream).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P2)
    @OpenGL_Extension("GL_ARB_transform_feedback_instanced")
    fn_glDrawTransformFeedbackStreamInstanced glDrawTransformFeedbackStreamInstanced;
    alias fn_glFenceSync = extern(System) GLsync function(GLenum condition, GLbitfield flags) @system @nogc nothrow;

    /++
     + glFenceSync: man4/glFenceSync.xml
     + 
     + $(D_INLINECODE glFenceSync) creates a new fence sync object, inserts a fence command into the GL command stream and associates it with that sync object, and returns a non-zero name corresponding to the sync object. When the specified $(D_INLINECODE condition) of the sync object is satisfied by the fence command, the sync object is signaled by the GL, causing any $(D_INLINECODE glWaitSync), $(D_INLINECODE glClientWaitSync) commands blocking in $(D_INLINECODE sync) to. No other state is affected by $(D_INLINECODE glFenceSync) or by the execution of the associated fence command. $(D_INLINECODE condition) must be $(D_INLINECODE GL_SYNC_GPU_COMMANDS_COMPLETE). This condition is satisfied by completion of the fence command corresponding to the sync object and all preceding commands in the same command stream. The sync object will not be signaled until all effects from these commands on GL client and server state and the framebuffer are fully realized. Note that completion of the fence command occurs once the state of the corresponding sync object has been changed, but commands waiting on that sync object may not be unblocked until after the fence command completes.
     + 
     + $(D_INLINECODE glFenceSync) is only supported if the GL version is 3.2 or greater, or if the $(D_INLINECODE ARB_sync) extension is supported.
     + 
     + Params:
     +     condition = Specifies the condition that must be met to set the sync object's state to signaled. $(D_INLINECODE condition) must be $(D_INLINECODE GL_SYNC_GPU_COMMANDS_COMPLETE).
     +     flags     = Specifies a bitwise combination of flags controlling the behavior of the sync object. No flags are presently defined for this operation and $(D_INLINECODE flags) must be zero. $(D_INLINECODE flags) is a placeholder for anticipated future extensions of fence sync object capabilities.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDeleteSync), $(D_INLINECODE glGetSync), $(D_INLINECODE glWaitSync), $(D_INLINECODE glClientWaitSync)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_sync")
    fn_glFenceSync glFenceSync;
    alias fn_glFinish = extern(System) void function() @system @nogc nothrow;

    /++
     + glFinish: man4/glFinish.xml
     + 
     + $(D_INLINECODE glFinish) does not return until the effects of all previously called GL commands are complete. Such effects include all changes to GL state, all changes to connection state, and all changes to the frame buffer contents.
     + 
     + $(D_INLINECODE glFinish) requires a round trip to the server.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glFlush)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glFinish glFinish;
    alias fn_glFlush = extern(System) void function() @system @nogc nothrow;

    /++
     + glFlush: man4/glFlush.xml
     + 
     + Different GL implementations buffer commands in several different locations, including network buffers and the graphics accelerator itself. $(D_INLINECODE glFlush) empties all of these buffers, causing all issued commands to be executed as quickly as they are accepted by the actual rendering engine. Though this execution may not be completed in any particular time period, it does complete in finite time. Because any GL program might be executed over a network, or on an accelerator that buffers commands, all programs should call $(D_INLINECODE glFlush) whenever they count on having all of their previously issued commands completed. For example, call $(D_INLINECODE glFlush) before waiting for user input that depends on the generated image.
     + 
     + $(D_INLINECODE glFlush) can return at any time. It does not wait until the execution of all previously issued GL commands is complete.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glFinish)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glFlush glFlush;
    alias fn_glFlushMappedBufferRange = extern(System) void function(GLenum target, GLintptr offset, GLsizeiptr length) @system @nogc nothrow;

    /++
     + glFlushMappedBufferRange: man4/glFlushMappedBufferRange.xml
     + 
     + $(D_INLINECODE glFlushMappedBufferRange) indicates that modifications have been made to a range of a mapped buffer object. The buffer object must previously have been mapped with the $(D_INLINECODE GL_MAP_FLUSH_EXPLICIT_BIT) flag. $(D_INLINECODE offset) and $(D_INLINECODE length) indicate the modified subrange of the mapping, in basic machine units. The specified subrange to flush is relative to the start of the currently mapped range of the buffer. These commands may be called multiple times to indicate distinct subranges of the mapping which require flushing. If a buffer range is mapped with both $(D_INLINECODE GL_MAP_PERSISTENT_BIT) and $(D_INLINECODE GL_MAP_FLUSH_EXPLICIT_BIT) set, then these commands may be called to ensure that data written by the client into the flushed region becomes visible to the server. Data written to a coherent store will always become visible to the server after an unspecified period of time.
     + 
     + The $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) and $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) targets are available only if the GL version is 4.3 or greater. The $(D_INLINECODE GL_QUERY_BUFFER) target is available only if the GL version is 4.4 or greater.
     + 
     + Params:
     +     target = Specifies the target to which the buffer object is bound for $(D_INLINECODE glFlushMappedBufferRange), which must be one of the buffer binding targets in the following table: $(B Buffer Binding Target) $(B Purpose) $(D_INLINECODE GL_ARRAY_BUFFER) Vertex attributes $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) Atomic counter storage $(D_INLINECODE GL_COPY_READ_BUFFER) Buffer copy source $(D_INLINECODE GL_COPY_WRITE_BUFFER) Buffer copy destination $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) Indirect compute dispatch commands $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) Indirect command arguments $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) Vertex array indices $(D_INLINECODE GL_PIXEL_PACK_BUFFER) Pixel read target $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) Texture data source $(D_INLINECODE GL_QUERY_BUFFER) Query result buffer $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) Read-write storage for shaders $(D_INLINECODE GL_TEXTURE_BUFFER) Texture data buffer $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) Transform feedback buffer $(D_INLINECODE GL_UNIFORM_BUFFER) Uniform block storage
     +     buffer = Specifies the name of the buffer object for $(D_INLINECODE glFlushMappedNamedBufferRange).
     +     offset = Specifies the start of the buffer subrange, in basic machine units.
     +     length = Specifies the length of the buffer subrange, in basic machine units.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glMapBufferRange), $(D_INLINECODE glMapBuffer), $(D_INLINECODE glUnmapBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_map_buffer_range")
    fn_glFlushMappedBufferRange glFlushMappedBufferRange;
    alias fn_glFlushMappedNamedBufferRange = extern(System) void function(GLuint buffer, GLintptr offset, GLsizei length) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glFlushMappedNamedBufferRange glFlushMappedNamedBufferRange;
    alias fn_glFramebufferParameteri = extern(System) void function(GLenum target, GLenum pname, GLint param) @system @nogc nothrow;

    /++
     + glFramebufferParameteri: man4/glFramebufferParameteri.xml
     + 
     + $(D_INLINECODE glFramebufferParameteri) and $(D_INLINECODE glNamedFramebufferParameteri) modify the value of the parameter named $(D_INLINECODE pname) in the specified framebuffer object. There are no modifiable parameters of the default draw and read framebuffer, so they are not valid targets of these commands. For $(D_INLINECODE glFramebufferParameteri), the framebuffer object is that bound to $(D_INLINECODE target), which must be $(D_INLINECODE GL_DRAW_FRAMEBUFFER), $(D_INLINECODE GL_READ_FRAMEBUFFER) or $(D_INLINECODE GL_FRAMEBUFFER). $(D_INLINECODE GL_FRAMEBUFFER) is equivalent to $(D_INLINECODE GL_DRAW_FRAMEBUFFER). For $(D_INLINECODE glNamedFramebufferParameteri), $(D_INLINECODE framebuffer) is the name of the framebuffer object. $(D_INLINECODE pname) specifies the parameter to be modified. The following values are accepted:
     + 
     + Params:
     +     target      = Specifies the target to which the framebuffer is bound for $(D_INLINECODE glFramebufferParameteri).
     +     framebuffer = Specifies the name of the framebuffer object for $(D_INLINECODE glNamedFramebufferParameteri).
     +     pname       = Specifies the framebuffer parameter to be modified.
     +     param       = The new value for the parameter named $(D_INLINECODE pname).
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindFramebuffer), $(D_INLINECODE glCreateFramebuffers), $(D_INLINECODE glFramebufferRenderbuffer), $(D_INLINECODE glFramebufferTexture), $(D_INLINECODE glGenFramebuffers), $(D_INLINECODE glGetFramebufferParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_framebuffer_no_attachments")
    fn_glFramebufferParameteri glFramebufferParameteri;
    alias fn_glNamedFramebufferParameteri = extern(System) void function(GLuint framebuffer, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glNamedFramebufferParameteri glNamedFramebufferParameteri;
    alias fn_glFramebufferRenderbuffer = extern(System) void function(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) @system @nogc nothrow;

    /++
     + glFramebufferRenderbuffer: man4/glFramebufferRenderbuffer.xml
     + 
     + $(D_INLINECODE glFramebufferRenderbuffer) and $(D_INLINECODE glNamedFramebufferRenderbuffer) attaches a renderbuffer as one of the logical buffers of the specified framebuffer object. Renderbuffers cannot be attached to the default draw and read framebuffer, so they are not valid targets of these commands. For $(D_INLINECODE glFramebufferRenderbuffer), the framebuffer object is that bound to $(D_INLINECODE target), which must be $(D_INLINECODE GL_DRAW_FRAMEBUFFER), $(D_INLINECODE GL_READ_FRAMEBUFFER) or $(D_INLINECODE GL_FRAMEBUFFER). $(D_INLINECODE GL_FRAMEBUFFER) is equivalent to $(D_INLINECODE GL_DRAW_FRAMEBUFFER). For $(D_INLINECODE glNamedFramebufferRenderbuffer), $(D_INLINECODE framebuffer) is the name of the framebuffer object. $(D_INLINECODE renderbuffertarget) must be $(D_INLINECODE GL_RENDERBUFFER). $(D_INLINECODE renderbuffer) must be zero or the name of an existing renderbuffer object of type $(D_INLINECODE renderbuffertarget). If $(D_INLINECODE renderbuffer) is not zero, then the specified renderbuffer will be used as the logical buffer identified by $(D_INLINECODE attachment) of the specified framebuffer object. If $(D_INLINECODE renderbuffer) is zero, then the value of $(D_INLINECODE renderbuffertarget) is ignored. $(D_INLINECODE attachment) specifies the logical attachment of the framebuffer and must be $(D_INLINECODE GL_COLOR_ATTACHMENT), $(D_INLINECODE GL_DEPTH_ATTACHMENT), $(D_INLINECODE GL_STENCIL_ATTACHMENT) or $(D_INLINECODE GL_DEPTH_STENCIL_ATTACHMENT). in may range from zero to the value of $(D_INLINECODE GL_MAX_COLOR_ATTACHMENTS) minus one. Setting $(D_INLINECODE attachment) to the value $(D_INLINECODE GL_DEPTH_STENCIL_ATTACHMENT) is a special case causing both the depth and stencil attachments of the specified framebuffer object to be set to $(D_INLINECODE renderbuffer), which should have the base internal format $(D_INLINECODE GL_DEPTH_STENCIL). The value of $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE) for the specified attachment point is set to $(D_INLINECODE GL_RENDERBUFFER) and the value of $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME) is set to $(D_INLINECODE renderbuffer). All other state values of specified attachment point are set to their default values. No change is made to the state of the renderbuuffer object and any previous attachment to the $(D_INLINECODE attachment) logical buffer of the specified framebuffer object is broken. If $(D_INLINECODE renderbuffer) is zero, these commands will detach the image, if any, identified by the specified attachment point of the specified framebuffer object. All state values of the attachment point are set to their default values.
     + 
     + Params:
     +     target             = Specifies the target to which the framebuffer is bound for $(D_INLINECODE glFramebufferRenderbuffer).
     +     framebuffer        = Specifies the name of the framebuffer object for $(D_INLINECODE glNamedFramebufferRenderbuffer).
     +     attachment         = Specifies the attachment point of the framebuffer.
     +     renderbuffertarget = Specifies the renderbuffer target. Must be $(D_INLINECODE GL_RENDERBUFFER).
     +     renderbuffer       = Specifies the name of an existing renderbuffer object of type $(D_INLINECODE renderbuffertarget) to attach.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenFramebuffers), $(D_INLINECODE glBindFramebuffer), $(D_INLINECODE glGenRenderbuffers), $(D_INLINECODE glFramebufferTexture), $(D_INLINECODE glFramebufferTexture1D), $(D_INLINECODE glFramebufferTexture2D), $(D_INLINECODE glFramebufferTexture3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    fn_glFramebufferRenderbuffer glFramebufferRenderbuffer;
    alias fn_glNamedFramebufferRenderbuffer = extern(System) void function(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glNamedFramebufferRenderbuffer glNamedFramebufferRenderbuffer;
    alias fn_glFramebufferTexture = extern(System) void function(GLenum target, GLenum attachment, GLuint texture, GLint level) @system @nogc nothrow;

    /++
     + glFramebufferTexture: man4/glFramebufferTexture.xml
     + 
     + These commands attach a selected mipmap level or image of a texture object as one of the logical buffers of the specified framebuffer object. Textures cannot be attached to the default draw and read framebuffer, so they are not valid targets of these commands. For all commands $(D_INLINECODE glNamedFramebufferTexture), the framebuffer object is that bound to $(D_INLINECODE target), which must be $(D_INLINECODE GL_DRAW_FRAMEBUFFER), $(D_INLINECODE GL_READ_FRAMEBUFFER), or $(D_INLINECODE GL_FRAMEBUFFER). $(D_INLINECODE GL_FRAMEBUFFER) is equivalent to $(D_INLINECODE GL_DRAW_FRAMEBUFFER). For $(D_INLINECODE glNamedFramebufferTexture), $(D_INLINECODE framebuffer) is the name of the framebuffer object. $(D_INLINECODE attachment) specifies the logical attachment of the framebuffer and must be $(D_INLINECODE GL_COLOR_ATTACHMENT), $(D_INLINECODE GL_DEPTH_ATTACHMENT), $(D_INLINECODE GL_STENCIL_ATTACHMENT) or $(D_INLINECODE GL_DEPTH_STENCIL_ATTACHMENT). in $(D_INLINECODE GL_COLOR_ATTACHMENT) may range from zero to the value of $(D_INLINECODE GL_MAX_COLOR_ATTACHMENTS) minus one. Attaching a level of a texture to $(D_INLINECODE GL_DEPTH_STENCIL_ATTACHMENT) is equivalent to attaching that level to both the $(D_INLINECODE GL_DEPTH_ATTACHMENT) the $(D_INLINECODE GL_STENCIL_ATTACHMENT) attachment points simultaneously. For $(D_INLINECODE glFramebufferTexture1D), $(D_INLINECODE glFramebufferTexture2D) and $(D_INLINECODE glFramebufferTexture3D), $(D_INLINECODE textarget) specifies what type of texture is named by $(D_INLINECODE texture), and for cube map textures, specifies the face that is to be attached. If $(D_INLINECODE texture) is not zero, it must be the name of an existing texture object with effective target $(D_INLINECODE textarget) unless it is a cube map texture, in which case $(D_INLINECODE textarget) must be $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X) $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Z), or $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Z). If $(D_INLINECODE texture) is non-zero, the specified $(D_INLINECODE level) of the texture object named $(D_INLINECODE texture) is attached to the framebfufer attachment point named by $(D_INLINECODE attachment). For $(D_INLINECODE glFramebufferTexture1D), $(D_INLINECODE glFramebufferTexture2D), and $(D_INLINECODE glFramebufferTexture3D), $(D_INLINECODE texture) must be zero or the name of an existing texture with an effective target of $(D_INLINECODE textarget), or $(D_INLINECODE texture) must be the name of an existing cube-map texture and $(D_INLINECODE textarget) must be one of $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Z), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Y), or $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Z). If $(D_INLINECODE textarget) is $(D_INLINECODE GL_TEXTURE_RECTANGLE), $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE), or $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY), then $(D_INLINECODE level) must be zero. If $(D_INLINECODE textarget) is $(D_INLINECODE GL_TEXTURE_3D), then $(D_INLINECODE level) must be greater than or equal to zero and less than or equal to $log_2$ of the value of $(D_INLINECODE GL_MAX_3D_TEXTURE_SIZE). If $(D_INLINECODE textarget) is one of $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Z), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Y), or $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Z), then $(D_INLINECODE level) must be greater than or equal to zero and less than or equal to $log_2$ of the value of $(D_INLINECODE GL_MAX_CUBE_MAP_TEXTURE_SIZE). For all other values of $(D_INLINECODE textarget), $(D_INLINECODE level) must be greater than or equal to zero and less than or equal to $log_2$ of the value of $(D_INLINECODE GL_MAX_TEXTURE_SIZE). $(D_INLINECODE layer) specifies the layer of a 2-dimensional image within a 3-dimensional texture. For $(D_INLINECODE glFramebufferTexture1D), if $(D_INLINECODE texture) is not zero, then $(D_INLINECODE textarget) must be $(D_INLINECODE GL_TEXTURE_1D). For $(D_INLINECODE glFramebufferTexture2D), if $(D_INLINECODE texture) is not zero, $(D_INLINECODE textarget) must be one of $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_RECTANGLE), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Z), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Z), or $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE). For $(D_INLINECODE glFramebufferTexture3D), if $(D_INLINECODE texture) is not zero, then $(D_INLINECODE textarget) must be $(D_INLINECODE GL_TEXTURE_3D). For $(D_INLINECODE glFramebufferTexture) and $(D_INLINECODE glNamedFramebufferTexture), if $(D_INLINECODE texture) is the name of a three-dimensional, cube map array, cube map, one- or two-dimensional array, or two-dimensional multisample array texture, the specified texture level is an array of images, and the framebuffer attachment is considered to be.
     + 
     + Params:
     +     target      = Specifies the target to which the framebuffer is bound for all commands $(D_INLINECODE glNamedFramebufferTexture).
     +     framebuffer = Specifies the name of the framebuffer object for $(D_INLINECODE glNamedFramebufferTexture).
     +     attachment  = Specifies the attachment point of the framebuffer.
     +     textarget   = For $(D_INLINECODE glFramebufferTexture1D), $(D_INLINECODE glFramebufferTexture2D) and $(D_INLINECODE glFramebufferTexture3D), specifies what type of texture is expected in the $(D_INLINECODE texture) parameter, or for cube map textures, which face is to be attached.
     +     texture     = Specifies the name of an existing texture object to attach.
     +     level       = Specifies the mipmap level of the texture object to attach.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenFramebuffers), $(D_INLINECODE glBindFramebuffer), $(D_INLINECODE glGenRenderbuffers), $(D_INLINECODE glFramebufferTexture), $(D_INLINECODE glFramebufferTexture1D), $(D_INLINECODE glFramebufferTexture2D), $(D_INLINECODE glFramebufferTexture3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    fn_glFramebufferTexture glFramebufferTexture;
    alias fn_glFramebufferTexture1D = extern(System) void function(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    fn_glFramebufferTexture1D glFramebufferTexture1D;
    alias fn_glFramebufferTexture2D = extern(System) void function(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    fn_glFramebufferTexture2D glFramebufferTexture2D;
    alias fn_glFramebufferTexture3D = extern(System) void function(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    fn_glFramebufferTexture3D glFramebufferTexture3D;
    alias fn_glNamedFramebufferTexture = extern(System) void function(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glNamedFramebufferTexture glNamedFramebufferTexture;
    alias fn_glFramebufferTextureLayer = extern(System) void function(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer) @system @nogc nothrow;

    /++
     + glFramebufferTextureLayer: man4/glFramebufferTextureLayer.xml
     + 
     + $(D_INLINECODE glFramebufferTextureLayer) and $(D_INLINECODE glNamedFramebufferTextureLayer) attach a single layer of a three-dimensional or array texture object as one of the logical buffers of the specified framebuffer object. Textures cannot be attached to the default draw and read framebuffer, so they are not valid targets of these commands. For $(D_INLINECODE glFramebufferTextureLayer), the framebuffer object is that bound to $(D_INLINECODE target), which must be $(D_INLINECODE GL_DRAW_FRAMEBUFFER), $(D_INLINECODE GL_READ_FRAMEBUFFER), or $(D_INLINECODE GL_FRAMEBUFFER). $(D_INLINECODE GL_FRAMEBUFFER) is equivalent to $(D_INLINECODE GL_DRAW_FRAMEBUFFER). For $(D_INLINECODE glNamedFramebufferTextureLayer), $(D_INLINECODE framebuffer) is the name of the framebuffer object. $(D_INLINECODE attachment) specifies the logical attachment of the framebuffer and must be $(D_INLINECODE GL_COLOR_ATTACHMENT), $(D_INLINECODE GL_DEPTH_ATTACHMENT), $(D_INLINECODE GL_STENCIL_ATTACHMENT) or $(D_INLINECODE GL_DEPTH_STENCIL_ATTACHMENT). in $(D_INLINECODE GL_COLOR_ATTACHMENT) may range from zero to the value of $(D_INLINECODE GL_MAX_COLOR_ATTACHMENTS) minus one. Attaching a level of a texture to $(D_INLINECODE GL_DEPTH_STENCIL_ATTACHMENT) is equivalent to attaching that level to both the $(D_INLINECODE GL_DEPTH_ATTACHMENT) the $(D_INLINECODE GL_STENCIL_ATTACHMENT) attachment points simultaneously. If $(D_INLINECODE texture) is not zero, it must be the name of a three-dimensional, two-dimensional multisample array, one- or two-dimensional array, or cube map array texture. If $(D_INLINECODE texture) is a three-dimensional texture, then $(D_INLINECODE level) must be greater than or equal to zero and less than or equal to $log_2$ of the value of $(D_INLINECODE GL_MAX_3D_TEXTURE_SIZE). If $(D_INLINECODE texture) is a two-dimensional array texture, then $(D_INLINECODE level) must be greater than or equal to zero and less than or equal to $log_2$ of the value of $(D_INLINECODE GL_MAX_TEXTURE_SIZE). For cube map textures, $(D_INLINECODE layer) is translated into a cube map face according to $$ face = k \bmod 6. $$ For cube map array textures, $(D_INLINECODE layer) is translated into an array layer and face according to $$ layer = \left\lfloor { layer \over 6 } \right\rfloor$$ and $$ face = k \bmod 6. $$
     + 
     + Params:
     +     target      = Specifies the target to which the framebuffer is bound for $(D_INLINECODE glFramebufferTextureLayer).
     +     framebuffer = Specifies the name of the framebuffer object for $(D_INLINECODE glNamedFramebufferTextureLayer).
     +     attachment  = Specifies the attachment point of the framebuffer.
     +     texture     = Specifies the name of an existing texture object to attach.
     +     level       = Specifies the mipmap level of the texture object to attach.
     +     layer       = Specifies the layer of the texture object to attach.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenFramebuffers), $(D_INLINECODE glBindFramebuffer), $(D_INLINECODE glGenRenderbuffers), $(D_INLINECODE glFramebufferTexture),
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    fn_glFramebufferTextureLayer glFramebufferTextureLayer;
    alias fn_glNamedFramebufferTextureLayer = extern(System) void function(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glNamedFramebufferTextureLayer glNamedFramebufferTextureLayer;
    alias fn_glFrontFace = extern(System) void function(GLenum mode) @system @nogc nothrow;

    /++
     + glFrontFace: man4/glFrontFace.xml
     + 
     + In a scene composed entirely of opaque closed surfaces, back-facing polygons are never visible. Eliminating these invisible polygons has the obvious benefit of speeding up the rendering of the image. To enable and disable elimination of back-facing polygons, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_CULL_FACE). The projection of a polygon to window coordinates is said to have clockwise winding if an imaginary object following the path from its first vertex, its second vertex, and so on, to its last vertex, and finally back to its first vertex, moves in a clockwise direction about the interior of the polygon. The polygon's winding is said to be counterclockwise if the imaginary object following the same path moves in a counterclockwise direction about the interior of the polygon. $(D_INLINECODE glFrontFace) specifies whether polygons with clockwise winding in window coordinates, or counterclockwise winding in window coordinates, are taken to be front-facing. Passing $(D_INLINECODE GL_CCW) to $(D_INLINECODE mode) selects counterclockwise polygons as front-facing; $(D_INLINECODE GL_CW) selects clockwise polygons as front-facing. By default, counterclockwise polygons are taken to be front-facing.
     + 
     + Params:
     +     mode = Specifies the orientation of front-facing polygons. $(D_INLINECODE GL_CW) and $(D_INLINECODE GL_CCW) are accepted. The initial value is $(D_INLINECODE GL_CCW).
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCullFace),
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glFrontFace glFrontFace;
    alias fn_glGenBuffers = extern(System) void function(GLsizei n, GLuint* buffers) @system @nogc nothrow;

    /++
     + glGenBuffers: man4/glGenBuffers.xml
     + 
     + $(D_INLINECODE glGenBuffers) returns $(D_INLINECODE n) buffer object names in $(D_INLINECODE buffers). There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to $(D_INLINECODE glGenBuffers). Buffer object names returned by a call to $(D_INLINECODE glGenBuffers) are not returned by subsequent calls, unless they are first deleted with $(D_INLINECODE glDeleteBuffers). No buffer objects are associated with the returned buffer object names until they are first bound by calling $(D_INLINECODE glBindBuffer).
     + 
     + Params:
     +     n       = Specifies the number of buffer object names to be generated.
     +     buffers = Specifies an array in which the generated buffer object names are stored.
     + 
     + Copyright:
     +     Copyright&copy; 2005 Addison-Wesley. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBuffer), $(D_INLINECODE glDeleteBuffers), $(D_INLINECODE glGet)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    fn_glGenBuffers glGenBuffers;
    alias fn_glGenerateMipmap = extern(System) void function(GLenum target) @system @nogc nothrow;

    /++
     + glGenerateMipmap: man4/glGenerateMipmap.xml
     + 
     + $(D_INLINECODE glGenerateMipmap) and $(D_INLINECODE glGenerateTextureMipmap) generates mipmaps for the specified texture object. For $(D_INLINECODE glGenerateMipmap), the texture object is that bound to to $(D_INLINECODE target). For $(D_INLINECODE glGenerateTextureMipmap), $(D_INLINECODE texture) is the name of the texture object. For cube map and cube map array textures, the texture object must be cube complete or cube array complete respectively. Mipmap generation replaces texel image levels $level_{base} + 1$ through $q$ with images derived from the $level_{base}$ image, regardless of their previous contents. All other mimap images, including the $level_{base}+1$ image, are left unchanged by this computation. The internal formats of the derived mipmap images all match those of the $level_{base}$ image. The contents of the derived images are computed by repeated, filtered reduction of the $level_{base} + 1$ image. For one- and two-dimensional array and cube map array textures, each layer is filtered independently.
     + 
     + Cube map array textures are accepted only if the GL version is 4.0 or higher.
     + 
     + Params:
     +     target  = Specifies the target to which the texture object is bound for $(D_INLINECODE glGenerateMipmap). Must be one of $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_CUBE_MAP), or $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY).
     +     texture = Specifies the texture object name for $(D_INLINECODE glGenerateTextureMipmap).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glTexImage2D), $(D_INLINECODE glBindTexture), $(D_INLINECODE glGenTextures)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    fn_glGenerateMipmap glGenerateMipmap;
    alias fn_glGenerateTextureMipmap = extern(System) void function(GLuint texture) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glGenerateTextureMipmap glGenerateTextureMipmap;
    alias fn_glGenFramebuffers = extern(System) void function(GLsizei n, GLuint* ids) @system @nogc nothrow;

    /++
     + glGenFramebuffers: man4/glGenFramebuffers.xml
     + 
     + $(D_INLINECODE glGenFramebuffers) returns $(D_INLINECODE n) framebuffer object names in $(D_INLINECODE ids). There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to $(D_INLINECODE glGenFramebuffers). Framebuffer object names returned by a call to $(D_INLINECODE glGenFramebuffers) are not returned by subsequent calls, unless they are first deleted with $(D_INLINECODE glDeleteFramebuffers). The names returned in $(D_INLINECODE ids) are marked as used, for the purposes of $(D_INLINECODE glGenFramebuffers) only, but they acquire state and type only when they are first bound.
     + 
     + Params:
     +     n   = Specifies the number of framebuffer object names to generate.
     +     ids = Specifies an array in which the generated framebuffer object names are stored.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindFramebuffer), $(D_INLINECODE glDeleteFramebuffers)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    fn_glGenFramebuffers glGenFramebuffers;
    alias fn_glGenProgramPipelines = extern(System) void function(GLsizei n, GLuint* pipelines) @system @nogc nothrow;

    /++
     + glGenProgramPipelines: man4/glGenProgramPipelines.xml
     + 
     + $(D_INLINECODE glGenProgramPipelines) returns $(D_INLINECODE n) previously unused program pipeline object names in $(D_INLINECODE pipelines). These names are marked as used, for the purposes of $(D_INLINECODE glGenProgramPipelines) only, but they acquire program pipeline state only when they are first bound.
     + 
     + Params:
     +     n         = Specifies the number of program pipeline object names to reserve.
     +     pipelines = Specifies an array of into which the reserved names will be written.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDeleteProgramPipelines), $(D_INLINECODE glBindProgramPipeline), $(D_INLINECODE glIsProgramPipeline), $(D_INLINECODE glUseProgramStages), $(D_INLINECODE glUseProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glGenProgramPipelines glGenProgramPipelines;
    alias fn_glGenQueries = extern(System) void function(GLsizei n, GLuint* ids) @system @nogc nothrow;

    /++
     + glGenQueries: man4/glGenQueries.xml
     + 
     + $(D_INLINECODE glGenQueries) returns $(D_INLINECODE n) query object names in $(D_INLINECODE ids). There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to $(D_INLINECODE glGenQueries). Query object names returned by a call to $(D_INLINECODE glGenQueries) are not returned by subsequent calls, unless they are first deleted with $(D_INLINECODE glDeleteQueries). No query objects are associated with the returned query object names until they are first used by calling $(D_INLINECODE glBeginQuery).
     + 
     + Params:
     +     n   = Specifies the number of query object names to be generated.
     +     ids = Specifies an array in which the generated query object names are stored.
     + 
     + Copyright:
     +     Copyright&copy; 2005 Addison-Wesley. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBeginQuery), $(D_INLINECODE glDeleteQueries), $(D_INLINECODE glEndQuery)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    fn_glGenQueries glGenQueries;
    alias fn_glGenRenderbuffers = extern(System) void function(GLsizei n, GLuint* renderbuffers) @system @nogc nothrow;

    /++
     + glGenRenderbuffers: man4/glGenRenderbuffers.xml
     + 
     + $(D_INLINECODE glGenRenderbuffers) returns $(D_INLINECODE n) renderbuffer object names in $(D_INLINECODE renderbuffers). There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to $(D_INLINECODE glGenRenderbuffers). Renderbuffer object names returned by a call to $(D_INLINECODE glGenRenderbuffers) are not returned by subsequent calls, unless they are first deleted with $(D_INLINECODE glDeleteRenderbuffers). The names returned in $(D_INLINECODE renderbuffers) are marked as used, for the purposes of $(D_INLINECODE glGenRenderbuffers) only, but they acquire state and type only when they are first bound.
     + 
     + Params:
     +     n             = Specifies the number of renderbuffer object names to generate.
     +     renderbuffers = Specifies an array in which the generated renderbuffer object names are stored.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glFramebufferRenderbuffer), $(D_INLINECODE glDeleteRenderbuffers)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    fn_glGenRenderbuffers glGenRenderbuffers;
    alias fn_glGenSamplers = extern(System) void function(GLsizei n, GLuint* samplers) @system @nogc nothrow;

    /++
     + glGenSamplers: man4/glGenSamplers.xml
     + 
     + $(D_INLINECODE glGenSamplers) returns $(D_INLINECODE n) sampler object names in $(D_INLINECODE samplers). There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to $(D_INLINECODE glGenSamplers). Sampler object names returned by a call to $(D_INLINECODE glGenSamplers) are not returned by subsequent calls, unless they are first deleted with $(D_INLINECODE glDeleteSamplers). The names returned in $(D_INLINECODE samplers) are marked as used, for the purposes of $(D_INLINECODE glGenSamplers) only, but they acquire state and type only when they are first bound.
     + 
     + $(D_INLINECODE glGenSamplers) is available only if the GL version is 3.3 or higher.
     + 
     + Params:
     +     n        = Specifies the number of sampler object names to generate.
     +     samplers = Specifies an array in which the generated sampler object names are stored.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindSampler), $(D_INLINECODE glIsSampler), $(D_INLINECODE glDeleteSamplers)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    fn_glGenSamplers glGenSamplers;
    alias fn_glGenTextures = extern(System) void function(GLsizei n, GLuint* textures) @system @nogc nothrow;

    /++
     + glGenTextures: man4/glGenTextures.xml
     + 
     + $(D_INLINECODE glGenTextures) returns $(D_INLINECODE n) texture names in $(D_INLINECODE textures). There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to $(D_INLINECODE glGenTextures). The generated textures have no dimensionality; they assume the dimensionality of the texture target to which they are first bound (see $(D_INLINECODE glBindTexture) ). Texture names returned by a call to $(D_INLINECODE glGenTextures) are not returned by subsequent calls, unless they are first deleted with $(D_INLINECODE glDeleteTextures).
     + 
     + Params:
     +     n        = Specifies the number of texture names to be generated.
     +     textures = Specifies an array in which the generated texture names are stored.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindTexture), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glDeleteTextures), $(D_INLINECODE glGet), $(D_INLINECODE glGetTexParameter), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    fn_glGenTextures glGenTextures;
    alias fn_glGenTransformFeedbacks = extern(System) void function(GLsizei n, GLuint* ids) @system @nogc nothrow;

    /++
     + glGenTransformFeedbacks: man4/glGenTransformFeedbacks.xml
     + 
     + $(D_INLINECODE glGenTransformFeedbacks) returns $(D_INLINECODE n) previously unused transform feedback object names in $(D_INLINECODE ids). These names are marked as used, for the purposes of $(D_INLINECODE glGenTransformFeedbacks) only, but they acquire transform feedback state only when they are first bound.
     + 
     + Params:
     +     n   = Specifies the number of transform feedback object names to reserve.
     +     ids = Specifies an array of into which the reserved names will be written.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDeleteTransformFeedbacks), $(D_INLINECODE glBindTransformFeedback), $(D_INLINECODE glIsTransformFeedback), $(D_INLINECODE glBeginTransformFeedback), $(D_INLINECODE glPauseTransformFeedback), $(D_INLINECODE glResumeTransformFeedback), $(D_INLINECODE glEndTransformFeedback)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_transform_feedback2")
    fn_glGenTransformFeedbacks glGenTransformFeedbacks;
    alias fn_glGenVertexArrays = extern(System) void function(GLsizei n, GLuint* arrays) @system @nogc nothrow;

    /++
     + glGenVertexArrays: man4/glGenVertexArrays.xml
     + 
     + $(D_INLINECODE glGenVertexArrays) returns $(D_INLINECODE n) vertex array object names in $(D_INLINECODE arrays). There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to $(D_INLINECODE glGenVertexArrays). Vertex array object names returned by a call to $(D_INLINECODE glGenVertexArrays) are not returned by subsequent calls, unless they are first deleted with $(D_INLINECODE glDeleteVertexArrays). The names returned in $(D_INLINECODE arrays) are marked as used, for the purposes of $(D_INLINECODE glGenVertexArrays) only, but they acquire state and type only when they are first bound.
     + 
     + Params:
     +     n      = Specifies the number of vertex array object names to generate.
     +     arrays = Specifies an array in which the generated vertex array object names are stored.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindVertexArray), $(D_INLINECODE glDeleteVertexArrays)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_vertex_array_object")
    fn_glGenVertexArrays glGenVertexArrays;
    alias fn_glGetBooleanv = extern(System) void function(GLenum pname, GLboolean* data) @system @nogc nothrow;

    /++
     + glGet: man4/glGet.xml
     + 
     + These commands return values for simple state variables in GL. $(D_INLINECODE pname) is a symbolic constant indicating the state variable to be returned, and $(D_INLINECODE data) is a pointer to an array of the indicated type in which to place the returned data. Type conversion is performed if $(D_INLINECODE data) has a different type than the state variable value being requested. If $(D_INLINECODE glGetBooleanv) is called, a floating-point (or integer) value is converted to $(D_INLINECODE GL_FALSE) if and only if it is 0.0 (or 0). Otherwise, it is converted to $(D_INLINECODE GL_TRUE). If $(D_INLINECODE glGetIntegerv) is called, boolean values are returned as $(D_INLINECODE GL_TRUE) or $(D_INLINECODE GL_FALSE), and most floating-point values are rounded to the nearest integer value. Floating-point colors and normals, however, are returned with a linear mapping that maps 1.0 to the most positive representable integer value and -1.0 to the most negative representable integer value. If $(D_INLINECODE glGetFloatv) or $(D_INLINECODE glGetDoublev) is called, boolean values are returned as $(D_INLINECODE GL_TRUE) or $(D_INLINECODE GL_FALSE), and integer values are converted to floating-point values. The following symbolic constants are accepted by $(D_INLINECODE pname) : Many of the boolean parameters can also be queried more easily using $(D_INLINECODE glIsEnabled).
     + 
     + The following parameters return the associated value for the active texture unit: $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_BINDING_1D), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_BINDING_2D), $(D_INLINECODE GL_TEXTURE_3D) and $(D_INLINECODE GL_TEXTURE_BINDING_3D). $(D_INLINECODE GL_MAX_VIEWPORTS), $(D_INLINECODE GL_VIEWPORT_SUBPIXEL_BITS), $(D_INLINECODE GL_VIEWPORT_BOUNDS_RANGE), $(D_INLINECODE GL_LAYER_PROVOKING_VERTEX), and $(D_INLINECODE GL_VIEWPORT_INDEX_PROVOKING_VERTEX) are available only if the GL version is 4.1 or greater. $(D_INLINECODE GL_MAX_VERTEX_ATOMIC_COUNTERS), $(D_INLINECODE GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS), $(D_INLINECODE GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS), $(D_INLINECODE GL_MAX_GEOMETRY_ATOMIC_COUNTERS), $(D_INLINECODE GL_MAX_FRAMGENT_ATOMIC_COUNTERS), and $(D_INLINECODE GL_MIN_MAP_BUFFER_ALIGNMENT) are accepted by $(D_INLINECODE pname) only if the GL version is 4.2 or greater. $(D_INLINECODE GL_MAX_ELEMENT_INDEX) is accepted by $(D_INLINECODE pname) only if the GL version is 4.3 or greater. $(D_INLINECODE GL_MAX_COMPUTE_UNIFORM_BLOCKS), $(D_INLINECODE GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS), $(D_INLINECODE GL_MAX_COMPUTE_UNIFORM_COMPONENTS), $(D_INLINECODE GL_MAX_COMPUTE_ATOMIC_COUNTERS), $(D_INLINECODE GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS), $(D_INLINECODE GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS), $(D_INLINECODE GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS), $(D_INLINECODE GL_MAX_COMPUTE_WORK_GROUP_COUNT), and $(D_INLINECODE GL_MAX_COMPUTE_WORK_GROUP_SIZE) and $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER_BINDING) are available only if the GL version is 4.3 or greater. $(D_INLINECODE GL_MAX_DEBUG_GROUP_STACK_DEPTH), $(D_INLINECODE GL_DEBUG_GROUP_STACK_DEPTH) and $(D_INLINECODE GL_MAX_LABEL_LENGTH) are accepted only if the GL version is 4.3 or greater. $(D_INLINECODE GL_MAX_UNIFORM_LOCATIONS) is accepted only if the GL version is 4.3 or greater. $(D_INLINECODE GL_MAX_FRAMEBUFFER_WIDTH), $(D_INLINECODE GL_MAX_FRAMEBUFFER_HEIGHT), $(D_INLINECODE GL_MAX_FRAMEBUFFER_LAYERS), and $(D_INLINECODE GL_MAX_FRAMEBUFFER_SAMPLES) are available only if the GL version is 4.3 or greater. $(D_INLINECODE GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS), $(D_INLINECODE GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS), $(D_INLINECODE GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS), $(D_INLINECODE GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS), $(D_INLINECODE GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS), and $(D_INLINECODE GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS) are available only if the GL version is 4.3 or higher. $(D_INLINECODE GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT) is available only if the GL version is 4.3 or greater. $(D_INLINECODE GL_VERTEX_BINDING_DIVISOR), $(D_INLINECODE GL_VERTEX_BINDING_OFFSET), $(D_INLINECODE GL_VERTEX_BINDING_STRIDE), $(D_INLINECODE GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET) and $(D_INLINECODE GL_MAX_VERTEX_ATTRIB_BINDINGS) are available only if the GL version is 4.3 or greater.
     + 
     + Params:
     +     pname  = Specifies the parameter value to be returned for non-indexed versions of $(D_INLINECODE glGet). The symbolic constants in the list below are accepted.
     +     target = Specifies the parameter value to be returned for indexed versions of $(D_INLINECODE glGet). The symbolic constants in the list below are accepted.
     +     index  = Specifies the index of the particular element being queried.
     +     data   = Returns the value or values of the specified parameter.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetActiveUniform), $(D_INLINECODE glGetAttachedShaders), $(D_INLINECODE glGetAttribLocation), $(D_INLINECODE glGetBufferParameter), $(D_INLINECODE glGetBufferPointerv), $(D_INLINECODE glGetBufferSubData), $(D_INLINECODE glGetCompressedTexImage), $(D_INLINECODE glGetError), $(D_INLINECODE glGetProgram), $(D_INLINECODE glGetProgramInfoLog), $(D_INLINECODE glGetQueryiv), $(D_INLINECODE glGetQueryObject), $(D_INLINECODE glGetShader), $(D_INLINECODE glGetShaderInfoLog), $(D_INLINECODE glGetShaderSource), $(D_INLINECODE glGetString), $(D_INLINECODE glGetTexImage), $(D_INLINECODE glGetTexLevelParameter), $(D_INLINECODE glGetTexParameter), $(D_INLINECODE glGetUniform), $(D_INLINECODE glGetUniformLocation), $(D_INLINECODE glGetVertexAttrib), $(D_INLINECODE glGetVertexAttribPointerv), $(D_INLINECODE glIsEnabled)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glGetBooleanv glGetBooleanv;
    alias fn_glGetActiveAtomicCounterBufferiv = extern(System) void function(GLuint program, GLuint bufferIndex, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glGetActiveAtomicCounterBufferiv: man4/glGetActiveAtomicCounterBufferiv.xml
     + 
     + $(D_INLINECODE glGetActiveAtomicCounterBufferiv) retrieves information about the set of active atomic counter buffers for a program object. $(D_INLINECODE program) is the name of a program object for which the command $(D_INLINECODE glLinkProgram) has been issued in the past. It is not necessary for $(D_INLINECODE program) to have been linked successfully. The link may have failed because the number of active atomic counters exceeded the limits. $(D_INLINECODE bufferIndex) specifies the index of an active atomic counter buffer and must be in the range zero to the value of $(D_INLINECODE GL_ACTIVE_ATOMIC_COUNTER_BUFFERS) minus one. The value of $(D_INLINECODE GL_ACTIVE_ATOMIC_COUNTER_BUFFERS) for $(D_INLINECODE program) indicates the number of active atomic counter buffer and can be queried with $(D_INLINECODE glGetProgram). If no error occurs, the parameter(s) specified by $(D_INLINECODE pname) are returned in $(D_INLINECODE params). If an error is generated, the contents of $(D_INLINECODE params) are not modified. If $(D_INLINECODE pname) is $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER_BINDING), then the index of the counter buffer binding point associated with the active atomic counter buffer $(D_INLINECODE bufferIndex) for $(D_INLINECODE program) is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE), then the implementation-dependent minimum total buffer object size, in baseic machine units, required to hold all active atomic counters in the atomic counter binding point identified by $(D_INLINECODE bufferIndex) is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS), then the number of active atomic counters for the atomic counter buffer identified by $(D_INLINECODE bufferIndex) is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES), then a list of the active atomic counter indices for the atomic counter buffer identified by $(D_INLINECODE bufferIndex) is returned. The number of elements that will be written into $(D_INLINECODE params) is the value of $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS) for $(D_INLINECODE bufferIndex). If $(D_INLINECODE pname) is $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER), $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER), $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER), $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER), $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER), $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER) then a boolean value indicating whether the atomic counter buffer identified by $(D_INLINECODE bufferIndex) is referenced by the vertex, tessellation control, tessellation evaluation, geometry, fragment or compute processing stages of $(D_INLINECODE program), respectively, is returned.
     + 
     + $(D_INLINECODE glGetActiveAtomicCounterBufferiv) is available only if the GL version is 4.2 or higher. $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER) is available only of the GL version is 4.3 or higher.
     + 
     + Params:
     +     program     = The name of a program object from which to retrieve information.
     +     bufferIndex = Specifies index of an active atomic counter buffer.
     +     pname       = Specifies which parameter of the atomic counter buffer to retrieve.
     +     params      = Specifies the address of a variable into which to write the retrieved information.
     + 
     + Copyright:
     +     Copyright&copy; 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetProgram), $(D_INLINECODE glGetActiveSubroutineUniform), $(D_INLINECODE glGetActiveSubroutineUniformName), $(D_INLINECODE glGetUniformLocation)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P2)
    @OpenGL_Extension("GL_ARB_shader_atomic_counters")
    fn_glGetActiveAtomicCounterBufferiv glGetActiveAtomicCounterBufferiv;
    alias fn_glGetActiveAttrib = extern(System) void function(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLint* size, GLenum* type, GLchar* name) @system @nogc nothrow;

    /++
     + glGetActiveAttrib: man4/glGetActiveAttrib.xml
     + 
     + $(D_INLINECODE glGetActiveAttrib) returns information about an active attribute variable in the program object specified by $(D_INLINECODE program). The number of active attributes can be obtained by calling $(D_INLINECODE glGetProgram) with the value $(D_INLINECODE GL_ACTIVE_ATTRIBUTES). A value of 0 for $(D_INLINECODE index) selects the first active attribute variable. Permissible values for $(D_INLINECODE index) range from zero to the number of active attribute variables minus one. A vertex shader may use either built-in attribute variables, user-defined attribute variables, or both. Built-in attribute variables have a prefix of &quot;gl_&quot; and reference conventional OpenGL vertex attribtes (e.g., $(D_INLINECODE gl_Vertex), $(D_INLINECODE gl_Normal), etc., see the OpenGL Shading Language specification for a complete list.) User-defined attribute variables have arbitrary names and obtain their values through numbered generic vertex attributes. An attribute variable (either built-in or user-defined) is considered active if it is determined during the link operation that it may be accessed during program execution. Therefore, $(D_INLINECODE program) should have previously been the target of a call to $(D_INLINECODE glLinkProgram), but it is not necessary for it to have been linked successfully. The size of the character buffer required to store the longest attribute variable name in $(D_INLINECODE program) can be obtained by calling $(D_INLINECODE glGetProgram) with the value $(D_INLINECODE GL_ACTIVE_ATTRIBUTE_MAX_LENGTH). This value should be used to allocate a buffer of sufficient size to store the returned attribute name. The size of this character buffer is passed in $(D_INLINECODE bufSize), and a pointer to this character buffer is passed in $(D_INLINECODE name). $(D_INLINECODE glGetActiveAttrib) returns the name of the attribute variable indicated by $(D_INLINECODE index), storing it in the character buffer specified by $(D_INLINECODE name). The string returned will be null terminated. The actual number of characters written into this buffer is returned in $(D_INLINECODE length), and this count does not include the null termination character. If the length of the returned string is not required, a value of $(D_INLINECODE null
     + ) can be passed in the $(D_INLINECODE length) argument. The $(D_INLINECODE type) argument specifies a pointer to a variable into which the attribute variable's data type will be written. The symbolic constants $(D_INLINECODE GL_FLOAT), $(D_INLINECODE GL_FLOAT_VEC2), $(D_INLINECODE GL_FLOAT_VEC3), $(D_INLINECODE GL_FLOAT_VEC4), $(D_INLINECODE GL_FLOAT_MAT2), $(D_INLINECODE GL_FLOAT_MAT3), $(D_INLINECODE GL_FLOAT_MAT4), $(D_INLINECODE GL_FLOAT_MAT2x3), $(D_INLINECODE GL_FLOAT_MAT2x4), $(D_INLINECODE GL_FLOAT_MAT3x2), $(D_INLINECODE GL_FLOAT_MAT3x4), $(D_INLINECODE GL_FLOAT_MAT4x2), $(D_INLINECODE GL_FLOAT_MAT4x3), $(D_INLINECODE GL_INT), $(D_INLINECODE GL_INT_VEC2), $(D_INLINECODE GL_INT_VEC3), $(D_INLINECODE GL_INT_VEC4), $(D_INLINECODE GL_UNSIGNED_INT), $(D_INLINECODE GL_UNSIGNED_INT_VEC2), $(D_INLINECODE GL_UNSIGNED_INT_VEC3), $(D_INLINECODE GL_UNSIGNED_INT_VEC4), $(D_INLINECODE GL_DOUBLE), $(D_INLINECODE GL_DOUBLE_VEC2), $(D_INLINECODE GL_DOUBLE_VEC3), $(D_INLINECODE GL_DOUBLE_VEC4), $(D_INLINECODE GL_DOUBLE_MAT2), $(D_INLINECODE GL_DOUBLE_MAT3), $(D_INLINECODE GL_DOUBLE_MAT4), $(D_INLINECODE GL_DOUBLE_MAT2x3), $(D_INLINECODE GL_DOUBLE_MAT2x4), $(D_INLINECODE GL_DOUBLE_MAT3x2), $(D_INLINECODE GL_DOUBLE_MAT3x4), $(D_INLINECODE GL_DOUBLE_MAT4x2), or $(D_INLINECODE GL_DOUBLE_MAT4x3) may be returned. The $(D_INLINECODE size) argument will return the size of the attribute, in units of the type returned in $(D_INLINECODE type). The list of active attribute variables may include both built-in attribute variables (which begin with the prefix &quot;gl_&quot;) as well as user-defined attribute variable names. This function will return as much information as it can about the specified active attribute variable. If no information is available, $(D_INLINECODE length) will be 0, and $(D_INLINECODE name) will be an empty string. This situation could occur if this function is called after a link operation that failed. If an error occurs, the return values $(D_INLINECODE length), $(D_INLINECODE size), $(D_INLINECODE type), and $(D_INLINECODE name) will be unmodified.
     + 
     + Params:
     +     program = Specifies the program object to be queried.
     +     index   = Specifies the index of the attribute variable to be queried.
     +     bufSize = Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by $(D_INLINECODE name).
     +     length  = Returns the number of characters actually written by OpenGL in the string indicated by $(D_INLINECODE name) (excluding the null terminator) if a value other than $(D_INLINECODE null) is passed.
     +     size    = Returns the size of the attribute variable.
     +     type    = Returns the data type of the attribute variable.
     +     name    = Returns a null terminated string containing the name of the attribute variable.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindAttribLocation), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glVertexAttrib), $(D_INLINECODE glVertexAttribPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glGetActiveAttrib glGetActiveAttrib;
    alias fn_glGetActiveSubroutineName = extern(System) void function(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei* length, GLchar* name) @system @nogc nothrow;

    /++
     + glGetActiveSubroutineName: man4/glGetActiveSubroutineName.xml
     + 
     + $(D_INLINECODE glGetActiveSubroutineName) queries the name of an active shader subroutine uniform from the program object given in $(D_INLINECODE program). $(D_INLINECODE index) specifies the index of the shader subroutine uniform within the shader stage given by $(D_INLINECODE stage), and must between zero and the value of $(D_INLINECODE GL_ACTIVE_SUBROUTINES) minus one for the shader stage. The name of the selected subroutine is returned as a null-terminated string in $(D_INLINECODE name). The actual number of characters written into $(D_INLINECODE name), not including the null-terminator, is is returned in $(D_INLINECODE length). If $(D_INLINECODE length) is $(D_INLINECODE null
     + ), no length is returned. The maximum number of characters that may be written into $(D_INLINECODE name), including the null-terminator, is given in $(D_INLINECODE bufsize).
     + 
     + Params:
     +     program    = Specifies the name of the program containing the subroutine.
     +     shadertype = Specifies the shader stage from which to query the subroutine name.
     +     index      = Specifies the index of the shader subroutine uniform.
     +     bufsize    = Specifies the size of the buffer whose address is given in $(D_INLINECODE name).
     +     length     = Specifies the address of a variable which is to receive the length of the shader subroutine uniform name.
     +     name       = Specifies the address of an array into which the name of the shader subroutine uniform will be written.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetSubroutineIndex), $(D_INLINECODE glGetActiveSubroutineUniform), $(D_INLINECODE glGetProgramStage)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_shader_subroutine")
    fn_glGetActiveSubroutineName glGetActiveSubroutineName;
    alias fn_glGetActiveSubroutineUniformiv = extern(System) void function(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint* values) @system @nogc nothrow;

    /++
     + glGetActiveSubroutineUniform: man4/glGetActiveSubroutineUniform.xml
     + 
     + $(D_INLINECODE glGetActiveSubroutineUniform) queries a parameter of an active shader subroutine uniform. $(D_INLINECODE program) contains the name of the program containing the uniform. $(D_INLINECODE shadertype) specifies the stage which which the uniform location, given by $(D_INLINECODE index), is valid. $(D_INLINECODE index) must be between zero and the value of $(D_INLINECODE GL_ACTIVE_SUBROUTINE_UNIFORMS) minus one for the shader stage. If $(D_INLINECODE pname) is $(D_INLINECODE GL_NUM_COMPATIBLE_SUBROUTINES), a single integer indicating the number of subroutines that can be assigned to the uniform is returned in $(D_INLINECODE values). If $(D_INLINECODE pname) is $(D_INLINECODE GL_COMPATIBLE_SUBROUTINES), an array of integers is returned in $(D_INLINECODE values), with each integer specifying the index of an active subroutine that can be assigned to the selected subroutine uniform. The number of integers returned is the same as the value returned for $(D_INLINECODE GL_NUM_COMPATIBLE_SUBROUTINES). If $(D_INLINECODE pname) is $(D_INLINECODE GL_UNIFORM_SIZE), a single integer is returned in $(D_INLINECODE values). If the selected subroutine uniform is an array, the  declared size of the array is returned; otherwise, one is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_UNIFORM_NAME_LENGTH), a single integer specifying the length of the subroutine uniform name (including the terminating null character) is returned in $(D_INLINECODE values).
     + 
     + Params:
     +     program    = Specifies the name of the program containing the subroutine.
     +     shadertype = Specifies the shader stage from which to query for the subroutine parameter. $(D_INLINECODE shadertype) must be one of $(D_INLINECODE GL_VERTEX_SHADER), $(D_INLINECODE GL_TESS_CONTROL_SHADER), $(D_INLINECODE GL_TESS_EVALUATION_SHADER), $(D_INLINECODE GL_GEOMETRY_SHADER) or $(D_INLINECODE GL_FRAGMENT_SHADER).
     +     index      = Specifies the index of the shader subroutine uniform.
     +     pname      = Specifies the parameter of the shader subroutine uniform to query. $(D_INLINECODE pname) must be $(D_INLINECODE GL_NUM_COMPATIBLE_SUBROUTINES), $(D_INLINECODE GL_COMPATIBLE_SUBROUTINES), $(D_INLINECODE GL_UNIFORM_SIZE) or $(D_INLINECODE GL_UNIFORM_NAME_LENGTH).
     +     values     = Specifies the address of a into which the queried value or values will be placed.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetSubroutineIndex), $(D_INLINECODE glGetActiveSubroutineUniformName), $(D_INLINECODE glGetProgramStage)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_shader_subroutine")
    fn_glGetActiveSubroutineUniformiv glGetActiveSubroutineUniformiv;
    alias fn_glGetActiveSubroutineUniformName = extern(System) void function(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei* length, GLchar* name) @system @nogc nothrow;

    /++
     + glGetActiveSubroutineUniformName: man4/glGetActiveSubroutineUniformName.xml
     + 
     + $(D_INLINECODE glGetActiveSubroutineUniformName) retrieves the name of an active shader subroutine uniform. $(D_INLINECODE program) contains the name of the program containing the uniform. $(D_INLINECODE shadertype) specifies the stage for which which the uniform location, given by $(D_INLINECODE index), is valid. $(D_INLINECODE index) must be between zero and the value of $(D_INLINECODE GL_ACTIVE_SUBROUTINE_UNIFORMS) minus one for the shader stage. The uniform name is returned as a null-terminated string in $(D_INLINECODE name). The actual number of characters written into $(D_INLINECODE name), excluding the null terminator is returned in $(D_INLINECODE length). If $(D_INLINECODE length) is $(D_INLINECODE null
     + ), no length is returned. The maximum number of characters that may be written into $(D_INLINECODE name), including the null terminator, is specified by $(D_INLINECODE bufsize). The length of the longest subroutine uniform name in $(D_INLINECODE program) and $(D_INLINECODE shadertype) is given by the value of $(D_INLINECODE GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH), which can be queried with $(D_INLINECODE glGetProgramStage).
     + 
     + Params:
     +     program    = Specifies the name of the program containing the subroutine.
     +     shadertype = Specifies the shader stage from which to query for the subroutine parameter. $(D_INLINECODE shadertype) must be one of $(D_INLINECODE GL_VERTEX_SHADER), $(D_INLINECODE GL_TESS_CONTROL_SHADER), $(D_INLINECODE GL_TESS_EVALUATION_SHADER), $(D_INLINECODE GL_GEOMETRY_SHADER) or $(D_INLINECODE GL_FRAGMENT_SHADER).
     +     index      = Specifies the index of the shader subroutine uniform.
     +     bufsize    = Specifies the size of the buffer whose address is given in $(D_INLINECODE name).
     +     length     = Specifies the address of a variable into which is written the number of characters copied into $(D_INLINECODE name).
     +     name       = Specifies the address of a buffer that will receive the name of the specified shader subroutine uniform.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetSubroutineIndex), $(D_INLINECODE glGetActiveSubroutineUniform), $(D_INLINECODE glGetProgramStage)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_shader_subroutine")
    fn_glGetActiveSubroutineUniformName glGetActiveSubroutineUniformName;
    alias fn_glGetActiveUniform = extern(System) void function(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLint* size, GLenum* type, GLchar* name) @system @nogc nothrow;

    /++
     + glGetActiveUniform: man4/glGetActiveUniform.xml
     + 
     + $(D_INLINECODE glGetActiveUniform) returns information about an active uniform variable in the program object specified by $(D_INLINECODE program). The number of active uniform variables can be obtained by calling $(D_INLINECODE glGetProgram) with the value $(D_INLINECODE GL_ACTIVE_UNIFORMS). A value of 0 for $(D_INLINECODE index) selects the first active uniform variable. Permissible values for $(D_INLINECODE index) range from zero to the number of active uniform variables minus one. Shaders may use either built-in uniform variables, user-defined uniform variables, or both. Built-in uniform variables have a prefix of &quot;gl_&quot; and reference existing OpenGL state or values derived from such state (e.g., $(D_INLINECODE gl_DepthRangeParameters), see the OpenGL Shading Language specification for a complete list.) User-defined uniform variables have arbitrary names and obtain their values from the application through calls to $(D_INLINECODE glUniform). A uniform variable (either built-in or user-defined) is considered active if it is determined during the link operation that it may be accessed during program execution. Therefore, $(D_INLINECODE program) should have previously been the target of a call to $(D_INLINECODE glLinkProgram), but it is not necessary for it to have been linked successfully. The size of the character buffer required to store the longest uniform variable name in $(D_INLINECODE program) can be obtained by calling $(D_INLINECODE glGetProgram) with the value $(D_INLINECODE GL_ACTIVE_UNIFORM_MAX_LENGTH). This value should be used to allocate a buffer of sufficient size to store the returned uniform variable name. The size of this character buffer is passed in $(D_INLINECODE bufSize), and a pointer to this character buffer is passed in $(D_INLINECODE name.) $(D_INLINECODE glGetActiveUniform) returns the name of the uniform variable indicated by $(D_INLINECODE index), storing it in the character buffer specified by $(D_INLINECODE name). The string returned will be null terminated. The actual number of characters written into this buffer is returned in $(D_INLINECODE length), and this count does not include the null termination character. If the length of the returned string is not required, a value of $(D_INLINECODE null
     + ) can be passed in the $(D_INLINECODE length) argument. The $(D_INLINECODE type) argument will return a pointer to the uniform variable's data type. The symbolic constants returned for uniform types are shown in the table below. $(B Returned Symbolic Contant) $(B Shader Uniform Type) $(D_INLINECODE GL_FLOAT) $(D_INLINECODE float) $(D_INLINECODE GL_FLOAT_VEC2) $(D_INLINECODE vec2) $(D_INLINECODE GL_FLOAT_VEC3) $(D_INLINECODE vec3) $(D_INLINECODE GL_FLOAT_VEC4) $(D_INLINECODE vec4) $(D_INLINECODE GL_DOUBLE) $(D_INLINECODE double) $(D_INLINECODE GL_DOUBLE_VEC2) $(D_INLINECODE dvec2) $(D_INLINECODE GL_DOUBLE_VEC3) $(D_INLINECODE dvec3) $(D_INLINECODE GL_DOUBLE_VEC4) $(D_INLINECODE dvec4) $(D_INLINECODE GL_INT) $(D_INLINECODE int) $(D_INLINECODE GL_INT_VEC2) $(D_INLINECODE ivec2) $(D_INLINECODE GL_INT_VEC3) $(D_INLINECODE ivec3) $(D_INLINECODE GL_INT_VEC4) $(D_INLINECODE ivec4) $(D_INLINECODE GL_UNSIGNED_INT) $(D_INLINECODE unsigned int) $(D_INLINECODE GL_UNSIGNED_INT_VEC2) $(D_INLINECODE uvec2) $(D_INLINECODE GL_UNSIGNED_INT_VEC3) $(D_INLINECODE uvec3) $(D_INLINECODE GL_UNSIGNED_INT_VEC4) $(D_INLINECODE uvec4) $(D_INLINECODE GL_BOOL) $(D_INLINECODE bool) $(D_INLINECODE GL_BOOL_VEC2) $(D_INLINECODE bvec2) $(D_INLINECODE GL_BOOL_VEC3) $(D_INLINECODE bvec3) $(D_INLINECODE GL_BOOL_VEC4) $(D_INLINECODE bvec4) $(D_INLINECODE GL_FLOAT_MAT2) $(D_INLINECODE mat2) $(D_INLINECODE GL_FLOAT_MAT3) $(D_INLINECODE mat3) $(D_INLINECODE GL_FLOAT_MAT4) $(D_INLINECODE mat4) $(D_INLINECODE GL_FLOAT_MAT2x3) $(D_INLINECODE mat2x3) $(D_INLINECODE GL_FLOAT_MAT2x4) $(D_INLINECODE mat2x4) $(D_INLINECODE GL_FLOAT_MAT3x2) $(D_INLINECODE mat3x2) $(D_INLINECODE GL_FLOAT_MAT3x4) $(D_INLINECODE mat3x4) $(D_INLINECODE GL_FLOAT_MAT4x2) $(D_INLINECODE mat4x2) $(D_INLINECODE GL_FLOAT_MAT4x3) $(D_INLINECODE mat4x3) $(D_INLINECODE GL_DOUBLE_MAT2) $(D_INLINECODE dmat2) $(D_INLINECODE GL_DOUBLE_MAT3) $(D_INLINECODE dmat3) $(D_INLINECODE GL_DOUBLE_MAT4) $(D_INLINECODE dmat4) $(D_INLINECODE GL_DOUBLE_MAT2x3) $(D_INLINECODE dmat2x3) $(D_INLINECODE GL_DOUBLE_MAT2x4) $(D_INLINECODE dmat2x4) $(D_INLINECODE GL_DOUBLE_MAT3x2) $(D_INLINECODE dmat3x2) $(D_INLINECODE GL_DOUBLE_MAT3x4) $(D_INLINECODE dmat3x4) $(D_INLINECODE GL_DOUBLE_MAT4x2) $(D_INLINECODE dmat4x2) $(D_INLINECODE GL_DOUBLE_MAT4x3) $(D_INLINECODE dmat4x3) $(D_INLINECODE GL_SAMPLER_1D) $(D_INLINECODE sampler1D) $(D_INLINECODE GL_SAMPLER_2D) $(D_INLINECODE sampler2D) $(D_INLINECODE GL_SAMPLER_3D) $(D_INLINECODE sampler3D) $(D_INLINECODE GL_SAMPLER_CUBE) $(D_INLINECODE samplerCube) $(D_INLINECODE GL_SAMPLER_1D_SHADOW) $(D_INLINECODE sampler1DShadow) $(D_INLINECODE GL_SAMPLER_2D_SHADOW) $(D_INLINECODE sampler2DShadow) $(D_INLINECODE GL_SAMPLER_1D_ARRAY) $(D_INLINECODE sampler1DArray) $(D_INLINECODE GL_SAMPLER_2D_ARRAY) $(D_INLINECODE sampler2DArray) $(D_INLINECODE GL_SAMPLER_1D_ARRAY_SHADOW) $(D_INLINECODE sampler1DArrayShadow) $(D_INLINECODE GL_SAMPLER_2D_ARRAY_SHADOW) $(D_INLINECODE sampler2DArrayShadow) $(D_INLINECODE GL_SAMPLER_2D_MULTISAMPLE) $(D_INLINECODE sampler2DMS) $(D_INLINECODE GL_SAMPLER_2D_MULTISAMPLE_ARRAY) $(D_INLINECODE sampler2DMSArray) $(D_INLINECODE GL_SAMPLER_CUBE_SHADOW) $(D_INLINECODE samplerCubeShadow) $(D_INLINECODE GL_SAMPLER_BUFFER) $(D_INLINECODE samplerBuffer) $(D_INLINECODE GL_SAMPLER_2D_RECT) $(D_INLINECODE sampler2DRect) $(D_INLINECODE GL_SAMPLER_2D_RECT_SHADOW) $(D_INLINECODE sampler2DRectShadow) $(D_INLINECODE GL_INT_SAMPLER_1D) $(D_INLINECODE isampler1D) $(D_INLINECODE GL_INT_SAMPLER_2D) $(D_INLINECODE isampler2D) $(D_INLINECODE GL_INT_SAMPLER_3D) $(D_INLINECODE isampler3D) $(D_INLINECODE GL_INT_SAMPLER_CUBE) $(D_INLINECODE isamplerCube) $(D_INLINECODE GL_INT_SAMPLER_1D_ARRAY) $(D_INLINECODE isampler1DArray) $(D_INLINECODE GL_INT_SAMPLER_2D_ARRAY) $(D_INLINECODE isampler2DArray) $(D_INLINECODE GL_INT_SAMPLER_2D_MULTISAMPLE) $(D_INLINECODE isampler2DMS) $(D_INLINECODE GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY) $(D_INLINECODE isampler2DMSArray) $(D_INLINECODE GL_INT_SAMPLER_BUFFER) $(D_INLINECODE isamplerBuffer) $(D_INLINECODE GL_INT_SAMPLER_2D_RECT) $(D_INLINECODE isampler2DRect) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_1D) $(D_INLINECODE usampler1D) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_2D) $(D_INLINECODE usampler2D) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_3D) $(D_INLINECODE usampler3D) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_CUBE) $(D_INLINECODE usamplerCube) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_1D_ARRAY) $(D_INLINECODE usampler2DArray) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_2D_ARRAY) $(D_INLINECODE usampler2DArray) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE) $(D_INLINECODE usampler2DMS) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY) $(D_INLINECODE usampler2DMSArray) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_BUFFER) $(D_INLINECODE usamplerBuffer) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_2D_RECT) $(D_INLINECODE usampler2DRect) $(D_INLINECODE GL_IMAGE_1D) $(D_INLINECODE image1D) $(D_INLINECODE GL_IMAGE_2D) $(D_INLINECODE image2D) $(D_INLINECODE GL_IMAGE_3D) $(D_INLINECODE image3D) $(D_INLINECODE GL_IMAGE_2D_RECT) $(D_INLINECODE image2DRect) $(D_INLINECODE GL_IMAGE_CUBE) $(D_INLINECODE imageCube) $(D_INLINECODE GL_IMAGE_BUFFER) $(D_INLINECODE imageBuffer) $(D_INLINECODE GL_IMAGE_1D_ARRAY) $(D_INLINECODE image1DArray) $(D_INLINECODE GL_IMAGE_2D_ARRAY) $(D_INLINECODE image2DArray) $(D_INLINECODE GL_IMAGE_2D_MULTISAMPLE) $(D_INLINECODE image2DMS) $(D_INLINECODE GL_IMAGE_2D_MULTISAMPLE_ARRAY) $(D_INLINECODE image2DMSArray) $(D_INLINECODE GL_INT_IMAGE_1D) $(D_INLINECODE iimage1D) $(D_INLINECODE GL_INT_IMAGE_2D) $(D_INLINECODE iimage2D) $(D_INLINECODE GL_INT_IMAGE_3D) $(D_INLINECODE iimage3D) $(D_INLINECODE GL_INT_IMAGE_2D_RECT) $(D_INLINECODE iimage2DRect) $(D_INLINECODE GL_INT_IMAGE_CUBE) $(D_INLINECODE iimageCube) $(D_INLINECODE GL_INT_IMAGE_BUFFER) $(D_INLINECODE iimageBuffer) $(D_INLINECODE GL_INT_IMAGE_1D_ARRAY) $(D_INLINECODE iimage1DArray) $(D_INLINECODE GL_INT_IMAGE_2D_ARRAY) $(D_INLINECODE iimage2DArray) $(D_INLINECODE GL_INT_IMAGE_2D_MULTISAMPLE) $(D_INLINECODE iimage2DMS) $(D_INLINECODE GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY) $(D_INLINECODE iimage2DMSArray) $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_1D) $(D_INLINECODE uimage1D) $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_2D) $(D_INLINECODE uimage2D) $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_3D) $(D_INLINECODE uimage3D) $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_2D_RECT) $(D_INLINECODE uimage2DRect) $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_CUBE) $(D_INLINECODE uimageCube) $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_BUFFER) $(D_INLINECODE uimageBuffer) $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_1D_ARRAY) $(D_INLINECODE uimage1DArray) $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_2D_ARRAY) $(D_INLINECODE uimage2DArray) $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE) $(D_INLINECODE uimage2DMS) $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY) $(D_INLINECODE uimage2DMSArray) $(D_INLINECODE GL_UNSIGNED_INT_ATOMIC_COUNTER) $(D_INLINECODE atomic_uint) If one or more elements of an array are active, the name of the array is returned in $(D_INLINECODE name), the type is returned in $(D_INLINECODE type), and the $(D_INLINECODE size) parameter returns the highest array element index used, plus one, as determined by the compiler and/or linker. Only one active uniform variable will be reported for a uniform array. Uniform variables that are declared as structures or arrays of structures will not be returned directly by this function. Instead, each of these uniform variables will be reduced to its fundamental components containing the &quot;.&quot; and &quot;[]&quot; operators such that each of the names is valid as an argument to $(D_INLINECODE glGetUniformLocation). Each of these reduced uniform variables is counted as one active uniform variable and is assigned an index. A valid name cannot be a structure, an array of structures, or a subcomponent of a vector or matrix. The size of the uniform variable will be returned in $(D_INLINECODE size). Uniform variables other than arrays will have a size of 1. Structures and arrays of structures will be reduced as described earlier, such that each of the names returned will be a data type in the earlier list. If this reduction results in an array, the size returned will be as described for uniform arrays; otherwise, the size returned will be 1. The list of active uniform variables may include both built-in uniform variables (which begin with the prefix &quot;gl_&quot;) as well as user-defined uniform variable names. This function will return as much information as it can about the specified active uniform variable. If no information is available, $(D_INLINECODE length) will be 0, and $(D_INLINECODE name) will be an empty string. This situation could occur if this function is called after a link operation that failed. If an error occurs, the return values $(D_INLINECODE length), $(D_INLINECODE size), $(D_INLINECODE type), and $(D_INLINECODE name) will be unmodified.
     + 
     + The double types, $(D_INLINECODE GL_DOUBLE), $(D_INLINECODE GL_DOUBLE_VEC2), $(D_INLINECODE GL_DOUBLE_VEC3), $(D_INLINECODE GL_DOUBLE_VEC4), $(D_INLINECODE GL_DOUBLE_MAT2), $(D_INLINECODE GL_DOUBLE_MAT3), $(D_INLINECODE GL_DOUBLE_MAT4), $(D_INLINECODE GL_DOUBLE_MAT2x3), $(D_INLINECODE GL_DOUBLE_MAT2x4), $(D_INLINECODE GL_DOUBLE_MAT3x2), $(D_INLINECODE GL_DOUBLE_MAT3x4), $(D_INLINECODE GL_DOUBLE_MAT4x2), and $(D_INLINECODE GL_DOUBLE_MAT4x3) are only available if the GL version is 4.1 or higher. The image types, $(D_INLINECODE GL_IMAGE_1D), $(D_INLINECODE GL_IMAGE_2D), $(D_INLINECODE GL_IMAGE_3D), $(D_INLINECODE GL_IMAGE_2D_RECT), $(D_INLINECODE GL_IMAGE_CUBE), $(D_INLINECODE GL_IMAGE_BUFFER), $(D_INLINECODE GL_IMAGE_1D_ARRAY), $(D_INLINECODE GL_IMAGE_2D_ARRAY), $(D_INLINECODE GL_IMAGE_2D_MULTISAMPLE), $(D_INLINECODE GL_IMAGE_2D_MULTISAMPLE_ARRAY), $(D_INLINECODE GL_INT_IMAGE_1D), $(D_INLINECODE GL_INT_IMAGE_2D), $(D_INLINECODE GL_INT_IMAGE_3D), $(D_INLINECODE GL_INT_IMAGE_2D_RECT), $(D_INLINECODE GL_INT_IMAGE_CUBE), $(D_INLINECODE GL_INT_IMAGE_BUFFER), $(D_INLINECODE GL_INT_IMAGE_1D_ARRAY), $(D_INLINECODE GL_INT_IMAGE_2D_ARRAY), $(D_INLINECODE GL_INT_IMAGE_2D_MULTISAMPLE), $(D_INLINECODE GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY), $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_1D), $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_2D), $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_3D), $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_2D_RECT), $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_CUBE), $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_BUFFER), $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_1D_ARRAY), $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_2D_ARRAY), $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE), $(D_INLINECODE GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY), and the atomic counter type, $(D_INLINECODE GL_UNSIGNED_INT_ATOMIC_COUNTER) are only available if the GL version is 4.2 or higher.
     + 
     + Params:
     +     program = Specifies the program object to be queried.
     +     index   = Specifies the index of the uniform variable to be queried.
     +     bufSize = Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by $(D_INLINECODE name).
     +     length  = Returns the number of characters actually written by OpenGL in the string indicated by $(D_INLINECODE name) (excluding the null terminator) if a value other than $(D_INLINECODE null) is passed.
     +     size    = Returns the size of the uniform variable.
     +     type    = Returns the data type of the uniform variable.
     +     name    = Returns a null terminated string containing the name of the uniform variable.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetUniform), $(D_INLINECODE glGetUniformLocation), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glUniform), $(D_INLINECODE glUseProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glGetActiveUniform glGetActiveUniform;
    alias fn_glGetActiveUniformBlockiv = extern(System) void function(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glGetActiveUniformBlock: man4/glGetActiveUniformBlock.xml
     + 
     + $(D_INLINECODE glGetActiveUniformBlockiv) retrieves information about an active uniform block within $(D_INLINECODE program). $(D_INLINECODE program) must be the name of a program object for which the command $(D_INLINECODE glLinkProgram) must have been called in the past, although it is not required that $(D_INLINECODE glLinkProgram) must have succeeded. The link could have failed because the number of active uniforms exceeded the limit. $(D_INLINECODE uniformBlockIndex) is an active uniform block index of $(D_INLINECODE program), and must be less than the value of $(D_INLINECODE GL_ACTIVE_UNIFORM_BLOCKS). Upon success, the uniform block parameter(s) specified by $(D_INLINECODE pname) are returned in $(D_INLINECODE params). If an error occurs, nothing will be written to $(D_INLINECODE params). If $(D_INLINECODE pname) is $(D_INLINECODE GL_UNIFORM_BLOCK_BINDING), then the index of the uniform buffer binding point last selected by the uniform block specified by $(D_INLINECODE uniformBlockIndex) for $(D_INLINECODE program) is returned. If no uniform block has been previously specified, zero is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_UNIFORM_BLOCK_DATA_SIZE), then the implementation-dependent minimum total buffer object size, in basic machine units, required to hold all active uniforms in the uniform block identified by $(D_INLINECODE uniformBlockIndex) is returned. It is neither guaranteed nor expected that a given implementation will arrange uniform values as tightly packed in a buffer object. The exception to this is the, which guarantees specific packing behavior and does not require the application to query for offsets and strides. In this case the minimum size may still be queried, even though it is determined in advance based only on the uniform block declaration. If $(D_INLINECODE pname) is $(D_INLINECODE GL_UNIFORM_BLOCK_NAME_LENGTH), then the total length (including the nul terminator) of the name of the uniform block identified by $(D_INLINECODE uniformBlockIndex) is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS), then the number of active uniforms in the uniform block identified by $(D_INLINECODE uniformBlockIndex) is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES), then a list of the active uniform indices for the uniform block identified by $(D_INLINECODE uniformBlockIndex) is returned. The number of elements that will be written to $(D_INLINECODE params) is the value of $(D_INLINECODE GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS) for $(D_INLINECODE uniformBlockIndex). If $(D_INLINECODE pname) is $(D_INLINECODE GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER), $(D_INLINECODE GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER), $(D_INLINECODE GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER), $(D_INLINECODE GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER), $(D_INLINECODE GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER), or $(D_INLINECODE GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER) then a boolean value indicating whether the uniform block identified by $(D_INLINECODE uniformBlockIndex) is referenced by the vertex, tessellation control, tessellation evaluation, geometry, fragment or compute programming stages of program, respectively, is returned.
     + 
     + $(D_INLINECODE glGetActiveUniformBlockiv) is available only if the GL version is 3.1 or greater. $(D_INLINECODE GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER) is accepted only if the GL version is 4.3 or greater.
     + 
     + Params:
     +     program           = Specifies the name of a program containing the uniform block.
     +     uniformBlockIndex = Specifies the index of the uniform block within $(D_INLINECODE program).
     +     pname             = Specifies the name of the parameter to query.
     +     params            = Specifies the address of a variable to receive the result of the query.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetActiveUniformBlockName), $(D_INLINECODE glGetUniformBlockIndex), $(D_INLINECODE glLinkProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P1)
    @OpenGL_Extension("GL_ARB_uniform_buffer_object")
    fn_glGetActiveUniformBlockiv glGetActiveUniformBlockiv;
    alias fn_glGetActiveUniformBlockName = extern(System) void function(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformBlockName) @system @nogc nothrow;

    /++
     + glGetActiveUniformBlockName: man4/glGetActiveUniformBlockName.xml
     + 
     + $(D_INLINECODE glGetActiveUniformBlockName) retrieves the name of the active uniform block at $(D_INLINECODE uniformBlockIndex) within $(D_INLINECODE program). $(D_INLINECODE program) must be the name of a program object for which the command $(D_INLINECODE glLinkProgram) must have been called in the past, although it is not required that $(D_INLINECODE glLinkProgram) must have succeeded. The link could have failed because the number of active uniforms exceeded the limit. $(D_INLINECODE uniformBlockIndex) is an active uniform block index of $(D_INLINECODE program), and must be less than the value of $(D_INLINECODE GL_ACTIVE_UNIFORM_BLOCKS). Upon success, the name of the uniform block identified by $(D_INLINECODE unifomBlockIndex) is returned into $(D_INLINECODE uniformBlockName). The name is nul-terminated. The actual number of characters written into $(D_INLINECODE uniformBlockName), excluding the nul terminator, is returned in $(D_INLINECODE length). If $(D_INLINECODE length) is $(D_INLINECODE null
     + ), no length is returned. $(D_INLINECODE bufSize) contains the maximum number of characters (including the nul terminator) that will be written into $(D_INLINECODE uniformBlockName). If an error occurs, nothing will be written to $(D_INLINECODE uniformBlockName) or $(D_INLINECODE length).
     + 
     + $(D_INLINECODE glGetActiveUniformBlockName) is available only if the GL version is 3.1 or greater.
     + 
     + Params:
     +     program           = Specifies the name of a program containing the uniform block.
     +     uniformBlockIndex = Specifies the index of the uniform block within $(D_INLINECODE program).
     +     bufSize           = Specifies the size of the buffer addressed by $(D_INLINECODE uniformBlockName).
     +     length            = Specifies the address of a variable to receive the number of characters that were written to $(D_INLINECODE uniformBlockName).
     +     uniformBlockName  = Specifies the address an array of characters to receive the name of the uniform block at $(D_INLINECODE uniformBlockIndex).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetActiveUniformBlock), $(D_INLINECODE glGetUniformBlockIndex)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P1)
    @OpenGL_Extension("GL_ARB_uniform_buffer_object")
    fn_glGetActiveUniformBlockName glGetActiveUniformBlockName;
    alias fn_glGetActiveUniformName = extern(System) void function(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformName) @system @nogc nothrow;

    /++
     + glGetActiveUniformName: man4/glGetActiveUniformName.xml
     + 
     + $(D_INLINECODE glGetActiveUniformName) returns the name of the active uniform at $(D_INLINECODE uniformIndex) within $(D_INLINECODE program). If $(D_INLINECODE uniformName) is not $(D_INLINECODE null
     + ), up to $(D_INLINECODE bufSize) characters (including a nul-terminator) will be written into the array whose address is specified by $(D_INLINECODE uniformName). If $(D_INLINECODE length) is not $(D_INLINECODE null
     + ), the number of characters that were (or would have been) written into $(D_INLINECODE uniformName) (not including the nul-terminator) will be placed in the variable whose address is specified in $(D_INLINECODE length). If $(D_INLINECODE length) is $(D_INLINECODE null
     + ), no length is returned. The length of the longest uniform name in $(D_INLINECODE program) is given by the value of $(D_INLINECODE GL_ACTIVE_UNIFORM_MAX_LENGTH), which can be queried with $(D_INLINECODE glGetProgram). If $(D_INLINECODE glGetActiveUniformName) is not successful, nothing is written to $(D_INLINECODE length) or $(D_INLINECODE uniformName). $(D_INLINECODE program) must be the name of a program for which the command $(D_INLINECODE glLinkProgram) has been issued in the past. It is not necessary for $(D_INLINECODE program) to have been linked successfully. The link could have failed because the number of active uniforms exceeded the limit. $(D_INLINECODE uniformIndex) must be an active uniform index of the program $(D_INLINECODE program), in the range zero to the value of $(D_INLINECODE GL_ACTIVE_UNIFORMS) minus one. The value of $(D_INLINECODE GL_ACTIVE_UNIFORMS) can be queried with $(D_INLINECODE glGetProgram).
     + 
     + Params:
     +     program      = Specifies the program containing the active uniform index $(D_INLINECODE uniformIndex).
     +     uniformIndex = Specifies the index of the active uniform whose name to query.
     +     bufSize      = Specifies the size of the buffer, in units of $(D_INLINECODE GLchar), of the buffer whose address is specified in $(D_INLINECODE uniformName).
     +     length       = Specifies the address of a variable that will receive the number of characters that were or would have been written to the buffer addressed by $(D_INLINECODE uniformName).
     +     uniformName  = Specifies the address of a buffer into which the GL will place the name of the active uniform at $(D_INLINECODE uniformIndex) within $(D_INLINECODE program).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetActiveUniform), $(D_INLINECODE glGetUniformIndices), $(D_INLINECODE glGetProgram), $(D_INLINECODE glLinkProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P1)
    @OpenGL_Extension("GL_ARB_uniform_buffer_object")
    fn_glGetActiveUniformName glGetActiveUniformName;
    alias fn_glGetActiveUniformsiv = extern(System) void function(GLuint program, GLsizei uniformCount, const( GLuint*) uniformIndices, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glGetActiveUniformsiv: man4/glGetActiveUniformsiv.xml
     + 
     + $(D_INLINECODE glGetActiveUniformsiv) queries the value of the parameter named $(D_INLINECODE pname) for each of the uniforms within $(D_INLINECODE program) whose indices are specified in the array of $(D_INLINECODE uniformCount) unsigned integers $(D_INLINECODE uniformIndices). Upon success, the value of the parameter for each uniform is written into the corresponding entry in the array whose address is given in $(D_INLINECODE params). If an error is generated, nothing is written into $(D_INLINECODE params). If $(D_INLINECODE pname) is $(D_INLINECODE GL_UNIFORM_TYPE), then an array identifying the types of uniforms specified by the corresponding array of $(D_INLINECODE uniformIndices) is returned. The returned types can be any of the values from the following table: $(B Returned Symbolic Contant) $(B Shader Uniform Type) $(D_INLINECODE GL_FLOAT) $(D_INLINECODE float) $(D_INLINECODE GL_FLOAT_VEC2) $(D_INLINECODE vec2) $(D_INLINECODE GL_FLOAT_VEC3) $(D_INLINECODE vec3) $(D_INLINECODE GL_FLOAT_VEC4) $(D_INLINECODE vec4) $(D_INLINECODE GL_DOUBLE) $(D_INLINECODE double) $(D_INLINECODE GL_DOUBLE_VEC2) $(D_INLINECODE dvec2) $(D_INLINECODE GL_DOUBLE_VEC3) $(D_INLINECODE dvec3) $(D_INLINECODE GL_DOUBLE_VEC4) $(D_INLINECODE dvec4) $(D_INLINECODE GL_INT) $(D_INLINECODE int) $(D_INLINECODE GL_INT_VEC2) $(D_INLINECODE ivec2) $(D_INLINECODE GL_INT_VEC3) $(D_INLINECODE ivec3) $(D_INLINECODE GL_INT_VEC4) $(D_INLINECODE ivec4) $(D_INLINECODE GL_UNSIGNED_INT) $(D_INLINECODE unsigned int) $(D_INLINECODE GL_UNSIGNED_INT_VEC2) $(D_INLINECODE uvec2) $(D_INLINECODE GL_UNSIGNED_INT_VEC3) $(D_INLINECODE uvec3) $(D_INLINECODE GL_UNSIGNED_INT_VEC4) $(D_INLINECODE uvec4) $(D_INLINECODE GL_BOOL) $(D_INLINECODE bool) $(D_INLINECODE GL_BOOL_VEC2) $(D_INLINECODE bvec2) $(D_INLINECODE GL_BOOL_VEC3) $(D_INLINECODE bvec3) $(D_INLINECODE GL_BOOL_VEC4) $(D_INLINECODE bvec4) $(D_INLINECODE GL_FLOAT_MAT2) $(D_INLINECODE mat2) $(D_INLINECODE GL_FLOAT_MAT3) $(D_INLINECODE mat3) $(D_INLINECODE GL_FLOAT_MAT4) $(D_INLINECODE mat4) $(D_INLINECODE GL_FLOAT_MAT2x3) $(D_INLINECODE mat2x3) $(D_INLINECODE GL_FLOAT_MAT2x4) $(D_INLINECODE mat2x4) $(D_INLINECODE GL_FLOAT_MAT3x2) $(D_INLINECODE mat3x2) $(D_INLINECODE GL_FLOAT_MAT3x4) $(D_INLINECODE mat3x4) $(D_INLINECODE GL_FLOAT_MAT4x2) $(D_INLINECODE mat4x2) $(D_INLINECODE GL_FLOAT_MAT4x3) $(D_INLINECODE mat4x3) $(D_INLINECODE GL_DOUBLE_MAT2) $(D_INLINECODE dmat2) $(D_INLINECODE GL_DOUBLE_MAT3) $(D_INLINECODE dmat3) $(D_INLINECODE GL_DOUBLE_MAT4) $(D_INLINECODE dmat4) $(D_INLINECODE GL_DOUBLE_MAT2x3) $(D_INLINECODE dmat2x3) $(D_INLINECODE GL_DOUBLE_MAT2x4) $(D_INLINECODE dmat2x4) $(D_INLINECODE GL_DOUBLE_MAT3x2) $(D_INLINECODE dmat3x2) $(D_INLINECODE GL_DOUBLE_MAT3x4) $(D_INLINECODE dmat3x4) $(D_INLINECODE GL_DOUBLE_MAT4x2) $(D_INLINECODE dmat4x2) $(D_INLINECODE GL_DOUBLE_MAT4x3) $(D_INLINECODE dmat4x3) $(D_INLINECODE GL_SAMPLER_1D) $(D_INLINECODE sampler1D) $(D_INLINECODE GL_SAMPLER_2D) $(D_INLINECODE sampler2D) $(D_INLINECODE GL_SAMPLER_3D) $(D_INLINECODE sampler3D) $(D_INLINECODE GL_SAMPLER_CUBE) $(D_INLINECODE samplerCube) $(D_INLINECODE GL_SAMPLER_1D_SHADOW) $(D_INLINECODE sampler1DShadow) $(D_INLINECODE GL_SAMPLER_2D_SHADOW) $(D_INLINECODE sampler2DShadow) $(D_INLINECODE GL_SAMPLER_1D_ARRAY) $(D_INLINECODE sampler1DArray) $(D_INLINECODE GL_SAMPLER_2D_ARRAY) $(D_INLINECODE sampler2DArray) $(D_INLINECODE GL_SAMPLER_1D_ARRAY_SHADOW) $(D_INLINECODE sampler1DArrayShadow) $(D_INLINECODE GL_SAMPLER_2D_ARRAY_SHADOW) $(D_INLINECODE sampler2DArrayShadow) $(D_INLINECODE GL_SAMPLER_2D_MULTISAMPLE) $(D_INLINECODE sampler2DMS) $(D_INLINECODE GL_SAMPLER_2D_MULTISAMPLE_ARRAY) $(D_INLINECODE sampler2DMSArray) $(D_INLINECODE GL_SAMPLER_CUBE_SHADOW) $(D_INLINECODE samplerCubeShadow) $(D_INLINECODE GL_SAMPLER_BUFFER) $(D_INLINECODE samplerBuffer) $(D_INLINECODE GL_SAMPLER_2D_RECT) $(D_INLINECODE sampler2DRect) $(D_INLINECODE GL_SAMPLER_2D_RECT_SHADOW) $(D_INLINECODE sampler2DRectShadow) $(D_INLINECODE GL_INT_SAMPLER_1D) $(D_INLINECODE isampler1D) $(D_INLINECODE GL_INT_SAMPLER_2D) $(D_INLINECODE isampler2D) $(D_INLINECODE GL_INT_SAMPLER_3D) $(D_INLINECODE isampler3D) $(D_INLINECODE GL_INT_SAMPLER_CUBE) $(D_INLINECODE isamplerCube) $(D_INLINECODE GL_INT_SAMPLER_1D_ARRAY) $(D_INLINECODE isampler1DArray) $(D_INLINECODE GL_INT_SAMPLER_2D_ARRAY) $(D_INLINECODE isampler2DArray) $(D_INLINECODE GL_INT_SAMPLER_2D_MULTISAMPLE) $(D_INLINECODE isampler2DMS) $(D_INLINECODE GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY) $(D_INLINECODE isampler2DMSArray) $(D_INLINECODE GL_INT_SAMPLER_BUFFER) $(D_INLINECODE isamplerBuffer) $(D_INLINECODE GL_INT_SAMPLER_2D_RECT) $(D_INLINECODE isampler2DRect) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_1D) $(D_INLINECODE usampler1D) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_2D) $(D_INLINECODE usampler2D) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_3D) $(D_INLINECODE usampler3D) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_CUBE) $(D_INLINECODE usamplerCube) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_1D_ARRAY) $(D_INLINECODE usampler2DArray) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_2D_ARRAY) $(D_INLINECODE usampler2DArray) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE) $(D_INLINECODE usampler2DMS) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY) $(D_INLINECODE usampler2DMSArray) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_BUFFER) $(D_INLINECODE usamplerBuffer) $(D_INLINECODE GL_UNSIGNED_INT_SAMPLER_2D_RECT) $(D_INLINECODE usampler2DRect) If $(D_INLINECODE pname) is $(D_INLINECODE GL_UNIFORM_SIZE), then an array identifying the size of the uniforms specified by the corresponding array of $(D_INLINECODE uniformIndices) is returned. The sizes returned are in units of the type returned by a query of $(D_INLINECODE GL_UNIFORM_TYPE). For active uniforms that are arrays, the size is the number of active elements in the array; for all other uniforms, the size is one. If $(D_INLINECODE pname) is $(D_INLINECODE GL_UNIFORM_NAME_LENGTH), then an array identifying the length, including the terminating null character, of the uniform name strings specified by the corresponding array of $(D_INLINECODE uniformIndices) is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_UNIFORM_BLOCK_INDEX), then an array identifying the the uniform block index of each of the uniforms specified by the corresponding array of $(D_INLINECODE uniformIndices) is returned. The uniform block index of a uniform associated with the default uniform block is -1. If $(D_INLINECODE pname) is $(D_INLINECODE GL_UNIFORM_OFFSET), then an array of uniform buffer offsets is returned. For uniforms in a named uniform block, the returned value will be its offset, in basic machine units, relative to the beginning of the uniform block in the buffer object data store. For atomic counter uniforms, the returned value will be its offset relative to the beginning of its active atomic counter buffer. For all other uniforms, -1 will be returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_UNIFORM_ARRAY_STRIDE), then an array identifying the stride between elements of each of the uniforms specified by the corresponding array of $(D_INLINECODE uniformIndices) is returned. For uniforms in named uniform blocks and for uniforms declared as atomic counters, the stride is the difference, in basic machine units, of consecutive elements in an array, or zero for uniforms not declared as an array. For all other uniforms, a stride of -1 will be returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_UNIFORM_MATRIX_STRIDE), then an array identifying the stride between columns of a column-major matrix or rows of a row-major matrix, in basic machine units, of each of the uniforms specified by the corresponding array of $(D_INLINECODE uniformIndices) is returned. The matrix stride of a uniform associated with the default uniform block is -1. Note that this information only makes sense for uniforms that are matrices. For uniforms that are not matrices, but are declared in a named uniform block, a matrix stride of zero is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_UNIFORM_IS_ROW_MAJOR), then an array identifying whether each of the uniforms specified by the corresponding array of $(D_INLINECODE uniformIndices) is a row-major matrix or not is returned. A value of one indicates a row-major matrix, and a value of zero indicates a column-major matrix, a matrix in the default uniform block, or a non-matrix. If $(D_INLINECODE pname) is $(D_INLINECODE GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX), then an array identifying the active atomic counter buffer index of each of the uniforms specified by the corresponding array of $(D_INLINECODE uniformIndices) is returned. For uniforms other than atomic counters, the returned buffer index is -1. The returned indices may be passed to $(D_INLINECODE glGetActiveAtomicCounterBufferiv) to query the properties of the associated buffer, and not necessarily the binding point specified in the uniform declaration.
     + 
     + The double types, $(D_INLINECODE GL_DOUBLE), $(D_INLINECODE GL_DOUBLE_VEC2), $(D_INLINECODE GL_DOUBLE_VEC3), $(D_INLINECODE GL_DOUBLE_VEC4), $(D_INLINECODE GL_DOUBLE_MAT2), $(D_INLINECODE GL_DOUBLE_MAT3), $(D_INLINECODE GL_DOUBLE_MAT4), $(D_INLINECODE GL_DOUBLE_MAT2x3), $(D_INLINECODE GL_DOUBLE_MAT2x4), $(D_INLINECODE GL_DOUBLE_MAT3x2), $(D_INLINECODE GL_DOUBLE_MAT3x4), $(D_INLINECODE GL_DOUBLE_MAT4x2), and $(D_INLINECODE GL_DOUBLE_MAT4x3) are only available if the GL version is 4.1 or higher. $(D_INLINECODE GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX) is only accepted by $(D_INLINECODE pname) if the GL version is 4.2 or higher.
     + 
     + Params:
     +     program        = Specifies the program object to be queried.
     +     uniformCount   = Specifies both the number of elements in the array of indices $(D_INLINECODE uniformIndices) and the number of parameters written to $(D_INLINECODE params) upon successful return.
     +     uniformIndices = Specifies the address of an array of $(D_INLINECODE uniformCount) integers containing the indices of uniforms within $(D_INLINECODE program) whose parameter $(D_INLINECODE pname) should be queried.
     +     pname          = Specifies the property of each uniform in $(D_INLINECODE uniformIndices) that should be written into the corresponding element of $(D_INLINECODE params).
     +     params         = Specifies the address of an array of $(D_INLINECODE uniformCount) integers which are to receive the value of $(D_INLINECODE pname) for each uniform in $(D_INLINECODE uniformIndices).
     + 
     + Copyright:
     +     Copyright&copy; 2011-2014 Khronos Group This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetUniform), $(D_INLINECODE glGetActiveUniform), $(D_INLINECODE glGetUniformLocation), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glUniform), $(D_INLINECODE glUseProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P1)
    @OpenGL_Extension("GL_ARB_uniform_buffer_object")
    fn_glGetActiveUniformsiv glGetActiveUniformsiv;
    alias fn_glGetAttachedShaders = extern(System) void function(GLuint program, GLsizei maxCount, GLsizei* count, GLuint* shaders) @system @nogc nothrow;

    /++
     + glGetAttachedShaders: man4/glGetAttachedShaders.xml
     + 
     + $(D_INLINECODE glGetAttachedShaders) returns the names of the shader objects attached to $(D_INLINECODE program). The names of shader objects that are attached to $(D_INLINECODE program) will be returned in $(D_INLINECODE shaders.) The actual number of shader names written into $(D_INLINECODE shaders) is returned in $(D_INLINECODE count.) If no shader objects are attached to $(D_INLINECODE program), $(D_INLINECODE count) is set to 0. The maximum number of shader names that may be returned in $(D_INLINECODE shaders) is specified by $(D_INLINECODE maxCount). If the number of names actually returned is not required (for instance, if it has just been obtained by calling $(D_INLINECODE glGetProgram) ), a value of $(D_INLINECODE null
     + ) may be passed for count. If no shader objects are attached to $(D_INLINECODE program), a value of 0 will be returned in $(D_INLINECODE count). The actual number of attached shaders can be obtained by calling $(D_INLINECODE glGetProgram) with the value $(D_INLINECODE GL_ATTACHED_SHADERS).
     + 
     + Params:
     +     program  = Specifies the program object to be queried.
     +     maxCount = Specifies the size of the array for storing the returned object names.
     +     count    = Returns the number of names actually returned in $(D_INLINECODE shaders).
     +     shaders  = Specifies an array that is used to return the names of attached shader objects.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAttachShader), $(D_INLINECODE glDetachShader).
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glGetAttachedShaders glGetAttachedShaders;
    alias fn_glGetAttribLocation = extern(System) GLint function(GLuint program, const( GLchar*) name) @system @nogc nothrow;

    /++
     + glGetAttribLocation: man4/glGetAttribLocation.xml
     + 
     + $(D_INLINECODE glGetAttribLocation) queries the previously linked program object specified by $(D_INLINECODE program) for the attribute variable specified by $(D_INLINECODE name) and returns the index of the generic vertex attribute that is bound to that attribute variable. If $(D_INLINECODE name) is a matrix attribute variable, the index of the first column of the matrix is returned. If the named attribute variable is not an active attribute in the specified program object or if $(D_INLINECODE name) starts with the reserved prefix &quot;gl_&quot;, a value of -1 is returned. The association between an attribute variable name and a generic attribute index can be specified at any time by calling $(D_INLINECODE glBindAttribLocation). Attribute bindings do not go into effect until $(D_INLINECODE glLinkProgram) is called. After a program object has been linked successfully, the index values for attribute variables remain fixed until the next link command occurs. The attribute values can only be queried after a link if the link was successful. $(D_INLINECODE glGetAttribLocation) returns the binding that actually went into effect the last time $(D_INLINECODE glLinkProgram) was called for the specified program object. Attribute bindings that have been specified since the last link operation are not returned by $(D_INLINECODE glGetAttribLocation).
     + 
     + Params:
     +     program = Specifies the program object to be queried.
     +     name    = Points to a null terminated string containing the name of the attribute variable whose location is to be queried.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindAttribLocation), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glVertexAttrib), $(D_INLINECODE glVertexAttribPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glGetAttribLocation glGetAttribLocation;
    alias fn_glGetBufferParameteriv = extern(System) void function(GLenum target, GLenum value, GLint* data) @system @nogc nothrow;

    /++
     + glGetBufferParameter: man4/glGetBufferParameter.xml
     + 
     + These functions return in $(D_INLINECODE data) a selected parameter of the specified buffer object. $(D_INLINECODE pname) names a specific buffer object parameter, as follows:
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE data). The $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) target is available only if the GL version is 4.2 or greater. The $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) and $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) targets are available only if the GL version is 4.3 or greater. The $(D_INLINECODE GL_QUERY_BUFFER) target is available only if the GL version is 4.4 or greater.
     + 
     + Params:
     +     target = Specifies the target to which the buffer object is bound for $(D_INLINECODE glGetBufferParameteriv) and $(D_INLINECODE glGetBufferParameteri64v). Must be one of the buffer binding targets in the following table: $(B Buffer Binding Target) $(B Purpose) $(D_INLINECODE GL_ARRAY_BUFFER) Vertex attributes $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) Atomic counter storage $(D_INLINECODE GL_COPY_READ_BUFFER) Buffer copy source $(D_INLINECODE GL_COPY_WRITE_BUFFER) Buffer copy destination $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) Indirect compute dispatch commands $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) Indirect command arguments $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) Vertex array indices $(D_INLINECODE GL_PIXEL_PACK_BUFFER) Pixel read target $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) Texture data source $(D_INLINECODE GL_QUERY_BUFFER) Query result buffer $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) Read-write storage for shaders $(D_INLINECODE GL_TEXTURE_BUFFER) Texture data buffer $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) Transform feedback buffer $(D_INLINECODE GL_UNIFORM_BUFFER) Uniform block storage
     +     buffer = Specifies the name of the buffer object for $(D_INLINECODE glGetNamedBufferParameteriv) and $(D_INLINECODE glGetNamedBufferParameteri64v).
     +     value  = Specifies the name of the buffer object parameter to query.
     +     data   = Returns the requested parameter.
     + 
     + Copyright:
     +     Copyright&copy; 2005 Addison-Wesley. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBuffer), $(D_INLINECODE glBufferData), $(D_INLINECODE glGetBufferPointerv), $(D_INLINECODE glMapBuffer), $(D_INLINECODE glUnmapBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    fn_glGetBufferParameteriv glGetBufferParameteriv;
    alias fn_glGetBufferParameteri64v = extern(System) void function(GLenum target, GLenum value, GLint64* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    fn_glGetBufferParameteri64v glGetBufferParameteri64v;
    alias fn_glGetNamedBufferParameteriv = extern(System) void function(GLuint buffer, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glGetNamedBufferParameteriv glGetNamedBufferParameteriv;
    alias fn_glGetNamedBufferParameteri64v = extern(System) void function(GLuint buffer, GLenum pname, GLint64* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glGetNamedBufferParameteri64v glGetNamedBufferParameteri64v;
    alias fn_glGetBufferPointerv = extern(System) void function(GLenum target, GLenum pname, GLvoid** params) @system @nogc nothrow;

    /++
     + glGetBufferPointerv: man4/glGetBufferPointerv.xml
     + 
     + $(D_INLINECODE glGetBufferPointerv) and $(D_INLINECODE glGetNamedBufferPointerv) return the buffer pointer $(D_INLINECODE pname), which must be $(D_INLINECODE GL_BUFFER_MAP_POINTER). The single buffer map pointer is returned in $(D_INLINECODE params). A $(D_INLINECODE null
     + ) pointer is returned if the buffer object's data store is not currently mapped; or if the requesting context did not map the buffer object's data store, and the implementation is unable to support mappings on multiple clients.
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE params). The initial value for the pointer is $(D_INLINECODE null
     + ). The $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) target is available only if the GL version is 4.2 or greater. The $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) and $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) targets are available only if the GL version is 4.3 or greater. The $(D_INLINECODE GL_QUERY_BUFFER) target is available only if the GL version is 4.4 or greater.
     + 
     + Params:
     +     target = Specifies the target to which the buffer object is bound for $(D_INLINECODE glGetBufferPointerv), which must be one of the buffer binding targets in the following table: $(B Buffer Binding Target) $(B Purpose) $(D_INLINECODE GL_ARRAY_BUFFER) Vertex attributes $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) Atomic counter storage $(D_INLINECODE GL_COPY_READ_BUFFER) Buffer copy source $(D_INLINECODE GL_COPY_WRITE_BUFFER) Buffer copy destination $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) Indirect compute dispatch commands $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) Indirect command arguments $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) Vertex array indices $(D_INLINECODE GL_PIXEL_PACK_BUFFER) Pixel read target $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) Texture data source $(D_INLINECODE GL_QUERY_BUFFER) Query result buffer $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) Read-write storage for shaders $(D_INLINECODE GL_TEXTURE_BUFFER) Texture data buffer $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) Transform feedback buffer $(D_INLINECODE GL_UNIFORM_BUFFER) Uniform block storage
     +     buffer = Specifies the name of the buffer object for $(D_INLINECODE glGetNamedBufferPointerv).
     +     pname  = Specifies the name of the pointer to be returned. Must be $(D_INLINECODE GL_BUFFER_MAP_POINTER).
     +     params = Returns the pointer value specified by $(D_INLINECODE pname).
     + 
     + Copyright:
     +     Copyright&copy; 2005 Addison-Wesley. Copyright&copy; 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBuffer), $(D_INLINECODE glMapBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    fn_glGetBufferPointerv glGetBufferPointerv;
    alias fn_glGetNamedBufferPointerv = extern(System) void function(GLuint buffer, GLenum pname, void** params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glGetNamedBufferPointerv glGetNamedBufferPointerv;
    alias fn_glGetBufferSubData = extern(System) void function(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid* data) @system @nogc nothrow;

    /++
     + glGetBufferSubData: man4/glGetBufferSubData.xml
     + 
     + $(D_INLINECODE glGetBufferSubData) and $(D_INLINECODE glGetNamedBufferSubData) return some or all of the data contents of the data store of the specified buffer object. Data starting at byte offset $(D_INLINECODE offset) and extending for $(D_INLINECODE size) bytes is copied from the buffer object's data store to the memory pointed to by $(D_INLINECODE data). An error is thrown if the buffer object is currently mapped, or if $(D_INLINECODE offset) and $(D_INLINECODE size) together define a range beyond the bounds of the buffer object's data store.
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE data). The $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) target is available only if the GL version is 4.2 or greater. The $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) and $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) targets are available only if the GL version is 4.3 or greater. The $(D_INLINECODE GL_QUERY_BUFFER) target is available only if the GL version is 4.4 or greater.
     + 
     + Params:
     +     target = Specifies the target to which the buffer object is bound for $(D_INLINECODE glGetBufferSubData), which must be one of the buffer binding targets in the following table: $(B Buffer Binding Target) $(B Purpose) $(D_INLINECODE GL_ARRAY_BUFFER) Vertex attributes $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) Atomic counter storage $(D_INLINECODE GL_COPY_READ_BUFFER) Buffer copy source $(D_INLINECODE GL_COPY_WRITE_BUFFER) Buffer copy destination $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) Indirect compute dispatch commands $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) Indirect command arguments $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) Vertex array indices $(D_INLINECODE GL_PIXEL_PACK_BUFFER) Pixel read target $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) Texture data source $(D_INLINECODE GL_QUERY_BUFFER) Query result buffer $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) Read-write storage for shaders $(D_INLINECODE GL_TEXTURE_BUFFER) Texture data buffer $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) Transform feedback buffer $(D_INLINECODE GL_UNIFORM_BUFFER) Uniform block storage
     +     buffer = Specifies the name of the buffer object for $(D_INLINECODE glGetNamedBufferSubData).
     +     offset = Specifies the offset into the buffer object's data store from which data will be returned, measured in bytes.
     +     size   = Specifies the size in bytes of the data store region being returned.
     +     data   = Specifies a pointer to the location where buffer object data is returned.
     + 
     + Copyright:
     +     Copyright&copy; 2005 Addison-Wesley. Copyright&copy; 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBuffer), $(D_INLINECODE glBufferData), $(D_INLINECODE glBufferSubData), $(D_INLINECODE glMapBuffer), $(D_INLINECODE glUnmapBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    fn_glGetBufferSubData glGetBufferSubData;
    alias fn_glGetNamedBufferSubData = extern(System) void function(GLuint buffer, GLintptr offset, GLsizei size, void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glGetNamedBufferSubData glGetNamedBufferSubData;
    alias fn_glGetCompressedTexImage = extern(System) void function(GLenum target, GLint level, GLvoid* pixels) @system @nogc nothrow;

    /++
     + glGetCompressedTexImage: man4/glGetCompressedTexImage.xml
     + 
     + $(D_INLINECODE glGetCompressedTexImage) and $(D_INLINECODE glGetnCompressedTexImage) return the compressed texture image associated with $(D_INLINECODE target) and $(D_INLINECODE lod) into $(D_INLINECODE pixels). $(D_INLINECODE glGetCompressedTextureImage) serves the same purpose, but instead of taking a texture target, it takes the ID of the texture object. $(D_INLINECODE pixels) should be an array of $(D_INLINECODE bufSize) bytes for $(D_INLINECODE glGetnCompresedTexImage) and $(D_INLINECODE glGetCompressedTextureImage) functions, and of $(D_INLINECODE GL_TEXTURE_COMPRESSED_IMAGE_SIZE) bytes in case of $(D_INLINECODE glGetCompressedTexImage). If the actual data takes less space than $(D_INLINECODE bufSize), the remaining bytes will not be touched. $(D_INLINECODE target) specifies the texture target, to which the texture the data the function should extract the data from is bound to. $(D_INLINECODE lod) specifies the level-of-detail number of the desired image. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_PACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is requested, $(D_INLINECODE pixels) is treated as a byte offset into the buffer object's data store. To minimize errors, first verify that the texture is compressed by calling $(D_INLINECODE glGetTexLevelParameter) with argument $(D_INLINECODE GL_TEXTURE_COMPRESSED). If the texture is compressed, you can determine the amount of memory required to store the compressed texture by calling $(D_INLINECODE glGetTexLevelParameter) with argument $(D_INLINECODE GL_TEXTURE_COMPRESSED_IMAGE_SIZE). Finally, retrieve the internal format of the texture by calling $(D_INLINECODE glGetTexLevelParameter) with argument $(D_INLINECODE GL_TEXTURE_INTERNAL_FORMAT). To store the texture for later use, associate the internal format and size with the retrieved texture image. These data can be used by the respective texture or subtexture loading routine used for loading $(D_INLINECODE target) textures.
     + 
     + Params:
     +     target  = Specifies the target to which the texture is bound for $(D_INLINECODE glGetCompressedTexImage) and $(D_INLINECODE glGetnCompressedTexImage) functions. $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Z), and $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Z), $(D_INLINECODE GL_TEXTURE_RECTANGLE) are accepted.
     +     texture = Specifies the texture object name for $(D_INLINECODE glGetCompressedTextureImage) function.
     +     level   = Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level $n$ is the $n$-th mipmap reduction image.
     +     bufSize = Specifies the size of the buffer $(D_INLINECODE pixels) for $(D_INLINECODE glGetCompressedTextureImage) and $(D_INLINECODE glGetnCompressedTexImage) functions.
     +     pixels  = Returns the compressed texture image.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glCompressedTexImage1D), $(D_INLINECODE glCompressedTexImage2D), $(D_INLINECODE glCompressedTexImage3D), $(D_INLINECODE glCompressedTexSubImage1D), $(D_INLINECODE glCompressedTexSubImage2D), $(D_INLINECODE glCompressedTexSubImage3D), $(D_INLINECODE glReadPixels), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexParameter), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glGetCompressedTexImage glGetCompressedTexImage;
    alias fn_glGetnCompressedTexImage = extern(System) void function(GLenum target, GLint level, GLsizei bufSize, void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    fn_glGetnCompressedTexImage glGetnCompressedTexImage;
    alias fn_glGetCompressedTextureImage = extern(System) void function(GLuint texture, GLint level, GLsizei bufSize, void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glGetCompressedTextureImage glGetCompressedTextureImage;
    alias fn_glGetCompressedTextureSubImage = extern(System) void function(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void* pixels) @system @nogc nothrow;

    /++
     + glGetCompressedTextureSubImage: man4/glGetCompressedTextureSubImage.xml
     + 
     + $(D_INLINECODE glGetCompressedTextureSubImage) can be used to obtain a sub-region of a compressed texture image instead of the whole image, as long as the compressed data are arranged into fixed-size blocks of texels. $(D_INLINECODE texture) is the name of the texture object, and must not be a buffer or multisample texture. The effective $(D_INLINECODE target) is the value of $(D_INLINECODE GL_TEXTURE_TARGET) for texture. $(D_INLINECODE level) and $(D_INLINECODE pixels) have the same meaning as the corresponding arguments of $(D_INLINECODE glCompressedTexSubImage3D). $(D_INLINECODE bufSize) indicates the size of the buffer to receive the retrieved pixel data. For cube map textures, the behavior is as though $(D_INLINECODE glGetCompressedTexImage) were called once for each requested face (selected by $(D_INLINECODE zoffset) and $(D_INLINECODE depth), as described below) with target corresponding to the requested texture cube map face as indicated by the table presented below. $(D_INLINECODE pixels) is offset appropriately for each successive image. Layer number Cube Map Face 0 $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X) 1 $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_X) 2 $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Y) 3 $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Y) 4 $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Z) 5 $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Z) $(D_INLINECODE xoffset), $(D_INLINECODE yoffset) and $(D_INLINECODE zoffset) indicate the position of the subregion to return. $(D_INLINECODE width), $(D_INLINECODE height) and $(D_INLINECODE depth) indicate the size of the region to return. These arguments have the same meaning as for $(D_INLINECODE glCompressedTexSubImage3D), though there are extra restrictions, described in the errors section below. The mapping between the $(D_INLINECODE xoffset), $(D_INLINECODE yoffset), $(D_INLINECODE zoffset), $(D_INLINECODE width), $(D_INLINECODE height) and $(D_INLINECODE depth) parameters and the faces, layers, and layer-faces for cube map, array, and cube map array textures is the same as for glGetTextureSubImage. The $(D_INLINECODE xoffset), $(D_INLINECODE yoffset), $(D_INLINECODE zoffset) offsets and $(D_INLINECODE width), $(D_INLINECODE height) and $(D_INLINECODE depth) sizes must be multiples of the values of $(D_INLINECODE GL_PACK_COMPRESSED_BLOCK_WIDTH), $(D_INLINECODE GL_PACK_COMPRESSED_BLOCK_HEIGHT), and $(D_INLINECODE GL_PACK_COMPRESSED_BLOCK_DEPTH) respectively, unless $(D_INLINECODE offset) is zero and the corresponding $(D_INLINECODE size) is the same as the texture size in that dimension. Pixel storage modes are treated as for $(D_INLINECODE glGetCompressedTexSubImage). The texel at ( $(D_INLINECODE xoffset), $(D_INLINECODE yoffset), $(D_INLINECODE zoffset) ) will be stored at the location indicated by $(D_INLINECODE pixels) and the current pixel packing parameters.
     + 
     + Params:
     +     texture = Specifies the name of the source texture object. Must be $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_CUBE_MAP), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY) or $(D_INLINECODE GL_TEXTURE_RECTANGLE). In specific, buffer and multisample textures are not permitted.
     +     level   = Specifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the $n$th mipmap reduction image.
     +     xoffset = Specifies a texel offset in the x direction within the texture array.
     +     yoffset = Specifies a texel offset in the y direction within the texture array.
     +     zoffset = Specifies a texel offset in the z direction within the texture array.
     +     width   = Specifies the width of the texture subimage. Must be a multiple of the compressed block's width, unless the $(D_INLINECODE offset) is zero and the size equals the texture image size.
     +     height  = Specifies the height of the texture subimage. Must be a multiple of the compressed block's height, unless the $(D_INLINECODE offset) is zero and the size equals the texture image size.
     +     depth   = Specifies the depth of the texture subimage. Must be a multiple of the compressed block's depth, unless the $(D_INLINECODE offset) is zero and the size equals the texture image size.
     +     bufSize = Specifies the size of the buffer to receive the retrieved pixel data.
     +     pixels  = Returns the texture subimage. Should be a pointer to an array of the type specified by type.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCompressedTexImage1D), $(D_INLINECODE glCompressedTexImage2D), $(D_INLINECODE glCompressedTexImage3D), $(D_INLINECODE glCompressedTexSubImage1D), $(D_INLINECODE glCompressedTexSubImage2D), $(D_INLINECODE glCompressedTexSubImage3D), $(D_INLINECODE glGetCompressedTexImage), $(D_INLINECODE glGetCompressedTextureImage), $(D_INLINECODE glReadPixels)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_get_texture_sub_image")
    fn_glGetCompressedTextureSubImage glGetCompressedTextureSubImage;
    alias fn_glGetDebugMessageLog = extern(System) GLuint function(GLuint count, GLsizei bufSize, GLenum* sources, GLenum* types, GLuint* ids, GLenum* severities, GLsizei* lengths, GLchar* messageLog) @system @nogc nothrow;

    /++
     + glGetDebugMessageLog: man4/glGetDebugMessageLog.xml
     + 
     + $(D_INLINECODE glGetDebugMessageLog) retrieves messages from the debug message log. A maximum of $(D_INLINECODE count) messages are retrieved from the log. If $(D_INLINECODE sources) is not null then the source of each message is written into up to
     +  $(D_INLINECODE count) elements of the array. If $(D_INLINECODE types) is not null then the type of each message is written into up to
     +  $(D_INLINECODE count) elements of the array. If $(D_INLINECODE id) is not null then the identifier of each message is written into up to
     +  $(D_INLINECODE count) elements of the array. If $(D_INLINECODE severities) is not null then the severity of each message is written into up to
     +  $(D_INLINECODE count) elements of the array. If $(D_INLINECODE lengths) is not null then the length of each message is written into up to
     +  $(D_INLINECODE count) elements of the array. $(D_INLINECODE messageLog) specifies the address of a character array into which the debug messages will be written. Each message will be concatenated onto the array starting at the first element of $(D_INLINECODE messageLog). $(D_INLINECODE bufSize) specifies the size of the array $(D_INLINECODE messageLog). If a message will not fit into the remaining space in $(D_INLINECODE messageLog) then the function terminates and returns the number of messages written so far, which may be zero. If $(D_INLINECODE glGetDebugMessageLog) returns zero then no messages are present in the debug log, or there was not enough space in $(D_INLINECODE messageLog) to retrieve the first message in the queue. If $(D_INLINECODE messageLog) is null then no messages are written and the value of
     +  $(D_INLINECODE bufSize) is ignored.
     + 
     + Although debug messages may be enabled in a non-debug context, the quantity and detail of such messages may be substantially inferior to those in a debug context. In particular, a valid implementation of the debug message queue in a non-debug context may produce no messages at all.
     + 
     + Params:
     +     count      = The number of debug messages to retrieve from the log.
     +     bufSize    = The size of the buffer whose address is given by $(D_INLINECODE messageLog).
     +     sources    = The address of an array of variables to receive the sources of the retrieved messages.
     +     types      = The address of an array of variables to receive the types of the retrieved messages.
     +     ids        = The address of an array of unsigned integers to receive the ids of the retrieved messages.
     +     severities = The address of an array of variables to receive the severites of the retrieved messages.
     +     lengths    = The address of an array of variables to receive the lengths of the received messages.
     +     messageLog = The address of an array of characters that will receive the messages.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDebugMessageInsert), $(D_INLINECODE glDebugMessageCallback), $(D_INLINECODE glDebugMessageControl).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_KHR_debug")
    fn_glGetDebugMessageLog glGetDebugMessageLog;
    alias fn_glGetError = extern(System) GLenum function() @system @nogc nothrow;

    /++
     + glGetError: man4/glGetError.xml
     + 
     + $(D_INLINECODE glGetError) returns the value of the error flag. Each detectable error is assigned a numeric code and symbolic name. When an error occurs, the error flag is set to the appropriate error code value. No other errors are recorded until $(D_INLINECODE glGetError) is called, the error code is returned, and the flag is reset to $(D_INLINECODE GL_NO_ERROR). If a call to $(D_INLINECODE glGetError) returns $(D_INLINECODE GL_NO_ERROR), there has been no detectable error since the last call to $(D_INLINECODE glGetError), or since the GL was initialized. To allow for distributed implementations, there may be several error flags. If any single error flag has recorded an error, the value of that flag is returned and that flag is reset to $(D_INLINECODE GL_NO_ERROR) when $(D_INLINECODE glGetError) is called. If more than one flag has recorded an error, $(D_INLINECODE glGetError) returns and clears an arbitrary error flag value. Thus, $(D_INLINECODE glGetError) should always be called in a loop, until it returns $(D_INLINECODE GL_NO_ERROR), if all error flags are to be reset. Initially, all error flags are set to $(D_INLINECODE GL_NO_ERROR). The following errors are currently defined: When an error flag is set, results of a GL operation are undefined only if $(D_INLINECODE GL_OUT_OF_MEMORY) has occurred. In all other cases, the command generating the error is ignored and has no effect on the GL state or frame buffer contents. If the generating command returns a value, it returns 0. If $(D_INLINECODE glGetError) itself generates an error, it returns 0.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glGetError glGetError;
    alias fn_glGetFragDataIndex = extern(System) GLint function(GLuint program, const( char*) name) @system @nogc nothrow;

    /++
     + glGetFragDataIndex: man4/glGetFragDataIndex.xml
     + 
     + $(D_INLINECODE glGetFragDataIndex) returns the index of the fragment color to which the variable $(D_INLINECODE name) was bound when the program object $(D_INLINECODE program) was last linked. If $(D_INLINECODE name) is not a varying out variable of $(D_INLINECODE program), or if an error occurs, -1 will be returned.
     + 
     + $(D_INLINECODE glGetFragDataIndex) is available only if the GL version is 3.3 or greater.
     + 
     + Params:
     +     program = The name of the program containing varying out variable whose binding to query
     +     name    = The name of the user-defined varying out variable whose index to query
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCreateProgram), $(D_INLINECODE glBindFragDataLocation), $(D_INLINECODE glBindFragDataLocationIndexed), $(D_INLINECODE glGetFragDataLocation)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_blend_func_extended")
    fn_glGetFragDataIndex glGetFragDataIndex;
    alias fn_glGetFragDataLocation = extern(System) GLint function(GLuint program, const( char*) name) @system @nogc nothrow;

    /++
     + glGetFragDataLocation: man4/glGetFragDataLocation.xml
     + 
     + $(D_INLINECODE glGetFragDataLocation) retrieves the assigned color number binding for the user-defined varying out variable $(D_INLINECODE name) for program $(D_INLINECODE program). $(D_INLINECODE program) must have previously been linked. $(D_INLINECODE name) must be a null-terminated string. If $(D_INLINECODE name) is not the name of an active user-defined varying out fragment shader variable within $(D_INLINECODE program), -1 will be returned.
     + 
     + Params:
     +     program = The name of the program containing varying out variable whose binding to query
     +     name    = The name of the user-defined varying out variable whose binding to query
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCreateProgram), $(D_INLINECODE glBindFragDataLocation)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glGetFragDataLocation glGetFragDataLocation;
    alias fn_glGetFramebufferAttachmentParameteriv = extern(System) void function(GLenum target, GLenum attachment, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glGetFramebufferAttachmentParameter: man4/glGetFramebufferAttachmentParameter.xml
     + 
     + $(D_INLINECODE glGetFramebufferAttachmentParameteriv) and $(D_INLINECODE glGetNamedFramebufferAttachmentParameteriv) return parameters of attachments of a specified framebuffer object. For $(D_INLINECODE glGetFramebufferAttachmentParameteriv), the framebuffer object is that bound to $(D_INLINECODE target), which must be one of $(D_INLINECODE GL_DRAW_FRAMEBUFFER), $(D_INLINECODE GL_READ_FRAMEBUFFER) or $(D_INLINECODE GL_FRAMEBUFFER). $(D_INLINECODE GL_FRAMEBUFFER) is equivalent to $(D_INLINECODE GL_DRAW_FRAMEBUFFER). Buffers of default framebuffers may also be queried if bound to $(D_INLINECODE target). For $(D_INLINECODE glGetNamedFramebufferAttachmentParameteriv), $(D_INLINECODE framebuffer) is the name of the framebuffer object. If $(D_INLINECODE framebuffer) is zero, the default draw framebuffer is queried. If the specified framebuffer is a framebuffer object, $(D_INLINECODE attachment) must be one of $(D_INLINECODE GL_DEPTH_ATTACHMENT), $(D_INLINECODE GL_STENCIL_ATTACHMENT) $(D_INLINECODE GL_DEPTH_STENCIL_ATTACHMENT), or $(D_INLINECODE GL_COLOR_ATTACHMENT), where is between zero and the value of $(D_INLINECODE GL_MAX_COLOR_ATTACHMENTS) minus one. If the specified framebuffer is a default framebuffer, $(D_INLINECODE target), $(D_INLINECODE attachment) must be one of $(D_INLINECODE GL_FRONT_LEFT), $(D_INLINECODE GL_FRONT_RIGHT), $(D_INLINECODE GL_BACK_LEFT), $(D_INLINECODE GL_BACK_RIGHT), $(D_INLINECODE GL_DEPTH) or $(D_INLINECODE GL_STENCIL), identifying the corresponding buffer. If $(D_INLINECODE attachment) is $(D_INLINECODE GL_DEPTH_STENCIL_ATTACHMENT), the same object must be bound to both the depth and stencil attachment points of the framebuffer object, and information about that object is returned. Upon successful return, if $(D_INLINECODE pname) is $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE), then $(D_INLINECODE params) will contain one of $(D_INLINECODE GL_NONE), $(D_INLINECODE GL_FRAMEBUFFER_DEFAULT), $(D_INLINECODE GL_TEXTURE), or $(D_INLINECODE GL_RENDERBUFFER), identifying the type of object which contains the attached image. Other values accepted for $(D_INLINECODE pname) depend on the type of object, as described below. If the value of $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE) is $(D_INLINECODE GL_NONE), then either no framebuffer is bound to $(D_INLINECODE target); or a default framebuffer is queried, $(D_INLINECODE attachment) is $(D_INLINECODE GL_DEPTH) or $(D_INLINECODE GL_STENCIL), and the number of depth or stencil bits, respectively, is zero. In this case querying $(D_INLINECODE pname) $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME) will return zero, and all other queries will generate an error. If the value of $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE) is not $(D_INLINECODE GL_NONE), these queries apply to all other framebuffer types: $(OL $(LI If $(D_INLINECODE pname) is $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE), $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE), $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE), $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE), $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE) or $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE), then $(D_INLINECODE params) will contain the number of bits in the corresponding red, green, blue, alpha, depth, or stencil component of the specified attachment. If the requested component is not present in the attachment, or if no data storage or texture image has been specified for the attachment, then $(D_INLINECODE params) will contain zero.) $(LI If $(D_INLINECODE pname) is $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE), then $(D_INLINECODE params) will contain the format of components of the specified attachment, one of $(D_INLINECODE GL_FLOAT), $(D_INLINECODE GL_INT), $(D_INLINECODE GL_UNSIGNED_INT), $(D_INLINECODE GL_SIGNED_NORMALIZED), or $(D_INLINECODE GL_UNSIGNED_NORMALIZED) for floating-point, signed integer, unsigned integer, signed normalized fixed-point, or unsigned normalized fixed-point components respectively. Only color buffers may have integer components. If no data storage or texture image has been specified for the attachment, then $(D_INLINECODE params) will contain $(D_INLINECODE GL_NONE). This query cannot be performed for a combined depth+stencil attachment, since it does not have a single format.) $(LI If $(D_INLINECODE pname) is $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING), then $(D_INLINECODE params) will contain the encoding of components of the specified attachment, one of $(D_INLINECODE GL_LINEAR) or $(D_INLINECODE GL_SRGB) for linear or sRGB-encoded components, respectively. Only color buffer components may be sRGB-encoded; such components are treated as described in the OpenGL Specification. For a default framebuffer, color encoding is determined by the implementation. For framebuffer objects, components are sRGB-encoded if the internal format of a color attachment is one of the color-renderable SRGB formats. If the attachment is not a color attachment, or if no data storage or texture image has been specified for the attachment, then $(D_INLINECODE params) will contain $(D_INLINECODE GL_LINEAR).)) If the value of $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE) is $(D_INLINECODE GL_RENDERBUFFER), then $(OL $(LI If $(D_INLINECODE pname) is $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME), $(D_INLINECODE params) will contain the name of the renderbuffer object which contains the attached image.)) If the value of $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE) is $(D_INLINECODE GL_TEXTURE), then $(OL $(LI If $(D_INLINECODE pname) is $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME), then $(D_INLINECODE params) will contain the name of the texture object which contains the attached image.) $(LI If $(D_INLINECODE pname) is $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL), then $(D_INLINECODE params) will contain the mipmap level of the texture object which contains the attached image.) $(LI If $(D_INLINECODE pname) is $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE) and the value of $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME) is the name of a cube map texture object, then $(D_INLINECODE params) will contain the cube map face of the cubemap texture object which contains the attached image. Otherwise $(D_INLINECODE params) will contain zero.) $(LI If $(D_INLINECODE pname) is $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_LAYERED), then $(D_INLINECODE params) will contain $(D_INLINECODE GL_TRUE) if an entire level of a three-dimensional texture, cube map texture, or one-or two-dimensional array texture is attached. Otherwise, $(D_INLINECODE params) will contain $(D_INLINECODE GL_FALSE).) $(LI If $(D_INLINECODE pname) is $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER); the value of $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME) is the name of a three-dimensional, or a one- or two-dimensional array texture; and the value of $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_LAYERED) is $(D_INLINECODE GL_FALSE), then $(D_INLINECODE params) will contain the texture layer which contains the attached image. Otherwise $(D_INLINECODE params) will contain zero.))
     + 
     + The $(D_INLINECODE GL_FRAMEBUFFER_ATTACHMENT_LAYERED) query is supported only if the GL version is 3.2 or greater.
     + 
     + Params:
     +     target      = Specifies the target to which the framebuffer object is bound for $(D_INLINECODE glGetFramebufferAttachmentParameteriv).
     +     framebuffer = Specifies the name of the framebuffer object for $(D_INLINECODE glGetNamedFramebufferAttachmentParameteriv).
     +     attachment  = Specifies the attachment of the framebuffer object to query.
     +     pname       = Specifies the parameter of $(D_INLINECODE attachment) to query.
     +     params      = Returns the value of parameter $(D_INLINECODE pname) for $(D_INLINECODE attachment).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenFramebuffers), $(D_INLINECODE glBindFramebuffer) $(D_INLINECODE glGetFramebufferParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    fn_glGetFramebufferAttachmentParameteriv glGetFramebufferAttachmentParameteriv;
    alias fn_glGetNamedFramebufferAttachmentParameteriv = extern(System) void function(GLuint framebuffer, GLenum attachment, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glGetNamedFramebufferAttachmentParameteriv glGetNamedFramebufferAttachmentParameteriv;
    alias fn_glGetFramebufferParameteriv = extern(System) void function(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glGetFramebufferParameter: man4/glGetFramebufferParameter.xml
     + 
     + $(D_INLINECODE glGetFramebufferParameteriv) and $(D_INLINECODE glGetNamedFramebufferParameteriv) query parameters of a specified framebuffer object. For $(D_INLINECODE glGetFramebufferParameteriv), the framebuffer object is that bound to $(D_INLINECODE target), which must be one of $(D_INLINECODE GL_DRAW_FRAMEBUFFER), $(D_INLINECODE GL_READ_FRAMEBUFFER) or $(D_INLINECODE GL_FRAMEBUFFER). $(D_INLINECODE GL_FRAMEBUFFER) is equivalent to $(D_INLINECODE GL_DRAW_FRAMEBUFFER). Default framebuffers may also be queried if bound to $(D_INLINECODE target). For $(D_INLINECODE glGetNamedFramebufferParameteriv), $(D_INLINECODE framebuffer) is the name of the framebuffer object. If $(D_INLINECODE framebuffer) is zero, the default draw framebuffer is queried. Upon successful return, $(D_INLINECODE param) will contain the value of the framebuffer parameter specified by $(D_INLINECODE pname), as described below. The following parameters can only be queried for framebuffer objects: The following parameters can be queried for both default framebuffers and framebuffer objects:
     + 
     + Queries of default framebuffers are supported only if the GL version is 4.5 or higher. Otherwise, an $(D_INLINECODE GL_INVALID_OPERATION) error is generated. Queries of the framebuffer-dependent parameters $(D_INLINECODE GL_DOUBLEBUFFER), $(D_INLINECODE GL_IMPLEMENTATION_COLOR_READ_FORMAT), $(D_INLINECODE GL_IMPLEMENTATION_COLOR_READ_TYPE), $(D_INLINECODE GL_SAMPLES), $(D_INLINECODE GL_SAMPLE_BUFFERS) and $(D_INLINECODE GL_STEREO) are supported only if the GL version is 4.5 or higher. The framebuffer-dependent state $(D_INLINECODE GL_SAMPLE_POSITION) cannot be queried with these commands.
     + 
     + Params:
     +     target      = Specifies the target to which the framebuffer object is bound for $(D_INLINECODE glGetFramebufferParameteriv).
     +     framebuffer = Specifies the name of the framebuffer object for $(D_INLINECODE glGetNamedFramebufferParameteriv).
     +     pname       = Specifies the parameter of the framebuffer object to query.
     +     params      = Returns the value of parameter $(D_INLINECODE pname) for the framebuffer object.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glFramebufferParameteri), $(D_INLINECODE glGetFramebufferAttachmentParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_framebuffer_no_attachments")
    fn_glGetFramebufferParameteriv glGetFramebufferParameteriv;
    alias fn_glGetNamedFramebufferParameteriv = extern(System) void function(GLuint framebuffer, GLenum pname, GLint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glGetNamedFramebufferParameteriv glGetNamedFramebufferParameteriv;
    alias fn_glGetGraphicsResetStatus = extern(System) GLenum function() @system @nogc nothrow;

    /++
     + glGetGraphicsResetStatus: man4/glGetGraphicsResetStatus.xml
     + 
     + Certain events can result in a reset of the GL context. Such a reset causes all context state to be lost and requires the application to recreate all objects in the affected context. $(D_INLINECODE glGetGraphicsResetStatus) can return one of the following constants: If a reset status other than $(D_INLINECODE GL_NO_ERROR) is returned and subsequent calls return $(D_INLINECODE GL_NO_ERROR), the context reset was encountered and completed. If a reset status is repeatedly returned, the context may be in the process of resetting. Reset notification behavior is determined at context creation time, and may be queried by calling $(D_INLINECODE GetIntegerv) with the symbolic constant $(D_INLINECODE GL_RESET_NOTIFICATION_STRATEGY). If the reset notification behavior is $(D_INLINECODE GL_NO_RESET_NOTIFICATION), then the implementation will never deliver notification of reset events, and $(D_INLINECODE glGetGraphicsResetStatus) will always return $(D_INLINECODE GL_NO_ERROR). If the behavior is $(D_INLINECODE GL_LOSE_CONTEXT_ON_RESET), a graphics reset will result in the loss of all context state, requiring the recreation of all associated objects. In this case $(D_INLINECODE glGetGraphicsResetStatus) may return any of the values described above. If a graphics reset notification occurs in a context, a notification must also occur in all other contexts which share objects with that context. After a graphics reset has occurred on a context, subsequent GL commands on that context (or any context which shares with that context) will generate a $(D_INLINECODE GL_CONTEXT_LOST) error. Such commands will not have side effects (in particular, they will not modify memory passed by pointer for query results), and will not block indefinitely or cause termination of the application. There are two important exceptions to this behavior: $(OL $(LI $(D_INLINECODE glGetError) and $(D_INLINECODE glGetGraphicsResetStatus) behave normally following a graphics reset, so that the application can determine a reset has occurred, and when it is safe to destroy and re-create the context.) $(LI Any commands which might cause a polling application to block indefinitely will generate a $(D_INLINECODE GL_CONTEXT_LOST) error, but will also return a value indicating completion to the application. Such commands include: $(OL $(LI $(D_INLINECODE glGetSynciv) with pname $(D_INLINECODE GL_SYNC_STATUS) ignores the other parameters and returns $(D_INLINECODE GL_SIGNALED) in $(D_INLINECODE values).) $(LI $(D_INLINECODE glGetQueryObjectuiv) with pname $(D_INLINECODE GL_QUERY_RESULT_AVAILABLE) ignores the other parameters and returns $(D_INLINECODE TRUE) in $(D_INLINECODE params).))))
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetError) $(D_INLINECODE glGetIntegerv), $(D_INLINECODE glGetQueryObjectuiv) $(D_INLINECODE glGetSynciv)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_KHR_robustness")
    fn_glGetGraphicsResetStatus glGetGraphicsResetStatus;
    alias fn_glGetInternalformativ = extern(System) void function(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint* params) @system @nogc nothrow;

    /++
     + glGetInternalformat: man4/glGetInternalformat.xml
     + 
     + $(D_INLINECODE glGetInternalformativ) and $(D_INLINECODE glGetInternalformati64v) retrieve information about implementation-dependent support for internal formats. $(D_INLINECODE target) indicates the target with which the internal format will be used and must be one of $(D_INLINECODE GL_RENDERBUFFER), $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE), or $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY), corresponding to usage as a renderbuffer, two-dimensional multisample texture or two-dimensional multisample array texture, respectively. $(D_INLINECODE internalformat) specifies the internal format about which to retrieve information and must be a color-renderable, depth-renderable or stencil-renderable format. The information retrieved will be written to memory addressed by the pointer specified in $(D_INLINECODE params). No more than $(D_INLINECODE bufSize) basic machine units will be written to this memory. If $(D_INLINECODE pname) is $(D_INLINECODE GL_NUM_SAMPLE_COUNTS), the number of sample counts that would be returned by querying $(D_INLINECODE GL_SAMPLES) will be returned in $(D_INLINECODE params). If $(D_INLINECODE pname) is $(D_INLINECODE GL_SAMPLES), the sample counts supported for $(D_INLINECODE internalformat) and $(D_INLINECODE target) are written into $(D_INLINECODE params) in descending numeric order. Only positive values are returned. Querying $(D_INLINECODE GL_SAMPLES) with $(D_INLINECODE bufSize) of one will return just the maximum supported number of samples for this format. The maximum value in $(D_INLINECODE GL_SAMPLES) is guaranteed to be at least the lowest of the following: $(OL $(LI The value of $(D_INLINECODE GL_MAX_INTEGER_SAMPLES) if $(D_INLINECODE internalformat) is a signed or unsigned integer format.) $(LI The value of $(D_INLINECODE GL_MAX_DEPTH_TEXTURE_SAMPLES) if $(D_INLINECODE internalformat) is a depth- or stencil-renderable format and $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE), $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY).) $(LI The value of $(D_INLINECODE GL_MAX_COLOR_TEXTURE_SAMPLES) if $(D_INLINECODE internalformat) is a color-renderable format and $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE) or $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY).) $(LI The value of $(D_INLINECODE GL_MAX_SAMPLES).)) If $(D_INLINECODE pname) is $(D_INLINECODE GL_INTERNALFORMAT_SUPPORTED), $(D_INLINECODE params) is set to $(D_INLINECODE GL_TRUE) if $(D_INLINECODE internalFormat) is a supported internal format for $(D_INLINECODE target) and to $(D_INLINECODE GL_FALSE) otherwise. If $(D_INLINECODE pname) is $(D_INLINECODE GL_INTERNALFORMAT_PREFERRED), $(D_INLINECODE params) is set to $(D_INLINECODE GL_TRUE) if $(D_INLINECODE internalFormat) is an format for $(D_INLINECODE target) that is preferred by the implementation and to $(D_INLINECODE GL_FALSE) otherwise. If $(D_INLINECODE pname) is $(D_INLINECODE GL_INTERNALFORMAT_RED_SIZE), $(D_INLINECODE GL_INTERNALFORMAT_GREEN_SIZE), $(D_INLINECODE GL_INTERNALFORMAT_BLUE_SIZE), $(D_INLINECODE GL_INTERNALFORMAT_ALPHA_SIZE), $(D_INLINECODE GL_INTERNALFORMAT_DEPTH_SIZE), $(D_INLINECODE GL_INTERNALFORMAT_STENCIL_SIZE), or $(D_INLINECODE GL_INTERNALFORMAT_SHARED_SIZE) then $(D_INLINECODE params) is set to the actual resolutions that would be used for storing image array components for the resource for the red, green, blue, alpha, depth, stencil and shared channels respectively. If $(D_INLINECODE internalFormat) is a compressed internal format, then $(D_INLINECODE params) is set to the component resolution of an uncompressed internal format that produces an image of roughly the same quality as the compressed algorithm. If the internal format is unsupported, or if a particular component is not present in the format, 0 is written to $(D_INLINECODE params). If $(D_INLINECODE pname) is $(D_INLINECODE GL_INTERNALFORMAT_RED_TYPE), $(D_INLINECODE GL_INTERNALFORMAT_GREEN_TYPE), $(D_INLINECODE GL_INTERNALFORMAT_BLUE_TYPE), $(D_INLINECODE GL_INTERNALFORMAT_ALPHA_TYPE), $(D_INLINECODE GL_INTERNALFORMAT_DEPTH_TYPE), or $(D_INLINECODE GL_INTERNALFORMAT_STENCIL_TYPE) then $(D_INLINECODE params) is set to a token identifying the data type used to store the respective component. If the $(D_INLINECODE internalFormat) represents a compressed internal format then the types returned specify how components are interpreted after decompression. If $(D_INLINECODE pname) is $(D_INLINECODE GL_MAX_WIDTH), $(D_INLINECODE GL_MAX_HEIGHT), $(D_INLINECODE GL_MAX_DEPTH), or $(D_INLINECODE GL_MAX_LAYERS) then $(D_INLINECODE pname) is filled with the maximum width, height, depth or layer count for textures with internal format $(D_INLINECODE internalFormat), respectively. If $(D_INLINECODE pname) is $(D_INLINECODE GL_MAX_COMBINED_DIMENSIONS) then $(D_INLINECODE pname) is filled with the maximum combined dimensions of a texture of the specified internal format. If $(D_INLINECODE pname) is $(D_INLINECODE GL_COLOR_COMPONENTS) then $(D_INLINECODE params) is set to the value $(D_INLINECODE GL_TRUE) if the internal format contains any color component (i.e., red, green, blue or alpha) and to $(D_INLINECODE GL_FALSE) otherwise. If $(D_INLINECODE pname) is $(D_INLINECODE GL_DEPTH_COMPONENTS) or $(D_INLINECODE GL_STENCIL_COMPONENTS) then $(D_INLINECODE params) is set to $(D_INLINECODE GL_TRUE) if the internal format contains a depth or stencil component, respectively, and to $(D_INLINECODE GL_FALSE) otherwise. If $(D_INLINECODE pname) is $(D_INLINECODE GL_COLOR_RENDERABLE), $(D_INLINECODE GL_DEPTH_RENDERABLE) or $(D_INLINECODE GL_STENCIL_RENDERABLE) then $(D_INLINECODE params) is set to $(D_INLINECODE GL_TRUE) if the specified internal format is color, depth or stencil renderable, respectively, and to $(D_INLINECODE GL_FALSE) otherwise. If $(D_INLINECODE pname) is $(D_INLINECODE GL_FRAMEBUFFER_RENDERABLE) or $(D_INLINECODE GL_FRAMEBUFFER_RENDERABLE_LAYERED) then $(D_INLINECODE params) is set to one of $(D_INLINECODE GL_FULL_SUPPORT), $(D_INLINECODE GL_CAVEAT_SUPPORT) or $(D_INLINECODE GL_NONE) to indicate that framebuffer attachments (layered attachments in the case of $(D_INLINECODE GL_FRAMEBUFFER_RENDERABLE_LAYERED) ) with that internal format are either renderable with no restrictions, renderable with some restrictions or not renderable at all. If $(D_INLINECODE pname) is $(D_INLINECODE GL_FRAMEBUFFER_BLEND), $(D_INLINECODE params) is set to $(D_INLINECODE GL_TRUE) to indicate that the internal format is supported for blending operations when attached to a framebuffer, and to $(D_INLINECODE GL_FALSE) otherwise. If $(D_INLINECODE pname) is $(D_INLINECODE GL_READ_PIXELS) then $(D_INLINECODE params) is set to $(D_INLINECODE GL_FULL_SUPPORT), $(D_INLINECODE GL_CAVEAT_SUPPORT) or $(D_INLINECODE GL_NONE) to that either full support, limited support or no support at all is supplied for reading pixels from framebuffer attachments in the specified internal format. If $(D_INLINECODE pname) is $(D_INLINECODE GL_READ_PIXELS_FORMAT) or $(D_INLINECODE GL_READ_PIXELS_TYPE) then $(D_INLINECODE params) is filled with the format or type, respectively, most recommended to obtain the highest image quality and performance. For $(D_INLINECODE GL_READ_PIXELS_FORMAT), the value returned in $(D_INLINECODE params) is a token that is accepted for the $(D_INLINECODE format) argument to $(D_INLINECODE glReadPixels). For $(D_INLINECODE GL_READ_PIXELS_TYPE), the value returned in $(D_INLINECODE params) is a token that is accepted for the $(D_INLINECODE type) argument to $(D_INLINECODE glReadPixels). If $(D_INLINECODE pname) is $(D_INLINECODE GL_TEXTURE_IMAGE_FORMAT) or $(D_INLINECODE GL_TEXTURE_IMAGE_TYPE) then $(D_INLINECODE params) is filled with the implementation-recommended format or type to be used in calls to $(D_INLINECODE glTexImage2D) and other similar functions. For $(D_INLINECODE GL_TEXTURE_IMAGE_FORMAT), $(D_INLINECODE params) is filled with a token suitable for use as the $(D_INLINECODE format) argument to $(D_INLINECODE glTexImage2D). For $(D_INLINECODE GL_TEXTURE_IMAGE_TYPE), $(D_INLINECODE params) is filled with a token suitable for use as the $(D_INLINECODE type) argument to $(D_INLINECODE glTexImage2D). If $(D_INLINECODE pname) is $(D_INLINECODE GL_GET_TEXTURE_IMAGE_FORMAT) or $(D_INLINECODE GL_GET_TEXTURE_IMAGE_TYPE) then $(D_INLINECODE params) is filled with the implementation-recommended format or type to be used in calls to $(D_INLINECODE glGetTexImage) and other similar functions. For $(D_INLINECODE GL_GET_TEXTURE_IMAGE_FORMAT), $(D_INLINECODE params) is filled with a token suitable for use as the $(D_INLINECODE format) argument to $(D_INLINECODE glGetTexImage). For $(D_INLINECODE GL_GET_TEXTURE_IMAGE_TYPE), $(D_INLINECODE params) is filled with a token suitable for use as the $(D_INLINECODE type) argument to $(D_INLINECODE glGetTexImage). If $(D_INLINECODE pname) is $(D_INLINECODE GL_MIPMAP) then $(D_INLINECODE pname) is set to $(D_INLINECODE GL_TRUE) to indicate that the specified internal format supports mipmaps and to $(D_INLINECODE GL_FALSE) otherwise. If $(D_INLINECODE pname) is $(D_INLINECODE GL_GENERATE_MIPMAP) or $(D_INLINECODE GL_AUTO_GENERATE_MIPMAP) then $(D_INLINECODE params) is indicates the level of support for manual or automatic mipmap generation for the specified internal format, respectively. Returned values may be one of $(D_INLINECODE GL_FULL_SUPPORT), $(D_INLINECODE GL_CAVEAT_SUPPORT) and $(D_INLINECODE GL_NONE) to indicate either full support, limited support or no support at all. If $(D_INLINECODE pname) is $(D_INLINECODE GL_COLOR_ENCODING) then the color encoding for the resource is returned in $(D_INLINECODE params). Possible values for color buffers are $(D_INLINECODE GL_LINEAR) or $(D_INLINECODE GL_SRGB), for linear or sRGB-encoded color components, respectively. For non-color formats (such as depth or stencil), or for unsupported resources, the value $(D_INLINECODE GL_NONE) is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_SRGB_READ), or $(D_INLINECODE GL_SRGB_WRITE) then $(D_INLINECODE params) indicates the level of support for reading and writing to sRGB encoded images, respectively. For $(D_INLINECODE GL_SRGB_READ), support for converting from sRGB colorspace on read operations is returned in $(D_INLINECODE params) and for $(D_INLINECODE GL_SRGB_WRITE), support for converting to sRGB colorspace on write operations to the resource is returned in $(D_INLINECODE params). $(D_INLINECODE params) may be set to $(D_INLINECODE GL_FULL_SUPPORT), $(D_INLINECODE GL_CAVEAT_SUPPORT), or $(D_INLINECODE GL_NONE) to indicate full support, limited support or no support at all, respecitively. If $(D_INLINECODE pname) is $(D_INLINECODE GL_FILTER) the $(D_INLINECODE params) is set to either $(D_INLINECODE GL_TRUE) or $(D_INLINECODE GL_FALSE) to indicate support or lack thereof for filter modes other than $(D_INLINECODE GL_NEAREST) or $(D_INLINECODE GL_NEAREST_MIPMAP) for the specified internal format. If $(D_INLINECODE pname) is $(D_INLINECODE GL_VERTEX_TEXTURE), $(D_INLINECODE GL_TESS_CONTROL_TEXTURE), $(D_INLINECODE GL_TESS_EVALUATION_TEXTURE), $(D_INLINECODE GL_GEOMETRY_TEXTURE), $(D_INLINECODE GL_FRAGMENT_TEXTURE), or $(D_INLINECODE GL_COMPUTE_TEXTURE), then the value written to $(D_INLINECODE params) indicates support for use of the resource as a source of texturing in the vertex, tessellation control, tessellation evaluation, geometry, fragment and compute shader stages, respectively. $(D_INLINECODE params) may be set to $(D_INLINECODE GL_FULL_SUPPORT), $(D_INLINECODE GL_CAVEAT_SUPPORT) or $(D_INLINECODE GL_NONE) to indicate full support, limited support or no support at all, respectively. If $(D_INLINECODE pname) is $(D_INLINECODE GL_TEXTURE_SHADOW), $(D_INLINECODE GL_TEXTURE_GATHER) or $(D_INLINECODE GL_TEXTURE_GATHER_SHADOW) then the value written to $(D_INLINECODE params) indicates the level of support for using the resource with a shadow sampler, in gather operations or as a shadow sampler in gather operations, respectively. Returned values may be $(D_INLINECODE GL_FULL_SUPPORT), $(D_INLINECODE GL_CAVEAT_SUPPORT) or $(D_INLINECODE GL_NONE) to indicate full support, limited support or no support at all, respectively. If $(D_INLINECODE pname) is $(D_INLINECODE GL_SHADER_IMAGE_LOAD), $(D_INLINECODE GL_SHADER_IMAGE_STORE) or $(D_INLINECODE GL_SHADER_IMAGE_ATOMIC) then the value returned in $(D_INLINECODE params) indicates the level of support for image loads, stores and atomics for resources of the specified internal format. Returned values may be $(D_INLINECODE GL_FULL_SUPPORT), $(D_INLINECODE GL_CAVEAT_SUPPORT) or $(D_INLINECODE GL_NONE) to indicate full support, limited support or no support at all, respectively. If $(D_INLINECODE pname) is $(D_INLINECODE GL_IMAGE_TEXEL_SIZE) then the size of a texel when the resource when used as an image texture is returned in $(D_INLINECODE params). If the resource is not supported for image textures zero is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_IMAGE_COMPATIBILITY_CLASS) then the compatibility class of the resource when used as an image texture is returned in $(D_INLINECODE params). The possible values returned are $(D_INLINECODE GL_IMAGE_CLASS_4_X_32), $(D_INLINECODE GL_IMAGE_CLASS_2_X_32), $(D_INLINECODE GL_IMAGE_CLASS_1_X_32), $(D_INLINECODE GL_IMAGE_CLASS_4_X_16), $(D_INLINECODE GL_IMAGE_CLASS_2_X_16), $(D_INLINECODE GL_IMAGE_CLASS_1_X_16), $(D_INLINECODE GL_IMAGE_CLASS_4_X_8), $(D_INLINECODE GL_IMAGE_CLASS_2_X_8), $(D_INLINECODE GL_IMAGE_CLASS_1_X_8), $(D_INLINECODE GL_IMAGE_CLASS_11_11_10), and $(D_INLINECODE GL_IMAGE_CLASS_10_10_10_2), which correspond to the 4x32, 2x32, 1x32, 4x16, 2x16, 1x16, 4x8, 2x8, 1x8, the class (a) 11/11/10 packed floating-point format, and the class (b) 10/10/10/2 packed formats, respectively. If the resource is not supported for image textures, $(D_INLINECODE GL_NONE) is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_IMAGE_PIXEL_FORMAT) or $(D_INLINECODE GL_IMAGE_PIXEL_TYPE) then the pixel format or type of the resource when used as an image texture is returned in $(D_INLINECODE params), respectively. In either case, the resource is not supported for image textures $(D_INLINECODE GL_NONE) is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_IMAGE_FORMAT_COMPATIBILITY_TYPE), the matching criteria use for the resource when used as an image textures is returned in $(D_INLINECODE params). Possible values returned in $(D_INLINECODE params) are $(D_INLINECODE GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE) or $(D_INLINECODE GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS). If the resource is not supported for image textures, $(D_INLINECODE GL_NONE) is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST) or $(D_INLINECODE GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST), support for using the resource both as a source for texture sampling while it is bound as a buffer for depth or stencil test, respectively, is written to $(D_INLINECODE params). Possible values returned are $(D_INLINECODE GL_FULL_SUPPORT), $(D_INLINECODE GL_CAVEAT_SUPPORT), or $(D_INLINECODE GL_NONE) to indicate full support, limited support or no support at all. If the resource or operation is not supported, $(D_INLINECODE GL_NONE) is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE) or $(D_INLINECODE GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE), support for using the resource both as a source for texture sampling while performing depth or stencil writes to the resources, respectively, is written to $(D_INLINECODE params). Possible values returned are $(D_INLINECODE GL_FULL_SUPPORT), $(D_INLINECODE GL_CAVEAT_SUPPORT), or $(D_INLINECODE GL_NONE) to indicate full support, limited support or no support at all. If the resource or operation is not supported, $(D_INLINECODE GL_NONE) is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_TEXTURE_COMPRESSED) then $(D_INLINECODE GL_TRUE) is returned in $(D_INLINECODE params) if $(D_INLINECODE internalformat) is a compressed internal format. $(D_INLINECODE GL_FALSE) is returned in $(D_INLINECODE params) otherwise. If $(D_INLINECODE pname) is $(D_INLINECODE GL_TEXTURE_COMPRESSED_BLOCK_WIDTH), $(D_INLINECODE GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT) or $(D_INLINECODE GL_TEXTURE_COMPRESSED_BLOCK_SIZE) then the width, height or total size, respectively of a block (in basic machine units) is returned in $(D_INLINECODE params). If the internal format is not compressed, or the resource is not supported, 0 is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_CLEAR_BUFFER), the level of support for using the resource with $(D_INLINECODE glClearBufferData) and $(D_INLINECODE glClearBufferSubData) is returned in $(D_INLINECODE params). Possible values returned are $(D_INLINECODE GL_FULL_SUPPORT), $(D_INLINECODE GL_CAVEAT_SUPPORT), or $(D_INLINECODE GL_NONE) to indicate full support, limited support or no support at all, respectively. If the resource or operation is not supported, $(D_INLINECODE GL_NONE) is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_TEXTURE_VIEW), the level of support for using the resource with the $(D_INLINECODE glTextureView) command is returned in $(D_INLINECODE params). Possible values returned are $(D_INLINECODE GL_FULL_SUPPORT), $(D_INLINECODE GL_CAVEAT_SUPPORT), or $(D_INLINECODE GL_NONE) to indicate full support, limited support or no support at all, respectively. If the resource or operation is not supported, $(D_INLINECODE GL_NONE) is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_VIEW_COMPATIBILITY_CLASS) then the compatibility class of the resource when used as a texture view is returned in $(D_INLINECODE params). The possible values returned are $(D_INLINECODE GL_VIEW_CLASS_128_BITS), $(D_INLINECODE GL_VIEW_CLASS_96_BITS), $(D_INLINECODE GL_VIEW_CLASS_64_BITS), $(D_INLINECODE GL_VIEW_CLASS_48_BITS), $(D_INLINECODE GL_VIEW_CLASS_32_BITS), $(D_INLINECODE GL_VIEW_CLASS_24_BITS), $(D_INLINECODE GL_VIEW_CLASS_16_BITS), $(D_INLINECODE GL_VIEW_CLASS_8_BITS), $(D_INLINECODE GL_VIEW_CLASS_S3TC_DXT1_RGB), $(D_INLINECODE GL_VIEW_CLASS_S3TC_DXT1_RGBA), $(D_INLINECODE GL_VIEW_CLASS_S3TC_DXT3_RGBA), $(D_INLINECODE GL_VIEW_CLASS_S3TC_DXT5_RGBA), $(D_INLINECODE GL_VIEW_CLASS_RGTC1_RED), $(D_INLINECODE GL_VIEW_CLASS_RGTC2_RG), $(D_INLINECODE GL_VIEW_CLASS_BPTC_UNORM), and $(D_INLINECODE GL_VIEW_CLASS_BPTC_FLOAT). If $(D_INLINECODE pname) is $(D_INLINECODE GL_CLEAR_TEXTURE) then the presence of support for using the $(D_INLINECODE glClearTexImage) and $(D_INLINECODE glClearTexSubImage) commands with the resource is written to $(D_INLINECODE params). Possible values written are $(D_INLINECODE GL_FULL_SUPPORT), $(D_INLINECODE GL_CAVEAT_SUPPORT), or $(D_INLINECODE GL_NONE) to indicate full support, limited support or no support at all, respectively. If the resource or operation is not supported, $(D_INLINECODE GL_NONE) is returned.
     + 
     + $(D_INLINECODE glGetInternalformativ) is available only if the GL version is 4.2 or higher. The tokens $(D_INLINECODE GL_INTERNALFORMAT_SUPPORTED), $(D_INLINECODE GL_INTERNALFORMAT_PREFERRED), $(D_INLINECODE GL_INTERNALFORMAT_RED_SIZE), $(D_INLINECODE GL_INTERNALFORMAT_GREEN_SIZE), $(D_INLINECODE GL_INTERNALFORMAT_BLUE_SIZE), $(D_INLINECODE GL_INTERNALFORMAT_ALPHA_SIZE), $(D_INLINECODE GL_INTERNALFORMAT_DEPTH_SIZE), $(D_INLINECODE GL_INTERNALFORMAT_STENCIL_SIZE), $(D_INLINECODE GL_INTERNALFORMAT_SHARED_SIZE), $(D_INLINECODE GL_INTERNALFORMAT_RED_TYPE), $(D_INLINECODE GL_INTERNALFORMAT_GREEN_TYPE), $(D_INLINECODE GL_INTERNALFORMAT_BLUE_TYPE), $(D_INLINECODE GL_INTERNALFORMAT_ALPHA_TYPE), $(D_INLINECODE GL_INTERNALFORMAT_DEPTH_TYPE), $(D_INLINECODE GL_INTERNALFORMAT_STENCIL_TYPE), $(D_INLINECODE GL_MAX_WIDTH), $(D_INLINECODE GL_MAX_HEIGHT), $(D_INLINECODE GL_MAX_DEPTH), $(D_INLINECODE GL_MAX_LAYERS), $(D_INLINECODE GL_MAX_COMBINED_DIMENSIONS), $(D_INLINECODE GL_COLOR_COMPONENTS), $(D_INLINECODE GL_DEPTH_COMPONENTS), $(D_INLINECODE GL_STENCIL_COMPONENTS), $(D_INLINECODE GL_COLOR_RENDERABLE), $(D_INLINECODE GL_DEPTH_RENDERABLE), $(D_INLINECODE GL_STENCIL_RENDERABLE), $(D_INLINECODE GL_FRAMEBUFFER_RENDERABLE), $(D_INLINECODE GL_FRAMEBUFFER_RENDERABLE_LAYERED), $(D_INLINECODE GL_FRAMEBUFFER_BLEND), $(D_INLINECODE GL_READ_PIXELS), $(D_INLINECODE GL_READ_PIXELS_FORMAT), $(D_INLINECODE GL_READ_PIXELS_TYPE), $(D_INLINECODE GL_TEXTURE_IMAGE_FORMAT), $(D_INLINECODE GL_TEXTURE_IMAGE_TYPE), $(D_INLINECODE GL_GET_TEXTURE_IMAGE_FORMAT), $(D_INLINECODE GL_GET_TEXTURE_IMAGE_TYPE), $(D_INLINECODE GL_MIPMAP), $(D_INLINECODE GL_GENERATE_MIPMAP), $(D_INLINECODE GL_AUTO_GENERATE_MIPMAP), $(D_INLINECODE GL_COLOR_ENCODING), $(D_INLINECODE GL_SRGB_READ), $(D_INLINECODE GL_SRGB_WRITE), $(D_INLINECODE GL_SRGB_DECODE_ARB), $(D_INLINECODE GL_FILTER), $(D_INLINECODE GL_VERTEX_TEXTURE), $(D_INLINECODE GL_TESS_CONTROL_TEXTURE), $(D_INLINECODE GL_TESS_EVALUATION_TEXTURE), $(D_INLINECODE GL_GEOMETRY_TEXTURE), $(D_INLINECODE GL_FRAGMENT_TEXTURE), $(D_INLINECODE GL_COMPUTE_TEXTURE), $(D_INLINECODE GL_TEXTURE_SHADOW), $(D_INLINECODE GL_TEXTURE_GATHER), $(D_INLINECODE GL_TEXTURE_GATHER_SHADOW), $(D_INLINECODE GL_SHADER_IMAGE_LOAD), $(D_INLINECODE GL_SHADER_IMAGE_STORE), $(D_INLINECODE GL_SHADER_IMAGE_ATOMIC), $(D_INLINECODE GL_IMAGE_TEXEL_SIZE), $(D_INLINECODE GL_IMAGE_COMPATIBILITY_CLASS), $(D_INLINECODE GL_IMAGE_PIXEL_FORMAT), $(D_INLINECODE GL_IMAGE_PIXEL_TYPE), $(D_INLINECODE GL_IMAGE_FORMAT_COMPATIBILITY_TYPE), $(D_INLINECODE GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST), $(D_INLINECODE GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST), $(D_INLINECODE GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE), $(D_INLINECODE GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE), $(D_INLINECODE GL_TEXTURE_COMPRESSED), $(D_INLINECODE GL_TEXTURE_COMPRESSED_BLOCK_WIDTH), $(D_INLINECODE GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT), $(D_INLINECODE GL_TEXTURE_COMPRESSED_BLOCK_SIZE), $(D_INLINECODE GL_CLEAR_BUFFER), $(D_INLINECODE GL_TEXTURE_VIEW), and $(D_INLINECODE GL_VIEW_COMPATIBILITY_CLASS) are supported only if the GL version is 4.3 or higher. The $(D_INLINECODE GL_CLEAR_TEXTURE) token is accepted for $(D_INLINECODE pname) only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     target         = Indicates the usage of the internal format. $(D_INLINECODE target) must be $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_CUBE_MAP), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY), $(D_INLINECODE GL_TEXTURE_RECTANGLE), $(D_INLINECODE GL_TEXTURE_BUFFER), $(D_INLINECODE GL_RENDERBUFFER), $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE) or $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY).
     +     internalformat = Specifies the internal format about which to retrieve information.
     +     pname          = Specifies the type of information to query.
     +     bufSize        = Specifies the maximum number of basic machine units that may be written to $(D_INLINECODE params) by the function.
     +     params         = Specifies the address of a variable into which to write the retrieved information.
     + 
     + Copyright:
     +     Copyright&copy; 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGet)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P2)
    @OpenGL_Extension("GL_ARB_internalformat_query")
    fn_glGetInternalformativ glGetInternalformativ;
    alias fn_glGetInternalformati64v = extern(System) void function(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_internalformat_query2")
    fn_glGetInternalformati64v glGetInternalformati64v;
    alias fn_glGetMultisamplefv = extern(System) void function(GLenum pname, GLuint index, GLfloat* val) @system @nogc nothrow;

    /++
     + glGetMultisample: man4/glGetMultisample.xml
     + 
     + $(D_INLINECODE glGetMultisamplefv) queries the location of a given sample. $(D_INLINECODE pname) specifies the sample parameter to retrieve and must be $(D_INLINECODE GL_SAMPLE_POSITION). $(D_INLINECODE index) corresponds to the sample for which the location should be returned. The sample location is returned as two floating-point values in $(D_INLINECODE val[0]) and $(D_INLINECODE val[1]), each between 0 and 1, corresponding to the $(D_INLINECODE x) and $(D_INLINECODE y) locations respectively in the GL pixel space of that sample. (0.5, 0.5) this corresponds to the pixel center. $(D_INLINECODE index) must be between zero and the value of $(D_INLINECODE GL_SAMPLES) minus one. If the multisample mode does not have fixed sample locations, the returned values may only reflect the locations of samples within some pixels.
     + 
     + Params:
     +     pname = Specifies the sample parameter name. $(D_INLINECODE pname) must be $(D_INLINECODE GL_SAMPLE_POSITION).
     +     index = Specifies the index of the sample whose position to query.
     +     val   = Specifies the address of an array to receive the position of the sample.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenFramebuffers), $(D_INLINECODE glBindFramebuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_texture_multisample")
    fn_glGetMultisamplefv glGetMultisamplefv;
    alias fn_glGetRenderbufferParameteriv = extern(System) void function(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glGetNamedRenderbufferParameteriv: man4/glGetRenderbufferParameter.xml
     + 
     + $(D_INLINECODE glGetRenderbufferParameteriv) and $(D_INLINECODE glGetNamedRenderbufferParameteriv) query parameters of a specified renderbuffer object. For $(D_INLINECODE glGetRenderbufferParameteriv), the renderbuffer object is that bound to $(D_INLINECODE target), which must be $(D_INLINECODE GL_RENDERBUFFER). For $(D_INLINECODE glGetNamedRenderbufferParameteriv), $(D_INLINECODE renderbuffer) is the name of the renderbuffer object. Upon successful return, $(D_INLINECODE param) will contain the value of the renderbuffer parameter specified by $(D_INLINECODE pname), as described below.
     + 
     + Params:
     +     target       = Specifies the target to which the renderbuffer object is bound for $(D_INLINECODE glGetRenderbufferParameteriv). $(D_INLINECODE target) must be $(D_INLINECODE GL_RENDERBUFFER).
     +     renderbuffer = Specifies the name of the renderbuffer object for $(D_INLINECODE glGetNamedRenderbufferParameteriv).
     +     pname        = Specifies the parameter of the renderbuffer object to query.
     +     params       = Returns the value of parameter $(D_INLINECODE pname) for the renderbuffer object.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenRenderbuffers), $(D_INLINECODE glFramebufferRenderbuffer), $(D_INLINECODE glBindRenderbuffer), $(D_INLINECODE glRenderbufferStorage), $(D_INLINECODE glRenderbufferStorageMultisample)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    fn_glGetRenderbufferParameteriv glGetRenderbufferParameteriv;
    alias fn_glGetNamedRenderbufferParameteriv = extern(System) void function(GLuint renderbuffer, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glGetNamedRenderbufferParameteriv glGetNamedRenderbufferParameteriv;
    alias fn_glGetTexImage = extern(System) void function(GLenum target, GLint level, GLenum format, GLenum type, GLvoid* pixels) @system @nogc nothrow;

    /++
     + glGetnTexImage: man4/glGetTexImage.xml
     + 
     + $(D_INLINECODE glGetTexImage), $(D_INLINECODE glGetnTexImage) and $(D_INLINECODE glGetTextureImage) functions return a texture image into $(D_INLINECODE pixels). For $(D_INLINECODE glGetTexImage) and $(D_INLINECODE glGetnTexImage), $(D_INLINECODE target) specifies whether the desired texture image is one specified by $(D_INLINECODE glTexImage1D) ( $(D_INLINECODE GL_TEXTURE_1D) ), $(D_INLINECODE glTexImage2D) ( $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_RECTANGLE), $(D_INLINECODE GL_TEXTURE_2D) or any of $(D_INLINECODE GL_TEXTURE_CUBE_MAP_*) ), or $(D_INLINECODE glTexImage3D) ( $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY) ). For $(D_INLINECODE glGetTextureImage), $(D_INLINECODE texture) specifies the texture object name. In addition to types of textures accepted by $(D_INLINECODE glGetTexImage) and $(D_INLINECODE glGetnTexImage), the function also accepts cube map texture objects (with effective target $(D_INLINECODE GL_TEXTURE_CUBE_MAP) ). $(D_INLINECODE level) specifies the level-of-detail number of the desired image. $(D_INLINECODE format) and $(D_INLINECODE type) specify the format and type of the desired image array. See the reference page for $(D_INLINECODE glTexImage1D) for a description of the acceptable values for the $(D_INLINECODE format) and $(D_INLINECODE type) parameters, respectively. For glGetnTexImage and glGetTextureImage functions, bufSize tells the size of the buffer to receive the retrieved pixel data. $(D_INLINECODE glGetnTexImage) and $(D_INLINECODE glGetTextureImage) do not write more than $(D_INLINECODE bufSize) bytes into $(D_INLINECODE pixels). If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_PACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is requested, $(D_INLINECODE pixels) is treated as a byte offset into the buffer object's data store. To understand the operation of $(D_INLINECODE glGetTexImage), consider the selected internal four-component texture image to be an RGBA color buffer the size of the image. The semantics of $(D_INLINECODE glGetTexImage) are then identical to those of $(D_INLINECODE glReadPixels), with the exception that no pixel transfer operations are performed, when called with the same $(D_INLINECODE format) and $(D_INLINECODE type), with and set to 0, set to the width of the texture image and set to 1 for 1D images, or to the height of the texture image for 2D images. If the selected texture image does not contain four components, the following mappings are applied. Single-component textures are treated as RGBA buffers with red set to the single-component value, green set to 0, blue set to 0, and alpha set to 1. Two-component textures are treated as RGBA buffers with red set to the value of component zero, alpha set to the value of component one, and green and blue set to 0. Finally, three-component textures are treated as RGBA buffers with red set to component zero, green set to component one, blue set to component two, and alpha set to 1. To determine the required size of $(D_INLINECODE pixels), use $(D_INLINECODE glGetTexLevelParameter) to determine the dimensions of the internal texture image, then scale the required number of pixels by the storage required for each pixel, based on $(D_INLINECODE format) and $(D_INLINECODE type). Be sure to take the pixel storage parameters into account, especially $(D_INLINECODE GL_PACK_ALIGNMENT). If $(D_INLINECODE glGetTextureImage) is used against a cube map texture object, the texture is treated as a three-dimensional image of a depth of 6, where the cube map faces are ordered as image layers, in an order presented in the table below: Layer number Cube Map Face 0 GL_TEXTURE_CUBE_MAP_POSITIVE_X 1 GL_TEXTURE_CUBE_MAP_NEGATIVE_X 2 GL_TEXTURE_CUBE_MAP_POSITIVE_Y 3 GL_TEXTURE_CUBE_MAP_NEGATIVE_Y 4 GL_TEXTURE_CUBE_MAP_POSITIVE_Z 5 GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE pixels). $(D_INLINECODE glGetTexImage) and $(D_INLINECODE glGetnTexImage) return the texture image for the active texture unit. $(D_INLINECODE GL_STENCIL_INDEX) is accepted for $(D_INLINECODE format) only if the GL version is 4.4 or greater.
     + 
     + Params:
     +     target  = Specifies the target to which the texture is bound for $(D_INLINECODE glGetTexImage) and $(D_INLINECODE glGetnTexImage) functions. $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_RECTANGLE), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Z), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Z), and $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY) are acceptable.
     +     texture = Specifies the texture object name.
     +     level   = Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the n th mipmap reduction image.
     +     format  = Specifies a pixel format for the returned data. The supported formats are $(D_INLINECODE GL_STENCIL_INDEX), $(D_INLINECODE GL_DEPTH_COMPONENT), $(D_INLINECODE GL_DEPTH_STENCIL), $(D_INLINECODE GL_RED), $(D_INLINECODE GL_GREEN), $(D_INLINECODE GL_BLUE), $(D_INLINECODE GL_RG), $(D_INLINECODE GL_RGB), $(D_INLINECODE GL_RGBA), $(D_INLINECODE GL_BGR), $(D_INLINECODE GL_BGRA), $(D_INLINECODE GL_RED_INTEGER), $(D_INLINECODE GL_GREEN_INTEGER), $(D_INLINECODE GL_BLUE_INTEGER), $(D_INLINECODE GL_RG_INTEGER), $(D_INLINECODE GL_RGB_INTEGER), $(D_INLINECODE GL_RGBA_INTEGER), $(D_INLINECODE GL_BGR_INTEGER), $(D_INLINECODE GL_BGRA_INTEGER).
     +     type    = Specifies a pixel type for the returned data. The supported types are $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), $(D_INLINECODE GL_SHORT), $(D_INLINECODE GL_UNSIGNED_INT), $(D_INLINECODE GL_INT), $(D_INLINECODE GL_HALF_FLOAT), $(D_INLINECODE GL_FLOAT), $(D_INLINECODE GL_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GL_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GL_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GL_UNSIGNED_INT_10_10_10_2), $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV), $(D_INLINECODE GL_UNSIGNED_INT_24_8), $(D_INLINECODE GL_UNSIGNED_INT_10F_11F_11F_REV), $(D_INLINECODE GL_UNSIGNED_INT_5_9_9_9_REV), and $(D_INLINECODE GL_FLOAT_32_UNSIGNED_INT_24_8_REV).
     +     bufSize = Specifies the size of the buffer $(D_INLINECODE pixels) for $(D_INLINECODE glGetnTexImage) and $(D_INLINECODE glGetTextureImage) functions.
     +     pixels  = Returns the texture image. Should be a pointer to an array of the type specified by $(D_INLINECODE type).
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glReadPixels), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glGetTexImage glGetTexImage;
    alias fn_glGetnTexImage = extern(System) void function(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    fn_glGetnTexImage glGetnTexImage;
    alias fn_glGetTextureImage = extern(System) void function(GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glGetTextureImage glGetTextureImage;
    alias fn_glGetUniformfv = extern(System) void function(GLuint program, GLint location, GLfloat* params) @system @nogc nothrow;

    /++
     + glGetnUniformdv: man4/glGetUniform.xml
     + 
     + $(D_INLINECODE glGetUniform) and $(D_INLINECODE glGetnUniform) return in $(D_INLINECODE params) the value(s) of the specified uniform variable. The type of the uniform variable specified by $(D_INLINECODE location) determines the number of values returned. If the uniform variable is defined in the shader as a boolean, int, or float, a single value will be returned. If it is defined as a vec2, ivec2, or bvec2, two values will be returned. If it is defined as a vec3, ivec3, or bvec3, three values will be returned, and so on. To query values stored in uniform variables declared as arrays, call $(D_INLINECODE glGetUniform) for each element of the array. To query values stored in uniform variables declared as structures, call $(D_INLINECODE glGetUniform) for each field in the structure. The values for uniform variables declared as a matrix will be returned in column major order. The locations assigned to uniform variables are not known until the program object is linked. After linking has occurred, the command $(D_INLINECODE glGetUniformLocation) can be used to obtain the location of a uniform variable. This location value can then be passed to $(D_INLINECODE glGetUniform) or $(D_INLINECODE glGetnUniform) in order to query the current value of the uniform variable. After a program object has been linked successfully, the index values for uniform variables remain fixed until the next link command occurs. The uniform variable values can only be queried after a link if the link was successful. The only difference between $(D_INLINECODE glGetUniform) and $(D_INLINECODE glGetnUniform) is that $(D_INLINECODE glGetnUniform) will generate an error if size of the $(D_INLINECODE params) buffer,as described by $(D_INLINECODE bufSize), is not large enough to hold the result data.
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE params).
     + 
     + Params:
     +     program  = Specifies the program object to be queried.
     +     location = Specifies the location of the uniform variable to be queried.
     +     bufSize  = Specifies the size of the buffer $(D_INLINECODE params).
     +     params   = Returns the value of the specified uniform variable.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCreateProgram), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glUniform)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glGetUniformfv glGetUniformfv;
    alias fn_glGetUniformiv = extern(System) void function(GLuint program, GLint location, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glGetUniformiv glGetUniformiv;
    alias fn_glGetUniformuiv = extern(System) void function(GLuint program, GLint location, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glGetUniformuiv glGetUniformuiv;
    alias fn_glGetUniformdv = extern(System) void function(GLuint program, GLint location, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    fn_glGetUniformdv glGetUniformdv;
    alias fn_glGetnUniformfv = extern(System) void function(GLuint program, GLint location, GLsizei bufSize, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_KHR_robustness")
    fn_glGetnUniformfv glGetnUniformfv;
    alias fn_glGetnUniformiv = extern(System) void function(GLuint program, GLint location, GLsizei bufSize, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_KHR_robustness")
    fn_glGetnUniformiv glGetnUniformiv;
    alias fn_glGetnUniformuiv = extern(System) void function(GLuint program, GLint location, GLsizei bufSize, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_KHR_robustness")
    fn_glGetnUniformuiv glGetnUniformuiv;
    alias fn_glGetnUniformdv = extern(System) void function(GLuint program, GLint location, GLsizei bufSize, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    fn_glGetnUniformdv glGetnUniformdv;
    alias fn_glGetObjectLabel = extern(System) void function(GLenum identifier, GLuint name, GLsizei bifSize, GLsizei* length, char* label) @system @nogc nothrow;

    /++
     + glGetObjectLabel: man4/glGetObjectLabel.xml
     + 
     + $(D_INLINECODE glGetObjectLabel) retrieves the label of the object identified by $(D_INLINECODE name) within the namespace given by $(D_INLINECODE identifier). $(D_INLINECODE identifier) must be one of $(D_INLINECODE GL_BUFFER), $(D_INLINECODE GL_SHADER), $(D_INLINECODE GL_PROGRAM), $(D_INLINECODE GL_VERTEX_ARRAY), $(D_INLINECODE GL_QUERY), $(D_INLINECODE GL_PROGRAM_PIPELINE), $(D_INLINECODE GL_TRANSFORM_FEEDBACK), $(D_INLINECODE GL_SAMPLER), $(D_INLINECODE GL_TEXTURE), $(D_INLINECODE GL_RENDERBUFFER), $(D_INLINECODE GL_FRAMEBUFFER), to indicate the namespace containing the names of buffers, shaders, programs, vertex array objects, query objects, program pipelines, transform feedback objects, samplers, textures, renderbuffers and frame buffers, respectively. $(D_INLINECODE label) is the address of a string that will be used to store the object label. $(D_INLINECODE bufSize) specifies the number of characters in the array identified by $(D_INLINECODE label). $(D_INLINECODE length) contains the address of a variable which will receive the the number of characters in the object label. If $(D_INLINECODE length) is null, then it is ignored and no data is written. Likewise, if
     +  $(D_INLINECODE label) is null, or if
     +  $(D_INLINECODE bufSize) is zero then no data is written to $(D_INLINECODE label).
     + 
     + Params:
     +     identifier = The namespace from which the name of the object is allocated.
     +     name       = The name of the object whose label to retrieve.
     +     bufSize    = The length of the buffer whose address is in $(D_INLINECODE label).
     +     length     = The address of a variable to receive the length of the object label.
     +     label      = The address of a string that will receive the object label.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glPushDebugGroup), $(D_INLINECODE glPopDebugGroup), $(D_INLINECODE glObjectLabel), $(D_INLINECODE glGetObjectPtrLabel).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_KHR_debug")
    fn_glGetObjectLabel glGetObjectLabel;
    alias fn_glGetObjectPtrLabel = extern(System) void function(void* ptr, GLsizei bifSize, GLsizei* length, char* label) @system @nogc nothrow;

    /++
     + glGetObjectPtrLabel: man4/glGetObjectPtrLabel.xml
     + 
     + $(D_INLINECODE glGetObjectPtrLabel) retrieves the label of the sync object identified by $(D_INLINECODE ptr). $(D_INLINECODE label) is the address of a string that will be used to store the object label. $(D_INLINECODE bufSize) specifies the number of characters in the array identified by $(D_INLINECODE label). $(D_INLINECODE length) contains the address of a variable which will receive the the number of characters in the object label. If $(D_INLINECODE length) is null, then it is ignored and no data is written. Likewise, if
     +  $(D_INLINECODE label) is null, or if
     +  $(D_INLINECODE bufSize) is zero then no data is written to $(D_INLINECODE label).
     + 
     + Params:
     +     ptr     = The name of the sync object whose label to retrieve.
     +     bufSize = The length of the buffer whose address is in $(D_INLINECODE label).
     +     length  = The address of a variable to receive the length of the object label.
     +     label   = The address of a string that will receive the object label.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glPushDebugGroup), $(D_INLINECODE glPopDebugGroup), $(D_INLINECODE glObjectLabel), $(D_INLINECODE glGetObjectLabel).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_KHR_debug")
    fn_glGetObjectPtrLabel glGetObjectPtrLabel;
    alias fn_glGetPointerv = extern(System) void function(GLenum pname, GLvoid** params) @system @nogc nothrow;

    /++
     + glGetPointerv: man4/glGetPointerv.xml
     + 
     + $(D_INLINECODE glGetPointerv) returns pointer information. $(D_INLINECODE pname) indicates the pointer to be returned, and $(D_INLINECODE params) is a pointer to a location in which to place the returned data. The parameters that may be queried include:
     + 
     + $(D_INLINECODE glGetPointerv) is available in the OpenGL core profile only if the GL version is 4.3 or later. It is available in the compatibility profile for all GL versions, and accepts additional queries. However, these reference pages document only the core profile.
     + 
     + Params:
     +     pname  = Specifies the pointer to be returned. Must be one of $(D_INLINECODE GL_DEBUG_CALLBACK_FUNCTION) or $(D_INLINECODE GL_DEBUG_CALLBACK_USER_PARAM).
     +     params = Returns the pointer value specified by $(D_INLINECODE pname).
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDebugMessageCallback)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    @OpenGL_Extension("GL_KHR_debug")
    fn_glGetPointerv glGetPointerv;
    alias fn_glGetProgramiv = extern(System) void function(GLuint program, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glGetProgram: man4/glGetProgram.xml
     + 
     + $(D_INLINECODE glGetProgram) returns in $(D_INLINECODE params) the value of a parameter for a specific program object. The following parameters are defined:
     + 
     + $(D_INLINECODE GL_ACTIVE_UNIFORM_BLOCKS) and $(D_INLINECODE GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH) are available only if the GL version 3.1 or greater. $(D_INLINECODE GL_GEOMETRY_VERTICES_OUT), $(D_INLINECODE GL_GEOMETRY_INPUT_TYPE) and $(D_INLINECODE GL_GEOMETRY_OUTPUT_TYPE) are accepted only if the GL version is 3.2 or greater. $(D_INLINECODE GL_COMPUTE_WORK_GROUP_SIZE) is accepted only if the GL version is 4.3 or greater. If an error is generated, no change is made to the contents of $(D_INLINECODE params).
     + 
     + Params:
     +     program = Specifies the program object to be queried.
     +     pname   = Specifies the object parameter. Accepted symbolic names are $(D_INLINECODE GL_DELETE_STATUS), $(D_INLINECODE GL_LINK_STATUS), $(D_INLINECODE GL_VALIDATE_STATUS), $(D_INLINECODE GL_INFO_LOG_LENGTH), $(D_INLINECODE GL_ATTACHED_SHADERS), $(D_INLINECODE GL_ACTIVE_ATOMIC_COUNTER_BUFFERS), $(D_INLINECODE GL_ACTIVE_ATTRIBUTES), $(D_INLINECODE GL_ACTIVE_ATTRIBUTE_MAX_LENGTH), $(D_INLINECODE GL_ACTIVE_UNIFORMS), $(D_INLINECODE GL_ACTIVE_UNIFORM_BLOCKS), $(D_INLINECODE GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH), $(D_INLINECODE GL_ACTIVE_UNIFORM_MAX_LENGTH), $(D_INLINECODE GL_COMPUTE_WORK_GROUP_SIZE) $(D_INLINECODE GL_PROGRAM_BINARY_LENGTH), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER_MODE), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_VARYINGS), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH), $(D_INLINECODE GL_GEOMETRY_VERTICES_OUT), $(D_INLINECODE GL_GEOMETRY_INPUT_TYPE), and $(D_INLINECODE GL_GEOMETRY_OUTPUT_TYPE).
     +     params  = Returns the requested object parameter.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAttachShader), $(D_INLINECODE glCreateProgram), $(D_INLINECODE glDeleteProgram), $(D_INLINECODE glGetShader), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glValidateProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glGetProgramiv glGetProgramiv;
    alias fn_glGetProgramBinary = extern(System) void function(GLuint program, GLsizei bufsize, GLsizei* length, GLenum* binaryFormat, void* binary) @system @nogc nothrow;

    /++
     + glGetProgramBinary: man4/glGetProgramBinary.xml
     + 
     + $(D_INLINECODE glGetProgramBinary) returns a binary representation of the compiled and linked executable for $(D_INLINECODE program) into the array of bytes whose address is specified in $(D_INLINECODE binary). The maximum number of bytes that may be written into $(D_INLINECODE binary) is specified by $(D_INLINECODE bufSize). If the program binary is greater in size than $(D_INLINECODE bufSize) bytes, then an error is generated, otherwise the actual number of bytes written into $(D_INLINECODE binary) is returned in the variable whose address is given by $(D_INLINECODE length). If $(D_INLINECODE length) is $(D_INLINECODE null
     + ), then no length is returned. The format of the program binary written into $(D_INLINECODE binary) is returned in the variable whose address is given by $(D_INLINECODE binaryFormat), and may be implementation dependent. The binary produced by the GL may subsequently be returned to the GL by calling $(D_INLINECODE glProgramBinary), with $(D_INLINECODE binaryFormat) and $(D_INLINECODE length) set to the values returned by $(D_INLINECODE glGetProgramBinary), and passing the returned binary data in the $(D_INLINECODE binary) parameter.
     + 
     + Params:
     +     program      = Specifies the name of a program object whose binary representation to retrieve.
     +     bufSize      = Specifies the size of the buffer whose address is given by $(D_INLINECODE binary).
     +     length       = Specifies the address of a variable to receive the number of bytes written into $(D_INLINECODE binary).
     +     binaryFormat = Specifies the address of a variable to receive a token indicating the format of the binary data returned by the GL.
     +     binary       = Specifies the address an array into which the GL will return $(D_INLINECODE program) 's binary representation.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetProgram), $(D_INLINECODE glProgramBinary)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_get_program_binary")
    fn_glGetProgramBinary glGetProgramBinary;
    alias fn_glGetProgramInfoLog = extern(System) void function(GLuint program, GLsizei maxLength, GLsizei* length, GLchar* infoLog) @system @nogc nothrow;

    /++
     + glGetProgramInfoLog: man4/glGetProgramInfoLog.xml
     + 
     + $(D_INLINECODE glGetProgramInfoLog) returns the information log for the specified program object. The information log for a program object is modified when the program object is linked or validated. The string that is returned will be null terminated. $(D_INLINECODE glGetProgramInfoLog) returns in $(D_INLINECODE infoLog) as much of the information log as it can, up to a maximum of $(D_INLINECODE maxLength) characters. The number of characters actually returned, excluding the null termination character, is specified by $(D_INLINECODE length). If the length of the returned string is not required, a value of $(D_INLINECODE null
     + ) can be passed in the $(D_INLINECODE length) argument. The size of the buffer required to store the returned information log can be obtained by calling $(D_INLINECODE glGetProgram) with the value $(D_INLINECODE GL_INFO_LOG_LENGTH). The information log for a program object is either an empty string, or a string containing information about the last link operation, or a string containing information about the last validation operation. It may contain diagnostic messages, warning messages, and other information. When a program object is created, its information log will be a string of length 0.
     + 
     + The information log for a program object is the OpenGL implementer's primary mechanism for conveying information about linking and validating. Therefore, the information log can be helpful to application developers during the development process, even when these operations are successful. Application developers should not expect different OpenGL implementations to produce identical information logs.
     + 
     + Params:
     +     program   = Specifies the program object whose information log is to be queried.
     +     maxLength = Specifies the size of the character buffer for storing the returned information log.
     +     length    = Returns the length of the string returned in $(D_INLINECODE infoLog) (excluding the null terminator).
     +     infoLog   = Specifies an array of characters that is used to return the information log.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCompileShader), $(D_INLINECODE glGetShaderInfoLog), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glValidateProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glGetProgramInfoLog glGetProgramInfoLog;
    alias fn_glGetProgramInterfaceiv = extern(System) void function(GLuint program, GLenum programInterface, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glGetProgramInterface: man4/glGetProgramInterface.xml
     + 
     + $(D_INLINECODE glGetProgramInterfaceiv) queries the property of the interface identifed by $(D_INLINECODE programInterface) in $(D_INLINECODE program), the property name of which is given by $(D_INLINECODE pname). $(D_INLINECODE program) must be the name of an existing program object. $(D_INLINECODE programInterface) is the name of the interface within $(D_INLINECODE program) to query and must be one of the following values: $(D_INLINECODE pname) identifies the property of $(D_INLINECODE programInterface) to return in $(D_INLINECODE params). If $(D_INLINECODE pname) is $(D_INLINECODE GL_ACTIVE_RESOURCES), the value returned is the number of resources in the active resource list for $(D_INLINECODE programInterface).  If the list of active resources for $(D_INLINECODE programInterface) is empty, zero is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_MAX_NAME_LENGTH), the value returned is the length of the longest active name string for an active resource in $(D_INLINECODE programInterface). This length includes an extra character for the null terminator.  If the list of active resources for $(D_INLINECODE programInterface) is empty, zero is returned.  It is an error to specify $(D_INLINECODE GL_MAX_NAME_LENGTH) when $(D_INLINECODE programInterface) is $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER), as active atomic counter buffer resources are not assigned name strings. If $(D_INLINECODE pname) is $(D_INLINECODE GL_MAX_NUM_ACTIVE_VARIABLES), the value returned is the number of active variables belonging to the interface block or atomic counter buffer resource in $(D_INLINECODE programInterface) with the most active variables.  If the list of active resources for $(D_INLINECODE programInterface) is empty, zero is returned.  When $(D_INLINECODE pname) is $(D_INLINECODE GL_MAX_NUM_ACTIVE_VARIABLES), $(D_INLINECODE programInterface) must be $(D_INLINECODE GL_UNIFORM_BLOCK), $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER), or $(D_INLINECODE GL_SHADER_STORAGE_BLOCK). If $(D_INLINECODE pname) is $(D_INLINECODE GL_MAX_NUM_COMPATIBLE_SUBROUTINES), the value returned is the number of compatible subroutines belonging to the active subroutine uniform in $(D_INLINECODE programInterface) with the most compatible subroutines.  If the list of active resources for $(D_INLINECODE programInterface) is empty, zero is returned. When $(D_INLINECODE pname) is $(D_INLINECODE GL_MAX_NUM_COMPATIBLE_SUBROUTINES), $(D_INLINECODE programInterface) must be one of $(D_INLINECODE GL_VERTEX_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_TESS_CONTROL_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_TESS_EVALUATION_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_GEOMETRY_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_FRAGMENT_SUBROUTINE_UNIFORM), or $(D_INLINECODE GL_COMPUTE_SUBROUTINE_UNIFORM).
     + 
     + Params:
     +     program          = The name of a program object whose interface to query.
     +     programInterface = A token identifying the interface within $(D_INLINECODE program) to query.
     +     pname            = The name of the parameter within $(D_INLINECODE programInterface) to query.
     +     params           = The address of a variable to retrieve the value of $(D_INLINECODE pname) for the program interface.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glPushDebugGroup), $(D_INLINECODE glPopDebugGroup), $(D_INLINECODE glObjectLabel), $(D_INLINECODE glGetObjectLabel).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_program_interface_query")
    fn_glGetProgramInterfaceiv glGetProgramInterfaceiv;
    alias fn_glGetProgramPipelineiv = extern(System) void function(GLuint pipeline, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glGetProgramPipeline: man4/glGetProgramPipeline.xml
     + 
     + $(D_INLINECODE glGetProgramPipelineiv) retrieves the value of a property of the program pipeline object $(D_INLINECODE pipeline). $(D_INLINECODE pname) specifies the name of the parameter whose value to retrieve. The value of the parameter is written to the variable whose address is given by $(D_INLINECODE params). If $(D_INLINECODE pname) is $(D_INLINECODE GL_ACTIVE_PROGRAM), the name of the active program object of the program pipeline object is returned in $(D_INLINECODE params). If $(D_INLINECODE pname) is $(D_INLINECODE GL_VERTEX_SHADER), the name of the current program object for the vertex shader type of the program pipeline object is returned in $(D_INLINECODE params). If $(D_INLINECODE pname) is $(D_INLINECODE GL_TESS_CONTROL_SHADER), the name of the current program object for the tessellation control shader type of the program pipeline object is returned in $(D_INLINECODE params). If $(D_INLINECODE pname) is $(D_INLINECODE GL_TESS_EVALUATION_SHADER), the name of the current program object for the tessellation evaluation shader type of the program pipeline object is returned in $(D_INLINECODE params). If $(D_INLINECODE pname) is $(D_INLINECODE GL_GEOMETRY_SHADER), the name of the current program object for the geometry shader type of the program pipeline object is returned in $(D_INLINECODE params). If $(D_INLINECODE pname) is $(D_INLINECODE GL_FRAGMENT_SHADER), the name of the current program object for the fragment shader type of the program pipeline object is returned in $(D_INLINECODE params). If $(D_INLINECODE pname) is $(D_INLINECODE GL_INFO_LOG_LENGTH), the length of the info log, including the null terminator, is returned in $(D_INLINECODE params). If there is no info log, zero is returned.
     + 
     + Params:
     +     pipeline = Specifies the name of a program pipeline object whose parameter retrieve.
     +     pname    = Specifies the name of the parameter to retrieve.
     +     params   = Specifies the address of a variable into which will be written the value or values of $(D_INLINECODE pname) for $(D_INLINECODE pipeline).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenProgramPipelines), $(D_INLINECODE glBindProgramPipeline), $(D_INLINECODE glDeleteProgramPipelines)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glGetProgramPipelineiv glGetProgramPipelineiv;
    alias fn_glGetProgramPipelineInfoLog = extern(System) void function(GLuint pipeline, GLsizei bufSize, GLsizei* length, GLchar* infoLog) @system @nogc nothrow;

    /++
     + glGetProgramPipelineInfoLog: man4/glGetProgramPipelineInfoLog.xml
     + 
     + $(D_INLINECODE glGetProgramPipelineInfoLog) retrieves the info log for the program pipeline object $(D_INLINECODE pipeline). The info log, including its null terminator, is written into the array of characters whose address is given by $(D_INLINECODE infoLog). The maximum number of characters that may be written into $(D_INLINECODE infoLog) is given by $(D_INLINECODE bufSize), and the actual number of characters written into $(D_INLINECODE infoLog) is returned in the integer whose address is given by $(D_INLINECODE length). If $(D_INLINECODE length) is $(D_INLINECODE null
     + ), no length is returned. The actual length of the info log for the program pipeline may be determined by calling $(D_INLINECODE glGetProgramPipeline) with $(D_INLINECODE pname) set to $(D_INLINECODE GL_INFO_LOG_LENGTH).
     + 
     + Params:
     +     pipeline = Specifies the name of a program pipeline object from which to retrieve the info log.
     +     bufSize  = Specifies the maximum number of characters, including the null terminator, that may be written into $(D_INLINECODE infoLog).
     +     length   = Specifies the address of a variable into which will be written the number of characters written into $(D_INLINECODE infoLog).
     +     infoLog  = Specifies the address of an array of characters into which will be written the info log for $(D_INLINECODE pipeline).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenProgramPipelines), $(D_INLINECODE glBindProgramPipeline), $(D_INLINECODE glDeleteProgramPipelines), $(D_INLINECODE glGetProgramPipeline)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glGetProgramPipelineInfoLog glGetProgramPipelineInfoLog;
    alias fn_glGetProgramResourceiv = extern(System) void function(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const(GLenum)* props, GLsizei bufSize, GLsizei* length, GLint* params) @system @nogc nothrow;

    /++
     + glGetProgramResource: man4/glGetProgramResource.xml
     + 
     + $(D_INLINECODE glGetProgramResourceiv) returns values for multiple properties of a single active resource with an index of $(D_INLINECODE index) in the interface $(D_INLINECODE programInterface) of program object $(D_INLINECODE program).  For each resource, values for $(D_INLINECODE propCount) properties specified by the array $(D_INLINECODE props) are returned. $(D_INLINECODE propCount) may not be zero. An error is generated if any value in $(D_INLINECODE props) is not one of the properties described immediately belowor if any value in $(D_INLINECODE props) is not allowed for $(D_INLINECODE programInterface).  The set of allowed $(D_INLINECODE programInterface) values for each property can be found in the following table: Property Supported Interfaces $(D_INLINECODE GL_NAME_LENGTH) Any except $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) and $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) $(D_INLINECODE GL_TYPE) $(D_INLINECODE GL_UNIFORM), $(D_INLINECODE GL_PROGRAM_INPUT), $(D_INLINECODE GL_PROGRAM_OUTPUT), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_VARYING), $(D_INLINECODE GL_BUFFER_VARIABLE) $(D_INLINECODE GL_ARRAY_SIZE) $(D_INLINECODE GL_UNIFORM), $(D_INLINECODE GL_BUFFER_VARIABLE), $(D_INLINECODE GL_PROGRAM_INPUT), $(D_INLINECODE GL_PROGRAM_OUTPUT, VERTEX_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_TESS_CONTROL_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_TESS_EVALUATION_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_GEOMETRY_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_FRAGMENT_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_COMPUTE_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_VARYING) $(D_INLINECODE GL_OFFSET) $(D_INLINECODE GL_UNIFORM), $(D_INLINECODE GL_BUFFER_VARIABLE), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_VARYING) $(D_INLINECODE GL_BLOCK_INDEX) $(D_INLINECODE GL_UNIFORM), $(D_INLINECODE GL_BUFFER_VARIABLE) $(D_INLINECODE GL_ARRAY_STRIDE) $(D_INLINECODE GL_UNIFORM), $(D_INLINECODE GL_BUFFER_VARIABLE) $(D_INLINECODE GL_MATRIX_STRIDE) $(D_INLINECODE GL_UNIFORM), $(D_INLINECODE GL_BUFFER_VARIABLE) $(D_INLINECODE GL_IS_ROW_MAJOR) $(D_INLINECODE GL_UNIFORM), $(D_INLINECODE GL_BUFFER_VARIABLE) $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER_INDEX) $(D_INLINECODE GL_UNIFORM) $(D_INLINECODE GL_TEXTURE_BUFFER) $(D_INLINECODE GL_BUFFER_BINDING) $(D_INLINECODE GL_UNIFORM_BLOCK), $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER), $(D_INLINECODE GL_SHADER_STORAGE_BLOCK), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) $(D_INLINECODE GL_BUFFER_DATA_SIZE) $(D_INLINECODE GL_UNIFORM_BLOCK), $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER), $(D_INLINECODE GL_SHADER_STORAGE_BLOCK) $(D_INLINECODE GL_NUM_ACTIVE_VARIABLES) $(D_INLINECODE GL_UNIFORM_BLOCK), $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER), $(D_INLINECODE GL_SHADER_STORAGE_BLOCK), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) $(D_INLINECODE GL_ACTIVE_VARIABLES) $(D_INLINECODE GL_UNIFORM_BLOCK), $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER), $(D_INLINECODE GL_SHADER_STORAGE_BLOCK), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) $(D_INLINECODE GL_REFERENCED_BY_VERTEX_SHADER) $(D_INLINECODE GL_UNIFORM), $(D_INLINECODE GL_UNIFORM_BLOCK), $(D_INLINECODE GL_ATOMIC_COUNTER_SHADER), $(D_INLINECODE GL_BUFFER), $(D_INLINECODE GL_SHADER_STORAGE_BLOCK), $(D_INLINECODE GL_BUFFER_VARIABLE), $(D_INLINECODE GL_PROGRAM_INPUT), $(D_INLINECODE GL_PROGRAM_OUTPUT) $(D_INLINECODE GL_REFERENCED_BY_TESS_CONTROL_SHADER) $(D_INLINECODE GL_UNIFORM), $(D_INLINECODE GL_UNIFORM_BLOCK), $(D_INLINECODE GL_ATOMIC_COUNTER_SHADER), $(D_INLINECODE GL_BUFFER), $(D_INLINECODE GL_SHADER_STORAGE_BLOCK), $(D_INLINECODE GL_BUFFER_VARIABLE), $(D_INLINECODE GL_PROGRAM_INPUT), $(D_INLINECODE GL_PROGRAM_OUTPUT) $(D_INLINECODE GL_REFERENCED_BY_TESS_EVALUATION_SHADER) $(D_INLINECODE GL_UNIFORM), $(D_INLINECODE GL_UNIFORM_BLOCK), $(D_INLINECODE GL_ATOMIC_COUNTER_SHADER), $(D_INLINECODE GL_BUFFER), $(D_INLINECODE GL_SHADER_STORAGE_BLOCK), $(D_INLINECODE GL_BUFFER_VARIABLE), $(D_INLINECODE GL_PROGRAM_INPUT), $(D_INLINECODE GL_PROGRAM_OUTPUT) $(D_INLINECODE GL_REFERENCED_BY_GEOMETRY_SHADER) $(D_INLINECODE GL_UNIFORM), $(D_INLINECODE GL_UNIFORM_BLOCK), $(D_INLINECODE GL_ATOMIC_COUNTER_SHADER), $(D_INLINECODE GL_BUFFER), $(D_INLINECODE GL_SHADER_STORAGE_BLOCK), $(D_INLINECODE GL_BUFFER_VARIABLE), $(D_INLINECODE GL_PROGRAM_INPUT), $(D_INLINECODE GL_PROGRAM_OUTPUT) $(D_INLINECODE GL_REFERENCED_BY_FRAGMENT_SHADER) $(D_INLINECODE GL_UNIFORM), $(D_INLINECODE GL_UNIFORM_BLOCK), $(D_INLINECODE GL_ATOMIC_COUNTER_SHADER), $(D_INLINECODE GL_BUFFER), $(D_INLINECODE GL_SHADER_STORAGE_BLOCK), $(D_INLINECODE GL_BUFFER_VARIABLE), $(D_INLINECODE GL_PROGRAM_INPUT), $(D_INLINECODE GL_PROGRAM_OUTPUT) $(D_INLINECODE GL_REFERENCED_BY_COMPUTE_SHADER) $(D_INLINECODE GL_UNIFORM), $(D_INLINECODE GL_UNIFORM_BLOCK), $(D_INLINECODE GL_ATOMIC_COUNTER_SHADER), $(D_INLINECODE GL_BUFFER), $(D_INLINECODE GL_SHADER_STORAGE_BLOCK), $(D_INLINECODE GL_BUFFER_VARIABLE), $(D_INLINECODE GL_PROGRAM_INPUT), $(D_INLINECODE GL_PROGRAM_OUTPUT) $(D_INLINECODE GL_NUM_COMPATIBLE_SUBROUTINES) $(D_INLINECODE GL_VERTEX_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_TESS_CONTROL_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_TESS_EVALUATION_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_GEOMETRY_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_FRAGMENT_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_COMPUTE_SUBROUTINE_UNIFORM) $(D_INLINECODE GL_COMPATIBLE_SUBROUTINES) $(D_INLINECODE GL_VERTEX_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_TESS_CONTROL_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_TESS_EVALUATION_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_GEOMETRY_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_FRAGMENT_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_COMPUTE_SUBROUTINE_UNIFORM) $(D_INLINECODE GL_TOP_LEVEL_ARRAY_SIZE) $(D_INLINECODE GL_BUFFER_VARIABLE) $(D_INLINECODE GL_TOP_LEVEL_ARRAY_STRIDE) $(D_INLINECODE GL_BUFFER_VARIABLE) $(D_INLINECODE GL_LOCATION) $(D_INLINECODE GL_UNIFORM), $(D_INLINECODE GL_PROGRAM_INPUT), $(D_INLINECODE GL_PROGRAM_OUTPUT), $(D_INLINECODE GL_VERTEX_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_TESS_CONTROL_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_TESS_EVALUATION_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_GEOMETRY_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_FRAGMENT_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_COMPUTE_SUBROUTINE_UNIFORM) $(D_INLINECODE GL_LOCATION_INDEX) $(D_INLINECODE GL_PROGRAM_OUTPUT) $(D_INLINECODE GL_IS_PER_PATCH) $(D_INLINECODE GL_PROGRAM_INPUT), $(D_INLINECODE GL_PROGRAM_OUTPUT) $(D_INLINECODE GL_LOCATION_COMPONENT) $(D_INLINECODE GL_PROGRAM_INPUT), $(D_INLINECODE GL_PROGRAM_OUTPUT) $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER_INDEX) $(D_INLINECODE GL_TRANSFORM_FEEDBACK_VARYING) $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE) $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) For the property $(D_INLINECODE GL_NAME_LENGTH), a single integer identifying the length of the name string associated with an active variable, interface block, or subroutine is written to $(D_INLINECODE params).  The name length includes a terminating null character. For the property $(D_INLINECODE GL_TYPE), a single integer identifying the type of an active variable is written to $(D_INLINECODE params).  The integer returned is one of the values found in table 2.16. For the property $(D_INLINECODE GL_ARRAY_SIZE), a single integer identifying the number of active array elements of an active variable is written to $(D_INLINECODE params).  The array size returned is in units of the type associated with the property $(D_INLINECODE GL_TYPE).  For active variables not corresponding to an array of basic types, the value zero is written to $(D_INLINECODE params). For the property $(D_INLINECODE GL_BLOCK_INDEX), a single integer identifying the index of the active interface block containing an active variable is written to $(D_INLINECODE params).  If the variable is not the member of an interface block, the value -1 is written to $(D_INLINECODE params). For the property $(D_INLINECODE GL_OFFSET), a single integer identifying the offset of an active variable is written to $(D_INLINECODE params).  For variables in the $(D_INLINECODE GL_UNIFORM) and $(D_INLINECODE GL_BUFFER_VARIABLE) interfaces that are backed by a buffer object, the value written is the offset of that variable relative to the base of the buffer range holding its value.  For variables in the $(D_INLINECODE GL_TRANSFORM_FEEDBACK_VARYING) interface, the value written is the offset in the transform feedback buffer storage assigned to each vertex captured in transform feedback mode where the value of the variable will be stored.  Such offsets are specified via the $(D_INLINECODE xfb_offset) layout qualifier or assigned according to the variables position in the list of strings passed to $(D_INLINECODE glTransformFeedbackVaryings).  Offsets are expressed in basic machine units. For all variables not recorded in transform feedback mode, including the special names $(D_INLINECODE "gl_NextBuffer"), $(D_INLINECODE "gl_SkipComponents1"), $(D_INLINECODE "gl_SkipComponents2"), $(D_INLINECODE "gl_SkipComponents3"), and $(D_INLINECODE "gl_SkipComponents4"), -1 is written to $(D_INLINECODE params). For the property $(D_INLINECODE GL_ARRAY_STRIDE), a single integer identifying the stride between array elements in an active variable is written to $(D_INLINECODE params).  For active variables declared as an array of basic types, the value written is the difference, in basic machine units, between the offsets of consecutive elements in an array.  For active variables not declared as an array of basic types, zero is written to $(D_INLINECODE params).  For active variables not backed by a buffer object, -1 is written to $(D_INLINECODE params), regardless of the variable type. For the property $(D_INLINECODE GL_MATRIX_STRIDE), a single integer identifying the stride between columns of a column-major matrix or rows of a row-major matrix is written to $(D_INLINECODE params).  For active variables declared a single matrix or array of matrices, the value written is the difference, in basic machine units, between the offsets of consecutive columns or rows in each matrix. For active variables not declared as a matrix or array of matrices, zero is written to $(D_INLINECODE params).  For active variables not backed by a buffer object, -1 is written to $(D_INLINECODE params), regardless of the variable type. For the property $(D_INLINECODE GL_IS_ROW_MAJOR), a single integer identifying whether an active variable is a row-major matrix is written to $(D_INLINECODE params).  For active variables backed by a buffer object, declared as a single matrix or array of matrices, and stored in row-major order, one is written to $(D_INLINECODE params). For all other active variables, zero is written to $(D_INLINECODE params). For the property $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER_INDEX), a single integer identifying the index of the active atomic counter buffer containing an active variable is written to $(D_INLINECODE params).  If the variable is not an atomic counter uniform, the value -1 is written to $(D_INLINECODE params). For the property $(D_INLINECODE GL_BUFFER_BINDING), to index of the buffer binding point associated with the active uniform block, shader storage block, atomic counter buffer or transform feedback buffer is written to $(D_INLINECODE params). For the property $(D_INLINECODE GL_BUFFER_DATA_SIZE), then the implementation-dependent minimum total buffer object size, in basic machine units, required to hold all active variables associated with an active uniform block, shader storage block, or atomic counter buffer is written to $(D_INLINECODE params).  If the final member of an active shader storage block is array with no declared size, the minimum buffer size is computed assuming the array was declared as an array with one element. For the property $(D_INLINECODE GL_NUM_ACTIVE_VARIABLES), the number of active variables associated with an active uniform block, shader storage block, atomic counter buffer or transform feedback buffer is written to $(D_INLINECODE params). For the property $(D_INLINECODE GL_ACTIVE_VARIABLES), an array of active variable indices associated with an active uniform block, shader storage block, atomic counter buffer or transform feedback buffer is written to $(D_INLINECODE params).  The number of values written to $(D_INLINECODE params) for an active resource is given by the value of the property $(D_INLINECODE GL_NUM_ACTIVE_VARIABLES) for the resource. For the properties $(D_INLINECODE GL_REFERENCED_BY_VERTEX_SHADER), $(D_INLINECODE GL_REFERENCED_BY_TESS_CONTROL_SHADER), $(D_INLINECODE GL_REFERENCED_BY_TESS_EVALUATION_SHADER), $(D_INLINECODE GL_REFERENCED_BY_GEOMETRY_SHADER), $(D_INLINECODE GL_REFERENCED_BY_FRAGMENT_SHADER), and $(D_INLINECODE GL_REFERENCED_BY_COMPUTE_SHADER), a single integer is written to $(D_INLINECODE params), identifying whether the active resource is referenced by the vertex, tessellation control, tessellation evaluation, geometry, or fragment shaders, respectively, in the program object.  The value one is written to $(D_INLINECODE params) if an active variable is referenced by the corresponding shader, or if an active uniform block, shader storage block, or atomic counter buffer contains at least one variable referenced by the corresponding shader.  Otherwise, the value zero is written to $(D_INLINECODE params). For the property $(D_INLINECODE GL_TOP_LEVEL_ARRAY_SIZE), a single integer identifying the number of active array elements of the top-level shader storage block member containing to the active variable is written to $(D_INLINECODE params).  If the top-level block member is not declared as an array, the value one is written to $(D_INLINECODE params).  If the top-level block member is an array with no declared size, the value zero is written to $(D_INLINECODE params). For the property $(D_INLINECODE GL_TOP_LEVEL_ARRAY_STRIDE), a single integer identifying the stride between array elements of the top-level shader storage block member containing the active variable is written to $(D_INLINECODE params).  For top-level block members declared as arrays, the value written is the difference, in basic machine units, between the offsets of the active variable for consecutive elements in the top-level array.  For top-level block members not declared as an array, zero is written to $(D_INLINECODE params). For the property $(D_INLINECODE GL_LOCATION), a single integer identifying the assigned location for an active uniform, input, output, or subroutine uniform variable is written to $(D_INLINECODE params).  For input, output, or uniform variables with locations specified by a layout qualifier, the specified location is used.  For vertex shader input or fragment shader output variables without a layout qualifier, the location assigned when a program is linked is written to $(D_INLINECODE params).  For all other input and output variables, the value -1 is written to $(D_INLINECODE params).  For uniforms in uniform blocks, the value -1 is written to $(D_INLINECODE params). For the property $(D_INLINECODE GL_LOCATION_INDEX), a single integer identifying the fragment color index of an active fragment shader output variable is written to $(D_INLINECODE params).  If the active variable is an output for a non-fragment shader, the value -1 will be written to $(D_INLINECODE params). For the property $(D_INLINECODE GL_IS_PER_PATCH), a single integer identifying whether the input or output is a per-patch attribute.  If the active variable is a per-patch attribute (declared with the $(D_INLINECODE patch) qualifier), the value one is written to $(D_INLINECODE params); otherwise, the value zero is written to $(D_INLINECODE params). For the property $(D_INLINECODE GL_LOCATION_COMPONENT), a single integer indicating the first component of the location assigned to an active input or output variable is written to $(D_INLINECODE params).  For input and output variables with a component specified by a $(D_INLINECODE layout) qualifier, the specified component is written. For all other input and output variables, the value zero is written. For the property $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER_INDEX), a single integer identifying the index of the active transform feedback buffer associated with an active variable is written to $(D_INLINECODE params).  For variables corresponding to the special names $(D_INLINECODE "gl_NextBuffer"), $(D_INLINECODE "gl_SkipComponents1"), $(D_INLINECODE "gl_SkipComponents2"), $(D_INLINECODE "gl_SkipComponents3"), and $(D_INLINECODE "gl_SkipComponents4"), -1 is written to $(D_INLINECODE params). For the property $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE), a single integer identifying the stride, in basic machine units, between consecutive vertices written to the transform feedback buffer is written to $(D_INLINECODE params).
     + 
     + Params:
     +     program          = The name of a program object whose resources to query.
     +     programInterface = A token identifying the interface within $(D_INLINECODE program) containing the resource named $(D_INLINECODE name).
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetProgramResourceName), $(D_INLINECODE glGetProgramResourceIndex), $(D_INLINECODE glGetProgramResourceLocation), $(D_INLINECODE glGetProgramResourceLocationIndex).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_program_interface_query")
    fn_glGetProgramResourceiv glGetProgramResourceiv;
    alias fn_glGetProgramResourceIndex = extern(System) GLuint function(GLuint program, GLenum programInterface, const( char*) name) @system @nogc nothrow;

    /++
     + glGetProgramResourceIndex: man4/glGetProgramResourceIndex.xml
     + 
     + $(D_INLINECODE glGetProgramResourceIndex) returns the unsigned integer index assigned to a resource named $(D_INLINECODE name) in the interface type $(D_INLINECODE programInterface) of program object $(D_INLINECODE program). $(D_INLINECODE program) must be the name of an existing program object. $(D_INLINECODE programInterface) is the name of the interface within $(D_INLINECODE program) which contains the resource named $(D_INLINECODE name) and must be one of the following values: If $(D_INLINECODE name) exactly matches the name string of one of the active resources for $(D_INLINECODE programInterface), the index of the matched resource is returned. Additionally, if $(D_INLINECODE name) would exactly match the name string of an active resource if "[0]" were appended to $(D_INLINECODE name), the index of the matched resource is returned.  Otherwise, $(D_INLINECODE name) is considered not to be the name of an active resource, and $(D_INLINECODE GL_INVALID_INDEX) is returned. For the interface $(D_INLINECODE GL_TRANSFORM_FEEDBACK_VARYING), the value $(D_INLINECODE GL_INVALID_INDEX) should be returned when querying the index assigned to the special names $(D_INLINECODE gl_NextBuffer), $(D_INLINECODE gl_SkipComponents1), $(D_INLINECODE gl_SkipComponents2), $(D_INLINECODE gl_SkipComponents3), or $(D_INLINECODE gl_SkipComponents4).
     + 
     + Params:
     +     program          = The name of a program object whose resources to query.
     +     programInterface = A token identifying the interface within $(D_INLINECODE program) containing the resource named $(D_INLINECODE name).
     +     name             = The name of the resource to query the index of.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetProgramResourceName), $(D_INLINECODE glGetProgramResource), $(D_INLINECODE glGetProgramResourceLocation), $(D_INLINECODE glGetProgramResourceLocationIndex).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_program_interface_query")
    fn_glGetProgramResourceIndex glGetProgramResourceIndex;
    alias fn_glGetProgramResourceLocation = extern(System) GLint function(GLuint program, GLenum programInterface, const( char*) name) @system @nogc nothrow;

    /++
     + glGetProgramResourceLocation: man4/glGetProgramResourceLocation.xml
     + 
     + $(D_INLINECODE glGetProgramResourceLocation) returns the location assigned to the variable named $(D_INLINECODE name) in interface $(D_INLINECODE programInterface) of program object $(D_INLINECODE program). $(D_INLINECODE program) must be the name of a program that has been linked successfully. $(D_INLINECODE programInterface) must be one of $(D_INLINECODE GL_UNIFORM), $(D_INLINECODE GL_PROGRAM_INPUT), $(D_INLINECODE GL_PROGRAM_OUTPUT), $(D_INLINECODE GL_VERTEX_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_TESS_CONTROL_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_TESS_EVALUATION_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_GEOMETRY_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_FRAGMENT_SUBROUTINE_UNIFORM), $(D_INLINECODE GL_COMPUTE_SUBROUTINE_UNIFORM), or $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER). The value -1 will be returned if an error occurs, if $(D_INLINECODE name) does not identify an active variable on $(D_INLINECODE programInterface), or if $(D_INLINECODE name) identifies an active variable that does not have a valid location assigned, as described above.  The locations returned by these commands are the same locations returned when querying the $(D_INLINECODE GL_LOCATION) and $(D_INLINECODE GL_LOCATION_INDEX) resource properties. A string provided to $(D_INLINECODE glGetProgramResourceLocation) is considered to match an active variable if: $(OL $(LI the string exactly matches the name of the active variable) $(LI if the string identifies the base name of an active array, where the string would exactly match the name of the variable if the suffix "[0]" were appended to the string) $(LI if the string identifies an active element of the array, where the string ends with the concatenation of the "[" character, an integer identifying an array element, and the "]" character, the integer is less than the number of active elements of the array variable, and where the string would exactly match the enumerated name of the array if the decimal integer were replaced with zero.)) Any other string is considered not to identify an active variable.  If the string specifies an element of an array variable, $(D_INLINECODE glGetProgramResourceLocation) returns the location assigned to that element.  If it specifies the base name of an array, it identifies the resources associated with the first element of the array.
     + 
     + Params:
     +     program          = The name of a program object whose resources to query.
     +     programInterface = A token identifying the interface within $(D_INLINECODE program) containing the resource named $(D_INLINECODE name).
     +     name             = The name of the resource to query the location of.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetProgramResourceName), $(D_INLINECODE glGetProgramResourceIndex), $(D_INLINECODE glGetProgramResource), $(D_INLINECODE glGetProgramResourceLocationIndex).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_program_interface_query")
    fn_glGetProgramResourceLocation glGetProgramResourceLocation;
    alias fn_glGetProgramResourceLocationIndex = extern(System) GLint function(GLuint program, GLenum programInterface, const( char*) name) @system @nogc nothrow;

    /++
     + glGetProgramResourceLocationIndex: man4/glGetProgramResourceLocationIndex.xml
     + 
     + $(D_INLINECODE glGetProgramResourceLocationIndex) returns the fragment color index assigned to the variable named $(D_INLINECODE name) in interface $(D_INLINECODE programInterface) of program object $(D_INLINECODE program). $(D_INLINECODE program) must be the name of a program that has been linked successfully. $(D_INLINECODE programInterface) must be $(D_INLINECODE GL_PROGRAM_OUTPUT). The value -1 will be returned if an error occurs, if $(D_INLINECODE name) does not identify an active variable on $(D_INLINECODE programInterface), or if $(D_INLINECODE name) identifies an active variable that does not have a valid location assigned, as described above.  The locations returned by these commands are the same locations returned when querying the $(D_INLINECODE GL_LOCATION) and $(D_INLINECODE GL_LOCATION_INDEX) resource properties. A string provided to $(D_INLINECODE glGetProgramResourceLocationIndex) is considered to match an active variable if: $(OL $(LI the string exactly matches the name of the active variable) $(LI if the string identifies the base name of an active array, where the string would exactly match the name of the variable if the suffix "[0]" were appended to the string) $(LI if the string identifies an active element of the array, where the string ends with the concatenation of the "[" character, an integer identifying an array element, and the "]" character, the integer is less than the number of active elements of the array variable, and where the string would exactly match the enumerated name of the array if the decimal integer were replaced with zero.)) Any other string is considered not to identify an active variable.  If the string specifies an element of an array variable, $(D_INLINECODE glGetProgramResourceLocation) returns the location assigned to that element.  If it specifies the base name of an array, it identifies the resources associated with the first element of the array.
     + 
     + Params:
     +     program          = The name of a program object whose resources to query.
     +     programInterface = A token identifying the interface within $(D_INLINECODE program) containing the resource named $(D_INLINECODE name).
     +     name             = The name of the resource to query the location of.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetProgramResourceName), $(D_INLINECODE glGetProgramResourceIndex), $(D_INLINECODE glGetProgramResource), $(D_INLINECODE glGetProgramResourceLocationIndex).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_program_interface_query")
    fn_glGetProgramResourceLocationIndex glGetProgramResourceLocationIndex;
    alias fn_glGetProgramResourceName = extern(System) void function(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei* length, char* name) @system @nogc nothrow;

    /++
     + glGetProgramResourceName: man4/glGetProgramResourceName.xml
     + 
     + $(D_INLINECODE glGetProgramResourceName) retrieves the name string assigned to the single active resource with an index of $(D_INLINECODE index) in the interface $(D_INLINECODE programInterface) of program object $(D_INLINECODE program). $(D_INLINECODE index) must be less than the number of entries in the active resource list for $(D_INLINECODE programInterface). $(D_INLINECODE program) must be the name of an existing program object. $(D_INLINECODE programInterface) is the name of the interface within $(D_INLINECODE program) which contains the resource and must be one of the following values: The name string assigned to the active resource identified by $(D_INLINECODE index) is returned as a null-terminated string in the character array whose address is given in $(D_INLINECODE name).  The actual number of characters written into $(D_INLINECODE name), excluding the null terminator, is returned in $(D_INLINECODE length).  If $(D_INLINECODE length) is null, no length is returned.  The maximum
     +  number of characters that may be written into
     +  $(D_INLINECODE name), including the null terminator, is specified by $(D_INLINECODE bufSize).  If the length of the name string is greater than $(D_INLINECODE bufSize), the first $(D_INLINECODE bufSize) -1 characters of the name string will be written to $(D_INLINECODE name), followed by a null terminator.  If $(D_INLINECODE bufSize) is zero, no error will be generated but no characters will be written to $(D_INLINECODE name).  The length of the longest name string for $(D_INLINECODE programInterface) &gt;, including a null terminator, can be queried by calling $(D_INLINECODE glGetProgramInterface) with a $(D_INLINECODE pname) of $(D_INLINECODE GL_MAX_NAME_LENGTH).
     + 
     + Params:
     +     program          = The name of a program object whose resources to query.
     +     programInterface = A token identifying the interface within $(D_INLINECODE program) containing the indexed resource.
     +     index            = The index of the resource within $(D_INLINECODE programInterface) of $(D_INLINECODE program).
     +     bufSize          = The size of the character array whose address is given by $(D_INLINECODE name).
     +     length           = The address of a variable which will receive the length of the resource name.
     +     name             = The address of a character array into which will be written the name of the resource.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetProgramResourceIndex), $(D_INLINECODE glGetProgramResource), $(D_INLINECODE glGetProgramResourceLocation), $(D_INLINECODE glGetProgramResourceLocationIndex).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_program_interface_query")
    fn_glGetProgramResourceName glGetProgramResourceName;
    alias fn_glGetProgramStageiv = extern(System) void function(GLuint program, GLenum shadertype, GLenum pname, GLint* values) @system @nogc nothrow;

    /++
     + glGetProgramStage: man4/glGetProgramStage.xml
     + 
     + $(D_INLINECODE glGetProgramStage) queries a parameter of a shader stage attached to a program object. $(D_INLINECODE program) contains the name of the program to which the shader is attached. $(D_INLINECODE shadertype) specifies the stage from which to query the parameter. $(D_INLINECODE pname) specifies which parameter should be queried. The value or values of the parameter to be queried is returned in the variable whose address is given in $(D_INLINECODE values). If $(D_INLINECODE pname) is $(D_INLINECODE GL_ACTIVE_SUBROUTINE_UNIFORMS), the number of active subroutine variables in the stage is returned in $(D_INLINECODE values). If $(D_INLINECODE pname) is $(D_INLINECODE GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS), the number of active subroutine variable locations in the stage is returned in $(D_INLINECODE values). If $(D_INLINECODE pname) is $(D_INLINECODE GL_ACTIVE_SUBROUTINES), the number of active subroutines in the stage is returned in $(D_INLINECODE values). If $(D_INLINECODE pname) is $(D_INLINECODE GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH), the length of the longest subroutine uniform for the stage is returned in $(D_INLINECODE values). If $(D_INLINECODE pname) is $(D_INLINECODE GL_ACTIVE_SUBROUTINE_MAX_LENGTH), the length of the longest subroutine name for the stage is returned in $(D_INLINECODE values). The returned name length includes space for the null-terminator. If there is no shader present of type $(D_INLINECODE shadertype), the returned value will be consistent with a shader containing no subroutines or subroutine uniforms.
     + 
     + Params:
     +     program    = Specifies the name of the program containing shader stage.
     +     shadertype = Specifies the shader stage from which to query for the subroutine parameter. $(D_INLINECODE shadertype) must be one of $(D_INLINECODE GL_VERTEX_SHADER), $(D_INLINECODE GL_TESS_CONTROL_SHADER), $(D_INLINECODE GL_TESS_EVALUATION_SHADER), $(D_INLINECODE GL_GEOMETRY_SHADER) or $(D_INLINECODE GL_FRAGMENT_SHADER).
     +     pname      = Specifies the parameter of the shader to query. $(D_INLINECODE pname) must be $(D_INLINECODE GL_ACTIVE_SUBROUTINE_UNIFORMS), $(D_INLINECODE GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS), $(D_INLINECODE GL_ACTIVE_SUBROUTINES), $(D_INLINECODE GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH), or $(D_INLINECODE GL_ACTIVE_SUBROUTINE_MAX_LENGTH).
     +     values     = Specifies the address of a variable into which the queried value or values will be placed.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_shader_subroutine")
    fn_glGetProgramStageiv glGetProgramStageiv;
    alias fn_glGetQueryIndexediv = extern(System) void function(GLenum target, GLuint index, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glGetQueryIndexed: man4/glGetQueryIndexed.xml
     + 
     + $(D_INLINECODE glGetQueryIndexediv) returns in $(D_INLINECODE params) a selected parameter of the indexed query object target specified by $(D_INLINECODE target) and $(D_INLINECODE index). $(D_INLINECODE index) specifies the index of the query object target and must be between zero and a target-specific maxiumum. $(D_INLINECODE pname) names a specific query object target parameter.  When $(D_INLINECODE pname) is $(D_INLINECODE GL_CURRENT_QUERY), the name of the currently active query for the specified $(D_INLINECODE index) of $(D_INLINECODE target), or zero if no query is active, will be placed in $(D_INLINECODE params). If $(D_INLINECODE pname) is $(D_INLINECODE GL_QUERY_COUNTER_BITS), the implementation-dependent number of bits used to hold the result of queries for $(D_INLINECODE target) is returned in $(D_INLINECODE params).
     + 
     + The target $(D_INLINECODE GL_ANY_SAMPLES_PASSED_CONSERVATIVE) is available only if the GL version is 4.3 or greater. If an error is generated, no change is made to the contents of $(D_INLINECODE params). Calling $(D_INLINECODE glGetQueryiv) is equivalent to calling $(D_INLINECODE glGetQueryIndexediv) with $(D_INLINECODE index) set to zero.
     + 
     + Params:
     +     target = Specifies a query object target. Must be $(D_INLINECODE GL_SAMPLES_PASSED), $(D_INLINECODE GL_ANY_SAMPLES_PASSED), $(D_INLINECODE GL_ANY_SAMPLES_PASSED_CONSERVATIVE) $(D_INLINECODE GL_PRIMITIVES_GENERATED), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN), $(D_INLINECODE GL_TIME_ELAPSED), or $(D_INLINECODE GL_TIMESTAMP).
     +     index  = Specifies the index of the query object target.
     +     pname  = Specifies the symbolic name of a query object target parameter. Accepted values are $(D_INLINECODE GL_CURRENT_QUERY) or $(D_INLINECODE GL_QUERY_COUNTER_BITS).
     +     params = Returns the requested data.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetQueryObject), $(D_INLINECODE glIsQuery)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_transform_feedback3")
    fn_glGetQueryIndexediv glGetQueryIndexediv;
    alias fn_glGetQueryiv = extern(System) void function(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glGetQueryiv: man4/glGetQueryiv.xml
     + 
     + $(D_INLINECODE glGetQueryiv) returns in $(D_INLINECODE params) a selected parameter of the query object target specified by $(D_INLINECODE target). $(D_INLINECODE pname) names a specific query object target parameter.  When $(D_INLINECODE pname) is $(D_INLINECODE GL_CURRENT_QUERY), the name of the currently active query for $(D_INLINECODE target), or zero if no query is active, will be placed in $(D_INLINECODE params). If $(D_INLINECODE pname) is $(D_INLINECODE GL_QUERY_COUNTER_BITS), the implementation-dependent number of bits used to hold the result of queries for $(D_INLINECODE target) is returned in $(D_INLINECODE params).
     + 
     + The target $(D_INLINECODE GL_ANY_SAMPLES_PASSED_CONSERVATIVE) is available only if the GL version is 4.3 or greater. If an error is generated, no change is made to the contents of $(D_INLINECODE params).
     + 
     + Params:
     +     target = Specifies a query object target. Must be $(D_INLINECODE GL_SAMPLES_PASSED), $(D_INLINECODE GL_ANY_SAMPLES_PASSED), $(D_INLINECODE GL_ANY_SAMPLES_PASSED_CONSERVATIVE) $(D_INLINECODE GL_PRIMITIVES_GENERATED), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN), $(D_INLINECODE GL_TIME_ELAPSED), or $(D_INLINECODE GL_TIMESTAMP).
     +     pname  = Specifies the symbolic name of a query object target parameter. Accepted values are $(D_INLINECODE GL_CURRENT_QUERY) or $(D_INLINECODE GL_QUERY_COUNTER_BITS).
     +     params = Returns the requested data.
     + 
     + Copyright:
     +     Copyright&copy; 2005 Addison-Wesley. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetQueryObject), $(D_INLINECODE glIsQuery)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    fn_glGetQueryiv glGetQueryiv;
    alias fn_glGetQueryObjectiv = extern(System) void function(GLuint id, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glGetQueryObject: man4/glGetQueryObject.xml
     + 
     + $(D_INLINECODE glGetQueryObject) returns in $(D_INLINECODE params) a selected parameter of the query object specified by $(D_INLINECODE id). $(D_INLINECODE pname) names a specific query object parameter. $(D_INLINECODE pname) can be as follows:
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE params). $(D_INLINECODE glGetQueryObject) implicitly flushes the GL pipeline so that any incomplete rendering delimited by the occlusion query completes in finite time. If multiple queries are issued using the same query object $(D_INLINECODE id) before calling $(D_INLINECODE glGetQueryObject), the results of the most recent query will be returned.  In this case, when issuing a new query, the results of the previous query are discarded. $(D_INLINECODE glGetQueryObjecti64v) and $(D_INLINECODE glGetQueryObjectui64v) are available only if the GL version is 3.3 or greater. $(D_INLINECODE GL_QUERY_RESULT_NO_WAIT) is accepted for $(D_INLINECODE pname) only if the GL version is 4.4 or greater. The $(D_INLINECODE GL_QUERY_RESULT_BUFFER) target is available only if the GL version is 4.4 or higher. On earlier versions of the GL, $(D_INLINECODE params) is always an address in client memory.
     + 
     + Params:
     +     id     = Specifies the name of a query object.
     +     pname  = Specifies the symbolic name of a query object parameter. Accepted values are $(D_INLINECODE GL_QUERY_RESULT) or $(D_INLINECODE GL_QUERY_RESULT_AVAILABLE).
     +     params = If a buffer is bound to the $(D_INLINECODE GL_QUERY_RESULT_BUFFER) target, then $(D_INLINECODE params) is treated as an offset to a location within that buffer's data store to receive the result of the query. If no buffer is bound to $(D_INLINECODE GL_QUERY_RESULT_BUFFER), then $(D_INLINECODE params) is treated as an address in client memory of a variable to receive the resulting data.
     + 
     + Copyright:
     +     Copyright&copy; 2005 Addison-Wesley. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBeginQuery), $(D_INLINECODE glEndQuery), $(D_INLINECODE glGetQueryiv), $(D_INLINECODE glIsQuery), $(D_INLINECODE glQueryCounter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    fn_glGetQueryObjectiv glGetQueryObjectiv;
    alias fn_glGetSamplerParameterfv = extern(System) void function(GLuint sampler, GLenum pname, GLfloat* params) @system @nogc nothrow;

    /++
     + glGetSamplerParameter: man4/glGetSamplerParameter.xml
     + 
     + $(D_INLINECODE glGetSamplerParameter) returns in $(D_INLINECODE params) the value or values of the sampler parameter specified as $(D_INLINECODE pname). $(D_INLINECODE sampler) defines the target sampler, and must be the name of an existing sampler object, returned from a previous call to $(D_INLINECODE glGenSamplers). $(D_INLINECODE pname) accepts the same symbols as $(D_INLINECODE glSamplerParameter), with the same interpretations:
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE params). $(D_INLINECODE glGetSamplerParameter) is available only if the GL version is 3.3 or higher.
     + 
     + Params:
     +     sampler = Specifies name of the sampler object from which to retrieve parameters.
     +     pname   = Specifies the symbolic name of a sampler parameter. $(D_INLINECODE GL_TEXTURE_MAG_FILTER), $(D_INLINECODE GL_TEXTURE_MIN_FILTER), $(D_INLINECODE GL_TEXTURE_MIN_LOD), $(D_INLINECODE GL_TEXTURE_MAX_LOD), $(D_INLINECODE GL_TEXTURE_LOD_BIAS), $(D_INLINECODE GL_TEXTURE_WRAP_S), $(D_INLINECODE GL_TEXTURE_WRAP_T), $(D_INLINECODE GL_TEXTURE_WRAP_R), $(D_INLINECODE GL_TEXTURE_BORDER_COLOR), $(D_INLINECODE GL_TEXTURE_COMPARE_MODE), and $(D_INLINECODE GL_TEXTURE_COMPARE_FUNC) are accepted.
     +     params  = Returns the sampler parameters.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glSamplerParameter), $(D_INLINECODE glGenSamplers), $(D_INLINECODE glDeleteSamplers), $(D_INLINECODE glSamplerParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    fn_glGetSamplerParameterfv glGetSamplerParameterfv;
    alias fn_glGetShaderiv = extern(System) void function(GLuint shader, GLenum pname, GLint* params) @system @nogc nothrow;

    /++
     + glGetShader: man4/glGetShader.xml
     + 
     + $(D_INLINECODE glGetShader) returns in $(D_INLINECODE params) the value of a parameter for a specific shader object. The following parameters are defined:
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE params).
     + 
     + Params:
     +     shader = Specifies the shader object to be queried.
     +     pname  = Specifies the object parameter. Accepted symbolic names are $(D_INLINECODE GL_SHADER_TYPE), $(D_INLINECODE GL_DELETE_STATUS), $(D_INLINECODE GL_COMPILE_STATUS), $(D_INLINECODE GL_INFO_LOG_LENGTH), $(D_INLINECODE GL_SHADER_SOURCE_LENGTH).
     +     params = Returns the requested object parameter.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCompileShader), $(D_INLINECODE glCreateShader), $(D_INLINECODE glDeleteShader), $(D_INLINECODE glGetProgram), $(D_INLINECODE glShaderSource)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glGetShaderiv glGetShaderiv;
    alias fn_glGetShaderInfoLog = extern(System) void function(GLuint shader, GLsizei maxLength, GLsizei* length, GLchar* infoLog) @system @nogc nothrow;

    /++
     + glGetShaderInfoLog: man4/glGetShaderInfoLog.xml
     + 
     + $(D_INLINECODE glGetShaderInfoLog) returns the information log for the specified shader object. The information log for a shader object is modified when the shader is compiled. The string that is returned will be null terminated. $(D_INLINECODE glGetShaderInfoLog) returns in $(D_INLINECODE infoLog) as much of the information log as it can, up to a maximum of $(D_INLINECODE maxLength) characters. The number of characters actually returned, excluding the null termination character, is specified by $(D_INLINECODE length). If the length of the returned string is not required, a value of $(D_INLINECODE null
     + ) can be passed in the $(D_INLINECODE length) argument. The size of the buffer required to store the returned information log can be obtained by calling $(D_INLINECODE glGetShader) with the value $(D_INLINECODE GL_INFO_LOG_LENGTH). The information log for a shader object is a string that may contain diagnostic messages, warning messages, and other information about the last compile operation. When a shader object is created, its information log will be a string of length 0.
     + 
     + The information log for a shader object is the OpenGL implementer's primary mechanism for conveying information about the compilation process. Therefore, the information log can be helpful to application developers during the development process, even when compilation is successful. Application developers should not expect different OpenGL implementations to produce identical information logs.
     + 
     + Params:
     +     shader    = Specifies the shader object whose information log is to be queried.
     +     maxLength = Specifies the size of the character buffer for storing the returned information log.
     +     length    = Returns the length of the string returned in $(D_INLINECODE infoLog) (excluding the null terminator).
     +     infoLog   = Specifies an array of characters that is used to return the information log.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCompileShader), $(D_INLINECODE glGetProgramInfoLog), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glValidateProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glGetShaderInfoLog glGetShaderInfoLog;
    alias fn_glGetShaderPrecisionFormat = extern(System) void function(GLenum shaderType, GLenum precisionType, GLint* range, GLint* precision) @system @nogc nothrow;

    /++
     + glGetShaderPrecisionFormat: man4/glGetShaderPrecisionFormat.xml
     + 
     + $(D_INLINECODE glGetShaderPrecisionFormat) retrieves the numeric range and precision for the implementation's representation of quantities in different numeric formats in specified shader type. $(D_INLINECODE shaderType) specifies the type of shader for which the numeric precision and range is to be retrieved and must be one of $(D_INLINECODE GL_VERTEX_SHADER) or $(D_INLINECODE GL_FRAGMENT_SHADER). $(D_INLINECODE precisionType) specifies the numeric format to query and must be one of $(D_INLINECODE GL_LOW_FLOAT), $(D_INLINECODE GL_MEDIUM_FLOAT) $(D_INLINECODE GL_HIGH_FLOAT), $(D_INLINECODE GL_LOW_INT), $(D_INLINECODE GL_MEDIUM_INT), or $(D_INLINECODE GL_HIGH_INT). $(D_INLINECODE range) points to an array of two integers into which the format's numeric range will be returned. If min and max are the smallest values representable in the format, then the values returned are defined to be: $(D_INLINECODE range) [0] = floor(log2(|min|)) and $(D_INLINECODE range) [1] = floor(log2(|max|)). $(D_INLINECODE precision) specifies the address of an integer into which will be written the log2 value of the number of bits of precision of the format. If the smallest representable value greater than 1 is 1 +, then the integer addressed by $(D_INLINECODE precision) will contain floor(-log2(eps)).
     + 
     + Params:
     +     shaderType    = Specifies the type of shader whose precision to query. $(D_INLINECODE shaderType) must be $(D_INLINECODE GL_VERTEX_SHADER) or $(D_INLINECODE GL_FRAGMENT_SHADER).
     +     precisionType = Specifies the numeric format whose precision and range to query.
     +     range         = Specifies the address of array of two integers into which encodings of the implementation's numeric range are returned.
     +     precision     = Specifies the address of an integer into which the numeric precision of the implementation is written.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_ES2_compatibility")
    fn_glGetShaderPrecisionFormat glGetShaderPrecisionFormat;
    alias fn_glGetShaderSource = extern(System) void function(GLuint shader, GLsizei bufSize, GLsizei* length, GLchar* source) @system @nogc nothrow;

    /++
     + glGetShaderSource: man4/glGetShaderSource.xml
     + 
     + $(D_INLINECODE glGetShaderSource) returns the concatenation of the source code strings from the shader object specified by $(D_INLINECODE shader). The source code strings for a shader object are the result of a previous call to $(D_INLINECODE glShaderSource). The string returned by the function will be null terminated. $(D_INLINECODE glGetShaderSource) returns in $(D_INLINECODE source) as much of the source code string as it can, up to a maximum of $(D_INLINECODE bufSize) characters. The number of characters actually returned, excluding the null termination character, is specified by $(D_INLINECODE length). If the length of the returned string is not required, a value of $(D_INLINECODE null
     + ) can be passed in the $(D_INLINECODE length) argument. The size of the buffer required to store the returned source code string can be obtained by calling $(D_INLINECODE glGetShader) with the value $(D_INLINECODE GL_SHADER_SOURCE_LENGTH).
     + 
     + Params:
     +     shader  = Specifies the shader object to be queried.
     +     bufSize = Specifies the size of the character buffer for storing the returned source code string.
     +     length  = Returns the length of the string returned in $(D_INLINECODE source) (excluding the null terminator).
     +     source  = Specifies an array of characters that is used to return the source code string.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCreateShader), $(D_INLINECODE glShaderSource)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glGetShaderSource glGetShaderSource;
    alias fn_glGetString = extern(System) const(GLubyte)* function(GLenum name) @system @nogc nothrow;

    /++
     + glGetString: man4/glGetString.xml
     + 
     + $(D_INLINECODE glGetString) returns a pointer to a static string describing some aspect of the current GL connection. $(D_INLINECODE name) can be one of the following: $(D_INLINECODE glGetStringi) returns a pointer to a static string indexed by $(D_INLINECODE index). $(D_INLINECODE name) can be one of the following: Strings $(D_INLINECODE GL_VENDOR) and $(D_INLINECODE GL_RENDERER) together uniquely specify a platform. They do not change from release to release and should be used by platform-recognition algorithms. The $(D_INLINECODE GL_VERSION) and $(D_INLINECODE GL_SHADING_LANGUAGE_VERSION) strings begin with a version number. The version number uses one of these forms: Vendor-specific information may follow the version number. Its format depends on the implementation, but a space always separates the version number and the vendor-specific information. All strings are null-terminated.
     + 
     + If an error is generated, $(D_INLINECODE glGetString) returns 0. The client and server may support different versions. $(D_INLINECODE glGetString) always returns a compatible version number. The release number always describes the server.
     + 
     + Params:
     +     name  = Specifies a symbolic constant, one of $(D_INLINECODE GL_VENDOR), $(D_INLINECODE GL_RENDERER), $(D_INLINECODE GL_VERSION), or $(D_INLINECODE GL_SHADING_LANGUAGE_VERSION). Additionally, $(D_INLINECODE glGetStringi) accepts the $(D_INLINECODE GL_EXTENSIONS) token.
     +     index = For $(D_INLINECODE glGetStringi), specifies the index of the string to return.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glGetString glGetString;
    alias fn_glGetSubroutineIndex = extern(System) GLuint function(GLuint program, GLenum shadertype, const( GLchar*) name) @system @nogc nothrow;

    /++
     + glGetSubroutineIndex: man4/glGetSubroutineIndex.xml
     + 
     + $(D_INLINECODE glGetSubroutineIndex) returns the index of a subroutine uniform within a shader stage attached to a program object. $(D_INLINECODE program) contains the name of the program to which the shader is attached. $(D_INLINECODE shadertype) specifies the stage from which to query shader subroutine index. $(D_INLINECODE name) contains the null-terminated name of the subroutine uniform whose name to query. If $(D_INLINECODE name) is not the name of a subroutine uniform in the shader stage, $(D_INLINECODE GL_INVALID_INDEX) is returned, but no error is generated. If $(D_INLINECODE name) is the name of a subroutine uniform in the shader stage, a value between zero and the value of $(D_INLINECODE GL_ACTIVE_SUBROUTINES) minus one will be returned. Subroutine indices are assigned using consecutive integers in the range from zero to the value of $(D_INLINECODE GL_ACTIVE_SUBROUTINES) minus one for the shader stage.
     + 
     + Params:
     +     program    = Specifies the name of the program containing shader stage.
     +     shadertype = Specifies the shader stage from which to query for subroutine uniform index. $(D_INLINECODE shadertype) must be one of $(D_INLINECODE GL_VERTEX_SHADER), $(D_INLINECODE GL_TESS_CONTROL_SHADER), $(D_INLINECODE GL_TESS_EVALUATION_SHADER), $(D_INLINECODE GL_GEOMETRY_SHADER) or $(D_INLINECODE GL_FRAGMENT_SHADER).
     +     name       = Specifies the name of the subroutine uniform whose index to query.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetProgram), $(D_INLINECODE glGetActiveSubroutineUniform), $(D_INLINECODE glGetActiveSubroutineUniformName)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_shader_subroutine")
    fn_glGetSubroutineIndex glGetSubroutineIndex;
    alias fn_glGetSubroutineUniformLocation = extern(System) GLint function(GLuint program, GLenum shadertype, const( GLchar*) name) @system @nogc nothrow;

    /++
     + glGetSubroutineUniformLocation: man4/glGetSubroutineUniformLocation.xml
     + 
     + $(D_INLINECODE glGetSubroutineUniformLocation) returns the location of the subroutine uniform variable $(D_INLINECODE name) in the shader stage of type $(D_INLINECODE shadertype) attached to $(D_INLINECODE program), with behavior otherwise identical to $(D_INLINECODE glGetUniformLocation). If $(D_INLINECODE name) is not the name of a subroutine uniform in the shader stage, -1 is returned, but no error is generated. If $(D_INLINECODE name) is the name of a subroutine uniform in the shader stage, a value between zero and the value of $(D_INLINECODE GL_ACTIVE_SUBROUTINE_LOCATIONS) minus one will be returned. Subroutine locations are assigned using consecutive integers in the range from zero to the value of $(D_INLINECODE GL_ACTIVE_SUBROUTINE_LOCATIONS) minus one for the shader stage.  For active subroutine uniforms declared as arrays, the declared array elements are assigned consecutive locations.
     + 
     + Params:
     +     program    = Specifies the name of the program containing shader stage.
     +     shadertype = Specifies the shader stage from which to query for subroutine uniform index. $(D_INLINECODE shadertype) must be one of $(D_INLINECODE GL_VERTEX_SHADER), $(D_INLINECODE GL_TESS_CONTROL_SHADER), $(D_INLINECODE GL_TESS_EVALUATION_SHADER), $(D_INLINECODE GL_GEOMETRY_SHADER) or $(D_INLINECODE GL_FRAGMENT_SHADER).
     +     name       = Specifies the name of the subroutine uniform whose index to query.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetProgram), $(D_INLINECODE glGetActiveSubroutineUniform), $(D_INLINECODE glGetActiveSubroutineUniformName), $(D_INLINECODE glGetUniformLocation)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_shader_subroutine")
    fn_glGetSubroutineUniformLocation glGetSubroutineUniformLocation;
    alias fn_glGetSynciv = extern(System) void function(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei* length, GLint* values) @system @nogc nothrow;

    /++
     + glGetSync: man4/glGetSync.xml
     + 
     + $(D_INLINECODE glGetSynciv) retrieves properties of a sync object. $(D_INLINECODE sync) specifies the name of the sync object whose properties to retrieve. On success, $(D_INLINECODE glGetSynciv) replaces up to $(D_INLINECODE bufSize) integers in $(D_INLINECODE values) with the corresponding property values of the object being queried.  The actual number of integers replaced is returned in the variable whose address is specified in $(D_INLINECODE length). If $(D_INLINECODE length) is $(D_INLINECODE null
     + ), no length is returned. If $(D_INLINECODE pname) is $(D_INLINECODE GL_OBJECT_TYPE), a single value representing the specific type of the sync object is placed in $(D_INLINECODE values). The only type supported is $(D_INLINECODE GL_SYNC_FENCE). If $(D_INLINECODE pname) is $(D_INLINECODE GL_SYNC_STATUS), a single value representing the status of the sync object ( $(D_INLINECODE GL_SIGNALED) or $(D_INLINECODE GL_UNSIGNALED) ) is placed in $(D_INLINECODE values). If $(D_INLINECODE pname) is $(D_INLINECODE GL_SYNC_CONDITION), a single value representing the condition of the sync object is placed in $(D_INLINECODE values). The only condition supported is $(D_INLINECODE GL_SYNC_GPU_COMMANDS_COMPLETE). If $(D_INLINECODE pname) is $(D_INLINECODE GL_SYNC_FLAGS), a single value representing the flags with which the sync object was created is placed in $(D_INLINECODE values). No flags are currently supported $(D_INLINECODE flags) is expected to be used in future extensions to the sync objects.. If an error occurs, nothing will be written to $(D_INLINECODE values) or $(D_INLINECODE length).
     + 
     + Params:
     +     sync    = Specifies the sync object whose properties to query.
     +     pname   = Specifies the parameter whose value to retrieve from the sync object specified in $(D_INLINECODE sync).
     +     bufSize = Specifies the size of the buffer whose address is given in $(D_INLINECODE values).
     +     length  = Specifies the address of an variable to receive the number of integers placed in $(D_INLINECODE values).
     +     values  = Specifies the address of an array to receive the values of the queried parameter.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glFenceSync), $(D_INLINECODE glWaitSync), $(D_INLINECODE glClientWaitSync)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_sync")
    fn_glGetSynciv glGetSynciv;
    alias fn_glGetTexLevelParameterfv = extern(System) void function(GLenum target, GLint level, GLenum pname, GLfloat* params) @system @nogc nothrow;

    /++
     + glGetTexLevelParameter: man4/glGetTexLevelParameter.xml
     + 
     + $(D_INLINECODE glGetTexLevelParameterfv), $(D_INLINECODE glGetTexLevelParameteriv), $(D_INLINECODE glGetTextureLevelParameterfv) and $(D_INLINECODE glGetTextureLevelParameteriv) return in $(D_INLINECODE params) texture parameter values for a specific level-of-detail value, specified as $(D_INLINECODE level). For the first two functions, $(D_INLINECODE target) defines the target texture, either $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_PROXY_TEXTURE_1D), $(D_INLINECODE GL_PROXY_TEXTURE_2D), $(D_INLINECODE GL_PROXY_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Z), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Z), or $(D_INLINECODE GL_PROXY_TEXTURE_CUBE_MAP). The remaining two take a $(D_INLINECODE texture) argument which specifies the name of the texture object. $(D_INLINECODE GL_MAX_TEXTURE_SIZE), and $(D_INLINECODE GL_MAX_3D_TEXTURE_SIZE) are not really descriptive enough. It has to report the largest square texture image that can be accommodated with mipmaps but a long skinny texture, or a texture without mipmaps may easily fit in texture memory. The proxy targets allow the user to more accurately query whether the GL can accommodate a texture of a given configuration. If the texture cannot be accommodated, the texture state variables, which may be queried with $(D_INLINECODE glGetTexLevelParameter) and $(D_INLINECODE glGetTextureLevelParameter), are set to 0. If the texture can be accommodated, the texture state values will be set as they would be set for a non-proxy target. $(D_INLINECODE pname) specifies the texture parameter whose value or values will be returned. The accepted parameter names are as follows:
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE params). $(D_INLINECODE glGetTexLevelParameter) returns the texture level parameters for the active texture unit. $(D_INLINECODE GL_TEXTURE_BUFFER_OFFSET) and $(D_INLINECODE GL_TEXTURE_BUFFER_SIZE) are available only if the GL version is 4.3 or greater.
     + 
     + Params:
     +     target  = Specifies the target to which the texture is bound for $(D_INLINECODE glGetTexLevelParameterfv) and $(D_INLINECODE glGetTexLevelParameteriv) functions. Must be one of the following values: $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_RECTANGLE), $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE), $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Z), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Z), $(D_INLINECODE GL_PROXY_TEXTURE_1D), $(D_INLINECODE GL_PROXY_TEXTURE_2D), $(D_INLINECODE GL_PROXY_TEXTURE_3D), $(D_INLINECODE GL_PROXY_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_PROXY_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_PROXY_TEXTURE_RECTANGLE), $(D_INLINECODE GL_PROXY_TEXTURE_2D_MULTISAMPLE), $(D_INLINECODE GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY), $(D_INLINECODE GL_PROXY_TEXTURE_CUBE_MAP), or $(D_INLINECODE GL_TEXTURE_BUFFER).
     +     texture = Specifies the texture object name for $(D_INLINECODE glGetTextureLevelParameterfv) and $(D_INLINECODE glGetTextureLevelParameteriv) functions.
     +     level   = Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n is the n th mipmap reduction image.
     +     pname   = Specifies the symbolic name of a texture parameter. $(D_INLINECODE GL_TEXTURE_WIDTH), $(D_INLINECODE GL_TEXTURE_HEIGHT), $(D_INLINECODE GL_TEXTURE_DEPTH), $(D_INLINECODE GL_TEXTURE_INTERNAL_FORMAT), $(D_INLINECODE GL_TEXTURE_RED_SIZE), $(D_INLINECODE GL_TEXTURE_GREEN_SIZE), $(D_INLINECODE GL_TEXTURE_BLUE_SIZE), $(D_INLINECODE GL_TEXTURE_ALPHA_SIZE), $(D_INLINECODE GL_TEXTURE_DEPTH_SIZE), $(D_INLINECODE GL_TEXTURE_COMPRESSED), $(D_INLINECODE GL_TEXTURE_COMPRESSED_IMAGE_SIZE), and $(D_INLINECODE GL_TEXTURE_BUFFER_OFFSET) are accepted.
     +     params  = Returns the requested data.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glGetTexParameter), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glGetTexLevelParameterfv glGetTexLevelParameterfv;
    alias fn_glGetTexLevelParameteriv = extern(System) void function(GLenum target, GLint level, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glGetTexLevelParameteriv glGetTexLevelParameteriv;
    alias fn_glGetTextureLevelParameterfv = extern(System) void function(GLuint texture, GLint level, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glGetTextureLevelParameterfv glGetTextureLevelParameterfv;
    alias fn_glGetTextureLevelParameteriv = extern(System) void function(GLuint texture, GLint level, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glGetTextureLevelParameteriv glGetTextureLevelParameteriv;
    alias fn_glGetTexParameterfv = extern(System) void function(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;

    /++
     + glGetTexParameter: man4/glGetTexParameter.xml
     + 
     + $(D_INLINECODE glGetTexParameter) and $(D_INLINECODE glGetTextureParameter) return in $(D_INLINECODE params) the value or values of the texture parameter specified as $(D_INLINECODE pname). $(D_INLINECODE target) defines the target texture. $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_RECTANGLE), $(D_INLINECODE GL_TEXTURE_CUBE_MAP), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY), $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE), or $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY) specify one-, two-, or three-dimensional, one-dimensional array, two-dimensional array, rectangle, cube-mapped or cube-mapped array, two-dimensional multisample, or two-dimensional multisample array texturing, respectively. $(D_INLINECODE pname) accepts the same symbols as $(D_INLINECODE glTexParameter), with the same interpretations: In addition to the parameters that may be set with $(D_INLINECODE glTexParameter), $(D_INLINECODE glGetTexParameter) and $(D_INLINECODE glGetTextureParameter) accept the following read-only parameters:
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE params). $(D_INLINECODE GL_IMAGE_FORMAT_COMPATIBILITY_TYPE) is available only if the GL version is 4.2 or greater. $(D_INLINECODE GL_DEPTH_STENCIL_TEXTURE_MODE), $(D_INLINECODE GL_TEXTURE_VIEW_MIN_LEVEL), $(D_INLINECODE GL_TEXTURE_VIEW_NUM_LEVELS), $(D_INLINECODE GL_TEXTURE_VIEW_MIN_LAYER), $(D_INLINECODE GL_TEXTURE_VIEW_NUM_LAYERS) and $(D_INLINECODE GL_TEXTURE_IMMUTABLE_LEVELS) are available only if the GL version is 4.3 or greater. $(D_INLINECODE GL_TEXTURE_TARGET) are available only if the GL version is 4.5 or greater.
     + 
     + Params:
     +     target  = Specifies the target to which the texture is bound for $(D_INLINECODE glGetTexParameterfv), $(D_INLINECODE glGetTexParameteriv), $(D_INLINECODE glGetTexParameterIiv), and $(D_INLINECODE glGetTexParameterIuiv) functions. $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE), $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_CUBE_MAP), $(D_INLINECODE GL_TEXTURE_RECTANGLE), and $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY) are accepted.
     +     texture = Specifies the texture object name for $(D_INLINECODE glGetTextureParameterfv), $(D_INLINECODE glGetTextureParameteriv), $(D_INLINECODE glGetTextureParameterIiv), and $(D_INLINECODE glGetTextureParameterIuiv) functions.
     +     pname   = Specifies the symbolic name of a texture parameter. $(D_INLINECODE GL_DEPTH_STENCIL_TEXTURE_MODE), $(D_INLINECODE GL_IMAGE_FORMAT_COMPATIBILITY_TYPE), $(D_INLINECODE GL_TEXTURE_BASE_LEVEL), $(D_INLINECODE GL_TEXTURE_BORDER_COLOR), $(D_INLINECODE GL_TEXTURE_COMPARE_MODE), $(D_INLINECODE GL_TEXTURE_COMPARE_FUNC), $(D_INLINECODE GL_TEXTURE_IMMUTABLE_FORMAT), $(D_INLINECODE GL_TEXTURE_IMMUTABLE_LEVELS), $(D_INLINECODE GL_TEXTURE_LOD_BIAS), $(D_INLINECODE GL_TEXTURE_MAG_FILTER), $(D_INLINECODE GL_TEXTURE_MAX_LEVEL), $(D_INLINECODE GL_TEXTURE_MAX_LOD), $(D_INLINECODE GL_TEXTURE_MIN_FILTER), $(D_INLINECODE GL_TEXTURE_MIN_LOD), $(D_INLINECODE GL_TEXTURE_SWIZZLE_R), $(D_INLINECODE GL_TEXTURE_SWIZZLE_G), $(D_INLINECODE GL_TEXTURE_SWIZZLE_B), $(D_INLINECODE GL_TEXTURE_SWIZZLE_A), $(D_INLINECODE GL_TEXTURE_SWIZZLE_RGBA), $(D_INLINECODE GL_TEXTURE_TARGET), $(D_INLINECODE GL_TEXTURE_VIEW_MIN_LAYER), $(D_INLINECODE GL_TEXTURE_VIEW_MIN_LEVEL), $(D_INLINECODE GL_TEXTURE_VIEW_NUM_LAYERS), $(D_INLINECODE GL_TEXTURE_VIEW_NUM_LEVELS), $(D_INLINECODE GL_TEXTURE_WRAP_S), $(D_INLINECODE GL_TEXTURE_WRAP_T), and $(D_INLINECODE GL_TEXTURE_WRAP_R) are accepted.
     +     params  = Returns the texture parameters.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glTexParameter), $(D_INLINECODE glTextureParameter), $(D_INLINECODE glTexStorage1D), $(D_INLINECODE glTexStorage2D), $(D_INLINECODE glTexStorage3D), $(D_INLINECODE glTextureStorage1D), $(D_INLINECODE glTextureStorage2D), $(D_INLINECODE glTextureStorage3D), $(D_INLINECODE glTextureView)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glGetTexParameterfv glGetTexParameterfv;
    alias fn_glGetTexParameteriv = extern(System) void function(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glGetTexParameteriv glGetTexParameteriv;
    alias fn_glGetTexParameterIiv = extern(System) void function(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glGetTexParameterIiv glGetTexParameterIiv;
    alias fn_glGetTexParameterIuiv = extern(System) void function(GLenum target, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glGetTexParameterIuiv glGetTexParameterIuiv;
    alias fn_glGetTextureParameterfv = extern(System) void function(GLuint texture, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glGetTextureParameterfv glGetTextureParameterfv;
    alias fn_glGetTextureParameteriv = extern(System) void function(GLuint texture, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glGetTextureParameteriv glGetTextureParameteriv;
    alias fn_glGetTextureParameterIiv = extern(System) void function(GLuint texture, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glGetTextureParameterIiv glGetTextureParameterIiv;
    alias fn_glGetTextureParameterIuiv = extern(System) void function(GLuint texture, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glGetTextureParameterIuiv glGetTextureParameterIuiv;
    alias fn_glGetTextureSubImage = extern(System) void function(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void* pixels) @system @nogc nothrow;

    /++
     + glGetTextureSubImage: man4/glGetTextureSubImage.xml
     + 
     + $(D_INLINECODE glGetTextureSubImage) returns a texture subimage into pixels. $(D_INLINECODE texture) is the name of the source texture object and must not be a buffer or multisample texture. The effective $(D_INLINECODE target) parameter is the value of $(D_INLINECODE GL_TEXTURE_TARGET) for texture. $(D_INLINECODE Level), $(D_INLINECODE format), $(D_INLINECODE type) and $(D_INLINECODE pixels) have the same meaning as for $(D_INLINECODE glGetTexImage). $(D_INLINECODE bufSize) is the size of the buffer to receive the retrieved pixel data. For cube map textures, the behavior is as though $(D_INLINECODE GetTextureImage) were called, but only texels from the requested cube map faces (selected by $(D_INLINECODE zoffset) and $(D_INLINECODE depth), as described below) were returned. $(D_INLINECODE xoffset), $(D_INLINECODE yoffset) and $(D_INLINECODE zoffset) values indicate the position of the subregion to return. $(D_INLINECODE width), $(D_INLINECODE height) and $(D_INLINECODE depth) indicate the size of the region to return. These parameters have the same meaning as for $(D_INLINECODE glTexSubImage3D), though for one- and two-dimensional textures there are extra restrictions, described in the errors section below. For one-dimensional array textures, $(D_INLINECODE yoffset) is interpreted as the first layer to access and $(D_INLINECODE height) is the number of layers to access. For two-dimensional array textures, $(D_INLINECODE zoffset) is interpreted as the first layer to access and $(D_INLINECODE depth) is the number of layers to access. Cube map textures are treated as an array of six slices in the z-dimension, where the value of $(D_INLINECODE zoffset) is interpreted as specifying the cube map face for the corresponding layer (as presented in the table below) and $(D_INLINECODE depth) is the number of faces to access: Layer number Cube Map Face 0 GL_TEXTURE_CUBE_MAP_POSITIVE_X 1 GL_TEXTURE_CUBE_MAP_NEGATIVE_X 2 GL_TEXTURE_CUBE_MAP_POSITIVE_Y 3 GL_TEXTURE_CUBE_MAP_NEGATIVE_Y 4 GL_TEXTURE_CUBE_MAP_POSITIVE_Z 5 GL_TEXTURE_CUBE_MAP_NEGATIVE_Z For cube map array textures, $(D_INLINECODE zoffset) is the first layer-face to access, and $(D_INLINECODE depth) is the number of layer-faces to access. A layer-face described by $k$ is translated into an array layer and face according to $$ layer = \left\lfloor { layer \over 6 } \right\rfloor$$ and $$ face = k \bmod 6. $$ Component groups from the specified sub-region are packed and placed into memory as described for $(D_INLINECODE glGetTextureImage), starting with the texel at ( $(D_INLINECODE xoffset), $(D_INLINECODE yoffset), $(D_INLINECODE zoffset) ).
     + 
     + Params:
     +     texture = Specifies the name of the source texture object. Must be $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_CUBE_MAP), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY) or $(D_INLINECODE GL_TEXTURE_RECTANGLE). In specific, buffer and multisample textures are not permitted.
     +     level   = Specifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the $n$th mipmap reduction image.
     +     xoffset = Specifies a texel offset in the x direction within the texture array.
     +     yoffset = Specifies a texel offset in the y direction within the texture array.
     +     zoffset = Specifies a texel offset in the z direction within the texture array.
     +     width   = Specifies the width of the texture subimage.
     +     height  = Specifies the height of the texture subimage.
     +     depth   = Specifies the depth of the texture subimage.
     +     format  = Specifies the format of the pixel data. The following symbolic values are accepted: $(D_INLINECODE GL_RED), $(D_INLINECODE GL_RG), $(D_INLINECODE GL_RGB), $(D_INLINECODE GL_BGR), $(D_INLINECODE GL_RGBA), $(D_INLINECODE GL_BGRA), $(D_INLINECODE GL_DEPTH_COMPONENT) and $(D_INLINECODE GL_STENCIL_INDEX).
     +     type    = Specifies the data type of the pixel data. The following symbolic values are accepted: $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), $(D_INLINECODE GL_SHORT), $(D_INLINECODE GL_UNSIGNED_INT), $(D_INLINECODE GL_INT), $(D_INLINECODE GL_FLOAT), $(D_INLINECODE GL_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GL_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GL_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GL_UNSIGNED_INT_10_10_10_2), and $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV).
     +     bufSize = Specifies the size of the buffer to receive the retrieved pixel data.
     +     pixels  = Returns the texture subimage. Should be a pointer to an array of the type specified by $(D_INLINECODE type).
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetTexImage), $(D_INLINECODE glGetTextureImage), $(D_INLINECODE glReadPixels), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_get_texture_sub_image")
    fn_glGetTextureSubImage glGetTextureSubImage;
    alias fn_glGetTransformFeedbackiv = extern(System) void function(GLuint xfb, GLenum pname, GLint* param) @system @nogc nothrow;

    /++
     + glGetTransformFeedback: man4/glGetTransformFeedback.xml
     + 
     + In order to use the Transform Feedback functionality, you need to configure the Transform Feedback Buffer indexed bindings. This can be achieved by either using $(D_INLINECODE glBindBufferBase) or $(D_INLINECODE glBindBuffersBase) to associate whole buffer object storage to one of the Transform Feedback Binding Points, or by calling $(D_INLINECODE glBindBufferRange) or $(D_INLINECODE glBindBuffersRange) to use a region of a buffer object storage for the binding. You may want to (but are not required to) bind a Transform Feedback Object first, in order to cache the binding configuration. This usually allows you to restore the Transform Feedback configuration faster, than if you were to execute a list of API calls necessary to set up the Transform Feedback state of your liking. This reference page discusses two types of getters that operate on Transform Feedback Objects and their bindings. The first class operates on general Transform Feedback binding point and includes $(D_INLINECODE glGetTransformFeedbackiv) function. $(D_INLINECODE glGetTransformFeedbackiv) can be used to retrieve information about Transform Feedback object bound to the general Transform Feedback binding point, as configured with a $(D_INLINECODE glBindTransformFeedback) call. In this case, you can check: $(OL $(LI What the ID of the currently bound Transform Feedback Object is; ( $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER_BINDING) )) $(LI Whether the Transform Feedback process is currently paused; ( $(D_INLINECODE GL_TRANSFORM_FEEDBACK_PAUSED) )) $(LI Whether the Transform Feedback process has been begun and is currently undergoing; ( $(D_INLINECODE GL_TRANSFORM_FEEDBACK_ACTIVE) ))) The latter class, which includes $(D_INLINECODE glGetTransformFeedbacki_v) and $(D_INLINECODE glGetTransformFeedbacki64_v) functions, can be used to check what the current configuration of each of the buffer object regions bound to Transform Feedback Buffer binding points is. This allows you to query for the following information: $(OL $(LI $(D_INLINECODE glGetTransformFeedbacki_v) only: What the ID of the Buffer Object bound to a Transform Feedback Binding Point of user-specified index is; ( $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER_BINDING) ).) $(LI $(D_INLINECODE glGetTransformFeedbacki64_v) only: What the start offset configured for the binding is; ( $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER_START) );) $(LI $(D_INLINECODE glGetTransformFeedbacki64_v) only: What the length of the region used for the binding is; ( $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER_SIZE) );))
     + 
     + Params:
     +     xfb   = The name of an existing transform feedback object, or zero for the default transform feedback object.
     +     pname = Property to use for the query. Must be one of the values: $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER_BINDING), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER_START), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER_SIZE), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_PAUSED), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_ACTIVE).
     +     index = Index of the transform feedback stream (for indexed state).
     +     param = The address of a buffer into which will be written the requested state information.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBufferBase), $(D_INLINECODE glBindBufferRange), $(D_INLINECODE glBindBuffersBase), $(D_INLINECODE glBindBuffersRange), $(D_INLINECODE glBindTransformFeedback)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glGetTransformFeedbackiv glGetTransformFeedbackiv;
    alias fn_glGetTransformFeedbackVarying = extern(System) void function(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLsizei* size, GLenum* type, char* name) @system @nogc nothrow;

    /++
     + glGetTransformFeedbackVarying: man4/glGetTransformFeedbackVarying.xml
     + 
     + Information about the set of varying variables in a linked program that will be captured during transform feedback may be retrieved by calling $(D_INLINECODE glGetTransformFeedbackVarying). $(D_INLINECODE glGetTransformFeedbackVarying) provides information about the varying variable selected by $(D_INLINECODE index). An $(D_INLINECODE index) of 0 selects the first varying variable specified in the $(D_INLINECODE varyings) array passed to $(D_INLINECODE glTransformFeedbackVaryings), and an $(D_INLINECODE index) of the value of $(D_INLINECODE GL_TRANSFORM_FEEDBACK_VARYINGS) minus one selects the last such variable. The name of the selected varying is returned as a null-terminated string in $(D_INLINECODE name). The actual number of characters written into $(D_INLINECODE name), excluding the null terminator, is returned in $(D_INLINECODE length). If $(D_INLINECODE length) is null, no length is returned. The maximum number of characters that may be written into
     +  $(D_INLINECODE name), including the null terminator, is specified by $(D_INLINECODE bufSize). The length of the longest varying name in program is given by $(D_INLINECODE GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH), which can be queried with $(D_INLINECODE glGetProgram). For the selected varying variable, its type is returned into $(D_INLINECODE type). The size of the varying is returned into $(D_INLINECODE size). The value in $(D_INLINECODE size) is in units of the type returned in $(D_INLINECODE type). The type returned can be any of the scalar, vector, or matrix attribute types returned by $(D_INLINECODE glGetActiveAttrib). If an error occurred, the return parameters $(D_INLINECODE length), $(D_INLINECODE size), $(D_INLINECODE type) and $(D_INLINECODE name) will be unmodified. This command will return as much information about the varying variables as possible. If no information is available, $(D_INLINECODE length) will be set to zero and $(D_INLINECODE name) will be an empty string. This situation could arise if $(D_INLINECODE glGetTransformFeedbackVarying) is called after a failed link.
     + 
     + Params:
     +     program = The name of the target program object.
     +     index   = The index of the varying variable whose information to retrieve.
     +     bufSize = The maximum number of characters, including the null terminator, that may be written into $(D_INLINECODE name).
     +     length  = The address of a variable which will receive the number of characters written into $(D_INLINECODE name), excluding the null-terminator. If $(D_INLINECODE length) is $(D_INLINECODE null) no length is returned.
     +     size    = The address of a variable that will receive the size of the varying.
     +     type    = The address of a variable that will recieve the type of the varying.
     +     name    = The address of a buffer into which will be written the name of the varying.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBeginTransformFeedback), $(D_INLINECODE glEndTransformFeedback), $(D_INLINECODE glTransformFeedbackVaryings), $(D_INLINECODE glGetProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glGetTransformFeedbackVarying glGetTransformFeedbackVarying;
    alias fn_glGetUniformBlockIndex = extern(System) GLuint function(GLuint program, const( GLchar*) uniformBlockName) @system @nogc nothrow;

    /++
     + glGetUniformBlockIndex: man4/glGetUniformBlockIndex.xml
     + 
     + $(D_INLINECODE glGetUniformBlockIndex) retrieves the index of a uniform block within $(D_INLINECODE program). $(D_INLINECODE program) must be the name of a program object for which the command $(D_INLINECODE glLinkProgram) must have been called in the past, although it is not required that $(D_INLINECODE glLinkProgram) must have succeeded. The link could have failed because the number of active uniforms exceeded the limit. $(D_INLINECODE uniformBlockName) must contain a nul-terminated string specifying the name of the uniform block. $(D_INLINECODE glGetUniformBlockIndex) returns the uniform block index for the uniform block named $(D_INLINECODE uniformBlockName) of $(D_INLINECODE program). If $(D_INLINECODE uniformBlockName) does not identify an active uniform block of $(D_INLINECODE program), $(D_INLINECODE glGetUniformBlockIndex) returns the special identifier, $(D_INLINECODE GL_INVALID_INDEX). Indices of the active uniform blocks of a program are assigned in consecutive order, beginning with zero.
     + 
     + $(D_INLINECODE glGetUniformBlockIndex) is available only if the GL version is 3.1 or greater.
     + 
     + Params:
     +     program          = Specifies the name of a program containing the uniform block.
     +     uniformBlockName = Specifies the address an array of characters to containing the name of the uniform block whose index to retrieve.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetActiveUniformBlockName), $(D_INLINECODE glGetActiveUniformBlock), $(D_INLINECODE glLinkProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P1)
    @OpenGL_Extension("GL_ARB_uniform_buffer_object")
    fn_glGetUniformBlockIndex glGetUniformBlockIndex;
    alias fn_glGetUniformIndices = extern(System) void function(GLuint program, GLsizei uniformCount, const( GLchar**) uniformNames, GLuint* uniformIndices) @system @nogc nothrow;

    /++
     + glGetUniformIndices: man4/glGetUniformIndices.xml
     + 
     + $(D_INLINECODE glGetUniformIndices) retrieves the indices of a number of uniforms within $(D_INLINECODE program). $(D_INLINECODE program) must be the name of a program object for which the command $(D_INLINECODE glLinkProgram) must have been called in the past, although it is not required that $(D_INLINECODE glLinkProgram) must have succeeded. The link could have failed because the number of active uniforms exceeded the limit. $(D_INLINECODE uniformCount) indicates both the number of elements in the array of names $(D_INLINECODE uniformNames) and the number of indices that may be written to $(D_INLINECODE uniformIndices). $(D_INLINECODE uniformNames) contains a list of $(D_INLINECODE uniformCount) name strings identifying the uniform names to be queried for indices. For each name string in $(D_INLINECODE uniformNames), the index assigned to the active uniform of that name will be written to the corresponding element of $(D_INLINECODE uniformIndices). If a string in $(D_INLINECODE uniformNames) is not the name of an active uniform, the special value $(D_INLINECODE GL_INVALID_INDEX) will be written to the corresponding element of $(D_INLINECODE uniformIndices). If an error occurs, nothing is written to $(D_INLINECODE uniformIndices).
     + 
     + $(D_INLINECODE glGetUniformIndices) is available only if the GL version is 3.1 or greater.
     + 
     + Params:
     +     program        = Specifies the name of a program containing uniforms whose indices to query.
     +     uniformCount   = Specifies the number of uniforms whose indices to query.
     +     uniformNames   = Specifies the address of an array of pointers to buffers containing the names of the queried uniforms.
     +     uniformIndices = Specifies the address of an array that will receive the indices of the uniforms.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetActiveUniform), $(D_INLINECODE glGetActiveUniformName), $(D_INLINECODE glLinkProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P1)
    @OpenGL_Extension("GL_ARB_uniform_buffer_object")
    fn_glGetUniformIndices glGetUniformIndices;
    alias fn_glGetUniformLocation = extern(System) GLint function(GLuint program, const( GLchar*) name) @system @nogc nothrow;

    /++
     + glGetUniformLocation: man4/glGetUniformLocation.xml
     + 
     + $(D_INLINECODE glGetUniformLocation) returns an integer that represents the location of a specific uniform variable within a program object. $(D_INLINECODE name) must be a null terminated string that contains no white space. $(D_INLINECODE name) must be an active uniform variable name in $(D_INLINECODE program) that is not a structure, an array of structures, or a subcomponent of a vector or a matrix. This function returns -1 if $(D_INLINECODE name) does not correspond to an active uniform variable in $(D_INLINECODE program), if $(D_INLINECODE name) starts with the reserved prefix &quot;gl_&quot;, or if $(D_INLINECODE name) is associated with an atomic counter or a named uniform block. Uniform variables that are structures or arrays of structures may be queried by calling $(D_INLINECODE glGetUniformLocation) for each field within the structure. The array element operator &quot;[]&quot; and the structure field operator &quot;.&quot; may be used in $(D_INLINECODE name) in order to select elements within an array or fields within a structure. The result of using these operators is not allowed to be another structure, an array of structures, or a subcomponent of a vector or a matrix. Except if the last part of $(D_INLINECODE name) indicates a uniform variable array, the location of the first element of an array can be retrieved by using the name of the array, or by using the name appended by &quot;[0]&quot;. The actual locations assigned to uniform variables are not known until the program object is linked successfully. After linking has occurred, the command $(D_INLINECODE glGetUniformLocation) can be used to obtain the location of a uniform variable. This location value can then be passed to $(D_INLINECODE glUniform) to set the value of the uniform variable or to $(D_INLINECODE glGetUniform) in order to query the current value of the uniform variable. After a program object has been linked successfully, the index values for uniform variables remain fixed until the next link command occurs. Uniform variable locations and values can only be queried after a link if the link was successful.
     + 
     + Params:
     +     program = Specifies the program object to be queried.
     +     name    = Points to a null terminated string containing the name of the uniform variable whose location is to be queried.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glLinkProgram), $(D_INLINECODE glUniform)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glGetUniformLocation glGetUniformLocation;
    alias fn_glGetUniformSubroutineuiv = extern(System) void function(GLenum shadertype, GLint location, GLuint* values) @system @nogc nothrow;

    /++
     + glGetUniformSubroutine: man4/glGetUniformSubroutine.xml
     + 
     + $(D_INLINECODE glGetUniformSubroutine) retrieves the value of the subroutine uniform at location $(D_INLINECODE location) for shader stage $(D_INLINECODE shadertype) of the current program. $(D_INLINECODE location) must be less than the value of $(D_INLINECODE GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS) for the shader currently in use at shader stage $(D_INLINECODE shadertype). The value of the subroutine uniform is returned in $(D_INLINECODE values).
     + 
     + Params:
     +     shadertype = Specifies the shader stage from which to query for subroutine uniform index. $(D_INLINECODE shadertype) must be one of $(D_INLINECODE GL_VERTEX_SHADER), $(D_INLINECODE GL_TESS_CONTROL_SHADER), $(D_INLINECODE GL_TESS_EVALUATION_SHADER), $(D_INLINECODE GL_GEOMETRY_SHADER) or $(D_INLINECODE GL_FRAGMENT_SHADER).
     +     location   = Specifies the location of the subroutine uniform.
     +     values     = Specifies the address of a variable to receive the value or values of the subroutine uniform.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetProgram), $(D_INLINECODE glGetActiveSubroutineUniform), $(D_INLINECODE glGetActiveSubroutineUniformName), $(D_INLINECODE glGetUniformLocation)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_shader_subroutine")
    fn_glGetUniformSubroutineuiv glGetUniformSubroutineuiv;
    alias fn_glGetVertexArrayIndexed64iv = extern(System) void function(GLuint vaobj, GLuint index, GLenum pname, GLint64* param) @system @nogc nothrow;

    /++
     + glGetVertexArrayIndexed: man4/glGetVertexArrayIndexed.xml
     + 
     + $(D_INLINECODE glGetVertexArrayIndexediv) and $(D_INLINECODE glGetVertexArrayIndexed64iv) provide a way of querying parameters of an attribute at an user-specified index of a vertex array object. The vertex array object does not have to be bound to the rendering context at the time of the call, but must have been bound at least once prior to this call. The following parameter values can be retrieved with $(D_INLINECODE glGetVertexArrayIndexediv) for each of the attributes defined for a vertex array object: $(OL $(LI $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_ENABLED) : $(D_INLINECODE param) returns a value that is non-zero (true) if the vertex attribute array for index is enabled and 0 (false) if it is disabled. The initial value is $(D_INLINECODE GL_FALSE).) $(LI $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_SIZE) : $(D_INLINECODE param) returns a single value, the size of the vertex attribute array for index. The size is the number of values for each element of the vertex attribute array, and it will be 1, 2, 3 or 4. The initial value is 4.) $(LI $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_STRIDE) : $(D_INLINECODE param) returns a single value, the array stride for (number of bytes between successive elements in) the vertex attribute array for index. A value of 0 indicates the array elements are stored sequentially in memory. The initial value is 0.) $(LI $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_TYPE) : $(D_INLINECODE param) returns a single value, a symbolic constant indicating the array type for the vertex attribute array for index. Possible values are $(D_INLINECODE GL_BYTE), $(D_INLINECODE GL_DOUBLE), $(D_INLINECODE GL_FIXED), $(D_INLINECODE GL_FLOAT), $(D_INLINECODE GL_HALF_FLOAT), $(D_INLINECODE GL_INT), $(D_INLINECODE GL_INT_2_10_10_10_REV), $(D_INLINECODE GL_SHORT), $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), $(D_INLINECODE GL_UNSIGNED_INT), $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV), and $(D_INLINECODE GL_UNSIGNED_INT_10F_11F_11F_REV). The initial value is $(D_INLINECODE GL_FLOAT).) $(LI $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_NORMALIZED) : $(D_INLINECODE param) returns a single value that is non-zero (true) if fixed-point data types for the vertex attribute array indicated by index are normalized when they are converted to floating-point, and 0 (false) otherwise. The initial value is $(D_INLINECODE GL_FALSE).) $(LI $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_INTEGER) : $(D_INLINECODE param) returns a single value that is non-zero (true) if fixed-point data types for the vertex attribute array indicated by index have integer data type, and 0 (false) otherwise. The initial value is 0 ( $(D_INLINECODE GL_FALSE) ).) $(LI $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_LONG) : $(D_INLINECODE param) returns a single value that is non-zero (true) if a vertex attribute is stored as an unconverted double, and 0 (false) otherwise. The initial value is 0 ( $(D_INLINECODE GL_FALSE) ).) $(LI $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_DIVISOR) : $(D_INLINECODE param) returns a single value that is the frequency divisor used for instanced rendering. See glVertexAttribDivisor. The initial value is 0.) $(LI $(D_INLINECODE GL_VERTEX_ATTRIB_RELATIVE_OFFSET) : $(D_INLINECODE param) returns a single value that is the byte offset of the first element relative to the start of the vertex buffer binding specified attribute fetches from. The initial value is 0.)) $(D_INLINECODE glGetVertexArrayIndexed64iv) can be used to retrieve $(D_INLINECODE GL_VERTEX_BINDING_OFFSET) parameter value for any of the attributes defined for a vertex array object. When $(D_INLINECODE pname) is set to $(D_INLINECODE GL_VERTEX_BINDING_OFFSET), $(D_INLINECODE param) returns a single value that is the byte offset of the first element in the bound buffer's data store. The initial value for this parameter is 0.
     + 
     + Params:
     +     vaobj = Specifies the name of a vertex array object.
     +     index = Specifies the index of the vertex array object attribute. Must be a number between 0 and ( $(D_INLINECODE GL_MAX_VERTEX_ATTRIBS) - 1).
     +     pname = Specifies the property to be used for the query. For $(D_INLINECODE glGetVertexArrayIndexediv), it must be one of the following values: $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_ENABLED), $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_SIZE), $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_STRIDE), $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_TYPE), $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_NORMALIZED), $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_INTEGER), $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_LONG), $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_DIVISOR), or $(D_INLINECODE GL_VERTEX_ATTRIB_RELATIVE_OFFSET). For $(D_INLINECODE glGetVertexArrayIndexed64v), it must be equal to $(D_INLINECODE GL_VERTEX_BINDING_OFFSET).
     +     param = Returns the requested value.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetVertexAttrib), $(D_INLINECODE glVertexAttribBinding), $(D_INLINECODE glVertexAttribIPointer), $(D_INLINECODE glVertexAttribLPointer), $(D_INLINECODE glVertexAttribPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glGetVertexArrayIndexed64iv glGetVertexArrayIndexed64iv;
    alias fn_glGetVertexArrayiv = extern(System) void function(GLuint vaobj, GLenum pname, GLint* param) @system @nogc nothrow;

    /++
     + glGetVertexArrayiv: man4/glGetVertexArrayiv.xml
     + 
     + This function provides a mean of querying properties of an existing vertex array object. The vertex array object does not have to be bound to the rendering context at the time of the call, but must have been bound at least once prior to this call. $(D_INLINECODE glGetVertexArrayiv) can be used to retrieve ID of a buffer object that will be bound to the $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) binding point whenever the queried vertex array object is bound to the rendering context. The binding can be changed for an active vertex array object with a $(D_INLINECODE glBindBuffer) call.
     + 
     + Params:
     +     vaobj = specifies the name of the vertex array object to use for the query.
     +     pname = Name of the property to use for the query. Must be $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER_BINDING).
     +     param = Returns the requested value.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBuffer), $(D_INLINECODE glBindVertexArray), $(D_INLINECODE glGet)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glGetVertexArrayiv glGetVertexArrayiv;
    alias fn_glGetVertexAttribdv = extern(System) void function(GLuint index, GLenum pname, GLdouble* params) @system @nogc nothrow;

    /++
     + glGetVertexAttrib: man4/glGetVertexAttrib.xml
     + 
     + $(D_INLINECODE glGetVertexAttrib) returns in $(D_INLINECODE params) the value of a generic vertex attribute parameter. The generic vertex attribute to be queried is specified by $(D_INLINECODE index), and the parameter to be queried is specified by $(D_INLINECODE pname). The accepted parameter names are as follows: All of the parameters except $(D_INLINECODE GL_CURRENT_VERTEX_ATTRIB) represent state stored in the currently bound vertex array object.
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE params).
     + 
     + Params:
     +     index  = Specifies the generic vertex attribute parameter to be queried.
     +     pname  = Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING), $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_ENABLED), $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_SIZE), $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_STRIDE), $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_TYPE), $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_NORMALIZED), $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_INTEGER), $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_DIVISOR), or $(D_INLINECODE GL_CURRENT_VERTEX_ATTRIB).
     +     params = Returns the requested data.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindAttribLocation), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glDisableVertexAttribArray), $(D_INLINECODE glEnableVertexAttribArray), $(D_INLINECODE glVertexAttrib), $(D_INLINECODE glVertexAttribDivisor), $(D_INLINECODE glVertexAttribPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glGetVertexAttribdv glGetVertexAttribdv;
    alias fn_glGetVertexAttribfv = extern(System) void function(GLuint index, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glGetVertexAttribfv glGetVertexAttribfv;
    alias fn_glGetVertexAttribiv = extern(System) void function(GLuint index, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glGetVertexAttribiv glGetVertexAttribiv;
    alias fn_glGetVertexAttribIiv = extern(System) void function(GLuint index, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glGetVertexAttribIiv glGetVertexAttribIiv;
    alias fn_glGetVertexAttribIuiv = extern(System) void function(GLuint index, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glGetVertexAttribIuiv glGetVertexAttribIuiv;
    alias fn_glGetVertexAttribLdv = extern(System) void function(GLuint index, GLenum pname, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_vertex_attrib_64bit")
    fn_glGetVertexAttribLdv glGetVertexAttribLdv;
    alias fn_glGetVertexAttribPointerv = extern(System) void function(GLuint index, GLenum pname, GLvoid** pointer) @system @nogc nothrow;

    /++
     + glGetVertexAttribPointerv: man4/glGetVertexAttribPointerv.xml
     + 
     + $(D_INLINECODE glGetVertexAttribPointerv) returns pointer information. $(D_INLINECODE index) is the generic vertex attribute to be queried, $(D_INLINECODE pname) is a symbolic constant indicating the pointer to be returned, and $(D_INLINECODE params) is a pointer to a location in which to place the returned data. The $(D_INLINECODE pointer) returned is a byte offset into the data store of the buffer object that was bound to the $(D_INLINECODE GL_ARRAY_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) when the desired pointer was previously specified.
     + 
     + The state returned is retrieved from the currently bound vertex array object. The initial value for each pointer is 0.
     + 
     + Params:
     +     index   = Specifies the generic vertex attribute parameter to be returned.
     +     pname   = Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_POINTER).
     +     pointer = Returns the pointer value.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetVertexAttrib), $(D_INLINECODE glVertexAttribPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glGetVertexAttribPointerv glGetVertexAttribPointerv;
    alias fn_glHint = extern(System) void function(GLenum target, GLenum mode) @system @nogc nothrow;

    /++
     + glHint: man4/glHint.xml
     + 
     + Certain aspects of GL behavior, when there is room for interpretation, can be controlled with hints. A hint is specified with two arguments. $(D_INLINECODE target) is a symbolic constant indicating the behavior to be controlled, and $(D_INLINECODE mode) is another symbolic constant indicating the desired behavior. The initial value for each $(D_INLINECODE target) is $(D_INLINECODE GL_DONT_CARE). $(D_INLINECODE mode) can be one of the following: Though the implementation aspects that can be hinted are well defined, the interpretation of the hints depends on the implementation. The hint aspects that can be specified with $(D_INLINECODE target), along with suggested semantics, are as follows:
     + 
     + The interpretation of hints depends on the implementation. Some implementations ignore $(D_INLINECODE glHint) settings.
     + 
     + Params:
     +     target = Specifies a symbolic constant indicating the behavior to be controlled. $(D_INLINECODE GL_LINE_SMOOTH_HINT), $(D_INLINECODE GL_POLYGON_SMOOTH_HINT), $(D_INLINECODE GL_TEXTURE_COMPRESSION_HINT), and $(D_INLINECODE GL_FRAGMENT_SHADER_DERIVATIVE_HINT) are accepted.
     +     mode   = Specifies a symbolic constant indicating the desired behavior. $(D_INLINECODE GL_FASTEST), $(D_INLINECODE GL_NICEST), and $(D_INLINECODE GL_DONT_CARE) are accepted.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glHint glHint;
    alias fn_glInvalidateBufferData = extern(System) void function(GLuint buffer) @system @nogc nothrow;

    /++
     + glInvalidateBufferData: man4/glInvalidateBufferData.xml
     + 
     + $(D_INLINECODE glInvalidateBufferData) invalidates all of the content of the data store of a buffer object. After invalidation, the content of the buffer's data store becomes undefined.
     + 
     + Params:
     +     buffer = The name of a buffer object whose data store to invalidate.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glInvalidateTexSubImage),, $(D_INLINECODE glInvalidateTexImage), $(D_INLINECODE glInvalidateBufferSubData), $(D_INLINECODE glInvalidateFramebuffer), $(D_INLINECODE glInvalidateSubFramebuffer).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_invalidate_subdata")
    fn_glInvalidateBufferData glInvalidateBufferData;
    alias fn_glInvalidateBufferSubData = extern(System) void function(GLuint buffer, GLintptr offset, GLsizeiptr length) @system @nogc nothrow;

    /++
     + glInvalidateBufferSubData: man4/glInvalidateBufferSubData.xml
     + 
     + $(D_INLINECODE glInvalidateBufferSubData) invalidates all or part of the content of the data store of a buffer object. After invalidation, the content of the specified range of the buffer's data store becomes undefined. The start of the range is given by $(D_INLINECODE offset) and its size is given by $(D_INLINECODE length), both measured in basic machine units.
     + 
     + Params:
     +     buffer = The name of a buffer object, a subrange of whose data store to invalidate.
     +     offset = The offset within the buffer's data store of the start of the range to be invalidated.
     +     length = The length of the range within the buffer's data store to be invalidated.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glInvalidateTexSubImage),, $(D_INLINECODE glInvalidateTexImage), $(D_INLINECODE glInvalidateBufferData), $(D_INLINECODE glInvalidateFramebuffer), $(D_INLINECODE glInvalidateSubFramebuffer).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_invalidate_subdata")
    fn_glInvalidateBufferSubData glInvalidateBufferSubData;
    alias fn_glInvalidateFramebuffer = extern(System) void function(GLenum target, GLsizei numAttachments, const( GLenum*) attachments) @system @nogc nothrow;

    /++
     + glInvalidateFramebuffer: man4/glInvalidateFramebuffer.xml
     + 
     + $(D_INLINECODE glInvalidateFramebuffer) and $(D_INLINECODE glInvalidateNamedFramebufferData) invalidate the entire contents of a specified set of attachments of a framebuffer. For $(D_INLINECODE glInvalidateFramebuffer), the framebuffer object is that bound to $(D_INLINECODE target). $(D_INLINECODE target) must be $(D_INLINECODE GL_FRAMEBUFFER), $(D_INLINECODE GL_READ_FRAMEBUFFER) or $(D_INLINECODE GL_DRAW_FRAMEBUFFER). $(D_INLINECODE GL_FRAMEBUFFER) is equivalent to $(D_INLINECODE GL_DRAW_FRAMEBUFFER). Default framebuffers may also be invalidated if bound to $(D_INLINECODE target). For $(D_INLINECODE glInvalidateNamedFramebufferData), $(D_INLINECODE framebuffer) is the name of the framebuffer object. If $(D_INLINECODE framebuffer) is zero, the default draw framebuffer is affected. The set of attachments whose contents are to be invalidated are specified in the $(D_INLINECODE attachments) array, which contains $(D_INLINECODE numAttachments) elements. If the specified framebuffer is a framebuffer object, each element of $(D_INLINECODE attachments) must be one of $(D_INLINECODE GL_DEPTH_ATTACHMENT), $(D_INLINECODE GL_STENCIL_ATTACHMENT) $(D_INLINECODE GL_DEPTH_STENCIL_ATTACHMENT), or $(D_INLINECODE GL_COLOR_ATTACHMENT), where is between zero and the value of $(D_INLINECODE GL_MAX_FRAMEBUFFER_ATTACHMENTS) minus one. If the specified framebuffer is a default framebuffer, each element of $(D_INLINECODE attachments) must be one of $(D_INLINECODE GL_FRONT_LEFT), $(D_INLINECODE GL_FRONT_RIGHT), $(D_INLINECODE GL_BACK_LEFT), $(D_INLINECODE GL_BACK_RIGHT), $(D_INLINECODE GL_AUX), $(D_INLINECODE GL_ACCUM), $(D_INLINECODE GL_COLOR), $(D_INLINECODE GL_DEPTH), or $(D_INLINECODE GL_STENCIL). $(D_INLINECODE GL_COLOR), is treated as $(D_INLINECODE GL_BACK_LEFT) for a double-buffered context and $(D_INLINECODE GL_FRONT_LEFT) for a single-buffered context. The other attachments identify the corresponding specific buffer. The entire contents of each specified attachment become undefined after execution of $(D_INLINECODE glInvalidateFramebuffer) or $(D_INLINECODE glInvalidateNamedFramebufferData). If the framebuffer object is not complete, $(D_INLINECODE glInvalidateFramebuffer) and $(D_INLINECODE glInvalidateNamedFramebufferData) may be ignored. This is not an error.
     + 
     + Params:
     +     target         = Specifies the target to which the framebuffer object is attached for $(D_INLINECODE glInvalidateFramebuffer).
     +     framebuffer    = Specifies the name of the framebuffer object for $(D_INLINECODE glInvalidateNamedFramebufferData).
     +     numAttachments = Specifies the number of entries in the $(D_INLINECODE attachments) array.
     +     attachments    = Specifies a pointer to an array identifying the attachments to be invalidated.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glInvalidateTexSubImage), $(D_INLINECODE glInvalidateTexImage), $(D_INLINECODE glInvalidateBufferSubData), $(D_INLINECODE glInvalidateBufferData), $(D_INLINECODE glInvalidateSubFramebuffer).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_invalidate_subdata")
    fn_glInvalidateFramebuffer glInvalidateFramebuffer;
    alias fn_glInvalidateNamedFramebufferData = extern(System) void function(GLuint framebuffer, GLsizei numAttachments, const( GLenum*) attachments) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glInvalidateNamedFramebufferData glInvalidateNamedFramebufferData;
    alias fn_glInvalidateSubFramebuffer = extern(System) void function(GLenum target, GLsizei numAttachments, const( GLenum*) attachments, GLint x, GLint y, GLint width, GLint height) @system @nogc nothrow;

    /++
     + glInvalidateNamedFramebufferSubData: man4/glInvalidateSubFramebuffer.xml
     + 
     + $(D_INLINECODE glInvalidateSubFramebuffer) and $(D_INLINECODE glInvalidateNamedFramebufferSubData) invalidate the contents of a specified region of a specified set of attachments of a framebuffer. For $(D_INLINECODE glInvalidateSubFramebuffer), the framebuffer object is that bound to $(D_INLINECODE target), which must be one of $(D_INLINECODE GL_FRAMEBUFFER), $(D_INLINECODE GL_READ_FRAMEBUFFER) or $(D_INLINECODE GL_DRAW_FRAMEBUFFER). $(D_INLINECODE GL_FRAMEBUFFER) is equivalent to $(D_INLINECODE GL_DRAW_FRAMEBUFFER). Default framebuffers may also be invalidated if bound to $(D_INLINECODE target). For $(D_INLINECODE glInvalidateNamedFramebufferSubData), $(D_INLINECODE framebuffer) is the name of the framebuffer object. If $(D_INLINECODE framebuffer) is zero, the default draw framebuffer is affected. The set of attachments of which a region is to be invalidated are specified in the $(D_INLINECODE attachments) array, which contains $(D_INLINECODE numAttachments) elements. If the specified framebuffer is a framebuffer object, each element of $(D_INLINECODE attachments) must be one of $(D_INLINECODE GL_DEPTH_ATTACHMENT), $(D_INLINECODE GL_STENCIL_ATTACHMENT) $(D_INLINECODE GL_DEPTH_STENCIL_ATTACHMENT), or $(D_INLINECODE GL_COLOR_ATTACHMENT), where is between zero and the value of $(D_INLINECODE GL_MAX_FRAMEBUFFER_ATTACHMENTS) minus one. If the specified framebuffer is a default framebuffer, each element of $(D_INLINECODE attachments) must be one of $(D_INLINECODE GL_FRONT_LEFT), $(D_INLINECODE GL_FRONT_RIGHT), $(D_INLINECODE GL_BACK_LEFT), $(D_INLINECODE GL_BACK_RIGHT), $(D_INLINECODE GL_AUX), $(D_INLINECODE GL_ACCUM), $(D_INLINECODE GL_COLOR), $(D_INLINECODE GL_DEPTH), or $(D_INLINECODE GL_STENCIL). $(D_INLINECODE GL_COLOR), is treated as $(D_INLINECODE GL_BACK_LEFT) for a double-buffered context and $(D_INLINECODE GL_FRONT_LEFT) for a single-buffered context. The other attachments identify the corresponding specific buffer. The contents of the specified region of each specified attachment become undefined after execution of $(D_INLINECODE glInvalidateSubFramebuffer) or $(D_INLINECODE glInvalidateNamedFramebufferSubData). The region to be invalidated is specified by $(D_INLINECODE x), $(D_INLINECODE y), $(D_INLINECODE width) and $(D_INLINECODE height) where $(D_INLINECODE x) and $(D_INLINECODE y) give the offset from the origin (with lower-left corner at $(0,0)$) and $(D_INLINECODE width) and $(D_INLINECODE height) are the width and height, respectively, of the region. Any pixels lying outside of the window allocated to the current GL context (for the default framebuffer), or outside of the attachments of the framebuffer object, are ignored. If the framebuffer object is not complete, these commands may be ignored. If the framebuffer object is not complete, $(D_INLINECODE glInvalidateSubFramebuffer) and $(D_INLINECODE glInvalidateNamedFramebufferSubData) may be ignored. This is not an error.
     + 
     + Params:
     +     target         = Specifies the target to which the framebuffer object is attached for $(D_INLINECODE glInvalidateSubFramebuffer).
     +     framebuffer    = Specifies the name of the framebuffer object for $(D_INLINECODE glInvalidateNamedFramebufferSubData).
     +     numAttachments = Specifies the number of entries in the $(D_INLINECODE attachments) array.
     +     attachments    = Specifies a pointer to an array identifying the attachments to be invalidated.
     +     x              = Specifies the X offset of the region to be invalidated.
     +     y              = Specifies the Y offset of the region to be invalidated.
     +     width          = Specifies the width of the region to be invalidated.
     +     height         = Specifies the height of the region to be invalidated.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glInvalidateTexSubImage), $(D_INLINECODE glInvalidateTexImage), $(D_INLINECODE glInvalidateBufferSubData), $(D_INLINECODE glInvalidateBufferData), $(D_INLINECODE glInvalidateFramebuffer).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_invalidate_subdata")
    fn_glInvalidateSubFramebuffer glInvalidateSubFramebuffer;
    alias fn_glInvalidateNamedFramebufferSubData = extern(System) void function(GLuint framebuffer, GLsizei numAttachments, const( GLenum*) attachments, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glInvalidateNamedFramebufferSubData glInvalidateNamedFramebufferSubData;
    alias fn_glInvalidateTexImage = extern(System) void function(GLuint texture, GLint level) @system @nogc nothrow;

    /++
     + glInvalidateTexImage: man4/glInvalidateTexImage.xml
     + 
     + $(D_INLINECODE glInvalidateTexSubImage) invalidates all of a texture image. $(D_INLINECODE texture) and $(D_INLINECODE level) indicated which texture image is being invalidated. After this command, data in the texture image has undefined values. $(D_INLINECODE level) must be greater than or equal to zero and be less than the base 2 logarithm of the maximum texture width, height, or depth. For textures of targets $(D_INLINECODE GL_TEXTURE_RECTANGLE), $(D_INLINECODE GL_TEXTURE_BUFFER), $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE), or $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY), level must be zero.
     + 
     + Params:
     +     texture = The name of a texture object to invalidate.
     +     level   = The level of detail of the texture object to invalidate.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glInvalidateTexSubImage),, $(D_INLINECODE glInvalidateBufferSubData), $(D_INLINECODE glInvalidateBufferData), $(D_INLINECODE glInvalidateFramebuffer), $(D_INLINECODE glInvalidateSubFramebuffer).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_invalidate_subdata")
    fn_glInvalidateTexImage glInvalidateTexImage;
    alias fn_glInvalidateTexSubImage = extern(System) void function(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth) @system @nogc nothrow;

    /++
     + glInvalidateTexSubImage: man4/glInvalidateTexSubImage.xml
     + 
     + $(D_INLINECODE glInvalidateTexSubImage) invalidates all or part of a texture image. $(D_INLINECODE texture) and $(D_INLINECODE level) indicated which texture image is being invalidated. After this command, data in that subregion have undefined values. $(D_INLINECODE xoffset), $(D_INLINECODE yoffset), $(D_INLINECODE zoffset), $(D_INLINECODE width), $(D_INLINECODE height), and $(D_INLINECODE depth) are interpreted as they are in $(D_INLINECODE glTexSubImage3D). For texture targets that don't have certain dimensions, this command treats those dimensions as having a size of 1. For example, to invalidate a portion of a two- dimensional texture, the application would use $(D_INLINECODE zoffset) equal to zero and $(D_INLINECODE depth) equal to one. Cube map textures are treated as an array of six slices in the z-dimension, where a value of $(D_INLINECODE zoffset) is interpreted as specifying face $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X) + $(D_INLINECODE zoffset). $(D_INLINECODE level) must be greater than or equal to zero and be less than the base 2 logarithm of the maximum texture width, height, or depth. $(D_INLINECODE xoffset), $(D_INLINECODE yoffset) and $(D_INLINECODE zoffset) must be greater than or equal to zero and be less than the width, height or depth of the image, respectively. Furthermore, $(D_INLINECODE xoffset) + $(D_INLINECODE width), $(D_INLINECODE yoffset) + $(D_INLINECODE height), and $(D_INLINECODE zoffset) + $(D_INLINECODE depth) must be less than or equal to the width, height or depth of the image, respectively. For textures of targets $(D_INLINECODE GL_TEXTURE_RECTANGLE), $(D_INLINECODE GL_TEXTURE_BUFFER), $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE), or $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY), level must be zero.
     + 
     + Params:
     +     texture = The name of a texture object a subregion of which to invalidate.
     +     level   = The level of detail of the texture object within which the region resides.
     +     xoffset = The X offset of the region to be invalidated.
     +     yoffset = The Y offset of the region to be invalidated.
     +     zoffset = The Z offset of the region to be invalidated.
     +     width   = The width of the region to be invalidated.
     +     height  = The height of the region to be invalidated.
     +     depth   = The depth of the region to be invalidated.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glInvalidateTexImage),, $(D_INLINECODE glInvalidateBufferSubData), $(D_INLINECODE glInvalidateBufferData), $(D_INLINECODE glInvalidateFramebuffer), $(D_INLINECODE glInvalidateSubFramebuffer).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_invalidate_subdata")
    fn_glInvalidateTexSubImage glInvalidateTexSubImage;
    alias fn_glIsBuffer = extern(System) GLboolean function(GLuint buffer) @system @nogc nothrow;

    /++
     + glIsBuffer: man4/glIsBuffer.xml
     + 
     + $(D_INLINECODE glIsBuffer) returns $(D_INLINECODE GL_TRUE) if $(D_INLINECODE buffer) is currently the name of a buffer object. If $(D_INLINECODE buffer) is zero, or is a non-zero value that is not currently the name of a buffer object, or if an error occurs, $(D_INLINECODE glIsBuffer) returns $(D_INLINECODE GL_FALSE). A name returned by $(D_INLINECODE glGenBuffers), but not yet associated with a buffer object by calling $(D_INLINECODE glBindBuffer), is not the name of a buffer object.
     + 
     + Params:
     +     buffer = Specifies a value that may be the name of a buffer object.
     + 
     + Copyright:
     +     Copyright&copy; 2005 Addison-Wesley. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBuffer), $(D_INLINECODE glDeleteBuffers), $(D_INLINECODE glGenBuffers), $(D_INLINECODE glGet)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    fn_glIsBuffer glIsBuffer;
    alias fn_glIsEnabled = extern(System) GLboolean function(GLenum cap) @system @nogc nothrow;

    /++
     + glIsEnabled: man4/glIsEnabled.xml
     + 
     + $(D_INLINECODE glIsEnabled) returns $(D_INLINECODE GL_TRUE) if $(D_INLINECODE cap) is an enabled capability and returns $(D_INLINECODE GL_FALSE) otherwise. Boolean states that are indexed may be tested with $(D_INLINECODE glIsEnabledi). For $(D_INLINECODE glIsEnabledi), $(D_INLINECODE index) specifies the index of the capability to test. $(D_INLINECODE index) must be between zero and the count of indexed capabilities for $(D_INLINECODE cap). Initially all capabilities except $(D_INLINECODE GL_DITHER) are disabled; $(D_INLINECODE GL_DITHER) is initially enabled. The following capabilities are accepted for $(D_INLINECODE cap) : $(B Constant) $(B See) $(D_INLINECODE GL_BLEND) $(D_INLINECODE glBlendFunc), $(D_INLINECODE glLogicOp) $(D_INLINECODE GL_CLIP_DISTANCE) $(D_INLINECODE glEnable) $(D_INLINECODE GL_COLOR_LOGIC_OP) $(D_INLINECODE glLogicOp) $(D_INLINECODE GL_CULL_FACE) $(D_INLINECODE glCullFace) $(D_INLINECODE GL_DEPTH_CLAMP) $(D_INLINECODE glEnable) $(D_INLINECODE GL_DEBUG_OUTPUT) $(D_INLINECODE glEnable) $(D_INLINECODE GL_DEBUG_OUTPUT_SYNCHRONOUS) $(D_INLINECODE glEnable) $(D_INLINECODE GL_DEPTH_TEST) $(D_INLINECODE glDepthFunc), $(D_INLINECODE glDepthRange) $(D_INLINECODE GL_DITHER) $(D_INLINECODE glEnable) $(D_INLINECODE GL_FRAMEBUFFER_SRGB) $(D_INLINECODE glEnable) $(D_INLINECODE GL_LINE_SMOOTH) $(D_INLINECODE glLineWidth) $(D_INLINECODE GL_MULTISAMPLE) $(D_INLINECODE glSampleCoverage) $(D_INLINECODE GL_POLYGON_SMOOTH) $(D_INLINECODE glPolygonMode) $(D_INLINECODE GL_POLYGON_OFFSET_FILL) $(D_INLINECODE glPolygonOffset) $(D_INLINECODE GL_POLYGON_OFFSET_LINE) $(D_INLINECODE glPolygonOffset) $(D_INLINECODE GL_POLYGON_OFFSET_POINT) $(D_INLINECODE glPolygonOffset) $(D_INLINECODE GL_PROGRAM_POINT_SIZE) $(D_INLINECODE glEnable) $(D_INLINECODE GL_PRIMITIVE_RESTART) $(D_INLINECODE glEnable), $(D_INLINECODE glPrimitiveRestartIndex) $(D_INLINECODE GL_SAMPLE_ALPHA_TO_COVERAGE) $(D_INLINECODE glSampleCoverage) $(D_INLINECODE GL_SAMPLE_ALPHA_TO_ONE) $(D_INLINECODE glSampleCoverage) $(D_INLINECODE GL_SAMPLE_COVERAGE) $(D_INLINECODE glSampleCoverage) $(D_INLINECODE GL_SAMPLE_MASK) $(D_INLINECODE glEnable) $(D_INLINECODE GL_SCISSOR_TEST) $(D_INLINECODE glScissor) $(D_INLINECODE GL_STENCIL_TEST) $(D_INLINECODE glStencilFunc), $(D_INLINECODE glStencilOp) $(D_INLINECODE GL_TEXTURE_CUBE_MAP_SEAMLESS) $(D_INLINECODE glEnable)
     + 
     + If an error is generated, $(D_INLINECODE glIsEnabled) and $(D_INLINECODE glIsEnabledi) return $(D_INLINECODE GL_FALSE). $(D_INLINECODE GL_DEBUG_OUTPUT) and $(D_INLINECODE GL_DEBUG_OUTPUT_SYNCHRONOUS) are available only if the GL version is 4.3 or greater.
     + 
     + Params:
     +     cap   = Specifies a symbolic constant indicating a GL capability.
     +     index = Specifies the index of the capability.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glEnable), $(D_INLINECODE glDisable), $(D_INLINECODE glGet)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glIsEnabled glIsEnabled;
    alias fn_glIsFramebuffer = extern(System) GLboolean function(GLuint framebuffer) @system @nogc nothrow;

    /++
     + glIsFramebuffer: man4/glIsFramebuffer.xml
     + 
     + $(D_INLINECODE glIsFramebuffer) returns $(D_INLINECODE GL_TRUE) if $(D_INLINECODE framebuffer) is currently the name of a framebuffer object. If $(D_INLINECODE framebuffer) is zero, or if $(D_INLINECODE framebuffer) is not the name of a framebuffer object, or if an error occurs, $(D_INLINECODE glIsFramebuffer) returns $(D_INLINECODE GL_FALSE). If $(D_INLINECODE framebuffer) is a name returned by $(D_INLINECODE glGenFramebuffers), by that has not yet been bound through a call to $(D_INLINECODE glBindFramebuffer), then the name is not a framebuffer object and $(D_INLINECODE glIsFramebuffer) returns $(D_INLINECODE GL_FALSE).
     + 
     + Params:
     +     framebuffer = Specifies a value that may be the name of a framebuffer object.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenFramebuffers), $(D_INLINECODE glBindFramebuffer), $(D_INLINECODE glDeleteFramebuffers)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    fn_glIsFramebuffer glIsFramebuffer;
    alias fn_glIsProgram = extern(System) GLboolean function(GLuint program) @system @nogc nothrow;

    /++
     + glIsProgram: man4/glIsProgram.xml
     + 
     + $(D_INLINECODE glIsProgram) returns $(D_INLINECODE GL_TRUE) if $(D_INLINECODE program) is the name of a program object previously created with $(D_INLINECODE glCreateProgram) and not yet deleted with $(D_INLINECODE glDeleteProgram). If $(D_INLINECODE program) is zero or a non-zero value that is not the name of a program object, or if an error occurs, $(D_INLINECODE glIsProgram) returns $(D_INLINECODE GL_FALSE).
     + 
     + No error is generated if $(D_INLINECODE program) is not a valid program object name. A program object marked for deletion with $(D_INLINECODE glDeleteProgram) but still in use as part of current rendering state is still considered a program object and $(D_INLINECODE glIsProgram) will return $(D_INLINECODE GL_TRUE).
     + 
     + Params:
     +     program = Specifies a potential program object.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAttachShader), $(D_INLINECODE glBindAttribLocation), $(D_INLINECODE glCreateProgram), $(D_INLINECODE glDeleteProgram), $(D_INLINECODE glDetachShader), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glUniform), $(D_INLINECODE glUseProgram), $(D_INLINECODE glValidateProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glIsProgram glIsProgram;
    alias fn_glIsProgramPipeline = extern(System) GLboolean function(GLuint pipeline) @system @nogc nothrow;

    /++
     + glIsProgramPipeline: man4/glIsProgramPipeline.xml
     + 
     + $(D_INLINECODE glIsProgramPipeline) returns $(D_INLINECODE GL_TRUE) if $(D_INLINECODE pipeline) is currently the name of a program pipeline object. If $(D_INLINECODE pipeline) is zero, or if $(D_INLINECODE pipeline) is not the name of a program pipeline object, or if an error occurs, $(D_INLINECODE glIsProgramPipeline) returns $(D_INLINECODE GL_FALSE). If $(D_INLINECODE pipeline) is a name returned by $(D_INLINECODE glGenProgramPipelines), but that has not yet been bound through a call to $(D_INLINECODE glBindProgramPipeline), then the name is not a program pipeline object and $(D_INLINECODE glIsProgramPipeline) returns $(D_INLINECODE GL_FALSE).
     + 
     + Params:
     +     pipeline = Specifies a value that may be the name of a program pipeline object.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenProgramPipelines), $(D_INLINECODE glBindProgramPipeline), $(D_INLINECODE glDeleteProgramPipelines)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glIsProgramPipeline glIsProgramPipeline;
    alias fn_glIsQuery = extern(System) GLboolean function(GLuint id) @system @nogc nothrow;

    /++
     + glIsQuery: man4/glIsQuery.xml
     + 
     + $(D_INLINECODE glIsQuery) returns $(D_INLINECODE GL_TRUE) if $(D_INLINECODE id) is currently the name of a query object. If $(D_INLINECODE id) is zero, or is a non-zero value that is not currently the name of a query object, or if an error occurs, $(D_INLINECODE glIsQuery) returns $(D_INLINECODE GL_FALSE). A name returned by $(D_INLINECODE glGenQueries), but not yet associated with a query object by calling $(D_INLINECODE glBeginQuery), is not the name of a query object.
     + 
     + Params:
     +     id = Specifies a value that may be the name of a query object.
     + 
     + Copyright:
     +     Copyright&copy; 2005 Addison-Wesley. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBeginQuery), $(D_INLINECODE glDeleteQueries), $(D_INLINECODE glEndQuery), $(D_INLINECODE glGenQueries)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    fn_glIsQuery glIsQuery;
    alias fn_glIsRenderbuffer = extern(System) GLboolean function(GLuint renderbuffer) @system @nogc nothrow;

    /++
     + glIsRenderbuffer: man4/glIsRenderbuffer.xml
     + 
     + $(D_INLINECODE glIsRenderbuffer) returns $(D_INLINECODE GL_TRUE) if $(D_INLINECODE renderbuffer) is currently the name of a renderbuffer object. If $(D_INLINECODE renderbuffer) is zero, or if $(D_INLINECODE renderbuffer) is not the name of a renderbuffer object, or if an error occurs, $(D_INLINECODE glIsRenderbuffer) returns $(D_INLINECODE GL_FALSE). If $(D_INLINECODE renderbuffer) is a name returned by $(D_INLINECODE glGenRenderbuffers), by that has not yet been bound through a call to $(D_INLINECODE glBindRenderbuffer) or $(D_INLINECODE glFramebufferRenderbuffer), then the name is not a renderbuffer object and $(D_INLINECODE glIsRenderbuffer) returns $(D_INLINECODE GL_FALSE).
     + 
     + Params:
     +     renderbuffer = Specifies a value that may be the name of a renderbuffer object.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenRenderbuffers), $(D_INLINECODE glBindRenderbuffer), $(D_INLINECODE glFramebufferRenderbuffer), $(D_INLINECODE glDeleteRenderbuffers)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    fn_glIsRenderbuffer glIsRenderbuffer;
    alias fn_glIsSampler = extern(System) GLboolean function(GLuint id) @system @nogc nothrow;

    /++
     + glIsSampler: man4/glIsSampler.xml
     + 
     + $(D_INLINECODE glIsSampler) returns $(D_INLINECODE GL_TRUE) if $(D_INLINECODE id) is currently the name of a sampler object. If $(D_INLINECODE id) is zero, or is a non-zero value that is not currently the name of a sampler object, or if an error occurs, $(D_INLINECODE glIsSampler) returns $(D_INLINECODE GL_FALSE). A name returned by $(D_INLINECODE glGenSamplers), is the name of a sampler object.
     + 
     + $(D_INLINECODE glIsSampler) is available only if the GL version is 3.3 or higher.
     + 
     + Params:
     +     id = Specifies a value that may be the name of a sampler object.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenSamplers), $(D_INLINECODE glBindSampler), $(D_INLINECODE glDeleteSamplers)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    fn_glIsSampler glIsSampler;
    alias fn_glIsShader = extern(System) GLboolean function(GLuint shader) @system @nogc nothrow;

    /++
     + glIsShader: man4/glIsShader.xml
     + 
     + $(D_INLINECODE glIsShader) returns $(D_INLINECODE GL_TRUE) if $(D_INLINECODE shader) is the name of a shader object previously created with $(D_INLINECODE glCreateShader) and not yet deleted with $(D_INLINECODE glDeleteShader). If $(D_INLINECODE shader) is zero or a non-zero value that is not the name of a shader object, or if an error occurs, $(D_INLINECODE glIsShader) returns $(D_INLINECODE GL_FALSE).
     + 
     + No error is generated if $(D_INLINECODE shader) is not a valid shader object name. A shader object marked for deletion with $(D_INLINECODE glDeleteShader) but still attached to a program object is still considered a shader object and $(D_INLINECODE glIsShader) will return $(D_INLINECODE GL_TRUE).
     + 
     + Params:
     +     shader = Specifies a potential shader object.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAttachShader), $(D_INLINECODE glCompileShader), $(D_INLINECODE glCreateShader), $(D_INLINECODE glDeleteShader), $(D_INLINECODE glDetachShader), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glShaderSource)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glIsShader glIsShader;
    alias fn_glIsSync = extern(System) GLboolean function(GLsync sync) @system @nogc nothrow;

    /++
     + glIsSync: man4/glIsSync.xml
     + 
     + $(D_INLINECODE glIsSync) returns $(D_INLINECODE GL_TRUE) if $(D_INLINECODE sync) is currently the name of a sync object. If $(D_INLINECODE sync) is not the name of a sync object, or if an error occurs, $(D_INLINECODE glIsSync) returns $(D_INLINECODE GL_FALSE). Note that zero is not the name of a sync object.
     + 
     + $(D_INLINECODE glIsSync) is available only if the GL version is 3.2 or greater.
     + 
     + Params:
     +     sync = Specifies a value that may be the name of a sync object.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glFenceSync), $(D_INLINECODE glWaitSync), $(D_INLINECODE glClientWaitSync), $(D_INLINECODE glDeleteSync)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_sync")
    fn_glIsSync glIsSync;
    alias fn_glIsTexture = extern(System) GLboolean function(GLuint texture) @system @nogc nothrow;

    /++
     + glIsTexture: man4/glIsTexture.xml
     + 
     + $(D_INLINECODE glIsTexture) returns $(D_INLINECODE GL_TRUE) if $(D_INLINECODE texture) is currently the name of a texture. If $(D_INLINECODE texture) is zero, or is a non-zero value that is not currently the name of a texture, or if an error occurs, $(D_INLINECODE glIsTexture) returns $(D_INLINECODE GL_FALSE). A name returned by $(D_INLINECODE glGenTextures), but not yet associated with a texture by calling $(D_INLINECODE glBindTexture), is not the name of a texture.
     + 
     + Params:
     +     texture = Specifies a value that may be the name of a texture.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindTexture), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glDeleteTextures), $(D_INLINECODE glGenTextures), $(D_INLINECODE glGet), $(D_INLINECODE glGetTexParameter), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    fn_glIsTexture glIsTexture;
    alias fn_glIsTransformFeedback = extern(System) GLboolean function(GLuint id) @system @nogc nothrow;

    /++
     + glIsTransformFeedback: man4/glIsTransformFeedback.xml
     + 
     + $(D_INLINECODE glIsTransformFeedback) returns $(D_INLINECODE GL_TRUE) if $(D_INLINECODE id) is currently the name of a transform feedback object. If $(D_INLINECODE id) is zero, or if $(D_INLINECODE id) is not the name of a transform feedback object, or if an error occurs, $(D_INLINECODE glIsTransformFeedback) returns $(D_INLINECODE GL_FALSE). If $(D_INLINECODE id) is a name returned by $(D_INLINECODE glGenTransformFeedbacks), but that has not yet been bound through a call to $(D_INLINECODE glBindTransformFeedback), then the name is not a transform feedback object and $(D_INLINECODE glIsTransformFeedback) returns $(D_INLINECODE GL_FALSE).
     + 
     + Params:
     +     id = Specifies a value that may be the name of a transform feedback object.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenTransformFeedbacks), $(D_INLINECODE glBindTransformFeedback), $(D_INLINECODE glDeleteTransformFeedbacks)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_transform_feedback2")
    fn_glIsTransformFeedback glIsTransformFeedback;
    alias fn_glIsVertexArray = extern(System) GLboolean function(GLuint array) @system @nogc nothrow;

    /++
     + glIsVertexArray: man4/glIsVertexArray.xml
     + 
     + $(D_INLINECODE glIsVertexArray) returns $(D_INLINECODE GL_TRUE) if $(D_INLINECODE array) is currently the name of a vertex array object. If $(D_INLINECODE array) is zero, or if $(D_INLINECODE array) is not the name of a vertex array object, or if an error occurs, $(D_INLINECODE glIsVertexArray) returns $(D_INLINECODE GL_FALSE). If $(D_INLINECODE array) is a name returned by $(D_INLINECODE glGenVertexArrays), by that has not yet been bound through a call to $(D_INLINECODE glBindVertexArray), then the name is not a vertex array object and $(D_INLINECODE glIsVertexArray) returns $(D_INLINECODE GL_FALSE).
     + 
     + Params:
     +     array = Specifies a value that may be the name of a vertex array object.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenVertexArrays), $(D_INLINECODE glBindVertexArray), $(D_INLINECODE glDeleteVertexArrays)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_vertex_array_object")
    fn_glIsVertexArray glIsVertexArray;
    alias fn_glLineWidth = extern(System) void function(GLfloat width) @system @nogc nothrow;

    /++
     + glLineWidth: man4/glLineWidth.xml
     + 
     + $(D_INLINECODE glLineWidth) specifies the rasterized width of both aliased and antialiased lines. Using a line width other than 1 has different effects, depending on whether line antialiasing is enabled. To enable and disable line antialiasing, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_LINE_SMOOTH). Line antialiasing is initially disabled. If line antialiasing is disabled, the actual width is determined by rounding the supplied width to the nearest integer. (If the rounding results in the value 0, it is as if the line width were 1.) If &#x394; x &gt;= &#x394; y, pixels are filled in each column that is rasterized, where is the rounded value of $(D_INLINECODE width). Otherwise, pixels are filled in each row that is rasterized. If antialiasing is enabled, line rasterization produces a fragment for each pixel square that intersects the region lying within the rectangle having width equal to the current line width, length equal to the actual length of the line, and centered on the mathematical line segment. The coverage value for each fragment is the window coordinate area of the intersection of the rectangular region with the corresponding pixel square. This value is saved and used in the final rasterization step. Not all widths can be supported when line antialiasing is enabled. If an unsupported width is requested, the nearest supported width is used. Only width 1 is guaranteed to be supported; others depend on the implementation.  Likewise, there is a range for aliased line widths as well. To query the range of supported widths and the size difference between supported widths within the range, call $(D_INLINECODE glGet) with arguments $(D_INLINECODE GL_ALIASED_LINE_WIDTH_RANGE), $(D_INLINECODE GL_SMOOTH_LINE_WIDTH_RANGE), and $(D_INLINECODE GL_SMOOTH_LINE_WIDTH_GRANULARITY).
     + 
     + The line width specified by $(D_INLINECODE glLineWidth) is always returned when $(D_INLINECODE GL_LINE_WIDTH) is queried. Clamping and rounding for aliased and antialiased lines have no effect on the specified value. Nonantialiased line width may be clamped to an implementation-dependent maximum.  Call $(D_INLINECODE glGet) with $(D_INLINECODE GL_ALIASED_LINE_WIDTH_RANGE) to determine the maximum width. In OpenGL 1.2, the tokens $(D_INLINECODE GL_LINE_WIDTH_RANGE) and $(D_INLINECODE GL_LINE_WIDTH_GRANULARITY) were replaced by $(D_INLINECODE GL_ALIASED_LINE_WIDTH_RANGE), $(D_INLINECODE GL_SMOOTH_LINE_WIDTH_RANGE), and $(D_INLINECODE GL_SMOOTH_LINE_WIDTH_GRANULARITY).  The old names are retained for backward compatibility, but should not be used in new code.
     + 
     + Params:
     +     width = Specifies the width of rasterized lines. The initial value is 1.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glEnable)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glLineWidth glLineWidth;
    alias fn_glLinkProgram = extern(System) void function(GLuint program) @system @nogc nothrow;

    /++
     + glLinkProgram: man4/glLinkProgram.xml
     + 
     + $(D_INLINECODE glLinkProgram) links the program object specified by $(D_INLINECODE program). If any shader objects of type $(D_INLINECODE GL_VERTEX_SHADER) are attached to $(D_INLINECODE program), they will be used to create an executable that will run on the programmable vertex processor. If any shader objects of type $(D_INLINECODE GL_GEOMETRY_SHADER) are attached to $(D_INLINECODE program), they will be used to create an executable that will run on the programmable geometry processor. If any shader objects of type $(D_INLINECODE GL_FRAGMENT_SHADER) are attached to $(D_INLINECODE program), they will be used to create an executable that will run on the programmable fragment processor. The status of the link operation will be stored as part of the program object's state. This value will be set to $(D_INLINECODE GL_TRUE) if the program object was linked without errors and is ready for use, and $(D_INLINECODE GL_FALSE) otherwise. It can be queried by calling $(D_INLINECODE glGetProgram) with arguments $(D_INLINECODE program) and $(D_INLINECODE GL_LINK_STATUS). As a result of a successful link operation, all active user-defined uniform variables belonging to $(D_INLINECODE program) will be initialized to 0, and each of the program object's active uniform variables will be assigned a location that can be queried by calling $(D_INLINECODE glGetUniformLocation). Also, any active user-defined attribute variables that have not been bound to a generic vertex attribute index will be bound to one at this time. Linking of a program object can fail for a number of reasons as specified in the. The following lists some of the conditions that will cause a link error. $(OL $(LI The number of active attribute variables supported by the implementation has been exceeded.) $(LI The storage limit for uniform variables has been exceeded.) $(LI The number of active uniform variables supported by the implementation has been exceeded.) $(LI The $(D_INLINECODE main) function is missing for the vertex, geometry or fragment shader.) $(LI A varying variable actually used in the fragment shader is not declared in the same way (or is not declared at all) in the vertex shader, or geometry shader shader if present.) $(LI A reference to a function or variable name is unresolved.) $(LI A shared global is declared with two different types or two different initial values.) $(LI One or more of the attached shader objects has not been successfully compiled.) $(LI Binding a generic attribute matrix caused some rows of the matrix to fall outside the allowed maximum of $(D_INLINECODE GL_MAX_VERTEX_ATTRIBS).) $(LI Not enough contiguous vertex attribute slots could be found to bind attribute matrices.) $(LI The program object contains objects to form a fragment shader but does not contain objects to form a vertex shader.) $(LI The program object contains objects to form a geometry shader but does not contain objects to form a vertex shader.) $(LI The program object contains objects to form a geometry shader and the input primitive type, output primitive type, or maximum output vertex count is not specified in any compiled geometry shader object.) $(LI The program object contains objects to form a geometry shader and the input primitive type, output primitive type, or maximum output vertex count is specified differently in multiple geometry shader objects.) $(LI The number of active outputs in the fragment shader is greater than the value of $(D_INLINECODE GL_MAX_DRAW_BUFFERS).) $(LI The program has an active output assigned to a location greater than or equal to the value of $(D_INLINECODE GL_MAX_DUAL_SOURCE_DRAW_BUFFERS) and has an active output assigned an index greater than or equal to one.) $(LI More than one varying out variable is bound to the same number and index.) $(LI The explicit binding assigments do not leave enough space for the linker to automatically assign a location for a varying out array, which requires multiple contiguous locations.) $(LI The $(D_INLINECODE count) specified by $(D_INLINECODE glTransformFeedbackVaryings) is non-zero, but the program object has no vertex or geometry shader.) $(LI Any variable name specified to $(D_INLINECODE glTransformFeedbackVaryings) in the $(D_INLINECODE varyings) array is not declared as an output in the vertex shader (or the geometry shader, if active).) $(LI Any two entries in the $(D_INLINECODE varyings) array given $(D_INLINECODE glTransformFeedbackVaryings) specify the same varying variable.) $(LI The total number of components to capture in any transform feedback varying variable is  greater  than  the  constant $(D_INLINECODE GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS) and the buffer mode is $(D_INLINECODE GL_SEPARATE_ATTRIBS).)) When a program object has been successfully linked, the program object can be made part of current state by calling $(D_INLINECODE glUseProgram). Whether or not the link operation was successful, the program object's information log will be overwritten. The information log can be retrieved by calling $(D_INLINECODE glGetProgramInfoLog). $(D_INLINECODE glLinkProgram) will also install the generated executables as part of the current rendering state if the link operation was successful and the specified program object is already currently in use as a result of a previous call to $(D_INLINECODE glUseProgram). If the program object currently in use is relinked unsuccessfully, its link status will be set to $(D_INLINECODE GL_FALSE), but the executables and associated state will remain part of the current state until a subsequent call to $(D_INLINECODE glUseProgram) removes it from use. After it is removed from use, it cannot be made part of current state until it has been successfully relinked. If $(D_INLINECODE program) contains shader objects of type $(D_INLINECODE GL_VERTEX_SHADER), and optionally of type $(D_INLINECODE GL_GEOMETRY_SHADER), but does not contain shader objects of type $(D_INLINECODE GL_FRAGMENT_SHADER), the vertex shader executable will be installed on the programmable vertex processor, the geometry shader executable, if present, will be installed on the programmable geometry processor, but no executable will be installed on the fragment processor. The results of rasterizing primitives with such a program will be undefined. The program object's information log is updated and the program is generated at the time of the link operation. After the link operation, applications are free to modify attached shader objects, compile attached shader objects, detach shader objects, delete shader objects, and attach additional shader objects. None of these operations affects the information log or the program that is part of the program object.
     + 
     + If the link operation is unsuccessful, any information about a previous link operation on $(D_INLINECODE program) is lost (i.e., a failed link does not restore the old state of $(D_INLINECODE program) ). Certain information can still be retrieved from $(D_INLINECODE program) even after an unsuccessful link operation. See for instance $(D_INLINECODE glGetActiveAttrib) and $(D_INLINECODE glGetActiveUniform).
     + 
     + Params:
     +     program = Specifies the handle of the program object to be linked.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAttachShader), $(D_INLINECODE glBindAttribLocation), $(D_INLINECODE glCompileShader), $(D_INLINECODE glCreateProgram), $(D_INLINECODE glDeleteProgram), $(D_INLINECODE glDetachShader), $(D_INLINECODE glUniform), $(D_INLINECODE glUseProgram), $(D_INLINECODE glValidateProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glLinkProgram glLinkProgram;
    alias fn_glLogicOp = extern(System) void function(GLenum opcode) @system @nogc nothrow;

    /++
     + glLogicOp: man4/glLogicOp.xml
     + 
     + $(D_INLINECODE glLogicOp) specifies a logical operation that, when enabled, is applied between the incoming RGBA color and the RGBA color at the corresponding location in the frame buffer. To enable or disable the logical operation, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) using the symbolic constant $(D_INLINECODE GL_COLOR_LOGIC_OP). The initial value is disabled. $(B Opcode) $(B Resulting Operation) $(D_INLINECODE GL_CLEAR) 0 $(D_INLINECODE GL_SET) 1 $(D_INLINECODE GL_COPY) s $(D_INLINECODE GL_COPY_INVERTED) ~s $(D_INLINECODE GL_NOOP) d $(D_INLINECODE GL_INVERT) ~d $(D_INLINECODE GL_AND) s &amp; d $(D_INLINECODE GL_NAND) ~(s &amp; d) $(D_INLINECODE GL_OR) s | d $(D_INLINECODE GL_NOR) ~(s | d) $(D_INLINECODE GL_XOR) s ^ d $(D_INLINECODE GL_EQUIV) ~(s ^ d) $(D_INLINECODE GL_AND_REVERSE) s &amp; ~d $(D_INLINECODE GL_AND_INVERTED) ~s &amp; d $(D_INLINECODE GL_OR_REVERSE) s | ~d $(D_INLINECODE GL_OR_INVERTED) ~s | d $(D_INLINECODE opcode) is a symbolic constant chosen from the list above. In the explanation of the logical operations, represents the incoming color and represents the color in the frame buffer. Standard C-language operators are used. As these bitwise operators suggest, the logical operation is applied independently to each bit pair of the source and destination colors.
     + 
     + When more than one RGBA color buffer is enabled for drawing, logical operations are performed separately for each enabled buffer, using for the destination value the contents of that buffer (see $(D_INLINECODE glDrawBuffer) ). Logic operations have no effect on floating point draw buffers. However, if $(D_INLINECODE GL_COLOR_LOGIC_OP) is enabled, blending is still disabled in this case.
     + 
     + Params:
     +     opcode = Specifies a symbolic constant that selects a logical operation. The following symbols are accepted: $(D_INLINECODE GL_CLEAR), $(D_INLINECODE GL_SET), $(D_INLINECODE GL_COPY), $(D_INLINECODE GL_COPY_INVERTED), $(D_INLINECODE GL_NOOP), $(D_INLINECODE GL_INVERT), $(D_INLINECODE GL_AND), $(D_INLINECODE GL_NAND), $(D_INLINECODE GL_OR), $(D_INLINECODE GL_NOR), $(D_INLINECODE GL_XOR), $(D_INLINECODE GL_EQUIV), $(D_INLINECODE GL_AND_REVERSE), $(D_INLINECODE GL_AND_INVERTED), $(D_INLINECODE GL_OR_REVERSE), and $(D_INLINECODE GL_OR_INVERTED). The initial value is $(D_INLINECODE GL_COPY).
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBlendFunc), $(D_INLINECODE glDrawBuffer), $(D_INLINECODE glEnable), $(D_INLINECODE glStencilOp)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glLogicOp glLogicOp;
    alias fn_glMapBuffer = extern(System) void* function(GLenum target, GLenum access) @system @nogc nothrow;

    /++
     + glMapBuffer: man4/glMapBuffer.xml
     + 
     + $(D_INLINECODE glMapBuffer) and $(D_INLINECODE glMapNamedBuffer) map the entire data store of a specified buffer object into the client's address space. The data can then be directly read and/or written relative to the returned pointer, depending on the specified $(D_INLINECODE access) policy. A pointer to the beginning of the mapped range is returned once all pending operations on that buffer object have completed, and may be used to modify and/or query the corresponding range of the data store according to the value of $(D_INLINECODE access) : $(OL $(LI $(D_INLINECODE GL_READ_ONLY) indicates that the returned pointer may be used to read buffer object data.) $(LI $(D_INLINECODE GL_WRITE_ONLY) indicates that the returned pointer may be used to modify buffer object data.) $(LI $(D_INLINECODE GL_READ_WRITE) indicates that the returned pointer may be used to read and to modify buffer object data.)) If an error is generated, a $(D_INLINECODE null
     + ) pointer is returned. If no error occurs, the returned pointer will reflect an allocation aligned to the value of $(D_INLINECODE GL_MIN_MAP_BUFFER_ALIGNMENT) basic machine units. The returned pointer values may not be passed as parameter values to GL commands. For example, they may not be used to specify array pointers, or to specify or query pixel or texture image data; such actions produce undefined results, although implementations may not check for such behavior for performance reasons. No GL error is generated if the returned pointer is accessed in a way inconsistent with $(D_INLINECODE access) (e.g. used to read from a mapping made with $(D_INLINECODE access) $(D_INLINECODE GL_WRITE_ONLY) or write to a mapping made with $(D_INLINECODE access) $(D_INLINECODE GL_READ_ONLY) ), but the result is undefined and system errors (possibly including program termination) may occur. Mappings to the data stores of buffer objects may have nonstandard performance characteristics. For example, such mappings may be marked as uncacheable regions of memory, and in such cases reading from them may be very slow. To ensure optimal performance, the client should use the mapping in a fashion consistent with the values of $(D_INLINECODE GL_BUFFER_USAGE) for the buffer object and of $(D_INLINECODE access). Using a mapping in a fashion inconsistent with these values is liable to be multiple orders of magnitude slower than using normal memory.
     + 
     + Alignment of the returned pointer is guaranteed only if the version of the GL version is 4.2 or greater. Also, the $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) target is accepted only if the GL version is 4.2 or greater. The $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) and $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) targets are available only if the GL version is 4.3 or greater. The $(D_INLINECODE GL_QUERY_BUFFER) target is available only if the GL version is 4.4 or greater.
     + 
     + Params:
     +     target = Specifies the target to which the buffer object is bound for $(D_INLINECODE glMapBuffer), which must be one of the buffer binding targets in the following table: $(B Buffer Binding Target) $(B Purpose) $(D_INLINECODE GL_ARRAY_BUFFER) Vertex attributes $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) Atomic counter storage $(D_INLINECODE GL_COPY_READ_BUFFER) Buffer copy source $(D_INLINECODE GL_COPY_WRITE_BUFFER) Buffer copy destination $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) Indirect compute dispatch commands $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) Indirect command arguments $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) Vertex array indices $(D_INLINECODE GL_PIXEL_PACK_BUFFER) Pixel read target $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) Texture data source $(D_INLINECODE GL_QUERY_BUFFER) Query result buffer $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) Read-write storage for shaders $(D_INLINECODE GL_TEXTURE_BUFFER) Texture data buffer $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) Transform feedback buffer $(D_INLINECODE GL_UNIFORM_BUFFER) Uniform block storage
     +     buffer = Specifies the name of the buffer object for $(D_INLINECODE glMapNamedBuffer).
     +     access = Specifies the access policy for $(D_INLINECODE glMapBuffer) and $(D_INLINECODE glMapNamedBuffer), indicating whether it will be possible to read from, write to, or both read from and write to the buffer object's mapped data store. The symbolic constant must be $(D_INLINECODE GL_READ_ONLY), $(D_INLINECODE GL_WRITE_ONLY), or $(D_INLINECODE GL_READ_WRITE).
     + 
     + Copyright:
     +     Copyright&copy; 2005 Addison-Wesley. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBuffer), $(D_INLINECODE glBindBufferBase), $(D_INLINECODE glBindBufferRange), $(D_INLINECODE glBufferData), $(D_INLINECODE glBufferSubData), $(D_INLINECODE glDeleteBuffers), $(D_INLINECODE glMapBufferRange), $(D_INLINECODE glUnmapBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    fn_glMapBuffer glMapBuffer;
    alias fn_glMapNamedBuffer = extern(System) void* function(GLuint buffer, GLenum access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glMapNamedBuffer glMapNamedBuffer;
    alias fn_glMapBufferRange = extern(System) void* function(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access) @system @nogc nothrow;

    /++
     + glMapBufferRange: man4/glMapBufferRange.xml
     + 
     + $(D_INLINECODE glMapBufferRange) and $(D_INLINECODE glMapNamedBufferRange) map all or part of the data store of a specified buffer object into the client's address space. $(D_INLINECODE offset) and $(D_INLINECODE length) indicate the range of data in the buffer object that is to be mapped, in terms of basic machine units. $(D_INLINECODE access) is a bitfield containing flags which describe the requested mapping. These flags are described below. A pointer to the beginning of the mapped range is returned once all pending operations on the buffer object have completed, and may be used to modify and/or query the corresponding range of the data store according to the following flag bits set in $(D_INLINECODE access) : $(OL $(LI $(D_INLINECODE GL_MAP_READ_BIT) indicates that the returned pointer may be used to read buffer object data. No GL error is generated if the pointer is used to query a mapping which excludes this flag, but the result is undefined and system errors (possibly including program termination) may occur.) $(LI $(D_INLINECODE GL_MAP_WRITE_BIT) indicates that the returned pointer may be used to modify buffer object data. No GL error is generated if the pointer is used to modify a mapping which excludes this flag, but the result is undefined and system errors (possibly including program termination) may occur.) $(LI $(D_INLINECODE GL_MAP_PERSISTENT_BIT) indicates that the mapping is to be made in a persistent fassion and that the client intends to hold and use the returned pointer during subsequent GL operation. It is not an error to call drawing commands (render) while buffers are mapped using this flag. It is an error to specify this flag if the buffer's data store was not allocated through a call to the $(D_INLINECODE glBufferStorage) command in which the $(D_INLINECODE GL_MAP_PERSISTENT_BIT) was also set.) $(LI $(D_INLINECODE GL_MAP_COHERENT_BIT) indicates that a persistent mapping is also to be coherent. Coherent maps guarantee that the effect of writes to a buffer's data store by either the client or server will eventually become visible to the other without further intervention from the application. In the absence of this bit, persistent mappings are not coherent and modified ranges of the buffer store must be explicitly communicated to the GL, either by unmapping the buffer, or through a call to $(D_INLINECODE glFlushMappedBufferRange) or $(D_INLINECODE glMemoryBarrier).)) The following flag bits in $(D_INLINECODE access) may be used to modify the mapping: $(OL $(LI $(D_INLINECODE GL_MAP_INVALIDATE_RANGE_BIT) indicates that the previous contents of the specified range may be discarded. Data within this range are undefined with the exception of subsequently written data. No GL error is generated if subsequent GL operations access unwritten data, but the result is undefined and system errors (possibly including program termination) may occur. This flag may not be used in combination with $(D_INLINECODE GL_MAP_READ_BIT).) $(LI $(D_INLINECODE GL_MAP_INVALIDATE_BUFFER_BIT) indicates that the previous contents of the entire buffer may be discarded. Data within the entire buffer are undefined with the exception of subsequently written data. No GL error is generated if subsequent GL operations access unwritten data, but the result is undefined and system errors (possibly including program termination) may occur. This flag may not be used in combination with $(D_INLINECODE GL_MAP_READ_BIT).) $(LI $(D_INLINECODE GL_MAP_FLUSH_EXPLICIT_BIT) indicates that one or more discrete subranges of the mapping may be modified. When this flag is set, modifications to each subrange must be explicitly flushed by calling $(D_INLINECODE glFlushMappedBufferRange). No GL error is set if a subrange of the mapping is modified and not flushed, but data within the corresponding subrange of the buffer are undefined. This flag may only be used in conjunction with $(D_INLINECODE GL_MAP_WRITE_BIT). When this option is selected, flushing is strictly limited to regions that are explicitly indicated with calls to $(D_INLINECODE glFlushMappedBufferRange) prior to unmap; if this option is not selected $(D_INLINECODE glUnmapBuffer) will automatically flush the entire mapped range when called.) $(LI $(D_INLINECODE GL_MAP_UNSYNCHRONIZED_BIT) indicates that the GL should not attempt to synchronize pending operations on the buffer prior to returning from $(D_INLINECODE glMapBufferRange) or $(D_INLINECODE glMapNamedBufferRange). No GL error is generated if pending operations which source or modify the buffer overlap the mapped region, but the result of such previous and any subsequent operations is undefined.)) If an error occurs, a $(D_INLINECODE null
     + ) pointer is returned. If no error occurs, the returned pointer will reflect an allocation aligned to the value of $(D_INLINECODE GL_MIN_MAP_BUFFER_ALIGNMENT) basic machine units. Subtracting $(D_INLINECODE offset) from this returned pointer will always produce a multiple of the value of $(D_INLINECODE GL_MIN_MAP_BUFFER_ALIGNMENT). The returned pointer values may not be passed as parameter values to GL commands. For example, they may not be used to specify array pointers, or to specify or query pixel or texture image data; such actions produce undefined results, although implementations may not check for such behavior for performance reasons. Mappings to the data stores of buffer objects may have nonstandard performance characteristics. For example, such mappings may be marked as uncacheable regions of memory, and in such cases reading from them may be very slow. To ensure optimal performance, the client should use the mapping in a fashion consistent with the values of $(D_INLINECODE GL_BUFFER_USAGE) for the buffer object and of $(D_INLINECODE access). Using a mapping in a fashion inconsistent with these values is liable to be multiple orders of magnitude slower than using normal memory.
     + 
     + Alignment of the returned pointer is guaranteed only if the version of the GL version is 4.2 or greater. Also, the $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) target is accepted only if the GL version is 4.2 or greater. The $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) and $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) targets are accepted only if the GL version is 4.3 or greater. The $(D_INLINECODE GL_QUERY_BUFFER) target is available only if the GL version is 4.4 or greater. The $(D_INLINECODE GL_MAP_PERSISTENT_BIT) and $(D_INLINECODE GL_MAP_COHERENT_BIT) flags are available only if the GL version is 4.4 or greater.
     + 
     + Params:
     +     target = Specifies the target to which the buffer object is bound for $(D_INLINECODE glMapBufferRange), which must be one of the buffer binding targets in the following table: $(B Buffer Binding Target) $(B Purpose) $(D_INLINECODE GL_ARRAY_BUFFER) Vertex attributes $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) Atomic counter storage $(D_INLINECODE GL_COPY_READ_BUFFER) Buffer copy source $(D_INLINECODE GL_COPY_WRITE_BUFFER) Buffer copy destination $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) Indirect compute dispatch commands $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) Indirect command arguments $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) Vertex array indices $(D_INLINECODE GL_PIXEL_PACK_BUFFER) Pixel read target $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) Texture data source $(D_INLINECODE GL_QUERY_BUFFER) Query result buffer $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) Read-write storage for shaders $(D_INLINECODE GL_TEXTURE_BUFFER) Texture data buffer $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) Transform feedback buffer $(D_INLINECODE GL_UNIFORM_BUFFER) Uniform block storage
     +     buffer = Specifies the name of the buffer object for $(D_INLINECODE glMapNamedBufferRange).
     +     offset = Specifies the starting offset within the buffer of the range to be mapped.
     +     length = Specifies the length of the range to be mapped.
     +     access = Specifies a combination of access flags indicating the desired access to the mapped range.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glMapBuffer), $(D_INLINECODE glUnmapBuffer), $(D_INLINECODE glFlushMappedBufferRange), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glBufferStorage)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_map_buffer_range")
    fn_glMapBufferRange glMapBufferRange;
    alias fn_glMapNamedBufferRange = extern(System) void* function(GLuint buffer, GLintptr offset, GLsizei length, GLbitfield access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glMapNamedBufferRange glMapNamedBufferRange;
    alias fn_glMemoryBarrier = extern(System) void function(GLbitfield barriers) @system @nogc nothrow;

    /++
     + glMemoryBarrier: man4/glMemoryBarrier.xml
     + 
     + $(D_INLINECODE glMemoryBarrier) defines a barrier ordering the memory transactions issued prior to the command relative to those issued after the barrier. For the purposes of this ordering, memory transactions performed by shaders are considered to be issued by the rendering command that triggered the execution of the shader. $(D_INLINECODE barriers) is a bitfield indicating the set of operations that are synchronized with shader stores; the bits used in $(D_INLINECODE barriers) are as follows: If $(D_INLINECODE barriers) is $(D_INLINECODE GL_ALL_BARRIER_BITS), shader memory accesses will be synchronized relative to all the operations described above. Implementations may cache buffer object and texture image memory that could be written by shaders in multiple caches; for example, there may be separate caches for texture, vertex fetching, and one or more caches for shader memory accesses.  Implementations are not required to keep these caches coherent with shader memory writes.  Stores issued by one invocation may not be immediately observable by other pipeline stages or other shader invocations because the value stored may remain in a cache local to the processor executing the store, or because data overwritten by the store is still in a cache elsewhere in the system. When $(D_INLINECODE glMemoryBarrier) is called, the GL flushes and/or invalidates any caches relevant to the operations specified by the $(D_INLINECODE barriers) parameter to ensure consistent ordering of operations across the barrier. To allow for independent shader invocations to communicate by reads and writes to a common memory address, image variables in the OpenGL Shading Language may be declared as "coherent".  Buffer object or texture image memory accessed through such variables may be cached only if caches are automatically updated due to stores issued by any other shader invocation. If the same address is accessed using both coherent and non-coherent variables, the accesses using variables declared as coherent will observe the results stored using coherent variables in other invocations.  Using variables declared as "coherent" guarantees only that the results of stores will be immediately visible to shader invocations using similarly-declared variables; calling $(D_INLINECODE glMemoryBarrier) is required to ensure that the stores are visible to other operations. The following guidelines may be helpful in choosing when to use coherent memory accesses and when to use barriers. $(OL $(LI Data that are read-only or constant may be accessed without using coherent variables or calling $(D_INLINECODE MemoryBarrier) (). Updates to the read-only data via API calls such as $(D_INLINECODE glBufferSubData) will invalidate shader caches implicitly as required.) $(LI Data that are shared between shader invocations at a fine granularity (e.g., written by one invocation, consumed by another invocation) should use coherent variables to read and write the shared data.) $(LI Data written by one shader invocation and consumed by other shader invocations launched as a result of its execution (&quot;dependent invocations&quot;) should use coherent variables in the producing shader invocation and call $(D_INLINECODE memoryBarrier) () after the last write. The consuming shader invocation should also use coherent variables.) $(LI Data written to image variables in one rendering pass and read by the shader in a later pass need not use coherent variables or memoryBarrier(). Calling $(D_INLINECODE glMemoryBarrier) with the SHADER_IMAGE_ACCESS_BARRIER_BIT set in $(D_INLINECODE barriers) between passes is necessary.) $(LI Data written by the shader in one rendering pass and read by another mechanism (e.g., vertex or index buffer pulling) in a later pass need not use coherent variables or $(D_INLINECODE memoryBarrier) (). Calling $(D_INLINECODE glMemoryBarrier) with the appropriate bits set in $(D_INLINECODE barriers) between passes is necessary.))
     + 
     + $(D_INLINECODE GL_SHADER_STORAGE_BARRIER_BIT) is available only if the GL version is 4.3 or higher. $(D_INLINECODE GL_QUERY_BUFFER_BARRIER_BIT) is available only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     barriers = Specifies the barriers to insert. For $(D_INLINECODE glMemoryBarrier), must be a bitwise combination of any of $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT), $(D_INLINECODE GL_ELEMENT_ARRAY_BARRIER_BIT), $(D_INLINECODE GL_UNIFORM_BARRIER_BIT), $(D_INLINECODE GL_TEXTURE_FETCH_BARRIER_BIT), $(D_INLINECODE GL_SHADER_IMAGE_ACCESS_BARRIER_BIT), $(D_INLINECODE GL_COMMAND_BARRIER_BIT), $(D_INLINECODE GL_PIXEL_BUFFER_BARRIER_BIT), $(D_INLINECODE GL_TEXTURE_UPDATE_BARRIER_BIT), $(D_INLINECODE GL_BUFFER_UPDATE_BARRIER_BIT), $(D_INLINECODE GL_FRAMEBUFFER_BARRIER_BIT), $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BARRIER_BIT), $(D_INLINECODE GL_ATOMIC_COUNTER_BARRIER_BIT), or $(D_INLINECODE GL_SHADER_STORAGE_BARRIER_BIT). For $(D_INLINECODE glMemoryBarrier), must be a bitwise combination of any of $(D_INLINECODE GL_ATOMIC_COUNTER_BARRIER_BIT), or $(D_INLINECODE GL_FRAMEBUFFER_BARRIER_BIT), $(D_INLINECODE GL_SHADER_IMAGE_ACCESS_BARRIER_BIT), $(D_INLINECODE GL_SHADER_STORAGE_BARRIER_BIT). $(D_INLINECODE GL_TEXTURE_FETCH_BARRIER_BIT), or $(D_INLINECODE GL_UNIFORM_BARRIER_BIT). If the special value $(D_INLINECODE GL_ALL_BARRIER_BITS) is specified, all supported barriers for the corresponding command will be inserted.
     + 
     + Copyright:
     +     Copyright&copy; 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindImageTexture), $(D_INLINECODE glBufferData), $(D_INLINECODE glMapBuffer), $(D_INLINECODE glMapBufferRange), $(D_INLINECODE glFlushMappedBufferRange), $(D_INLINECODE memoryBarrier)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P2)
    @OpenGL_Extension("GL_ARB_shader_image_load_store")
    fn_glMemoryBarrier glMemoryBarrier;
    alias fn_glMemoryBarrierByRegion = extern(System) void function(GLbitfield barriers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_ES3_1_compatibility")
    fn_glMemoryBarrierByRegion glMemoryBarrierByRegion;
    alias fn_glMinSampleShading = extern(System) void function(GLfloat value) @system @nogc nothrow;

    /++
     + glMinSampleShading: man4/glMinSampleShading.xml
     + 
     + $(D_INLINECODE glMinSampleShading) specifies the rate at which samples are shaded within a covered pixel. Sample-rate shading is enabled by calling $(D_INLINECODE glEnable) with the parameter $(D_INLINECODE GL_SAMPLE_SHADING). If $(D_INLINECODE GL_MULTISAMPLE) or $(D_INLINECODE GL_SAMPLE_SHADING) is disabled, sample shading has no effect. Otherwise, an implementation must provide at least as many unique color values for each covered fragment as specified by $(D_INLINECODE value) times $(D_INLINECODE samples) where $(D_INLINECODE samples) is the value of $(D_INLINECODE GL_SAMPLES) for the current framebuffer. At least 1 sample for each covered fragment is generated. A $(D_INLINECODE value) of 1.0 indicates that each sample in the framebuffer should be indpendently shaded. A $(D_INLINECODE value) of 0.0 effectively allows the GL to ignore sample rate shading. Any value between 0.0 and 1.0 allows the GL to shade only a subset of the total samples within each covered fragment. Which samples are shaded and the algorithm used to select that subset of the fragment's samples is implementation dependent.
     + 
     + The type of the $(D_INLINECODE value) parameter was changed from GLclampf to GLfloat. This change is transparent to user code and is described in detail on the $(D_INLINECODE removedTypes) page.
     + 
     + Params:
     +     value = Specifies the rate at which samples are shaded within each covered pixel.
     + 
     + Copyright:
     +     Copyright&copy; 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE removedTypes)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    fn_glMinSampleShading glMinSampleShading;
    alias fn_glMultiDrawArrays = extern(System) void function(GLenum mode, const( GLint*) first, const( GLsizei*) count, GLsizei drawcount) @system @nogc nothrow;

    /++
     + glMultiDrawArrays: man4/glMultiDrawArrays.xml
     + 
     + $(D_INLINECODE glMultiDrawArrays) specifies multiple sets of geometric primitives with very few subroutine calls. Instead of calling a GL procedure to pass each individual vertex, normal, texture coordinate, edge flag, or color, you can prespecify separate arrays of vertices, normals, and colors and use them to construct a sequence of primitives with a single call to $(D_INLINECODE glMultiDrawArrays). $(D_INLINECODE glMultiDrawArrays) behaves identically to $(D_INLINECODE glDrawArrays) except that $(D_INLINECODE drawcount) separate ranges of elements are specified instead. When $(D_INLINECODE glMultiDrawArrays) is called, it uses $(D_INLINECODE count) sequential elements from each enabled array to construct a sequence of geometric primitives, beginning with element $(D_INLINECODE first). $(D_INLINECODE mode) specifies what kind of primitives are constructed, and how the array elements construct those primitives. Vertex attributes that are modified by $(D_INLINECODE glMultiDrawArrays) have an unspecified value after $(D_INLINECODE glMultiDrawArrays) returns. Attributes that aren't modified remain well defined.
     + 
     + $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY) and $(D_INLINECODE GL_TRIANGLES_ADJACENCY) are available only if the GL version is 3.2 or greater.
     + 
     + Params:
     +     mode      = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY) and $(D_INLINECODE GL_PATCHES) are accepted.
     +     first     = Points to an array of starting indices in the enabled arrays.
     +     count     = Points to an array of the number of indices to be rendered.
     +     drawcount = Specifies the size of the first and count
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glMultiDrawArrays glMultiDrawArrays;
    alias fn_glMultiDrawArraysIndirect = extern(System) void function(GLenum mode, const( void*) indirect, GLsizei drawcount, GLsizei stride) @system @nogc nothrow;

    /++
     + glMultiDrawArraysIndirect: man4/glMultiDrawArraysIndirect.xml
     + 
     + $(D_INLINECODE glMultiDrawArraysIndirect) specifies multiple geometric primitives with very few subroutine calls. $(D_INLINECODE glMultiDrawArraysIndirect) behaves similarly to a multitude of calls to $(D_INLINECODE glDrawArraysInstancedBaseInstance), execept that the parameters to each call to $(D_INLINECODE glDrawArraysInstancedBaseInstance) are stored in an array in memory at the address given by $(D_INLINECODE indirect), separated by the stride, in basic machine units, specified by $(D_INLINECODE stride). If $(D_INLINECODE stride) is zero, then the array is assumed to be tightly packed in memory. The parameters addressed by $(D_INLINECODE indirect) are packed into an array of structures, each element of which takes the form (in C):
     + 
     + ---
     + typedef  struct {
     +     uint  count;
     +     uint  instanceCount;
     +     uint  first;
     +     uint  baseInstance;
     + } DrawArraysIndirectCommand;
     + ---
     +  A single call to $(D_INLINECODE glMultiDrawArraysIndirect) is equivalent, assuming no errors are generated to:
     + 
     + ---
     + GLsizei n;
     + for (n = 0; n &lt; drawcount; n++) {
     +     const DrawArraysIndirectCommand *cmd;
     +     if (stride != 0) {
     +         cmd = (const DrawArraysIndirectCommand  *)((uintptr)indirect + n * stride);
     +     } else  {
     +         cmd = (const DrawArraysIndirectCommand  *)indirect + n;
     +     }
     + 
     +     glDrawArraysInstancedBaseInstance(mode, cmd-&gt;first, cmd-&gt;count, cmd-&gt;instanceCount, cmd-&gt;baseInstance);
     + }
     + ---
     +  If a buffer is bound to the $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) binding at the time of a call to $(D_INLINECODE glMultiDrawArraysIndirect), $(D_INLINECODE indirect) is interpreted as an offset, in basic machine units, into that buffer and the parameter data is read from the buffer rather than from client memory. In contrast to $(D_INLINECODE glDrawArraysInstancedBaseInstance), the $(D_INLINECODE first) member of the parameter structure is unsigned, and out-of-range indices do not generate an error. Vertex attributes that are modified by $(D_INLINECODE glMultiDrawArraysIndirect) have an unspecified value after $(D_INLINECODE glMultiDrawArraysIndirect) returns. Attributes that aren't modified remain well defined.
     + 
     + The $(D_INLINECODE baseInstance) member of the $(D_INLINECODE DrawArraysIndirectCommand) structure is defined only if the GL version is 4.2 or greater. For versions of the GL less than 4.2, this parameter is present but is reserved and should be set to zero. On earlier versions of the GL, behavior is undefined if it is non-zero. $(D_INLINECODE glMultiDrawArraysIndirect) is available only if the GL version is 4.3 or greater.
     + 
     + Params:
     +     mode      = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY), and $(D_INLINECODE GL_PATCHES) are accepted.
     +     indirect  = Specifies the address of an array of structures containing the draw parameters.
     +     drawcount = Specifies the the number of elements in the array of draw parameter structures.
     +     stride    = Specifies the distance in basic machine units between elements of the draw parameter array.
     + 
     + Copyright:
     +     Copyright&copy; 2012-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawArraysInstanced), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawArraysIndirect), $(D_INLINECODE glMultiDrawElementsIndirect)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_multi_draw_indirect")
    fn_glMultiDrawArraysIndirect glMultiDrawArraysIndirect;
    alias fn_glMultiDrawElements = extern(System) void function(GLenum mode, const( GLsizei*) count, GLenum type, const(const(GLvoid*)*) indices, GLsizei drawcount) @system @nogc nothrow;

    /++
     + glMultiDrawElements: man4/glMultiDrawElements.xml
     + 
     + $(D_INLINECODE glMultiDrawElements) specifies multiple sets of geometric primitives with very few subroutine calls. Instead of calling a GL function to pass each individual vertex, normal, texture coordinate, edge flag, or color, you can prespecify separate arrays of vertices, normals, and so on, and use them to construct a sequence of primitives with a single call to $(D_INLINECODE glMultiDrawElements). $(D_INLINECODE glMultiDrawElements) is identical in operation to $(D_INLINECODE glDrawElements) except that $(D_INLINECODE drawcount) separate lists of elements are specified. Vertex attributes that are modified by $(D_INLINECODE glMultiDrawElements) have an unspecified value after $(D_INLINECODE glMultiDrawElements) returns. Attributes that aren't modified maintain their previous values.
     + 
     + $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY) and $(D_INLINECODE GL_TRIANGLES_ADJACENCY) are available only if the GL version is 3.2 or greater.
     + 
     + Params:
     +     mode      = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY) and $(D_INLINECODE GL_PATCHES) are accepted.
     +     count     = Points to an array of the elements counts.
     +     type      = Specifies the type of the values in $(D_INLINECODE indices). Must be one of $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), or $(D_INLINECODE GL_UNSIGNED_INT).
     +     indices   = Specifies a pointer to the location where the indices are stored.
     +     drawcount = Specifies the size of the $(D_INLINECODE count) and $(D_INLINECODE indices) arrays.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawRangeElements)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glMultiDrawElements glMultiDrawElements;
    alias fn_glMultiDrawElementsBaseVertex = extern(System) void function(GLenum mode, const( GLsizei*) count, GLenum type, const(const(GLvoid*)*) indices, GLsizei drawcount, const( GLint*) basevertex) @system @nogc nothrow;

    /++
     + glMultiDrawElementsBaseVertex: man4/glMultiDrawElementsBaseVertex.xml
     + 
     + $(D_INLINECODE glMultiDrawElementsBaseVertex) behaves identically to $(D_INLINECODE glDrawElementsBaseVertex), except that $(D_INLINECODE drawcount) separate lists of elements are specifried instead. It has the same effect as:
     + 
     + ---
     + for (int i = 0; i &lt;  $(D_INLINECODE drawcount); i++)
     +     if ( $(D_INLINECODE count)[i] &gt; 0)
     +         glDrawElementsBaseVertex( $(D_INLINECODE mode),
     +                                   $(D_INLINECODE count)[i],
     +                                   $(D_INLINECODE type),
     +                                   $(D_INLINECODE indices[i]),
     +                                   $(D_INLINECODE basevertex[i]));
     + ---
     + 
     + 
     + $(D_INLINECODE glMultiDrawElementsBaseVertex) is available only if the GL version is 3.1 or greater. $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY) and $(D_INLINECODE GL_TRIANGLES_ADJACENCY) are available only if the GL version is 3.2 or greater.
     + 
     + Params:
     +     mode       = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY) and $(D_INLINECODE GL_PATCHES) are accepted.
     +     count      = Points to an array of the elements counts.
     +     type       = Specifies the type of the values in $(D_INLINECODE indices). Must be one of $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), or $(D_INLINECODE GL_UNSIGNED_INT).
     +     indices    = Specifies a pointer to the location where the indices are stored.
     +     drawcount  = Specifies the size of the $(D_INLINECODE count), $(D_INLINECODE indices) and $(D_INLINECODE basevertex) arrays.
     +     basevertex = Specifies a pointer to the location where the base vertices are stored.
     + 
     + Copyright:
     +     Copyright&copy; 2010 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glMultiDrawElements), $(D_INLINECODE glDrawElementsBaseVertex), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glVertexAttribPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_draw_elements_base_vertex")
    fn_glMultiDrawElementsBaseVertex glMultiDrawElementsBaseVertex;
    alias fn_glMultiDrawElementsIndirect = extern(System) void function(GLenum mode, GLenum type, const( void*) indirect, GLsizei drawcount, GLsizei stride) @system @nogc nothrow;

    /++
     + glMultiDrawElementsIndirect: man4/glMultiDrawElementsIndirect.xml
     + 
     + $(D_INLINECODE glMultiDrawElementsIndirect) specifies multiple indexed geometric primitives with very few subroutine calls. $(D_INLINECODE glMultiDrawElementsIndirect) behaves similarly to a multitude of calls to $(D_INLINECODE glDrawElementsInstancedBaseVertexBaseInstance), execpt that the parameters to $(D_INLINECODE glDrawElementsInstancedBaseVertexBaseInstance) are stored in an array in memory at the address given by $(D_INLINECODE indirect), separated by the stride, in basic machine units, specified by $(D_INLINECODE stride). If $(D_INLINECODE stride) is zero, then the array is assumed to be tightly packed in memory. The parameters addressed by $(D_INLINECODE indirect) are packed into a structure that takes the form (in C):
     + 
     + ---
     + typedef  struct {
     +     uint  count;
     +     uint  instanceCount;
     +     uint  firstIndex;
     +     uint  baseVertex;
     +     uint  baseInstance;
     + } DrawElementsIndirectCommand;
     + ---
     +  A single call to $(D_INLINECODE glMultiDrawElementsIndirect) is equivalent, assuming no errors are generated to:
     + 
     + ---
     + GLsizei n;
     + for (n = 0; n &lt; drawcount; n++) {
     +     const DrawElementsIndirectCommand *cmd;
     +     if (stride != 0) {
     +         cmd = (const DrawElementsIndirectCommand  *)((uintptr)indirect + n * stride);
     +     } else {
     +         cmd = (const DrawElementsIndirectCommand  *)indirect + n;
     +     }
     + 
     +     glDrawElementsInstancedBaseVertexBaseInstance(mode,
     +                                                   cmd-&gt;count,
     +                                                   type,
     +                                                   cmd-&gt;firstIndex + size-of-type,
     +                                                   cmd-&gt;instanceCount,
     +                                                   cmd-&gt;baseVertex,
     +                                                   cmd-&gt;baseInstance);
     + }
     + ---
     +  If a buffer is bound to the $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) binding at the time of a call to $(D_INLINECODE glDrawElementsIndirect), $(D_INLINECODE indirect) is interpreted as an offset, in basic machine units, into that buffer and the parameter data is read from the buffer rather than from client memory. Note that indices stored in client memory are not supported. If no buffer is bound to the $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) binding, an error will be generated. The results of the operation are undefined if the $(D_INLINECODE reservedMustBeZero) member of the parameter structure is non-zero. However, no error is generated in this case. Vertex attributes that are modified by $(D_INLINECODE glDrawElementsIndirect) have an unspecified value after $(D_INLINECODE glDrawElementsIndirect) returns. Attributes that aren't modified remain well defined.
     + 
     + The $(D_INLINECODE baseInstance) member of the $(D_INLINECODE DrawElementsIndirectCommand) structure is defined only if the GL version is 4.2 or greater. For versions of the GL less than 4.2, this parameter is present but is reserved and should be set to zero. On earlier versions of the GL, behavior is undefined if it is non-zero.
     + 
     + Params:
     +     mode      = Specifies what kind of primitives to render. Symbolic constants $(D_INLINECODE GL_POINTS), $(D_INLINECODE GL_LINE_STRIP), $(D_INLINECODE GL_LINE_LOOP), $(D_INLINECODE GL_LINES), $(D_INLINECODE GL_LINE_STRIP_ADJACENCY), $(D_INLINECODE GL_LINES_ADJACENCY), $(D_INLINECODE GL_TRIANGLE_STRIP), $(D_INLINECODE GL_TRIANGLE_FAN), $(D_INLINECODE GL_TRIANGLES), $(D_INLINECODE GL_TRIANGLE_STRIP_ADJACENCY), $(D_INLINECODE GL_TRIANGLES_ADJACENCY), and $(D_INLINECODE GL_PATCHES) are accepted.
     +     type      = Specifies the type of data in the buffer bound to the $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) binding.
     +     indirect  = Specifies the address of a structure containing an array of draw parameters.
     +     drawcount = Specifies the number of elements in the array addressed by $(D_INLINECODE indirect).
     +     stride    = Specifies the distance in basic machine units between elements of the draw parameter array.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawArraysInstanced), $(D_INLINECODE glDrawArraysIndirect), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawElementsIndirect), $(D_INLINECODE glMultiDrawArraysIndirect)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_multi_draw_indirect")
    fn_glMultiDrawElementsIndirect glMultiDrawElementsIndirect;
    alias fn_glReadBuffer = extern(System) void function(GLenum mode) @system @nogc nothrow;

    /++
     + glNamedFramebufferReadBuffer: man4/glReadBuffer.xml
     + 
     + $(D_INLINECODE glReadBuffer) specifies a color buffer as the source for subsequent $(D_INLINECODE glReadPixels), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), and $(D_INLINECODE glCopyTexSubImage3D) commands. $(D_INLINECODE mode) accepts one of twelve or more predefined values. In a fully configured system, $(D_INLINECODE GL_FRONT), $(D_INLINECODE GL_LEFT), and $(D_INLINECODE GL_FRONT_LEFT) all name the front left buffer, $(D_INLINECODE GL_FRONT_RIGHT) and $(D_INLINECODE GL_RIGHT) name the front right buffer, and $(D_INLINECODE GL_BACK_LEFT) and $(D_INLINECODE GL_BACK) name the back left buffer. Further more, the constants $(D_INLINECODE GL_COLOR_ATTACHMENT) may be used to indicate the<sup> th</sup> color attachment where ranges from zero to the value of $(D_INLINECODE GL_MAX_COLOR_ATTACHMENTS) minus one. Nonstereo double-buffered configurations have only a front left and a back left buffer. Single-buffered configurations have a front left and a front right buffer if stereo, and only a front left buffer if nonstereo. It is an error to specify a nonexistent buffer to $(D_INLINECODE glReadBuffer). $(D_INLINECODE mode) is initially $(D_INLINECODE GL_FRONT) in single-buffered configurations and $(D_INLINECODE GL_BACK) in double-buffered configurations. For $(D_INLINECODE glReadBuffer), the target framebuffer object is that bound to $(D_INLINECODE GL_READ_FRAMEBUFFER). For $(D_INLINECODE glNamedFramebufferReadBuffer), $(D_INLINECODE framebuffer) must either be zero or the name of the target framebuffer object. If $(D_INLINECODE framebuffer) is zero, then the default read framebuffer is affected.
     + 
     + Params:
     +     framebuffer = Specifies the name of the framebuffer object for $(D_INLINECODE glNamedFramebufferReadBuffer) function.
     +     mode        = Specifies a color buffer. Accepted values are $(D_INLINECODE GL_FRONT_LEFT), $(D_INLINECODE GL_FRONT_RIGHT), $(D_INLINECODE GL_BACK_LEFT), $(D_INLINECODE GL_BACK_RIGHT), $(D_INLINECODE GL_FRONT), $(D_INLINECODE GL_BACK), $(D_INLINECODE GL_LEFT), $(D_INLINECODE GL_RIGHT), and the constants $(D_INLINECODE GL_COLOR_ATTACHMENT).
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2011-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glDrawBuffer), $(D_INLINECODE glReadPixels)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glReadBuffer glReadBuffer;
    alias fn_glNamedFramebufferReadBuffer = extern(System) void function(GLuint framebuffer, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glNamedFramebufferReadBuffer glNamedFramebufferReadBuffer;
    alias fn_glRenderbufferStorage = extern(System) void function(GLenum target, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;

    /++
     + glNamedRenderbufferStorage: man4/glRenderbufferStorage.xml
     + 
     + $(D_INLINECODE glRenderbufferStorage) is equivalent to calling $(D_INLINECODE glRenderbufferStorageMultisample) with the $(D_INLINECODE samples) set to zero, and $(D_INLINECODE glNamedRenderbufferStorage) is equivalent to calling $(D_INLINECODE glNamedRenderbufferStorageMultisample) with the samples set to zero. For $(D_INLINECODE glRenderbufferStorage), the target of the operation, specified by $(D_INLINECODE target) must be $(D_INLINECODE GL_RENDERBUFFER). For $(D_INLINECODE glNamedRenderbufferStorage), $(D_INLINECODE renderbuffer) must be a name of an existing renderbuffer object. $(D_INLINECODE internalformat) specifies the internal format to be used for the renderbuffer object's storage and must be a color-renderable, depth-renderable, or stencil-renderable format. $(D_INLINECODE width) and $(D_INLINECODE height) are the dimensions, in pixels, of the renderbuffer. Both $(D_INLINECODE width) and $(D_INLINECODE height) must be less than or equal to the value of $(D_INLINECODE GL_MAX_RENDERBUFFER_SIZE). Upon success, $(D_INLINECODE glRenderbufferStorage) and $(D_INLINECODE glNamedRenderbufferStorage) delete any existing data store for the renderbuffer image and the contents of the data store after calling $(D_INLINECODE glRenderbufferStorage) are undefined.
     + 
     + Params:
     +     target         = Specifies a binding target of the allocation for $(D_INLINECODE glRenderbufferStorage) function. Must be $(D_INLINECODE GL_RENDERBUFFER).
     +     renderbuffer   = Specifies the name of the renderbuffer object for $(D_INLINECODE glNamedRenderbufferStorage) function.
     +     internalformat = Specifies the internal format to use for the renderbuffer object's image.
     +     width          = Specifies the width of the renderbuffer, in pixels.
     +     height         = Specifies the height of the renderbuffer, in pixels.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenRenderbuffers), $(D_INLINECODE glBindRenderbuffer), $(D_INLINECODE glNamedRenderbufferStorageMultisample), $(D_INLINECODE glRenderbufferStorageMultisample), $(D_INLINECODE glFramebufferRenderbuffer), $(D_INLINECODE glDeleteRenderbuffers)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    fn_glRenderbufferStorage glRenderbufferStorage;
    alias fn_glNamedRenderbufferStorage = extern(System) void function(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glNamedRenderbufferStorage glNamedRenderbufferStorage;
    alias fn_glRenderbufferStorageMultisample = extern(System) void function(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;

    /++
     + glNamedRenderbufferStorageMultisample: man4/glRenderbufferStorageMultisample.xml
     + 
     + $(D_INLINECODE glRenderbufferStorageMultisample) and $(D_INLINECODE glNamedRenderbufferStorageMultisample) establish the data storage, format, dimensions and number of samples of a renderbuffer object's image. For $(D_INLINECODE glRenderbufferStorageMultisample), the target of the operation, specified by $(D_INLINECODE target) must be $(D_INLINECODE GL_RENDERBUFFER). For $(D_INLINECODE glNamedRenderbufferStorageMultisample), $(D_INLINECODE renderbuffer) must be an ID of an existing renderbuffer object. $(D_INLINECODE internalformat) specifies the internal format to be used for the renderbuffer object's storage and must be a color-renderable, depth-renderable, or stencil-renderable format. $(D_INLINECODE width) and $(D_INLINECODE height) are the dimensions, in pixels, of the renderbuffer. Both $(D_INLINECODE width) and $(D_INLINECODE height) must be less than or equal to the value of $(D_INLINECODE GL_MAX_RENDERBUFFER_SIZE). $(D_INLINECODE samples) specifies the number of samples to be used for the renderbuffer object's image, and must be less than or equal to the value of $(D_INLINECODE GL_MAX_SAMPLES). If $(D_INLINECODE internalformat) is a signed or unsigned integer format then $(D_INLINECODE samples) must be less than or equal to the value of $(D_INLINECODE GL_MAX_INTEGER_SAMPLES). Upon success, $(D_INLINECODE glRenderbufferStorageMultisample) and $(D_INLINECODE glNamedRenderbufferStorageMultisample) delete any existing data store for the renderbuffer image and the contents of the data store after calling either of the functions are undefined.
     + 
     + Params:
     +     target         = Specifies a binding target of the allocation for $(D_INLINECODE glRenderbufferStorageMultisample) function. Must be $(D_INLINECODE GL_RENDERBUFFER).
     +     renderbuffer   = Specifies the name of the renderbuffer object for $(D_INLINECODE glNamedRenderbufferStorageMultisample) function.
     +     samples        = Specifies the number of samples to be used for the renderbuffer object's storage.
     +     internalformat = Specifies the internal format to use for the renderbuffer object's image.
     +     width          = Specifies the width of the renderbuffer, in pixels.
     +     height         = Specifies the height of the renderbuffer, in pixels.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenRenderbuffers), $(D_INLINECODE glBindRenderbuffer), $(D_INLINECODE glNamedRenderbufferStorage), $(D_INLINECODE glRenderbufferStorage), $(D_INLINECODE glFramebufferRenderbuffer), $(D_INLINECODE glDeleteRenderbuffers)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_framebuffer_object")
    fn_glRenderbufferStorageMultisample glRenderbufferStorageMultisample;
    alias fn_glNamedRenderbufferStorageMultisample = extern(System) void function(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glNamedRenderbufferStorageMultisample glNamedRenderbufferStorageMultisample;
    alias fn_glObjectLabel = extern(System) void function(GLenum identifier, GLuint name, GLsizei length, const( char*) label) @system @nogc nothrow;

    /++
     + glObjectLabel: man4/glObjectLabel.xml
     + 
     + $(D_INLINECODE glObjectLabel) labels the object identified by $(D_INLINECODE name) within the namespace given by $(D_INLINECODE identifier). $(D_INLINECODE identifier) must be one of $(D_INLINECODE GL_BUFFER), $(D_INLINECODE GL_SHADER), $(D_INLINECODE GL_PROGRAM), $(D_INLINECODE GL_VERTEX_ARRAY), $(D_INLINECODE GL_QUERY), $(D_INLINECODE GL_PROGRAM_PIPELINE), $(D_INLINECODE GL_TRANSFORM_FEEDBACK), $(D_INLINECODE GL_SAMPLER), $(D_INLINECODE GL_TEXTURE), $(D_INLINECODE GL_RENDERBUFFER), $(D_INLINECODE GL_FRAMEBUFFER), to indicate the namespace containing the names of buffers, shaders, programs, vertex array objects, query objects, program pipelines, transform feedback objects, samplers, textures, renderbuffers and frame buffers, respectively. $(D_INLINECODE label) is the address of a string that will be used to label an object. $(D_INLINECODE length) contains the number of characters in $(D_INLINECODE label). If $(D_INLINECODE length) is negative, it is implied that $(D_INLINECODE label) contains a null-terminated string. If $(D_INLINECODE label) is null, any debug label is effectively removed from the object.
     + 
     + Params:
     +     identifier = The namespace from which the name of the object is allocated.
     +     name       = The name of the object to label.
     +     length     = The length of the label to be used for the object.
     +     label      = The address of a string containing the label to assign to the object.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glPushDebugGroup), $(D_INLINECODE glPopDebugGroup), $(D_INLINECODE glObjectPtrLabel).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_KHR_debug")
    fn_glObjectLabel glObjectLabel;
    alias fn_glObjectPtrLabel = extern(System) void function(void* ptr, GLsizei length, const( char*) label) @system @nogc nothrow;

    /++
     + glObjectPtrLabel: man4/glObjectPtrLabel.xml
     + 
     + $(D_INLINECODE glObjectPtrLabel) labels the sync object identified by $(D_INLINECODE ptr). $(D_INLINECODE label) is the address of a string that will be used to label the object. $(D_INLINECODE length) contains the number of characters in $(D_INLINECODE label). If $(D_INLINECODE length) is negative, it is implied that $(D_INLINECODE label) contains a null-terminated string. If $(D_INLINECODE label) is null, any debug label is effectively removed from the object.
     + 
     + Params:
     +     ptr    = A pointer identifying a sync object.
     +     length = The length of the label to be used for the object.
     +     label  = The address of a string containing the label to assign to the object.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glPushDebugGroup), $(D_INLINECODE glPopDebugGroup), $(D_INLINECODE glObjectLabel).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_KHR_debug")
    fn_glObjectPtrLabel glObjectPtrLabel;
    alias fn_glPatchParameteri = extern(System) void function(GLenum pname, GLint value) @system @nogc nothrow;

    /++
     + glPatchParameter: man4/glPatchParameter.xml
     + 
     + $(D_INLINECODE glPatchParameter) specifies the parameters that will be used for patch primitives. $(D_INLINECODE pname) specifies the parameter to modify and must be either $(D_INLINECODE GL_PATCH_VERTICES), $(D_INLINECODE GL_PATCH_DEFAULT_OUTER_LEVEL) or $(D_INLINECODE GL_PATCH_DEFAULT_INNER_LEVEL). For $(D_INLINECODE glPatchParameteri), $(D_INLINECODE value) specifies the new value for the parameter specified by $(D_INLINECODE pname). For $(D_INLINECODE glPatchParameterfv), $(D_INLINECODE values) specifies the address of an array containing the new values for the parameter specified by $(D_INLINECODE pname). When $(D_INLINECODE pname) is $(D_INLINECODE GL_PATCH_VERTICES), $(D_INLINECODE value) specifies the number of vertices that will be used to make up a single patch primitive. Patch primitives are consumed by the tessellation control shader (if present) and subsequently used for tessellation. When primitives are specified using $(D_INLINECODE glDrawArrays) or a similar function, each patch will be made from $(D_INLINECODE parameter) control points, each represented by a vertex taken from the enabeld vertex arrays. $(D_INLINECODE parameter) must be greater than zero, and less than or equal to the value of $(D_INLINECODE GL_MAX_PATCH_VERTICES). When $(D_INLINECODE pname) is $(D_INLINECODE GL_PATCH_DEFAULT_OUTER_LEVEL) or $(D_INLINECODE GL_PATCH_DEFAULT_INNER_LEVEL), $(D_INLINECODE values) contains the address of an array contiaining the default outer or inner tessellation levels, respectively, to be used when no tessellation control shader is present.
     + 
     + Params:
     +     pname  = Specifies the name of the parameter to set. The symbolc constants $(D_INLINECODE GL_PATCH_VERTICES), $(D_INLINECODE GL_PATCH_DEFAULT_OUTER_LEVEL), and $(D_INLINECODE GL_PATCH_DEFAULT_INNER_LEVEL) are accepted.
     +     value  = Specifies the new value for the parameter given by $(D_INLINECODE pname).
     +     values = Specifies the address of an array containing the new values for the parameter given by $(D_INLINECODE pname).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawArraysInstanced), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements),
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_tessellation_shader")
    fn_glPatchParameteri glPatchParameteri;
    alias fn_glPauseTransformFeedback = extern(System) void function() @system @nogc nothrow;

    /++
     + glPauseTransformFeedback: man4/glPauseTransformFeedback.xml
     + 
     + $(D_INLINECODE glPauseTransformFeedback) pauses transform feedback operations on the currently active transform feedback object. When transform feedback operations are paused, transform feedback is still considered active and changing most transform feedback state related to the object results in an error. However, a new transform feedback object may be bound while transform feedback is paused.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenTransformFeedbacks), $(D_INLINECODE glBindTransformFeedback), $(D_INLINECODE glBeginTransformFeedback), $(D_INLINECODE glResumeTransformFeedback), $(D_INLINECODE glEndTransformFeedback), $(D_INLINECODE glDeleteTransformFeedbacks)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_transform_feedback2")
    fn_glPauseTransformFeedback glPauseTransformFeedback;
    alias fn_glPixelStoref = extern(System) void function(GLenum pname, GLfloat param) @system @nogc nothrow;

    /++
     + glPixelStore: man4/glPixelStore.xml
     + 
     + $(D_INLINECODE glPixelStore) sets pixel storage modes that affect the operation of subsequent $(D_INLINECODE glReadPixels) as well as the unpacking of texture patterns (see $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D) ), $(D_INLINECODE glCompressedTexImage1D), $(D_INLINECODE glCompressedTexImage2D), $(D_INLINECODE glCompressedTexImage3D), $(D_INLINECODE glCompressedTexSubImage1D), $(D_INLINECODE glCompressedTexSubImage2D) or $(D_INLINECODE glCompressedTexSubImage1D). $(D_INLINECODE pname) is a symbolic constant indicating the parameter to be set, and $(D_INLINECODE param) is the new value.  Six of the twelve storage parameters affect how pixel data is returned to client memory. They are as follows: The other six of the twelve storage parameters affect how pixel data is read from client memory. These values are significant for $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), and $(D_INLINECODE glTexSubImage3D) They are as follows: The following table gives the type, initial value, and range of valid values for each storage parameter that can be set with $(D_INLINECODE glPixelStore). $(B $(D_INLINECODE pname)) $(B Type) $(B Initial Value) $(B Valid Range) $(D_INLINECODE GL_PACK_SWAP_BYTES) boolean false true or false $(D_INLINECODE GL_PACK_LSB_FIRST) boolean false true or false $(D_INLINECODE GL_PACK_ROW_LENGTH) integer 0 0 &infin; $(D_INLINECODE GL_PACK_IMAGE_HEIGHT) integer 0 0 &infin; $(D_INLINECODE GL_PACK_SKIP_ROWS) integer 0 0 &infin; $(D_INLINECODE GL_PACK_SKIP_PIXELS) integer 0 0 &infin; $(D_INLINECODE GL_PACK_SKIP_IMAGES) integer 0 0 &infin; $(D_INLINECODE GL_PACK_ALIGNMENT) integer 4 1, 2, 4, or 8 $(D_INLINECODE GL_UNPACK_SWAP_BYTES) boolean false true or false $(D_INLINECODE GL_UNPACK_LSB_FIRST) boolean false true or false $(D_INLINECODE GL_UNPACK_ROW_LENGTH) integer 0 0 &infin; $(D_INLINECODE GL_UNPACK_IMAGE_HEIGHT) integer 0 0 &infin; $(D_INLINECODE GL_UNPACK_SKIP_ROWS) integer 0 0 &infin; $(D_INLINECODE GL_UNPACK_SKIP_PIXELS) integer 0 0 &infin; $(D_INLINECODE GL_UNPACK_SKIP_IMAGES) integer 0 0 &infin; $(D_INLINECODE GL_UNPACK_ALIGNMENT) integer 4 1, 2, 4, or 8 $(D_INLINECODE glPixelStoref) can be used to set any pixel store parameter. If the parameter type is boolean, then if $(D_INLINECODE param) is 0, the parameter is false; otherwise it is set to true. If $(D_INLINECODE pname) is a integer type parameter, $(D_INLINECODE param) is rounded to the nearest integer. Likewise, $(D_INLINECODE glPixelStorei) can also be used to set any of the pixel store parameters. Boolean parameters are set to false if $(D_INLINECODE param) is 0 and true otherwise.
     + 
     + Params:
     +     pname = Specifies the symbolic name of the parameter to be set. Six values affect the packing of pixel data into memory: $(D_INLINECODE GL_PACK_SWAP_BYTES), $(D_INLINECODE GL_PACK_LSB_FIRST), $(D_INLINECODE GL_PACK_ROW_LENGTH), $(D_INLINECODE GL_PACK_IMAGE_HEIGHT), $(D_INLINECODE GL_PACK_SKIP_PIXELS), $(D_INLINECODE GL_PACK_SKIP_ROWS), $(D_INLINECODE GL_PACK_SKIP_IMAGES), and $(D_INLINECODE GL_PACK_ALIGNMENT). Six more affect the unpacking of pixel data memory: $(D_INLINECODE GL_UNPACK_SWAP_BYTES), $(D_INLINECODE GL_UNPACK_LSB_FIRST), $(D_INLINECODE GL_UNPACK_ROW_LENGTH), $(D_INLINECODE GL_UNPACK_IMAGE_HEIGHT), $(D_INLINECODE GL_UNPACK_SKIP_PIXELS), $(D_INLINECODE GL_UNPACK_SKIP_ROWS), $(D_INLINECODE GL_UNPACK_SKIP_IMAGES), and $(D_INLINECODE GL_UNPACK_ALIGNMENT).
     +     param = Specifies the value that $(D_INLINECODE pname) is set to.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glReadPixels), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glCompressedTexImage1D), $(D_INLINECODE glCompressedTexImage2D), $(D_INLINECODE glCompressedTexImage3D), $(D_INLINECODE glCompressedTexSubImage1D), $(D_INLINECODE glCompressedTexSubImage2D), $(D_INLINECODE glCompressedTexSubImage1D).
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glPixelStoref glPixelStoref;
    alias fn_glPointParameterf = extern(System) void function(GLenum pname, GLfloat param) @system @nogc nothrow;

    /++
     + glPointParameter: man4/glPointParameter.xml
     + 
     + The following values are accepted for $(D_INLINECODE pname) :
     + 
     + Params:
     +     pname  = Specifies a single-valued point parameter. $(D_INLINECODE GL_POINT_FADE_THRESHOLD_SIZE), and $(D_INLINECODE GL_POINT_SPRITE_COORD_ORIGIN) are accepted.
     +     param  = For $(D_INLINECODE glPointParameterf) and $(D_INLINECODE glPointParameteri), specifies the value that $(D_INLINECODE pname) will be set to.
     +     params = For $(D_INLINECODE glPointParameterfv) and $(D_INLINECODE glPointParameteriv), specifies a pointer to an array where the value or values to be assigned to $(D_INLINECODE pname) are stored.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glPointSize)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glPointParameterf glPointParameterf;
    alias fn_glPointSize = extern(System) void function(GLfloat size) @system @nogc nothrow;

    /++
     + glPointSize: man4/glPointSize.xml
     + 
     + $(D_INLINECODE glPointSize) specifies the rasterized diameter of points. If point size mode is disabled (see $(D_INLINECODE glEnable) with parameter $(D_INLINECODE GL_PROGRAM_POINT_SIZE) ), this value will be used to rasterize points. Otherwise, the value written to the shading language built-in variable $(D_INLINECODE gl_PointSize) will be used.
     + 
     + The point size specified by $(D_INLINECODE glPointSize) is always returned when $(D_INLINECODE GL_POINT_SIZE) is queried.  Clamping and rounding for points have no effect on the specified value.
     + 
     + Params:
     +     size = Specifies the diameter of rasterized points. The initial value is 1.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glEnable), $(D_INLINECODE glPointParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glPointSize glPointSize;
    alias fn_glPolygonMode = extern(System) void function(GLenum face, GLenum mode) @system @nogc nothrow;

    /++
     + glPolygonMode: man4/glPolygonMode.xml
     + 
     + $(D_INLINECODE glPolygonMode) controls the interpretation of polygons for rasterization. $(D_INLINECODE face) describes which polygons $(D_INLINECODE mode) applies to: both front and back-facing polygons ( $(D_INLINECODE GL_FRONT_AND_BACK) ). The polygon mode affects only the final rasterization of polygons. In particular, a polygon's vertices are lit and the polygon is clipped and possibly culled before these modes are applied. Three modes are defined and can be specified in $(D_INLINECODE mode) :
     + 
     + Vertices are marked as boundary or nonboundary with an edge flag. Edge flags are generated internally by the GL when it decomposes triangle stips and fans.
     + 
     + Params:
     +     face = Specifies the polygons that $(D_INLINECODE mode) applies to. Must be $(D_INLINECODE GL_FRONT_AND_BACK) for front- and back-facing polygons.
     +     mode = Specifies how polygons will be rasterized. Accepted values are $(D_INLINECODE GL_POINT), $(D_INLINECODE GL_LINE), and $(D_INLINECODE GL_FILL). The initial value is $(D_INLINECODE GL_FILL) for both front- and back-facing polygons.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glLineWidth), $(D_INLINECODE glPointSize)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glPolygonMode glPolygonMode;
    alias fn_glPolygonOffset = extern(System) void function(GLfloat factor, GLfloat units) @system @nogc nothrow;

    /++
     + glPolygonOffset: man4/glPolygonOffset.xml
     + 
     + When $(D_INLINECODE GL_POLYGON_OFFSET_FILL), $(D_INLINECODE GL_POLYGON_OFFSET_LINE), or $(D_INLINECODE GL_POLYGON_OFFSET_POINT) is enabled, each fragment's value will be offset after it is interpolated from the values of the appropriate vertices. The value of the offset is factor &times; DZ + r &times; units, where DZ is a measurement of the change in depth relative to the screen area of the polygon, and r is the smallest value that is guaranteed to produce a resolvable offset for a given implementation. The offset is added before the depth test is performed and before the value is written into the depth buffer. $(D_INLINECODE glPolygonOffset) is useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges.
     + 
     + Params:
     +     factor = Specifies a scale factor that is used to create a variable depth offset for each polygon. The initial value is 0.
     +     units  = Is multiplied by an implementation-specific value to create a constant depth offset. The initial value is 0.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDepthFunc), $(D_INLINECODE glEnable), $(D_INLINECODE glGet), $(D_INLINECODE glIsEnabled)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    fn_glPolygonOffset glPolygonOffset;
    alias fn_glPopDebugGroup = extern(System) void function() @system @nogc nothrow;

    /++
     + glPopDebugGroup: man4/glPopDebugGroup.xml
     + 
     + $(D_INLINECODE glPopDebugGroup) pops the active debug group. After popping a debug group, the GL will also generate a debug output message describing its cause based on the $(D_INLINECODE message) string, the source $(D_INLINECODE source), and an ID $(D_INLINECODE id) submitted to the corresponding $(D_INLINECODE glPushDebugGroup) command. $(D_INLINECODE GL_DEBUG_TYPE_PUSH_GROUP) and $(D_INLINECODE GL_DEBUG_TYPE_POP_GROUP) share a single namespace for message $(D_INLINECODE id). $(D_INLINECODE severity) has the value $(D_INLINECODE GL_DEBUG_SEVERITY_NOTIFICATION). The $(D_INLINECODE type) has the value $(D_INLINECODE GL_DEBUG_TYPE_POP_GROUP). Popping a debug group restores the debug output volume control of the parent debug group.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glPushDebugGroup), $(D_INLINECODE glObjectLabel), $(D_INLINECODE glObjectPtrLabel).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_KHR_debug")
    fn_glPopDebugGroup glPopDebugGroup;
    alias fn_glPrimitiveRestartIndex = extern(System) void function(GLuint index) @system @nogc nothrow;

    /++
     + glPrimitiveRestartIndex: man4/glPrimitiveRestartIndex.xml
     + 
     + $(D_INLINECODE glPrimitiveRestartIndex) specifies a vertex array element that is treated specially when primitive restarting is enabled. This is known as the primitive restart index. When one of the $(D_INLINECODE Draw*) commands transfers a set of generic attribute array elements to the GL, if the index within the vertex arrays corresponding to that set is equal to the primitive restart index, then the GL does not process those elements as a vertex. Instead, it is as if the drawing command ended with the immediately preceding transfer, and another drawing command is immediately started with the same parameters, but only transferring the immediately following element through the end of the originally specified elements. When either $(D_INLINECODE glDrawElementsBaseVertex), $(D_INLINECODE glDrawElementsInstancedBaseVertex) or $(D_INLINECODE glMultiDrawElementsBaseVertex) is used, the primitive restart comparison occurs before the basevertex offset is added to the array index.
     + 
     + $(D_INLINECODE glPrimitiveRestartIndex) is available only if the GL version is 3.1 or greater.
     + 
     + Params:
     +     index = Specifies the value to be interpreted as the primitive restart index.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawElementsBaseVertex), $(D_INLINECODE glDrawElementsInstancedBaseVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P1)
    fn_glPrimitiveRestartIndex glPrimitiveRestartIndex;
    alias fn_glProgramBinary = extern(System) void function(GLuint program, GLenum binaryFormat, const( void*) binary, GLsizei length) @system @nogc nothrow;

    /++
     + glProgramBinary: man4/glProgramBinary.xml
     + 
     + $(D_INLINECODE glProgramBinary) loads a program object with a program binary previously returned from $(D_INLINECODE glGetProgramBinary). $(D_INLINECODE binaryFormat) and $(D_INLINECODE binary) must be those returned by a previous call to $(D_INLINECODE glGetProgramBinary), and $(D_INLINECODE length) must be the length returned by $(D_INLINECODE glGetProgramBinary), or by $(D_INLINECODE glGetProgram) when called with $(D_INLINECODE pname) set to $(D_INLINECODE GL_PROGRAM_BINARY_LENGTH). If these conditions are not met, loading the program binary will fail and $(D_INLINECODE program) 's $(D_INLINECODE GL_LINK_STATUS) will be set to $(D_INLINECODE GL_FALSE). A program object's program binary is replaced by calls to $(D_INLINECODE glLinkProgram) or $(D_INLINECODE glProgramBinary). When linking success or failure is concerned, $(D_INLINECODE glProgramBinary) can be considered to perform an implicit linking operation. $(D_INLINECODE glLinkProgram) and $(D_INLINECODE glProgramBinary) both set the program object's $(D_INLINECODE GL_LINK_STATUS) to $(D_INLINECODE GL_TRUE) or $(D_INLINECODE GL_FALSE). A successful call to $(D_INLINECODE glProgramBinary) will reset all uniform variables to their initial values. The initial value is either the value of the variable's initializer as specified in the original shader source, or zero if no initializer was present. Additionally, all vertex shader input and fragment shader output assignments that were in effect when the program was linked before saving are restored with $(D_INLINECODE glProgramBinary) is called.
     + 
     + A program binary may fail to load if the implementation determines that there has been a change in hardware or software configuration from when the program binary was produced such as having been compiled with an incompatible or outdated version of the compiler.
     + 
     + Params:
     +     program      = Specifies the name of a program object into which to load a program binary.
     +     binaryFormat = Specifies the format of the binary data in binary.
     +     binary       = Specifies the address an array containing the binary to be loaded into $(D_INLINECODE program).
     +     length       = Specifies the number of bytes contained in $(D_INLINECODE binary).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetProgram), $(D_INLINECODE glGetProgramBinary)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_get_program_binary")
    fn_glProgramBinary glProgramBinary;
    alias fn_glProgramParameteri = extern(System) void function(GLuint program, GLenum pname, GLint value) @system @nogc nothrow;

    /++
     + glProgramParameter: man4/glProgramParameter.xml
     + 
     + $(D_INLINECODE glProgramParameter) specifies a new value for the parameter nameed by $(D_INLINECODE pname) for the program object $(D_INLINECODE program). If $(D_INLINECODE pname) is $(D_INLINECODE GL_PROGRAM_BINARY_RETRIEVABLE_HINT), $(D_INLINECODE value) should be $(D_INLINECODE GL_FALSE) or $(D_INLINECODE GL_TRUE) to indicate to the implementation the intention of the application to retrieve the program's binary representation with $(D_INLINECODE glGetProgramBinary). The implementation may use this information to store information that may be useful for a future query of the program's binary. It is recommended to set $(D_INLINECODE GL_PROGRAM_BINARY_RETRIEVABLE_HINT) for the program to $(D_INLINECODE GL_TRUE) before calling $(D_INLINECODE glLinkProgram), and using the program at run-time if the binary is to be retrieved later. If $(D_INLINECODE pname) is $(D_INLINECODE GL_PROGRAM_SEPARABLE), $(D_INLINECODE value) must be $(D_INLINECODE GL_TRUE) or $(D_INLINECODE GL_FALSE) and indicates whether $(D_INLINECODE program) can be bound to individual pipeline stages via $(D_INLINECODE glUseProgramStages). A program's $(D_INLINECODE GL_PROGRAM_SEPARABLE) parameter must be set to $(D_INLINECODE GL_TRUE) $(D_INLINECODE glLinkProgram) is called in order for it to be usable with a program pipeline object. The initial state of $(D_INLINECODE GL_PROGRAM_SEPARABLE) is $(D_INLINECODE GL_FALSE).
     + 
     + Params:
     +     program = Specifies the name of a program object whose parameter to modify.
     +     pname   = Specifies the name of the parameter to modify.
     +     value   = Specifies the new value of the parameter specified by $(D_INLINECODE pname) for $(D_INLINECODE program).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetProgram), $(D_INLINECODE glGetProgramBinary), $(D_INLINECODE glProgramBinary)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_get_program_binary")
    fn_glProgramParameteri glProgramParameteri;
    alias fn_glProgramUniform1f = extern(System) void function(GLuint program, GLint location, GLfloat v0) @system @nogc nothrow;

    /++
     + glProgramUniform: man4/glProgramUniform.xml
     + 
     + $(D_INLINECODE glProgramUniform) modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to be modified is specified by $(D_INLINECODE location), which should be a value returned by $(D_INLINECODE glGetUniformLocation). $(D_INLINECODE glProgramUniform) operates on the program object specified by $(D_INLINECODE program). The commands $(D_INLINECODE glProgramUniform{1|2|3|4}{f|i|ui}) are used to change the value of the uniform variable specified by $(D_INLINECODE location) using the values passed as arguments. The number specified in the command should match the number of components in the data type of the specified uniform variable (e.g., $(D_INLINECODE 1) for $(D_INLINECODE float), $(D_INLINECODE int), $(D_INLINECODE unsigned int), $(D_INLINECODE bool); $(D_INLINECODE 2) for $(D_INLINECODE vec2), $(D_INLINECODE ivec2), $(D_INLINECODE uvec2), $(D_INLINECODE bvec2), etc.). The suffix $(D_INLINECODE f) indicates that floating-point values are being passed; the suffix $(D_INLINECODE i) indicates that integer values are being passed; the suffix $(D_INLINECODE ui) indicates that unsigned integer values are being passed, and this type should also match the data type of the specified uniform variable. The $(D_INLINECODE i) variants of this function should be used to provide values for uniform variables defined as $(D_INLINECODE int), $(D_INLINECODE ivec2), $(D_INLINECODE ivec3), $(D_INLINECODE ivec4), or arrays of these. The $(D_INLINECODE ui) variants of this function should be used to provide values for uniform variables defined as $(D_INLINECODE unsigned int), $(D_INLINECODE uvec2), $(D_INLINECODE uvec3), $(D_INLINECODE uvec4), or arrays of these. The $(D_INLINECODE f) variants should be used to provide values for uniform variables of type $(D_INLINECODE float), $(D_INLINECODE vec2), $(D_INLINECODE vec3), $(D_INLINECODE vec4), or arrays of these. Either the $(D_INLINECODE i), $(D_INLINECODE ui) or $(D_INLINECODE f) variants may be used to provide values for uniform variables of type $(D_INLINECODE bool), $(D_INLINECODE bvec2), $(D_INLINECODE bvec3), $(D_INLINECODE bvec4), or arrays of these. The uniform variable will be set to $(D_INLINECODE false) if the input value is 0 or 0.0f, and it will be set to $(D_INLINECODE true) otherwise. All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully. They retain the values assigned to them by a call to $(D_INLINECODE glProgramUniform) until the next successful link operation occurs on the program object, when they are once again initialized to 0. The commands $(D_INLINECODE glProgramUniform{1|2|3|4}{f|i|ui}v) can be used to modify a single uniform variable or a uniform variable array. These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used to modify an entire array or part of an array. When loading elements starting at an arbitrary position in a uniform variable array, elements + - 1 in the array will be replaced with the new values. If $(D_INLINECODE m) + $(D_INLINECODE n) - 1 is larger than the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number specified in the name of the command indicates the number of components for each element in $(D_INLINECODE value), and it should match the number of components in the data type of the specified uniform variable (e.g., $(D_INLINECODE 1) for $(D_INLINECODE float), $(D_INLINECODE int), $(D_INLINECODE bool); $(D_INLINECODE 2) for $(D_INLINECODE vec2), $(D_INLINECODE ivec2), $(D_INLINECODE bvec2), etc.). The data type specified in the name of the command must match the data type for the specified uniform variable as described previously for $(D_INLINECODE glProgramUniform{1|2|3|4}{f|i|ui}). For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command (e.g., $(D_INLINECODE glProgramUniform3f) or $(D_INLINECODE glProgramUniform3fv) can be used to load a uniform variable array of type vec3). The number of elements of the uniform variable array to be modified is specified by $(D_INLINECODE count) The commands $(D_INLINECODE glProgramUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv) are used to modify a matrix or an array of matrices. The numbers in the command name are interpreted as the dimensionality of the matrix. The number $(D_INLINECODE 2) indicates a 2 &#215; 2 matrix (i.e., 4 values), the number $(D_INLINECODE 3) indicates a 3 &#215; 3 matrix (i.e., 9 values), and the number $(D_INLINECODE 4) indicates a 4 &#215; 4 matrix (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and the second number representing the number of rows.  For example, $(D_INLINECODE 2x4) indicates a 2 &#215; 4 matrix with 2 columns and 4 rows (i.e., 8 values). If $(D_INLINECODE transpose) is $(D_INLINECODE GL_FALSE), each matrix is assumed to be supplied in column major order. If $(D_INLINECODE transpose) is $(D_INLINECODE GL_TRUE), each matrix is assumed to be supplied in row major order. The $(D_INLINECODE count) argument indicates the number of matrices to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be used to modify an array of matrices.
     + 
     + $(D_INLINECODE glProgramUniform1i) and $(D_INLINECODE glProgramUniform1iv) are the only two functions that may be used to load uniform variables defined as sampler types. Loading samplers with any other function will result in a $(D_INLINECODE GL_INVALID_OPERATION) error. If $(D_INLINECODE count) is greater than 1 and the indicated uniform variable is not an array, a $(D_INLINECODE GL_INVALID_OPERATION) error is generated and the specified uniform variable will remain unchanged. Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match the type and size specified in the name of the command used to load its value, a $(D_INLINECODE GL_INVALID_OPERATION) error will be generated and the specified uniform variable will remain unchanged. If $(D_INLINECODE location) is a value other than -1 and it does not represent a valid uniform variable location in within $(D_INLINECODE program), an error will be generated, and no changes will be made to the uniform variable storage of $(D_INLINECODE program). If $(D_INLINECODE location) is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
     + 
     + Params:
     +     program        = Specifies the handle of the program containing the uniform variable to be modified.
     +     location       = Specifies the location of the uniform variable to be modified.
     +     count          = For the vector commands ( $(D_INLINECODE glProgramUniform*v) ), specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. For the matrix commands ( $(D_INLINECODE glProgramUniformMatrix*) ), specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
     +     transpose      = For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
     +     v0, v1, v2, v3 = For the scalar commands, specifies the new values to be used for the specified uniform variable.
     +     value          = For the vector and matrix commands, specifies a pointer to an array of $(D_INLINECODE count) values that will be used to update the specified uniform variable.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glLinkProgram), $(D_INLINECODE glUseProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniform1f glProgramUniform1f;
    alias fn_glProgramUniform2f = extern(System) void function(GLuint program, GLint location, GLfloat v0, GLfloat v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniform2f glProgramUniform2f;
    alias fn_glProgramUniform3f = extern(System) void function(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniform3f glProgramUniform3f;
    alias fn_glProgramUniform4f = extern(System) void function(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniform4f glProgramUniform4f;
    alias fn_glProgramUniform1i = extern(System) void function(GLuint program, GLint location, GLint v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniform1i glProgramUniform1i;
    alias fn_glProgramUniform2i = extern(System) void function(GLuint program, GLint location, GLint v0, GLint v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniform2i glProgramUniform2i;
    alias fn_glProgramUniform3i = extern(System) void function(GLuint program, GLint location, GLint v0, GLint v1, GLint v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniform3i glProgramUniform3i;
    alias fn_glProgramUniform4i = extern(System) void function(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniform4i glProgramUniform4i;
    alias fn_glProgramUniform1ui = extern(System) void function(GLuint program, GLint location, GLuint v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniform1ui glProgramUniform1ui;
    alias fn_glProgramUniform2ui = extern(System) void function(GLuint program, GLint location, GLint v0, GLuint v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniform2ui glProgramUniform2ui;
    alias fn_glProgramUniform3ui = extern(System) void function(GLuint program, GLint location, GLint v0, GLint v1, GLuint v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniform3ui glProgramUniform3ui;
    alias fn_glProgramUniform4ui = extern(System) void function(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLuint v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniform4ui glProgramUniform4ui;
    alias fn_glProgramUniform1fv = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniform1fv glProgramUniform1fv;
    alias fn_glProgramUniform2fv = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniform2fv glProgramUniform2fv;
    alias fn_glProgramUniform3fv = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniform3fv glProgramUniform3fv;
    alias fn_glProgramUniform4fv = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniform4fv glProgramUniform4fv;
    alias fn_glProgramUniform1iv = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniform1iv glProgramUniform1iv;
    alias fn_glProgramUniform2iv = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniform2iv glProgramUniform2iv;
    alias fn_glProgramUniform3iv = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniform3iv glProgramUniform3iv;
    alias fn_glProgramUniform4iv = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniform4iv glProgramUniform4iv;
    alias fn_glProgramUniform1uiv = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLuint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniform1uiv glProgramUniform1uiv;
    alias fn_glProgramUniform2uiv = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLuint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniform2uiv glProgramUniform2uiv;
    alias fn_glProgramUniform3uiv = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLuint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniform3uiv glProgramUniform3uiv;
    alias fn_glProgramUniform4uiv = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLuint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniform4uiv glProgramUniform4uiv;
    alias fn_glProgramUniformMatrix2fv = extern(System) void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniformMatrix2fv glProgramUniformMatrix2fv;
    alias fn_glProgramUniformMatrix3fv = extern(System) void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniformMatrix3fv glProgramUniformMatrix3fv;
    alias fn_glProgramUniformMatrix4fv = extern(System) void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniformMatrix4fv glProgramUniformMatrix4fv;
    alias fn_glProgramUniformMatrix2x3fv = extern(System) void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniformMatrix2x3fv glProgramUniformMatrix2x3fv;
    alias fn_glProgramUniformMatrix3x2fv = extern(System) void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniformMatrix3x2fv glProgramUniformMatrix3x2fv;
    alias fn_glProgramUniformMatrix2x4fv = extern(System) void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniformMatrix2x4fv glProgramUniformMatrix2x4fv;
    alias fn_glProgramUniformMatrix4x2fv = extern(System) void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniformMatrix4x2fv glProgramUniformMatrix4x2fv;
    alias fn_glProgramUniformMatrix3x4fv = extern(System) void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniformMatrix3x4fv glProgramUniformMatrix3x4fv;
    alias fn_glProgramUniformMatrix4x3fv = extern(System) void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniformMatrix4x3fv glProgramUniformMatrix4x3fv;
    alias fn_glProvokingVertex = extern(System) void function(GLenum provokeMode) @system @nogc nothrow;

    /++
     + glProvokingVertex: man4/glProvokingVertex.xml
     + 
     + a vertex shader varying output means to assign all vetices of the primitive the same value for that output. The vertex from which these values is derived is known as the and $(D_INLINECODE glProvokingVertex) specifies which vertex is to be used as the source of data for flat shaded varyings. $(D_INLINECODE provokeMode) must be either $(D_INLINECODE GL_FIRST_VERTEX_CONVENTION) or $(D_INLINECODE GL_LAST_VERTEX_CONVENTION), and controls the selection of the vertex whose values are assigned to flatshaded varying outputs. The interpretation of these values for the supported primitive types is: $(B Primitive Type of Polygon) $(B First Vertex Convention) $(B Last Vertex Convention) point independent line 2 - 1 2 line loop + 1, if &lt; 1, if = line strip + 1 independent triangle 3 - 2 3 triangle strip + 2 triangle fan + 1 + 2 line adjacency 4 - 2 4 - 1 line strip adjacency + 1 + 2 triangle adjacency 6 - 5 6 - 1 triangle strip adjacency 2 - 1 2 + 3 If a vertex or geometry shader is active, user-defined varying outputs may be flatshaded by using the $(D_INLINECODE flat) qualifier when declaring the output.
     + 
     + $(D_INLINECODE glProvokingVertex) is available only if the GL version is 3.2 or greater.
     + 
     + Params:
     +     provokeMode = Specifies the vertex to be used as the source of data for flat shaded varyings.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_provoking_vertex")
    fn_glProvokingVertex glProvokingVertex;
    alias fn_glPushDebugGroup = extern(System) void function(GLenum source, GLuint id, GLsizei length, const( char*) message) @system @nogc nothrow;

    /++
     + glPushDebugGroup: man4/glPushDebugGroup.xml
     + 
     + $(D_INLINECODE glPushDebugGroup) pushes a debug group described by the string $(D_INLINECODE message) into the command stream. The value of $(D_INLINECODE id) specifies the ID of messages generated. The parameter $(D_INLINECODE length) contains the number of characters in $(D_INLINECODE message). If $(D_INLINECODE length) is negative, it is implied that $(D_INLINECODE message) contains a null terminated string. The message has the specified $(D_INLINECODE source) and $(D_INLINECODE id), the $(D_INLINECODE type) $(D_INLINECODE GL_DEBUG_TYPE_PUSH_GROUP), and $(D_INLINECODE severity) $(D_INLINECODE GL_DEBUG_SEVERITY_NOTIFICATION). The GL will put a new debug group on top of the debug group stack which inherits the control of the volume of debug output of the debug group previously residing on the top of the debug group stack. Because debug groups are strictly hierarchical, any additional control of the debug output volume will only apply within the active debug group and the debug groups pushed on top of the active debug group.
     + 
     + Params:
     +     source  = The source of the debug message.
     +     id      = The identifier of the message.
     +     length  = The length of the message to be sent to the debug output stream.
     +     message = The a string containing the message to be sent to the debug output stream.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glPopDebugGroup), $(D_INLINECODE glObjectLabel), $(D_INLINECODE glObjectPtrLabel).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_KHR_debug")
    fn_glPushDebugGroup glPushDebugGroup;
    alias fn_glQueryCounter = extern(System) void function(GLuint id, GLenum target) @system @nogc nothrow;

    /++
     + glQueryCounter: man4/glQueryCounter.xml
     + 
     + $(D_INLINECODE glQueryCounter) causes the GL to record the current time into the query object named $(D_INLINECODE id). $(D_INLINECODE target) must be $(D_INLINECODE GL_TIMESTAMP). The time is recorded after all previous commands on the GL client and server state and the framebuffer have been fully realized. When the time is recorded, the query result for that object is marked available. $(D_INLINECODE glQueryCounter) timer queries can be used within a $(D_INLINECODE glBeginQuery) / $(D_INLINECODE glEndQuery) block where the target is $(D_INLINECODE GL_TIME_ELAPSED) and it does not affect the result of that query object.
     + 
     + $(D_INLINECODE glQueryCounter) is available only if the GL version is 3.3 or higher.
     + 
     + Params:
     +     id     = Specify the name of a query object into which to record the GL time.
     +     target = Specify the counter to query. $(D_INLINECODE target) must be $(D_INLINECODE GL_TIMESTAMP).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenQueries), $(D_INLINECODE glBeginQuery), $(D_INLINECODE glEndQuery), $(D_INLINECODE glDeleteQueries), $(D_INLINECODE glGetQueryObject), $(D_INLINECODE glGetQueryiv), $(D_INLINECODE glGet)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_timer_query")
    fn_glQueryCounter glQueryCounter;
    alias fn_glReadPixels = extern(System) void function(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid* data) @system @nogc nothrow;

    /++
     + glReadnPixels: man4/glReadPixels.xml
     + 
     + $(D_INLINECODE glReadPixels) and $(D_INLINECODE glReadnPixels) return pixel data from the frame buffer, starting with the pixel whose lower left corner is at location ( $(D_INLINECODE x), $(D_INLINECODE y) ), into client memory starting at location $(D_INLINECODE data). Several parameters control the processing of the pixel data before it is placed into client memory. These parameters are set with $(D_INLINECODE glPixelStore). This reference page describes the effects on $(D_INLINECODE glReadPixels) and $(D_INLINECODE glReadnPixels) of most, but not all of the parameters specified by these three commands. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_PACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a block of pixels is requested, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store rather than a pointer to client memory. $(D_INLINECODE glReadPixels) and $(D_INLINECODE glReadnPixels) return values from each pixel with lower left corner at x + i y + j for 0 &lt;= i &lt; width and 0 &lt;= j &lt; height. This pixel is said to be the i th pixel in the j th row. Pixels are returned in row order from the lowest to the highest row, left to right in each row. $(D_INLINECODE format) specifies the format for the returned pixel values; accepted values are: Finally, the indices or components are converted to the proper format, as specified by $(D_INLINECODE type). If $(D_INLINECODE format) is $(D_INLINECODE GL_STENCIL_INDEX) and $(D_INLINECODE type) is not $(D_INLINECODE GL_FLOAT), each index is masked with the mask value given in the following table. If $(D_INLINECODE type) is $(D_INLINECODE GL_FLOAT), then each integer index is converted to single-precision floating-point format. If $(D_INLINECODE format) is $(D_INLINECODE GL_RED), $(D_INLINECODE GL_GREEN), $(D_INLINECODE GL_BLUE), $(D_INLINECODE GL_RGB), $(D_INLINECODE GL_BGR), $(D_INLINECODE GL_RGBA), or $(D_INLINECODE GL_BGRA) and $(D_INLINECODE type) is not $(D_INLINECODE GL_FLOAT), each component is multiplied by the multiplier shown in the following table. If type is $(D_INLINECODE GL_FLOAT), then each component is passed as is (or converted to the client's single-precision floating-point format if it is different from the one used by the GL). $(D_INLINECODE type) $(B Index Mask) $(B Component Conversion) $(D_INLINECODE GL_UNSIGNED_BYTE) 2 8 - 1 2 8 - 1 &it; c $(D_INLINECODE GL_BYTE) 2 7 - 1 2 8 - 1 &it; c - 1 2 $(D_INLINECODE GL_UNSIGNED_SHORT) 2 16 - 1 2 16 - 1 &it; c $(D_INLINECODE GL_SHORT) 2 15 - 1 2 16 - 1 &it; c - 1 2 $(D_INLINECODE GL_UNSIGNED_INT) 2 32 - 1 2 32 - 1 &it; c $(D_INLINECODE GL_INT) 2 31 - 1 2 32 - 1 &it; c - 1 2 $(D_INLINECODE GL_HALF_FLOAT) none c $(D_INLINECODE GL_FLOAT) none c $(D_INLINECODE GL_UNSIGNED_BYTE_3_3_2) 2 N - 1 2 N - 1 &it; c $(D_INLINECODE GL_UNSIGNED_BYTE_2_3_3_REV) 2 N - 1 2 N - 1 &it; c $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5) 2 N - 1 2 N - 1 &it; c $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5_REV) 2 N - 1 2 N - 1 &it; c $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4) 2 N - 1 2 N - 1 &it; c $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4_REV) 2 N - 1 2 N - 1 &it; c $(D_INLINECODE GL_UNSIGNED_SHORT_5_5_5_1) 2 N - 1 2 N - 1 &it; c $(D_INLINECODE GL_UNSIGNED_SHORT_1_5_5_5_REV) 2 N - 1 2 N - 1 &it; c $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8) 2 N - 1 2 N - 1 &it; c $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8_REV) 2 N - 1 2 N - 1 &it; c $(D_INLINECODE GL_UNSIGNED_INT_10_10_10_2) 2 N - 1 2 N - 1 &it; c $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV) 2 N - 1 2 N - 1 &it; c $(D_INLINECODE GL_UNSIGNED_INT_24_8) 2 N - 1 2 N - 1 &it; c $(D_INLINECODE GL_UNSIGNED_INT_10F_11F_11F_REV) -- Special $(D_INLINECODE GL_UNSIGNED_INT_5_9_9_9_REV) -- Special $(D_INLINECODE GL_FLOAT_32_UNSIGNED_INT_24_8_REV) none c (Depth Only) Return values are placed in memory as follows. If $(D_INLINECODE format) is $(D_INLINECODE GL_STENCIL_INDEX), $(D_INLINECODE GL_DEPTH_COMPONENT), $(D_INLINECODE GL_RED), $(D_INLINECODE GL_GREEN), or $(D_INLINECODE GL_BLUE), a single value is returned and the data for the i th pixel in the j th row is placed in location j &it; width + i. $(D_INLINECODE GL_RGB) and $(D_INLINECODE GL_BGR) return three values, $(D_INLINECODE GL_RGBA) and $(D_INLINECODE GL_BGRA) return four values for each pixel, with all values corresponding to a single pixel occupying contiguous space in $(D_INLINECODE data). Storage parameters set by $(D_INLINECODE glPixelStore), such as $(D_INLINECODE GL_PACK_LSB_FIRST) and $(D_INLINECODE GL_PACK_SWAP_BYTES), affect the way that data is written into memory. See $(D_INLINECODE glPixelStore) for a description. $(D_INLINECODE glReadnPixels) function will only handle the call if $(D_INLINECODE bufSize) is at least of the size required to store the requested data. Otherwise, it will generate a $(D_INLINECODE GL_INVALID_OPERATION) error.
     + 
     + Values for pixels that lie outside the window connected to the current GL context are undefined. If an error is generated, no change is made to the contents of $(D_INLINECODE data).
     + 
     + Params:
     +     x       = Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
     +     width   = Specify the dimensions of the pixel rectangle. $(D_INLINECODE width) and $(D_INLINECODE height) of one correspond to a single pixel.
     +     format  = Specifies the format of the pixel data. The following symbolic values are accepted: $(D_INLINECODE GL_STENCIL_INDEX), $(D_INLINECODE GL_DEPTH_COMPONENT), $(D_INLINECODE GL_DEPTH_STENCIL), $(D_INLINECODE GL_RED), $(D_INLINECODE GL_GREEN), $(D_INLINECODE GL_BLUE), $(D_INLINECODE GL_RGB), $(D_INLINECODE GL_BGR), $(D_INLINECODE GL_RGBA), and $(D_INLINECODE GL_BGRA).
     +     type    = Specifies the data type of the pixel data. Must be one of $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), $(D_INLINECODE GL_SHORT), $(D_INLINECODE GL_UNSIGNED_INT), $(D_INLINECODE GL_INT), $(D_INLINECODE GL_HALF_FLOAT), $(D_INLINECODE GL_FLOAT), $(D_INLINECODE GL_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GL_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GL_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GL_UNSIGNED_INT_10_10_10_2), $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV), $(D_INLINECODE GL_UNSIGNED_INT_24_8), $(D_INLINECODE GL_UNSIGNED_INT_10F_11F_11F_REV), $(D_INLINECODE GL_UNSIGNED_INT_5_9_9_9_REV), or $(D_INLINECODE GL_FLOAT_32_UNSIGNED_INT_24_8_REV).
     +     bufSize = Specifies the size of the buffer $(D_INLINECODE data) for $(D_INLINECODE glReadnPixels) function.
     +     data    = Returns the pixel data.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glPixelStore), $(D_INLINECODE glReadBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glReadPixels glReadPixels;
    alias fn_glReadnPixels = extern(System) void function(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_KHR_robustness")
    fn_glReadnPixels glReadnPixels;
    alias fn_glReleaseShaderCompiler = extern(System) void function() @system @nogc nothrow;

    /++
     + glReleaseShaderCompiler: man4/glReleaseShaderCompiler.xml
     + 
     + $(D_INLINECODE glReleaseShaderCompiler) provides a hint to the implementation that it may free internal resources associated with its shader compiler. $(D_INLINECODE glCompileShader) may subsequently be called and the implementation may at that time reallocate resources previously freed by the call to $(D_INLINECODE glReleaseShaderCompiler).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCompileShader), $(D_INLINECODE glLinkProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_ES2_compatibility")
    fn_glReleaseShaderCompiler glReleaseShaderCompiler;
    alias fn_glResumeTransformFeedback = extern(System) void function() @system @nogc nothrow;

    /++
     + glResumeTransformFeedback: man4/glResumeTransformFeedback.xml
     + 
     + $(D_INLINECODE glResumeTransformFeedback) resumes transform feedback operations on the currently active transform feedback object. When transform feedback operations are paused, transform feedback is still considered active and changing most transform feedback state related to the object results in an error. However, a new transform feedback object may be bound while transform feedback is paused.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenTransformFeedbacks), $(D_INLINECODE glBindTransformFeedback), $(D_INLINECODE glBeginTransformFeedback), $(D_INLINECODE glPauseTransformFeedback), $(D_INLINECODE glEndTransformFeedback), $(D_INLINECODE glDeleteTransformFeedbacks)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_transform_feedback2")
    fn_glResumeTransformFeedback glResumeTransformFeedback;
    alias fn_glSampleCoverage = extern(System) void function(GLfloat value, GLboolean invert) @system @nogc nothrow;

    /++
     + glSampleCoverage: man4/glSampleCoverage.xml
     + 
     + Multisampling samples a pixel multiple times at various implementation-dependent subpixel locations to generate antialiasing effects.  Multisampling transparently antialiases points, lines, polygons, and images if it is enabled. $(D_INLINECODE value) is used in constructing a temporary mask used in determining which samples will be used in resolving the final fragment color.  This mask is bitwise-anded with the coverage mask generated from the multisampling computation.  If the $(D_INLINECODE invert) flag is set, the temporary mask is inverted (all bits flipped) and then the bitwise-and is computed. If an implementation does not have any multisample buffers available, or multisampling is disabled, rasterization occurs with only a single sample computing a pixel's final RGB color. Provided an implementation supports multisample buffers, and multisampling is enabled, then a pixel's final color is generated by combining several samples per pixel.  Each sample contains color, depth, and stencil information, allowing those operations to be performed on each sample.
     + 
     + The type of the $(D_INLINECODE value) parameter was changed from GLclampf to GLfloat. This change is transparent to user code and is described in detail on the $(D_INLINECODE removedTypes) page.
     + 
     + Params:
     +     value  = Specify a single floating-point sample coverage value.  The value is clamped to the range 0 1. The initial value is 1.0.
     +     invert = Specify a single boolean value representing if the coverage masks should be inverted. $(D_INLINECODE GL_TRUE) and $(D_INLINECODE GL_FALSE) are accepted.  The initial value is $(D_INLINECODE GL_FALSE).
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glEnable), $(D_INLINECODE removedTypes)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glSampleCoverage glSampleCoverage;
    alias fn_glSampleMaski = extern(System) void function(GLuint maskNumber, GLbitfield mask) @system @nogc nothrow;

    /++
     + glSampleMaski: man4/glSampleMaski.xml
     + 
     + $(D_INLINECODE glSampleMaski) sets one 32-bit sub-word of the multi-word sample mask, $(D_INLINECODE GL_SAMPLE_MASK_VALUE). $(D_INLINECODE maskIndex) specifies which 32-bit sub-word of the sample mask to update, and $(D_INLINECODE mask) specifies the new value to use for that sub-word. $(D_INLINECODE maskIndex) must be less than the value of $(D_INLINECODE GL_MAX_SAMPLE_MASK_WORDS). Bit of mask word corresponds to sample 32 x +.
     + 
     + $(D_INLINECODE glSampleMaski) is available only if the GL version is 3.2 or greater, or if the $(D_INLINECODE ARB_texture_multisample) extension is supported.
     + 
     + Params:
     +     maskNumber = Specifies which 32-bit sub-word of the sample mask to update.
     +     mask       = Specifies the new value of the mask sub-word.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenRenderbuffers), $(D_INLINECODE glBindRenderbuffer), $(D_INLINECODE glRenderbufferStorageMultisample), $(D_INLINECODE glFramebufferRenderbuffer), $(D_INLINECODE glDeleteRenderbuffers)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_texture_multisample")
    fn_glSampleMaski glSampleMaski;
    alias fn_glSamplerParameterf = extern(System) void function(GLuint sampler, GLenum pname, GLfloat param) @system @nogc nothrow;

    /++
     + glSamplerParameter: man4/glSamplerParameter.xml
     + 
     + $(D_INLINECODE glSamplerParameter) assigns the value or values in $(D_INLINECODE params) to the sampler parameter specified as $(D_INLINECODE pname). $(D_INLINECODE sampler) specifies the sampler object to be modified, and must be the name of a sampler object previously returned from a call to $(D_INLINECODE glGenSamplers). The following symbols are accepted in $(D_INLINECODE pname) :
     + 
     + $(D_INLINECODE glSamplerParameter) is available only if the GL version is 3.3 or higher. If a sampler object is bound to a texture unit and that unit is used to sample from a texture, the parameters in the sampler are used to sample from the texture, rather than the equivalent parameters in the texture object bound to that unit. This introduces the possibility of sampling from the same texture object with different sets of sampler state, which may lead to a condition where a texture is with respect to one sampler object and not with respect to another. Thus, completeness can be considered a function of a sampler object and a texture object bound to a single texture unit, rather than a property of the texture object itself. $(D_INLINECODE GL_MIRROR_CLAMP_TO_EDGE) is available only if the GL version is 4.4 or greater.
     + 
     + Params:
     +     sampler = Specifies the sampler object whose parameter to modify.
     +     pname   = Specifies the symbolic name of a sampler parameter. $(D_INLINECODE pname) can be one of the following: $(D_INLINECODE GL_TEXTURE_WRAP_S), $(D_INLINECODE GL_TEXTURE_WRAP_T), $(D_INLINECODE GL_TEXTURE_WRAP_R), $(D_INLINECODE GL_TEXTURE_MIN_FILTER), $(D_INLINECODE GL_TEXTURE_MAG_FILTER), $(D_INLINECODE GL_TEXTURE_BORDER_COLOR), $(D_INLINECODE GL_TEXTURE_MIN_LOD), $(D_INLINECODE GL_TEXTURE_MAX_LOD), $(D_INLINECODE GL_TEXTURE_LOD_BIAS) $(D_INLINECODE GL_TEXTURE_COMPARE_MODE), or $(D_INLINECODE GL_TEXTURE_COMPARE_FUNC).
     +     param   = For the scalar commands, specifies the value of $(D_INLINECODE pname).
     +     params  = For the vector commands ( $(D_INLINECODE glSamplerParameter*v) ), specifies a pointer to an array where the value or values of $(D_INLINECODE pname) are stored.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenSamplers), $(D_INLINECODE glBindSampler), $(D_INLINECODE glDeleteSamplers), $(D_INLINECODE glIsSampler), $(D_INLINECODE glBindTexture), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    fn_glSamplerParameterf glSamplerParameterf;
    alias fn_glScissor = extern(System) void function(GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;

    /++
     + glScissor: man4/glScissor.xml
     + 
     + $(D_INLINECODE glScissor) defines a rectangle, called the scissor box, in window coordinates. The first two arguments, $(D_INLINECODE x) and $(D_INLINECODE y), specify the lower left corner of the box. $(D_INLINECODE width) and $(D_INLINECODE height) specify the width and height of the box. To enable and disable the scissor test, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_SCISSOR_TEST). The test is initially disabled. While the test is enabled, only pixels that lie within the scissor box can be modified by drawing commands. Window coordinates have integer values at the shared corners of frame buffer pixels. $(D_INLINECODE glScissor(0,0,1,1)) allows modification of only the lower left pixel in the window, and $(D_INLINECODE glScissor(0,0,0,0)) doesn't allow modification of any pixels in the window. When the scissor test is disabled, it is as though the scissor box includes the entire window.
     + 
     + Params:
     +     x     = Specify the lower left corner of the scissor box. Initially (0, 0).
     +     width = Specify the width and height of the scissor box. When a GL context is first attached to a window, $(D_INLINECODE width) and $(D_INLINECODE height) are set to the dimensions of that window.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glEnable), $(D_INLINECODE glViewport)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glScissor glScissor;
    alias fn_glScissorArrayv = extern(System) void function(GLuint first, GLsizei count, const( GLint*) v) @system @nogc nothrow;

    /++
     + glScissorArray: man4/glScissorArray.xml
     + 
     + $(D_INLINECODE glScissorArrayv) defines rectangles, called scissor boxes, in window coordinates for each viewport. $(D_INLINECODE first) specifies the index of the first scissor box to modify and $(D_INLINECODE count) specifies the number of scissor boxes to modify. $(D_INLINECODE first) must be less than the value of $(D_INLINECODE GL_MAX_VIEWPORTS), and $(D_INLINECODE first) + $(D_INLINECODE count) must be less than or equal to the value of $(D_INLINECODE GL_MAX_VIEWPORTS). $(D_INLINECODE v) specifies the address of an array containing integers specifying the lower left corner of the scissor boxes, and the width and height of the scissor boxes, in that order. To enable and disable the scissor test, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_SCISSOR_TEST). The test is initially disabled for all viewports. While the test is enabled, only pixels that lie within the scissor box can be modified by drawing commands. Window coordinates have integer values at the shared corners of frame buffer pixels. $(D_INLINECODE glScissor(0,0,1,1)) allows modification of only the lower left pixel in the window, and $(D_INLINECODE glScissor(0,0,0,0)) doesn't allow modification of any pixels in the window. When the scissor test is disabled, it is as though the scissor box includes the entire window.
     + 
     + Params:
     +     first = Specifies the index of the first viewport whose scissor box to modify.
     +     count = Specifies the number of scissor boxes to modify.
     +     v     = Specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glEnable), $(D_INLINECODE glViewport), $(D_INLINECODE glViewportIndexed), $(D_INLINECODE glViewportArray)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_viewport_array")
    fn_glScissorArrayv glScissorArrayv;
    alias fn_glScissorIndexed = extern(System) void function(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height) @system @nogc nothrow;

    /++
     + glScissorIndexed: man4/glScissorIndexed.xml
     + 
     + $(D_INLINECODE glScissorIndexed) defines the scissor box for a specified viewport. $(D_INLINECODE index) specifies the index of scissor box to modify. $(D_INLINECODE index) must be less than the value of $(D_INLINECODE GL_MAX_VIEWPORTS). For $(D_INLINECODE glScissorIndexed), $(D_INLINECODE left), $(D_INLINECODE bottom), $(D_INLINECODE width) and $(D_INLINECODE height) specify the left, bottom, width and height of the scissor box, in pixels, respectively. For $(D_INLINECODE glScissorIndexedv), $(D_INLINECODE v) specifies the address of an array containing integers specifying the lower left corner of the scissor box, and the width and height of the scissor box, in that order. To enable and disable the scissor test, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_SCISSOR_TEST). The test is initially disabled for all viewports. While the test is enabled, only pixels that lie within the scissor box can be modified by drawing commands. Window coordinates have integer values at the shared corners of frame buffer pixels. $(D_INLINECODE glScissor(0,0,1,1)) allows modification of only the lower left pixel in the window, and $(D_INLINECODE glScissor(0,0,0,0)) doesn't allow modification of any pixels in the window. When the scissor test is disabled, it is as though the scissor box includes the entire window.
     + 
     + Params:
     +     index = Specifies the index of the viewport whose scissor box to modify.
     +     left  = Specify the coordinate of the bottom left corner of the scissor box, in pixels.
     +     width = Specify ths dimensions of the scissor box, in pixels.
     +     v     = For $(D_INLINECODE glScissorIndexedv), specifies the address of an array containing the left, bottom, width and height of each scissor box, in that order.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glEnable), $(D_INLINECODE glScissor), $(D_INLINECODE glScissorArray)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_viewport_array")
    fn_glScissorIndexed glScissorIndexed;
    alias fn_glScissorIndexedv = extern(System) void function(GLuint index, const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_viewport_array")
    fn_glScissorIndexedv glScissorIndexedv;
    alias fn_glShaderBinary = extern(System) void function(GLsizei count, const( GLuint*) shaders, GLenum binaryFormat, const( void*) binary, GLsizei length) @system @nogc nothrow;

    /++
     + glShaderBinary: man4/glShaderBinary.xml
     + 
     + $(D_INLINECODE glShaderBinary) loads pre-compiled shader binary code into the $(D_INLINECODE count) shader objects whose handles are given in $(D_INLINECODE shaders). $(D_INLINECODE binary) points to $(D_INLINECODE length) bytes of binary shader code stored in client memory. $(D_INLINECODE binaryFormat) specifies the format of the pre-compiled code. The binary image contained in $(D_INLINECODE binary) will be decoded according to the extension specification defining the specified $(D_INLINECODE binaryFormat) token. OpenGL does not define any specific binary formats, but it does provide a mechanism to obtain token vaues for such formats provided by such extensions. Depending on the types of the shader objects in $(D_INLINECODE shaders), $(D_INLINECODE glShaderBinary) will individually load binary vertex or fragment shaders, or load an executable binary that contains an optimized pair of vertex and fragment shaders stored in the same binary.
     + 
     + Params:
     +     count        = Specifies the number of shader object handles contained in $(D_INLINECODE shaders).
     +     shaders      = Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
     +     binaryFormat = Specifies the format of the shader binaries contained in $(D_INLINECODE binary).
     +     binary       = Specifies the address of an array of bytes containing pre-compiled binary shader code.
     +     length       = Specifies the length of the array whose address is given in $(D_INLINECODE binary).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetProgram), $(D_INLINECODE glGetProgramBinary), $(D_INLINECODE glProgramBinary)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_ES2_compatibility")
    fn_glShaderBinary glShaderBinary;
    alias fn_glShaderSource = extern(System) void function(GLuint shader, GLsizei count, const( GLchar**) string, const( GLint*) length) @system @nogc nothrow;

    /++
     + glShaderSource: man4/glShaderSource.xml
     + 
     + $(D_INLINECODE glShaderSource) sets the source code in $(D_INLINECODE shader) to the source code in the array of strings specified by $(D_INLINECODE string). Any source code previously stored in the shader object is completely replaced. The number of strings in the array is specified by $(D_INLINECODE count). If $(D_INLINECODE length) is $(D_INLINECODE null
     + ), each string is assumed to be null terminated. If $(D_INLINECODE length) is a value other than $(D_INLINECODE null
     + ), it points to an array containing a string length for each of the corresponding elements of $(D_INLINECODE string). Each element in the $(D_INLINECODE length) array may contain the length of the corresponding string (the null character is not counted as part of the string length) or a value less than 0 to indicate that the string is null terminated. The source code strings are not scanned or parsed at this time; they are simply copied into the specified shader object.
     + 
     + OpenGL copies the shader source code strings when $(D_INLINECODE glShaderSource) is called, so an application may free its copy of the source code strings immediately after the function returns.
     + 
     + Params:
     +     shader = Specifies the handle of the shader object whose source code is to be replaced.
     +     count  = Specifies the number of elements in the $(D_INLINECODE string) and $(D_INLINECODE length) arrays.
     +     string = Specifies an array of pointers to strings containing the source code to be loaded into the shader.
     +     length = Specifies an array of string lengths.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCompileShader), $(D_INLINECODE glCreateShader), $(D_INLINECODE glDeleteShader)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glShaderSource glShaderSource;
    alias fn_glShaderStorageBlockBinding = extern(System) void function(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding) @system @nogc nothrow;

    /++
     + glShaderStorageBlockBinding: man4/glShaderStorageBlockBinding.xml
     + 
     + $(D_INLINECODE glShaderStorageBlockBinding), changes the active shader storage block with an assigned index of $(D_INLINECODE storageBlockIndex) in program object $(D_INLINECODE program). $(D_INLINECODE storageBlockIndex) must be an active shader storage block index in $(D_INLINECODE program). $(D_INLINECODE storageBlockBinding) must be less than the value of $(D_INLINECODE GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS). If successful, $(D_INLINECODE glShaderStorageBinding) specifies that $(D_INLINECODE program) will use the data store of the buffer object bound to the binding point $(D_INLINECODE storageBlockBinding) to read and write the values of the buffer variables in the shader storage block identified by $(D_INLINECODE storageBlockIndex).
     + 
     + Params:
     +     program             = The name of the program containing the block whose binding to change.
     +     storageBlockIndex   = The index storage block within the program.
     +     storageBlockBinding = The index storage block binding to associate with the specified storage block.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_shader_storage_buffer_object")
    fn_glShaderStorageBlockBinding glShaderStorageBlockBinding;
    alias fn_glStencilFunc = extern(System) void function(GLenum func, GLint ref_, GLuint mask) @system @nogc nothrow;

    /++
     + glStencilFunc: man4/glStencilFunc.xml
     + 
     + Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. Stencil planes are first drawn into using GL drawing primitives, then geometry and images are rendered using the stencil planes to mask out portions of the screen. Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry rendering. The stencil test conditionally eliminates a pixel based on the outcome of a comparison between the reference value and the value in the stencil buffer. To enable and disable the test, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_STENCIL_TEST). To specify actions based on the outcome of the stencil test, call $(D_INLINECODE glStencilOp) or $(D_INLINECODE glStencilOpSeparate). There can be two separate sets of $(D_INLINECODE func), $(D_INLINECODE ref), and $(D_INLINECODE mask) parameters; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. $(D_INLINECODE glStencilFunc) sets both front and back stencil state to the same values. Use $(D_INLINECODE glStencilFuncSeparate) to set front and back stencil state to different values. $(D_INLINECODE func) is a symbolic constant that determines the stencil comparison function. It accepts one of eight values, shown in the following list. $(D_INLINECODE ref) is an integer reference value that is used in the stencil comparison. It is clamped to the range 0 2 n - 1, where n is the number of bitplanes in the stencil buffer. $(D_INLINECODE mask) is bitwise ANDed with both the reference value and the stored stencil value, with the ANDed values participating in the comparison. If represents the value stored in the corresponding stencil buffer location, the following list shows the effect of each comparison function that can be specified by $(D_INLINECODE func). Only if the comparison succeeds is the pixel passed through to the next stage in the rasterization process (see $(D_INLINECODE glStencilOp) ). All tests treat values as unsigned integers in the range 0 2 n - 1, where n is the number of bitplanes in the stencil buffer. The following values are accepted by $(D_INLINECODE func) :
     + 
     + Initially, the stencil test is disabled. If there is no stencil buffer, no stencil modification can occur and it is as if the stencil test always passes. $(D_INLINECODE glStencilFunc) is the same as calling $(D_INLINECODE glStencilFuncSeparate) with $(D_INLINECODE face) set to $(D_INLINECODE GL_FRONT_AND_BACK).
     + 
     + Params:
     +     func = Specifies the test function. Eight symbolic constants are valid: $(D_INLINECODE GL_NEVER), $(D_INLINECODE GL_LESS), $(D_INLINECODE GL_LEQUAL), $(D_INLINECODE GL_GREATER), $(D_INLINECODE GL_GEQUAL), $(D_INLINECODE GL_EQUAL), $(D_INLINECODE GL_NOTEQUAL), and $(D_INLINECODE GL_ALWAYS). The initial value is $(D_INLINECODE GL_ALWAYS).
     +     ref_ = Specifies the reference value for the stencil test. $(D_INLINECODE ref) is clamped to the range 0 2 n - 1, where n is the number of bitplanes in the stencil buffer. The initial value is 0.
     +     mask = Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBlendFunc), $(D_INLINECODE glDepthFunc), $(D_INLINECODE glEnable), $(D_INLINECODE glLogicOp), $(D_INLINECODE glStencilFuncSeparate), $(D_INLINECODE glStencilMask), $(D_INLINECODE glStencilMaskSeparate), $(D_INLINECODE glStencilOp), $(D_INLINECODE glStencilOpSeparate)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glStencilFunc glStencilFunc;
    alias fn_glStencilFuncSeparate = extern(System) void function(GLenum face, GLenum func, GLint ref_, GLuint mask) @system @nogc nothrow;

    /++
     + glStencilFuncSeparate: man4/glStencilFuncSeparate.xml
     + 
     + Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You draw into the stencil planes using GL drawing primitives, then render geometry and images, using the stencil planes to mask out portions of the screen. Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry rendering. The stencil test conditionally eliminates a pixel based on the outcome of a comparison between the reference value and the value in the stencil buffer. To enable and disable the test, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_STENCIL_TEST). To specify actions based on the outcome of the stencil test, call $(D_INLINECODE glStencilOp) or $(D_INLINECODE glStencilOpSeparate). There can be two separate sets of $(D_INLINECODE func), $(D_INLINECODE ref), and $(D_INLINECODE mask) parameters; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. $(D_INLINECODE glStencilFunc) sets both front and back stencil state to the same values, as if $(D_INLINECODE glStencilFuncSeparate) were called with $(D_INLINECODE face) set to $(D_INLINECODE GL_FRONT_AND_BACK). $(D_INLINECODE func) is a symbolic constant that determines the stencil comparison function. It accepts one of eight values, shown in the following list. $(D_INLINECODE ref) is an integer reference value that is used in the stencil comparison. It is clamped to the range 0 2 n - 1, where n is the number of bitplanes in the stencil buffer. $(D_INLINECODE mask) is bitwise ANDed with both the reference value and the stored stencil value, with the ANDed values participating in the comparison. If represents the value stored in the corresponding stencil buffer location, the following list shows the effect of each comparison function that can be specified by $(D_INLINECODE func). Only if the comparison succeeds is the pixel passed through to the next stage in the rasterization process (see $(D_INLINECODE glStencilOp) ). All tests treat values as unsigned integers in the range 0 2 n - 1, where n is the number of bitplanes in the stencil buffer. The following values are accepted by $(D_INLINECODE func) :
     + 
     + Initially, the stencil test is disabled. If there is no stencil buffer, no stencil modification can occur and it is as if the stencil test always passes.
     + 
     + Params:
     +     face = Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: $(D_INLINECODE GL_FRONT), $(D_INLINECODE GL_BACK), and $(D_INLINECODE GL_FRONT_AND_BACK).
     +     func = Specifies the test function. Eight symbolic constants are valid: $(D_INLINECODE GL_NEVER), $(D_INLINECODE GL_LESS), $(D_INLINECODE GL_LEQUAL), $(D_INLINECODE GL_GREATER), $(D_INLINECODE GL_GEQUAL), $(D_INLINECODE GL_EQUAL), $(D_INLINECODE GL_NOTEQUAL), and $(D_INLINECODE GL_ALWAYS). The initial value is $(D_INLINECODE GL_ALWAYS).
     +     ref_ = Specifies the reference value for the stencil test. $(D_INLINECODE ref) is clamped to the range 0 2 n - 1, where n is the number of bitplanes in the stencil buffer. The initial value is 0.
     +     mask = Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.
     + 
     + Copyright:
     +     Copyright&copy; 2006 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBlendFunc), $(D_INLINECODE glDepthFunc), $(D_INLINECODE glEnable), $(D_INLINECODE glLogicOp), $(D_INLINECODE glStencilFunc), $(D_INLINECODE glStencilMask), $(D_INLINECODE glStencilMaskSeparate), $(D_INLINECODE glStencilOp), $(D_INLINECODE glStencilOpSeparate)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glStencilFuncSeparate glStencilFuncSeparate;
    alias fn_glStencilMask = extern(System) void function(GLuint mask) @system @nogc nothrow;

    /++
     + glStencilMask: man4/glStencilMask.xml
     + 
     + $(D_INLINECODE glStencilMask) controls the writing of individual bits in the stencil planes. The least significant n bits of $(D_INLINECODE mask), where n is the number of bits in the stencil buffer, specify a mask. Where a 1 appears in the mask, it's possible to write to the corresponding bit in the stencil buffer. Where a 0 appears, the corresponding bit is write-protected. Initially, all bits are enabled for writing. There can be two separate $(D_INLINECODE mask) writemasks; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. $(D_INLINECODE glStencilMask) sets both front and back stencil writemasks to the same values. Use $(D_INLINECODE glStencilMaskSeparate) to set front and back stencil writemasks to different values.
     + 
     + $(D_INLINECODE glStencilMask) is the same as calling $(D_INLINECODE glStencilMaskSeparate) with $(D_INLINECODE face) set to $(D_INLINECODE GL_FRONT_AND_BACK).
     + 
     + Params:
     +     mask = Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorMask), $(D_INLINECODE glDepthMask), $(D_INLINECODE glStencilFunc), $(D_INLINECODE glStencilFuncSeparate), $(D_INLINECODE glStencilMaskSeparate), $(D_INLINECODE glStencilOp), $(D_INLINECODE glStencilOpSeparate)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glStencilMask glStencilMask;
    alias fn_glStencilMaskSeparate = extern(System) void function(GLenum face, GLuint mask) @system @nogc nothrow;

    /++
     + glStencilMaskSeparate: man4/glStencilMaskSeparate.xml
     + 
     + $(D_INLINECODE glStencilMaskSeparate) controls the writing of individual bits in the stencil planes. The least significant n bits of $(D_INLINECODE mask), where n is the number of bits in the stencil buffer, specify a mask. Where a 1 appears in the mask, it's possible to write to the corresponding bit in the stencil buffer. Where a 0 appears, the corresponding bit is write-protected. Initially, all bits are enabled for writing. There can be two separate $(D_INLINECODE mask) writemasks; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. $(D_INLINECODE glStencilMask) sets both front and back stencil writemasks to the same values, as if $(D_INLINECODE glStencilMaskSeparate) were called with $(D_INLINECODE face) set to $(D_INLINECODE GL_FRONT_AND_BACK).
     + 
     + Params:
     +     face = Specifies whether the front and/or back stencil writemask is updated. Three symbolic constants are valid: $(D_INLINECODE GL_FRONT), $(D_INLINECODE GL_BACK), and $(D_INLINECODE GL_FRONT_AND_BACK).
     +     mask = Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's.
     + 
     + Copyright:
     +     Copyright&copy; 2006 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorMask), $(D_INLINECODE glDepthMask), $(D_INLINECODE glStencilFunc), $(D_INLINECODE glStencilFuncSeparate), $(D_INLINECODE glStencilMask), $(D_INLINECODE glStencilOp), $(D_INLINECODE glStencilOpSeparate)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glStencilMaskSeparate glStencilMaskSeparate;
    alias fn_glStencilOp = extern(System) void function(GLenum sfail, GLenum dpfail, GLenum dppass) @system @nogc nothrow;

    /++
     + glStencilOp: man4/glStencilOp.xml
     + 
     + Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You draw into the stencil planes using GL drawing primitives, then render geometry and images, using the stencil planes to mask out portions of the screen. Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry rendering. The stencil test conditionally eliminates a pixel based on the outcome of a comparison between the value in the stencil buffer and a reference value. To enable and disable the test, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_STENCIL_TEST); to control it, call $(D_INLINECODE glStencilFunc) or $(D_INLINECODE glStencilFuncSeparate). There can be two separate sets of $(D_INLINECODE sfail), $(D_INLINECODE dpfail), and $(D_INLINECODE dppass) parameters; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. $(D_INLINECODE glStencilOp) sets both front and back stencil state to the same values. Use $(D_INLINECODE glStencilOpSeparate) to set front and back stencil state to different values. $(D_INLINECODE glStencilOp) takes three arguments that indicate what happens to the stored stencil value while stenciling is enabled. If the stencil test fails, no change is made to the pixel's color or depth buffers, and $(D_INLINECODE sfail) specifies what happens to the stencil buffer contents. The following eight actions are possible. Stencil buffer values are treated as unsigned integers. When incremented and decremented, values are clamped to 0 and 2 n - 1, where n is the value returned by querying $(D_INLINECODE GL_STENCIL_BITS). The other two arguments to $(D_INLINECODE glStencilOp) specify stencil buffer actions that depend on whether subsequent depth buffer tests succeed ( $(D_INLINECODE dppass) ) or fail ( $(D_INLINECODE dpfail) ) (see $(D_INLINECODE glDepthFunc) ). The actions are specified using the same eight symbolic constants as $(D_INLINECODE sfail). Note that $(D_INLINECODE dpfail) is ignored when there is no depth buffer, or when the depth buffer is not enabled. In these cases, $(D_INLINECODE sfail) and $(D_INLINECODE dppass) specify stencil action when the stencil test fails and passes, respectively.
     + 
     + Initially the stencil test is disabled. If there is no stencil buffer, no stencil modification can occur and it is as if the stencil tests always pass, regardless of any call to $(D_INLINECODE glStencilOp). $(D_INLINECODE glStencilOp) is the same as calling $(D_INLINECODE glStencilOpSeparate) with $(D_INLINECODE face) set to $(D_INLINECODE GL_FRONT_AND_BACK).
     + 
     + Params:
     +     sfail  = Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: $(D_INLINECODE GL_KEEP), $(D_INLINECODE GL_ZERO), $(D_INLINECODE GL_REPLACE), $(D_INLINECODE GL_INCR), $(D_INLINECODE GL_INCR_WRAP), $(D_INLINECODE GL_DECR), $(D_INLINECODE GL_DECR_WRAP), and $(D_INLINECODE GL_INVERT). The initial value is $(D_INLINECODE GL_KEEP).
     +     dpfail = Specifies the stencil action when the stencil test passes, but the depth test fails. $(D_INLINECODE dpfail) accepts the same symbolic constants as $(D_INLINECODE sfail). The initial value is $(D_INLINECODE GL_KEEP).
     +     dppass = Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. $(D_INLINECODE dppass) accepts the same symbolic constants as $(D_INLINECODE sfail). The initial value is $(D_INLINECODE GL_KEEP).
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBlendFunc), $(D_INLINECODE glDepthFunc), $(D_INLINECODE glEnable), $(D_INLINECODE glLogicOp), $(D_INLINECODE glStencilFunc), $(D_INLINECODE glStencilFuncSeparate), $(D_INLINECODE glStencilMask), $(D_INLINECODE glStencilMaskSeparate), $(D_INLINECODE glStencilOpSeparate)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glStencilOp glStencilOp;
    alias fn_glStencilOpSeparate = extern(System) void function(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass) @system @nogc nothrow;

    /++
     + glStencilOpSeparate: man4/glStencilOpSeparate.xml
     + 
     + Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You draw into the stencil planes using GL drawing primitives, then render geometry and images, using the stencil planes to mask out portions of the screen. Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry rendering. The stencil test conditionally eliminates a pixel based on the outcome of a comparison between the value in the stencil buffer and a reference value. To enable and disable the test, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_STENCIL_TEST); to control it, call $(D_INLINECODE glStencilFunc) or $(D_INLINECODE glStencilFuncSeparate). There can be two separate sets of $(D_INLINECODE sfail), $(D_INLINECODE dpfail), and $(D_INLINECODE dppass) parameters; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. $(D_INLINECODE glStencilOp) sets both front and back stencil state to the same values, as if $(D_INLINECODE glStencilOpSeparate) were called with $(D_INLINECODE face) set to $(D_INLINECODE GL_FRONT_AND_BACK). $(D_INLINECODE glStencilOpSeparate) takes three arguments that indicate what happens to the stored stencil value while stenciling is enabled. If the stencil test fails, no change is made to the pixel's color or depth buffers, and $(D_INLINECODE sfail) specifies what happens to the stencil buffer contents. The following eight actions are possible. Stencil buffer values are treated as unsigned integers. When incremented and decremented, values are clamped to 0 and 2 n - 1, where n is the value returned by querying $(D_INLINECODE GL_STENCIL_BITS). The other two arguments to $(D_INLINECODE glStencilOpSeparate) specify stencil buffer actions that depend on whether subsequent depth buffer tests succeed ( $(D_INLINECODE dppass) ) or fail ( $(D_INLINECODE dpfail) ) (see $(D_INLINECODE glDepthFunc) ). The actions are specified using the same eight symbolic constants as $(D_INLINECODE sfail). Note that $(D_INLINECODE dpfail) is ignored when there is no depth buffer, or when the depth buffer is not enabled. In these cases, $(D_INLINECODE sfail) and $(D_INLINECODE dppass) specify stencil action when the stencil test fails and passes, respectively.
     + 
     + Initially the stencil test is disabled. If there is no stencil buffer, no stencil modification can occur and it is as if the stencil test always passes.
     + 
     + Params:
     +     face   = Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: $(D_INLINECODE GL_FRONT), $(D_INLINECODE GL_BACK), and $(D_INLINECODE GL_FRONT_AND_BACK).
     +     sfail  = Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: $(D_INLINECODE GL_KEEP), $(D_INLINECODE GL_ZERO), $(D_INLINECODE GL_REPLACE), $(D_INLINECODE GL_INCR), $(D_INLINECODE GL_INCR_WRAP), $(D_INLINECODE GL_DECR), $(D_INLINECODE GL_DECR_WRAP), and $(D_INLINECODE GL_INVERT). The initial value is $(D_INLINECODE GL_KEEP).
     +     dpfail = Specifies the stencil action when the stencil test passes, but the depth test fails. $(D_INLINECODE dpfail) accepts the same symbolic constants as $(D_INLINECODE sfail). The initial value is $(D_INLINECODE GL_KEEP).
     +     dppass = Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. $(D_INLINECODE dppass) accepts the same symbolic constants as $(D_INLINECODE sfail). The initial value is $(D_INLINECODE GL_KEEP).
     + 
     + Copyright:
     +     Copyright&copy; 2006 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBlendFunc), $(D_INLINECODE glDepthFunc), $(D_INLINECODE glEnable), $(D_INLINECODE glLogicOp), $(D_INLINECODE glStencilFunc), $(D_INLINECODE glStencilFuncSeparate), $(D_INLINECODE glStencilMask), $(D_INLINECODE glStencilMaskSeparate), $(D_INLINECODE glStencilOp)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glStencilOpSeparate glStencilOpSeparate;
    alias fn_glTexBuffer = extern(System) void function(GLenum target, GLenum internalFormat, GLuint buffer) @system @nogc nothrow;

    /++
     + glTexBuffer: man4/glTexBuffer.xml
     + 
     + $(D_INLINECODE glTexBuffer) and $(D_INLINECODE glTextureBuffer) attaches the data store of a specified buffer object to a specified texture object, and specify the storage format for the texture image found found in the buffer object. The texture object must be a buffer texture. If $(D_INLINECODE buffer) is zero, any buffer object attached to the buffer texture is detached and no new buffer object is attached. If $(D_INLINECODE buffer) is non-zero, it must be the name of an existing buffer object. $(D_INLINECODE internalformat) specifies the storage format, and must be one of the following sized internal formats: $(D_INLINECODE internalformat) specifies the storage format, and must be one of the following sized internal formats: $(B Component) $(B Sized Internal Format) $(B Base Type) $(B Components) $(B Norm) 0 1 2 3 $(D_INLINECODE GL_R8) ubyte 1 YES R 0 0 1 $(D_INLINECODE GL_R16) ushort 1 YES R 0 0 1 $(D_INLINECODE GL_R16F) half 1 NO R 0 0 1 $(D_INLINECODE GL_R32F) float 1 NO R 0 0 1 $(D_INLINECODE GL_R8I) byte 1 NO R 0 0 1 $(D_INLINECODE GL_R16I) short 1 NO R 0 0 1 $(D_INLINECODE GL_R32I) int 1 NO R 0 0 1 $(D_INLINECODE GL_R8UI) ubyte 1 NO R 0 0 1 $(D_INLINECODE GL_R16UI) ushort 1 NO R 0 0 1 $(D_INLINECODE GL_R32UI) uint 1 NO R 0 0 1 $(D_INLINECODE GL_RG8) ubyte 2 YES R G 0 1 $(D_INLINECODE GL_RG16) ushort 2 YES R G 0 1 $(D_INLINECODE GL_RG16F) half 2 NO R G 0 1 $(D_INLINECODE GL_RG32F) float 2 NO R G 0 1 $(D_INLINECODE GL_RG8I) byte 2 NO R G 0 1 $(D_INLINECODE GL_RG16I) short 2 NO R G 0 1 $(D_INLINECODE GL_RG32I) int 2 NO R G 0 1 $(D_INLINECODE GL_RG8UI) ubyte 2 NO R G 0 1 $(D_INLINECODE GL_RG16UI) ushort 2 NO R G 0 1 $(D_INLINECODE GL_RG32UI) uint 2 NO R G 0 1 $(D_INLINECODE GL_RGB32F) float 3 NO R G B 1 $(D_INLINECODE GL_RGB32I) int 3 NO R G B 1 $(D_INLINECODE GL_RGB32UI) uint 3 NO R G B 1 $(D_INLINECODE GL_RGBA8) uint 4 YES R G B A $(D_INLINECODE GL_RGBA16) short 4 YES R G B A $(D_INLINECODE GL_RGBA16F) half 4 NO R G B A $(D_INLINECODE GL_RGBA32F) float 4 NO R G B A $(D_INLINECODE GL_RGBA8I) byte 4 NO R G B A $(D_INLINECODE GL_RGBA16I) short 4 NO R G B A $(D_INLINECODE GL_RGBA32I) int 4 NO R G B A $(D_INLINECODE GL_RGBA8UI) ubyte 4 NO R G B A $(D_INLINECODE GL_RGBA16UI) ushort 4 NO R G B A $(D_INLINECODE GL_RGBA32UI) uint 4 NO R G B A When a buffer object is attached to a buffer texture, the buffer object's data store is taken as the texture's texel array. The number of texels in the buffer texture's texel array is given by $$ \left\lfloor { size \over { components \times sizeof(base\_type) } } \right\rfloor $$ where $size$ is the size of the buffer object in basic machine units (the value of $(D_INLINECODE GL_BUFFER_SIZE) for $(D_INLINECODE buffer) ), and $components$ and $base\_type$ are the element count and base data type for elements, as specified in the table above. The number of texels in the texel array is then clamped to the value of the implementation-dependent limit $(D_INLINECODE GL_MAX_TEXTURE_BUFFER_SIZE). When a buffer texture is accessed in a shader, the results of a texel fetch are undefined if the specified texel coordinate is negative, or greater than or equal to the clamped number of texels in the texel array.
     + 
     + Params:
     +     target         = Specifies the target to which the texture is bound for $(D_INLINECODE glTexBuffer). Must be $(D_INLINECODE GL_TEXTURE_BUFFER).
     +     texture        = Specifies the texture object name for $(D_INLINECODE glTextureBuffer).
     +     internalFormat = Specifies the internal format of the data in the store belonging to $(D_INLINECODE buffer).
     +     buffer         = Specifies the name of the buffer object whose storage to attach to the active buffer texture.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenBuffers), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glBufferData), $(D_INLINECODE glDeleteBuffers), $(D_INLINECODE glGenTextures), $(D_INLINECODE glBindTexture), $(D_INLINECODE glDeleteTextures)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P1)
    fn_glTexBuffer glTexBuffer;
    alias fn_glTextureBuffer = extern(System) void function(GLuint texture, GLenum internalformat, GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glTextureBuffer glTextureBuffer;
    alias fn_glTexBufferRange = extern(System) void function(GLenum target, GLenum internalFormat, GLuint buffer, GLintptr offset, GLsizeiptr size) @system @nogc nothrow;

    /++
     + glTexBufferRange: man4/glTexBufferRange.xml
     + 
     + $(D_INLINECODE glTexBufferRange) and $(D_INLINECODE glTextureBufferRange) attach a range of the data store of a specified buffer object to a specified texture object, and specify the storage format for the texture image found found in the buffer object. The texture object must be a buffer texture. If $(D_INLINECODE buffer) is zero, any buffer object attached to the buffer texture is detached and no new buffer object is attached. If $(D_INLINECODE buffer) is non-zero, it must be the name of an existing buffer object. The start and size of the range are specified by $(D_INLINECODE offset) and $(D_INLINECODE size) respectively, both measured in basic machine units. $(D_INLINECODE offset) must be greater than or equal to zero, $(D_INLINECODE size) must be greater than zero, and the sum of $(D_INLINECODE offset) and $(D_INLINECODE size) must not exceed the value of $(D_INLINECODE GL_BUFFER_SIZE) for $(D_INLINECODE buffer). Furthermore, $(D_INLINECODE offset) must be an integer multiple of the value of $(D_INLINECODE GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT). $(D_INLINECODE internalformat) specifies the storage format, and must be one of the following sized internal formats: $(B Component) $(B Sized Internal Format) $(B Base Type) $(B Components) $(B Norm) 0 1 2 3 $(D_INLINECODE GL_R8) ubyte 1 YES R 0 0 1 $(D_INLINECODE GL_R16) ushort 1 YES R 0 0 1 $(D_INLINECODE GL_R16F) half 1 NO R 0 0 1 $(D_INLINECODE GL_R32F) float 1 NO R 0 0 1 $(D_INLINECODE GL_R8I) byte 1 NO R 0 0 1 $(D_INLINECODE GL_R16I) short 1 NO R 0 0 1 $(D_INLINECODE GL_R32I) int 1 NO R 0 0 1 $(D_INLINECODE GL_R8UI) ubyte 1 NO R 0 0 1 $(D_INLINECODE GL_R16UI) ushort 1 NO R 0 0 1 $(D_INLINECODE GL_R32UI) uint 1 NO R 0 0 1 $(D_INLINECODE GL_RG8) ubyte 2 YES R G 0 1 $(D_INLINECODE GL_RG16) ushort 2 YES R G 0 1 $(D_INLINECODE GL_RG16F) half 2 NO R G 0 1 $(D_INLINECODE GL_RG32F) float 2 NO R G 0 1 $(D_INLINECODE GL_RG8I) byte 2 NO R G 0 1 $(D_INLINECODE GL_RG16I) short 2 NO R G 0 1 $(D_INLINECODE GL_RG32I) int 2 NO R G 0 1 $(D_INLINECODE GL_RG8UI) ubyte 2 NO R G 0 1 $(D_INLINECODE GL_RG16UI) ushort 2 NO R G 0 1 $(D_INLINECODE GL_RG32UI) uint 2 NO R G 0 1 $(D_INLINECODE GL_RGB32F) float 3 NO R G B 1 $(D_INLINECODE GL_RGB32I) int 3 NO R G B 1 $(D_INLINECODE GL_RGB32UI) uint 3 NO R G B 1 $(D_INLINECODE GL_RGBA8) uint 4 YES R G B A $(D_INLINECODE GL_RGBA16) short 4 YES R G B A $(D_INLINECODE GL_RGBA16F) half 4 NO R G B A $(D_INLINECODE GL_RGBA32F) float 4 NO R G B A $(D_INLINECODE GL_RGBA8I) byte 4 NO R G B A $(D_INLINECODE GL_RGBA16I) short 4 NO R G B A $(D_INLINECODE GL_RGBA32I) int 4 NO R G B A $(D_INLINECODE GL_RGBA8UI) ubyte 4 NO R G B A $(D_INLINECODE GL_RGBA16UI) ushort 4 NO R G B A $(D_INLINECODE GL_RGBA32UI) uint 4 NO R G B A When a range of a buffer object is attached to a buffer texture, the specified range of the buffer object's data store is taken as the texture's texel array. The number of texels in the buffer texture's texel array is given by $$ \left\lfloor { size \over { components \times sizeof(base\_type) } } \right\rfloor $$ where $components$ and $base\_type$ are the element count and base data type for elements, as specified in the table above. The number of texels in the texel array is then clamped to the value of the implementation-dependent limit $(D_INLINECODE GL_MAX_TEXTURE_BUFFER_SIZE). When a buffer texture is accessed in a shader, the results of a texel fetch are undefined if the specified texel coordinate is negative, or greater than or equal to the clamped number of texels in the texel array.
     + 
     + Params:
     +     target         = Specifies the target to which the texture object is bound for $(D_INLINECODE glTexBufferRange). Must be $(D_INLINECODE GL_TEXTURE_BUFFER).
     +     texture        = Specifies the texture object name for $(D_INLINECODE glTextureBufferRange).
     +     internalFormat = Specifies the internal format of the data in the store belonging to $(D_INLINECODE buffer).
     +     buffer         = Specifies the name of the buffer object whose storage to attach to the active buffer texture.
     +     offset         = Specifies the offset of the start of the range of the buffer's data store to attach.
     +     size           = Specifies the size of the range of the buffer's data store to attach.
     + 
     + Copyright:
     +     Copyright&copy; 2012-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glTexBuffer).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_texture_buffer_range")
    fn_glTexBufferRange glTexBufferRange;
    alias fn_glTextureBufferRange = extern(System) void function(GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizei size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glTextureBufferRange glTextureBufferRange;
    alias fn_glTexImage1D = extern(System) void function(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLint border, GLenum format, GLenum type, const( GLvoid*) data) @system @nogc nothrow;

    /++
     + glTexImage1D: man4/glTexImage1D.xml
     + 
     + Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled. To enable and disable one-dimensional texturing, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_TEXTURE_1D). Texture images are defined with $(D_INLINECODE glTexImage1D). The arguments describe the parameters of the texture image, such as width, width of the border, level-of-detail number (see $(D_INLINECODE glTexParameter) ), and the internal resolution and format used to store the image. The last three arguments describe how the image is represented in memory. If $(D_INLINECODE target) is $(D_INLINECODE GL_PROXY_TEXTURE_1D), no data is read from $(D_INLINECODE data), but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities. If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see $(D_INLINECODE glGetError) ). To query for an entire mipmap array, use an image array level greater than or equal to 1. If $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_1D), data is read from $(D_INLINECODE data) as a sequence of signed or unsigned bytes, shorts, or longs, or single-precision floating-point values, depending on $(D_INLINECODE type). These values are grouped into sets of one, two, three, or four values, depending on $(D_INLINECODE format), to form elements. Each data byte is treated as eight 1-bit elements, with bit ordering determined by $(D_INLINECODE GL_UNPACK_LSB_FIRST) (see $(D_INLINECODE glPixelStore) ). If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store. The first element corresponds to the left end of the texture array. Subsequent elements progress left-to-right through the remaining texels in the texture array. The final element corresponds to the right end of the texture array. $(D_INLINECODE format) determines the composition of each element in $(D_INLINECODE data). It can assume one of these symbolic values: If an application wants to store the texture at a certain resolution or in a certain format, it can request the resolution and format with $(D_INLINECODE internalFormat). The GL will choose an internal representation that closely approximates that requested by $(D_INLINECODE internalFormat), but it may not match exactly. (The representations specified by $(D_INLINECODE GL_RED), $(D_INLINECODE GL_RG), $(D_INLINECODE GL_RGB) and $(D_INLINECODE GL_RGBA) must match exactly.) $(D_INLINECODE internalFormat) may be one of the base internal formats shown in Table 1, below<h3> Base Internal Formats</h3> $(B Base Internal Format) $(B RGBA, Depth and Stencil Values) $(B Internal Components) $(D_INLINECODE GL_DEPTH_COMPONENT) Depth D $(D_INLINECODE GL_DEPTH_STENCIL) Depth, Stencil D, S $(D_INLINECODE GL_RED) Red R $(D_INLINECODE GL_RG) Red, Green R, G $(D_INLINECODE GL_RGB) Red, Green, Blue R, G, B $(D_INLINECODE GL_RGBA) Red, Green, Blue, Alpha R, G, B, A $(D_INLINECODE internalFormat) may also be one of the sized internal formats shown in Table 2, below<h3> Sized Internal Formats</h3> $(B Sized Internal Format) $(B Base Internal Format) $(B Red Bits) $(B Green Bits) $(B Blue Bits) $(B Alpha Bits) $(B Shared Bits) $(D_INLINECODE GL_R8) $(D_INLINECODE GL_RED) 8 $(D_INLINECODE GL_R8_SNORM) $(D_INLINECODE GL_RED) s8 $(D_INLINECODE GL_R16) $(D_INLINECODE GL_RED) 16 $(D_INLINECODE GL_R16_SNORM) $(D_INLINECODE GL_RED) s16 $(D_INLINECODE GL_RG8) $(D_INLINECODE GL_RG) 8 8 $(D_INLINECODE GL_RG8_SNORM) $(D_INLINECODE GL_RG) s8 s8 $(D_INLINECODE GL_RG16) $(D_INLINECODE GL_RG) 16 16 $(D_INLINECODE GL_RG16_SNORM) $(D_INLINECODE GL_RG) s16 s16 $(D_INLINECODE GL_R3_G3_B2) $(D_INLINECODE GL_RGB) 3 3 2 $(D_INLINECODE GL_RGB4) $(D_INLINECODE GL_RGB) 4 4 4 $(D_INLINECODE GL_RGB5) $(D_INLINECODE GL_RGB) 5 5 5 $(D_INLINECODE GL_RGB8) $(D_INLINECODE GL_RGB) 8 8 8 $(D_INLINECODE GL_RGB8_SNORM) $(D_INLINECODE GL_RGB) s8 s8 s8 $(D_INLINECODE GL_RGB10) $(D_INLINECODE GL_RGB) 10 10 10 $(D_INLINECODE GL_RGB12) $(D_INLINECODE GL_RGB) 12 12 12 $(D_INLINECODE GL_RGB16_SNORM) $(D_INLINECODE GL_RGB) 16 16 16 $(D_INLINECODE GL_RGBA2) $(D_INLINECODE GL_RGB) 2 2 2 2 $(D_INLINECODE GL_RGBA4) $(D_INLINECODE GL_RGB) 4 4 4 4 $(D_INLINECODE GL_RGB5_A1) $(D_INLINECODE GL_RGBA) 5 5 5 1 $(D_INLINECODE GL_RGBA8) $(D_INLINECODE GL_RGBA) 8 8 8 8 $(D_INLINECODE GL_RGBA8_SNORM) $(D_INLINECODE GL_RGBA) s8 s8 s8 s8 $(D_INLINECODE GL_RGB10_A2) $(D_INLINECODE GL_RGBA) 10 10 10 2 $(D_INLINECODE GL_RGB10_A2UI) $(D_INLINECODE GL_RGBA) ui10 ui10 ui10 ui2 $(D_INLINECODE GL_RGBA12) $(D_INLINECODE GL_RGBA) 12 12 12 12 $(D_INLINECODE GL_RGBA16) $(D_INLINECODE GL_RGBA) 16 16 16 16 $(D_INLINECODE GL_SRGB8) $(D_INLINECODE GL_RGB) 8 8 8 $(D_INLINECODE GL_SRGB8_ALPHA8) $(D_INLINECODE GL_RGBA) 8 8 8 8 $(D_INLINECODE GL_R16F) $(D_INLINECODE GL_RED) f16 $(D_INLINECODE GL_RG16F) $(D_INLINECODE GL_RG) f16 f16 $(D_INLINECODE GL_RGB16F) $(D_INLINECODE GL_RGB) f16 f16 f16 $(D_INLINECODE GL_RGBA16F) $(D_INLINECODE GL_RGBA) f16 f16 f16 f16 $(D_INLINECODE GL_R32F) $(D_INLINECODE GL_RED) f32 $(D_INLINECODE GL_RG32F) $(D_INLINECODE GL_RG) f32 f32 $(D_INLINECODE GL_RGB32F) $(D_INLINECODE GL_RGB) f32 f32 f32 $(D_INLINECODE GL_RGBA32F) $(D_INLINECODE GL_RGBA) f32 f32 f32 f32 $(D_INLINECODE GL_R11F_G11F_B10F) $(D_INLINECODE GL_RGB) f11 f11 f10 $(D_INLINECODE GL_RGB9_E5) $(D_INLINECODE GL_RGB) 9 9 9 5 $(D_INLINECODE GL_R8I) $(D_INLINECODE GL_RED) i8 $(D_INLINECODE GL_R8UI) $(D_INLINECODE GL_RED) ui8 $(D_INLINECODE GL_R16I) $(D_INLINECODE GL_RED) i16 $(D_INLINECODE GL_R16UI) $(D_INLINECODE GL_RED) ui16 $(D_INLINECODE GL_R32I) $(D_INLINECODE GL_RED) i32 $(D_INLINECODE GL_R32UI) $(D_INLINECODE GL_RED) ui32 $(D_INLINECODE GL_RG8I) $(D_INLINECODE GL_RG) i8 i8 $(D_INLINECODE GL_RG8UI) $(D_INLINECODE GL_RG) ui8 ui8 $(D_INLINECODE GL_RG16I) $(D_INLINECODE GL_RG) i16 i16 $(D_INLINECODE GL_RG16UI) $(D_INLINECODE GL_RG) ui16 ui16 $(D_INLINECODE GL_RG32I) $(D_INLINECODE GL_RG) i32 i32 $(D_INLINECODE GL_RG32UI) $(D_INLINECODE GL_RG) ui32 ui32 $(D_INLINECODE GL_RGB8I) $(D_INLINECODE GL_RGB) i8 i8 i8 $(D_INLINECODE GL_RGB8UI) $(D_INLINECODE GL_RGB) ui8 ui8 ui8 $(D_INLINECODE GL_RGB16I) $(D_INLINECODE GL_RGB) i16 i16 i16 $(D_INLINECODE GL_RGB16UI) $(D_INLINECODE GL_RGB) ui16 ui16 ui16 $(D_INLINECODE GL_RGB32I) $(D_INLINECODE GL_RGB) i32 i32 i32 $(D_INLINECODE GL_RGB32UI) $(D_INLINECODE GL_RGB) ui32 ui32 ui32 $(D_INLINECODE GL_RGBA8I) $(D_INLINECODE GL_RGBA) i8 i8 i8 i8 $(D_INLINECODE GL_RGBA8UI) $(D_INLINECODE GL_RGBA) ui8 ui8 ui8 ui8 $(D_INLINECODE GL_RGBA16I) $(D_INLINECODE GL_RGBA) i16 i16 i16 i16 $(D_INLINECODE GL_RGBA16UI) $(D_INLINECODE GL_RGBA) ui16 ui16 ui16 ui16 $(D_INLINECODE GL_RGBA32I) $(D_INLINECODE GL_RGBA) i32 i32 i32 i32 $(D_INLINECODE GL_RGBA32UI) $(D_INLINECODE GL_RGBA) ui32 ui32 ui32 ui32 Finally, $(D_INLINECODE internalFormat) may also be one of the generic or compressed compressed texture formats shown in Table 3 below<h3> Compressed Internal Formats</h3> $(B Compressed Internal Format) $(B Base Internal Format) $(B Type) $(D_INLINECODE GL_COMPRESSED_RED) $(D_INLINECODE GL_RED) Generic $(D_INLINECODE GL_COMPRESSED_RG) $(D_INLINECODE GL_RG) Generic $(D_INLINECODE GL_COMPRESSED_RGB) $(D_INLINECODE GL_RGB) Generic $(D_INLINECODE GL_COMPRESSED_RGBA) $(D_INLINECODE GL_RGBA) Generic $(D_INLINECODE GL_COMPRESSED_SRGB) $(D_INLINECODE GL_RGB) Generic $(D_INLINECODE GL_COMPRESSED_SRGB_ALPHA) $(D_INLINECODE GL_RGBA) Generic $(D_INLINECODE GL_COMPRESSED_RED_RGTC1) $(D_INLINECODE GL_RED) Specific $(D_INLINECODE GL_COMPRESSED_SIGNED_RED_RGTC1) $(D_INLINECODE GL_RED) Specific $(D_INLINECODE GL_COMPRESSED_RG_RGTC2) $(D_INLINECODE GL_RG) Specific $(D_INLINECODE GL_COMPRESSED_SIGNED_RG_RGTC2) $(D_INLINECODE GL_RG) Specific $(D_INLINECODE GL_COMPRESSED_RGBA_BPTC_UNORM) $(D_INLINECODE GL_RGBA) Specific $(D_INLINECODE GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM) $(D_INLINECODE GL_RGBA) Specific $(D_INLINECODE GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT) $(D_INLINECODE GL_RGB) Specific $(D_INLINECODE GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT) $(D_INLINECODE GL_RGB) Specific If the $(D_INLINECODE internalFormat) parameter is one of the generic compressed formats, $(D_INLINECODE GL_COMPRESSED_RED), $(D_INLINECODE GL_COMPRESSED_RG), $(D_INLINECODE GL_COMPRESSED_RGB), or $(D_INLINECODE GL_COMPRESSED_RGBA), the GL will replace the internal format with the symbolic constant for a specific internal format and compress the texture before storage.  If no corresponding internal format is available, or the GL can not compress that image for any reason, the internal format is instead replaced with a corresponding base internal format. If the $(D_INLINECODE internalFormat) parameter is $(D_INLINECODE GL_SRGB), $(D_INLINECODE GL_SRGB8), $(D_INLINECODE GL_SRGB_ALPHA) or $(D_INLINECODE GL_SRGB8_ALPHA8), the texture is treated as if the red, green, or blue components are encoded in the sRGB color space.    Any alpha component is left unchanged.  The conversion from the sRGB encoded component c s to a linear component c l is: c l = { c s 12.92 if c s &le; 0.04045 ( c s + 0.055 1.055 ) 2.4 if c s &gt; 0.04045 Assume c s is the sRGB component in the range [0,1]. Use the $(D_INLINECODE GL_PROXY_TEXTURE_1D) target to try out a resolution and format. The implementation will update and recompute its best match for the requested storage resolution and format. To then query this state, call $(D_INLINECODE glGetTexLevelParameter). If the texture cannot be accommodated, texture state is set to 0. A one-component texture image uses only the red component of the RGBA color from $(D_INLINECODE data). A two-component image uses the R and A values. A three-component image uses the R, G, and B values. A four-component image uses all of the RGBA components. Image-based shadowing can be enabled by comparing texture r coordinates to depth texture values to generate a boolean result.  See $(D_INLINECODE glTexParameter) for details on texture comparison.
     + 
     + $(D_INLINECODE glPixelStore) modes affect texture images. $(D_INLINECODE data) may be a null pointer. In this case texture memory is allocated to accommodate a texture of width $(D_INLINECODE width). You can then download subtextures to initialize the texture memory. The image is undefined if the program tries to apply an uninitialized portion of the texture image to a primitive. $(D_INLINECODE glTexImage1D) specifies the one-dimensional texture for the current texture unit, specified with $(D_INLINECODE glActiveTexture). $(D_INLINECODE GL_STENCIL_INDEX) may be used for $(D_INLINECODE format) only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     target         = Specifies the target texture. Must be $(D_INLINECODE GL_TEXTURE_1D) or $(D_INLINECODE GL_PROXY_TEXTURE_1D).
     +     level          = Specifies the level-of-detail number. Level 0 is the base image level. Level is the th mipmap reduction image.
     +     internalFormat = Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
     +     width          = Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide. The height of the 1D texture image is 1.
     +     border         = This value must be 0.
     +     format         = Specifies the format of the pixel data. The following symbolic values are accepted: $(D_INLINECODE GL_RED), $(D_INLINECODE GL_RG), $(D_INLINECODE GL_RGB), $(D_INLINECODE GL_BGR), $(D_INLINECODE GL_RGBA), $(D_INLINECODE GL_BGRA), $(D_INLINECODE GL_RED_INTEGER), $(D_INLINECODE GL_RG_INTEGER), $(D_INLINECODE GL_RGB_INTEGER), $(D_INLINECODE GL_BGR_INTEGER), $(D_INLINECODE GL_RGBA_INTEGER), $(D_INLINECODE GL_BGRA_INTEGER), $(D_INLINECODE GL_STENCIL_INDEX), $(D_INLINECODE GL_DEPTH_COMPONENT), $(D_INLINECODE GL_DEPTH_STENCIL).
     +     type           = Specifies the data type of the pixel data. The following symbolic values are accepted: $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), $(D_INLINECODE GL_SHORT), $(D_INLINECODE GL_UNSIGNED_INT), $(D_INLINECODE GL_INT), $(D_INLINECODE GL_FLOAT), $(D_INLINECODE GL_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GL_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GL_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GL_UNSIGNED_INT_10_10_10_2), and $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV).
     +     data           = Specifies a pointer to the image data in memory.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2011-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glCompressedTexImage1D), $(D_INLINECODE glCompressedTexSubImage1D), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glGetCompressedTexImage), $(D_INLINECODE glPixelStore), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexImage1D glTexImage1D;
    alias fn_glTexImage2D = extern(System) void function(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const( GLvoid*) data) @system @nogc nothrow;

    /++
     + glTexImage2D: man4/glTexImage2D.xml
     + 
     + Texturing allows elements of an image array to be read by shaders. To define texture images, call $(D_INLINECODE glTexImage2D). The arguments describe the parameters of the texture image, such as height, width, width of the border, level-of-detail number (see $(D_INLINECODE glTexParameter) ), and number of color components provided. The last three arguments describe how the image is represented in memory. If $(D_INLINECODE target) is $(D_INLINECODE GL_PROXY_TEXTURE_2D), $(D_INLINECODE GL_PROXY_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_PROXY_TEXTURE_CUBE_MAP), or $(D_INLINECODE GL_PROXY_TEXTURE_RECTANGLE), no data is read from $(D_INLINECODE data), but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities. If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see $(D_INLINECODE glGetError) ). To query for an entire mipmap array, use an image array level greater than or equal to 1. If $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_RECTANGLE) or one of the $(D_INLINECODE GL_TEXTURE_CUBE_MAP) targets, data is read from $(D_INLINECODE data) as a sequence of signed or unsigned bytes, shorts, or longs, or single-precision floating-point values, depending on $(D_INLINECODE type).  These values are grouped into sets of one, two, three, or four values, depending on $(D_INLINECODE format), to form elements. Each data byte is treated as eight 1-bit elements, with bit ordering determined by $(D_INLINECODE GL_UNPACK_LSB_FIRST) (see $(D_INLINECODE glPixelStore) ). If $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_1D_ARRAY), data is interpreted as an array of one-dimensional images. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store. The first element corresponds to the lower left corner of the texture image. Subsequent elements progress left-to-right through the remaining texels in the lowest row of the texture image, and then in successively higher rows of the texture image. The final element corresponds to the upper right corner of the texture image. $(D_INLINECODE format) determines the composition of each element in $(D_INLINECODE data). It can assume one of these symbolic values: If an application wants to store the texture at a certain resolution or in a certain format, it can request the resolution and format with $(D_INLINECODE internalFormat). The GL will choose an internal representation that closely approximates that requested by $(D_INLINECODE internalFormat), but it may not match exactly. (The representations specified by $(D_INLINECODE GL_RED), $(D_INLINECODE GL_RG), $(D_INLINECODE GL_RGB), and $(D_INLINECODE GL_RGBA) must match exactly.) $(D_INLINECODE internalFormat) may be one of the base internal formats shown in Table 1, below<h3> Base Internal Formats</h3> $(B Base Internal Format) $(B RGBA, Depth and Stencil Values) $(B Internal Components) $(D_INLINECODE GL_DEPTH_COMPONENT) Depth D $(D_INLINECODE GL_DEPTH_STENCIL) Depth, Stencil D, S $(D_INLINECODE GL_RED) Red R $(D_INLINECODE GL_RG) Red, Green R, G $(D_INLINECODE GL_RGB) Red, Green, Blue R, G, B $(D_INLINECODE GL_RGBA) Red, Green, Blue, Alpha R, G, B, A $(D_INLINECODE internalFormat) may also be one of the sized internal formats shown in Table 2, below<h3> Sized Internal Formats</h3> $(B Sized Internal Format) $(B Base Internal Format) $(B Red Bits) $(B Green Bits) $(B Blue Bits) $(B Alpha Bits) $(B Shared Bits) $(D_INLINECODE GL_R8) $(D_INLINECODE GL_RED) 8 $(D_INLINECODE GL_R8_SNORM) $(D_INLINECODE GL_RED) s8 $(D_INLINECODE GL_R16) $(D_INLINECODE GL_RED) 16 $(D_INLINECODE GL_R16_SNORM) $(D_INLINECODE GL_RED) s16 $(D_INLINECODE GL_RG8) $(D_INLINECODE GL_RG) 8 8 $(D_INLINECODE GL_RG8_SNORM) $(D_INLINECODE GL_RG) s8 s8 $(D_INLINECODE GL_RG16) $(D_INLINECODE GL_RG) 16 16 $(D_INLINECODE GL_RG16_SNORM) $(D_INLINECODE GL_RG) s16 s16 $(D_INLINECODE GL_R3_G3_B2) $(D_INLINECODE GL_RGB) 3 3 2 $(D_INLINECODE GL_RGB4) $(D_INLINECODE GL_RGB) 4 4 4 $(D_INLINECODE GL_RGB5) $(D_INLINECODE GL_RGB) 5 5 5 $(D_INLINECODE GL_RGB8) $(D_INLINECODE GL_RGB) 8 8 8 $(D_INLINECODE GL_RGB8_SNORM) $(D_INLINECODE GL_RGB) s8 s8 s8 $(D_INLINECODE GL_RGB10) $(D_INLINECODE GL_RGB) 10 10 10 $(D_INLINECODE GL_RGB12) $(D_INLINECODE GL_RGB) 12 12 12 $(D_INLINECODE GL_RGB16_SNORM) $(D_INLINECODE GL_RGB) 16 16 16 $(D_INLINECODE GL_RGBA2) $(D_INLINECODE GL_RGB) 2 2 2 2 $(D_INLINECODE GL_RGBA4) $(D_INLINECODE GL_RGB) 4 4 4 4 $(D_INLINECODE GL_RGB5_A1) $(D_INLINECODE GL_RGBA) 5 5 5 1 $(D_INLINECODE GL_RGBA8) $(D_INLINECODE GL_RGBA) 8 8 8 8 $(D_INLINECODE GL_RGBA8_SNORM) $(D_INLINECODE GL_RGBA) s8 s8 s8 s8 $(D_INLINECODE GL_RGB10_A2) $(D_INLINECODE GL_RGBA) 10 10 10 2 $(D_INLINECODE GL_RGB10_A2UI) $(D_INLINECODE GL_RGBA) ui10 ui10 ui10 ui2 $(D_INLINECODE GL_RGBA12) $(D_INLINECODE GL_RGBA) 12 12 12 12 $(D_INLINECODE GL_RGBA16) $(D_INLINECODE GL_RGBA) 16 16 16 16 $(D_INLINECODE GL_SRGB8) $(D_INLINECODE GL_RGB) 8 8 8 $(D_INLINECODE GL_SRGB8_ALPHA8) $(D_INLINECODE GL_RGBA) 8 8 8 8 $(D_INLINECODE GL_R16F) $(D_INLINECODE GL_RED) f16 $(D_INLINECODE GL_RG16F) $(D_INLINECODE GL_RG) f16 f16 $(D_INLINECODE GL_RGB16F) $(D_INLINECODE GL_RGB) f16 f16 f16 $(D_INLINECODE GL_RGBA16F) $(D_INLINECODE GL_RGBA) f16 f16 f16 f16 $(D_INLINECODE GL_R32F) $(D_INLINECODE GL_RED) f32 $(D_INLINECODE GL_RG32F) $(D_INLINECODE GL_RG) f32 f32 $(D_INLINECODE GL_RGB32F) $(D_INLINECODE GL_RGB) f32 f32 f32 $(D_INLINECODE GL_RGBA32F) $(D_INLINECODE GL_RGBA) f32 f32 f32 f32 $(D_INLINECODE GL_R11F_G11F_B10F) $(D_INLINECODE GL_RGB) f11 f11 f10 $(D_INLINECODE GL_RGB9_E5) $(D_INLINECODE GL_RGB) 9 9 9 5 $(D_INLINECODE GL_R8I) $(D_INLINECODE GL_RED) i8 $(D_INLINECODE GL_R8UI) $(D_INLINECODE GL_RED) ui8 $(D_INLINECODE GL_R16I) $(D_INLINECODE GL_RED) i16 $(D_INLINECODE GL_R16UI) $(D_INLINECODE GL_RED) ui16 $(D_INLINECODE GL_R32I) $(D_INLINECODE GL_RED) i32 $(D_INLINECODE GL_R32UI) $(D_INLINECODE GL_RED) ui32 $(D_INLINECODE GL_RG8I) $(D_INLINECODE GL_RG) i8 i8 $(D_INLINECODE GL_RG8UI) $(D_INLINECODE GL_RG) ui8 ui8 $(D_INLINECODE GL_RG16I) $(D_INLINECODE GL_RG) i16 i16 $(D_INLINECODE GL_RG16UI) $(D_INLINECODE GL_RG) ui16 ui16 $(D_INLINECODE GL_RG32I) $(D_INLINECODE GL_RG) i32 i32 $(D_INLINECODE GL_RG32UI) $(D_INLINECODE GL_RG) ui32 ui32 $(D_INLINECODE GL_RGB8I) $(D_INLINECODE GL_RGB) i8 i8 i8 $(D_INLINECODE GL_RGB8UI) $(D_INLINECODE GL_RGB) ui8 ui8 ui8 $(D_INLINECODE GL_RGB16I) $(D_INLINECODE GL_RGB) i16 i16 i16 $(D_INLINECODE GL_RGB16UI) $(D_INLINECODE GL_RGB) ui16 ui16 ui16 $(D_INLINECODE GL_RGB32I) $(D_INLINECODE GL_RGB) i32 i32 i32 $(D_INLINECODE GL_RGB32UI) $(D_INLINECODE GL_RGB) ui32 ui32 ui32 $(D_INLINECODE GL_RGBA8I) $(D_INLINECODE GL_RGBA) i8 i8 i8 i8 $(D_INLINECODE GL_RGBA8UI) $(D_INLINECODE GL_RGBA) ui8 ui8 ui8 ui8 $(D_INLINECODE GL_RGBA16I) $(D_INLINECODE GL_RGBA) i16 i16 i16 i16 $(D_INLINECODE GL_RGBA16UI) $(D_INLINECODE GL_RGBA) ui16 ui16 ui16 ui16 $(D_INLINECODE GL_RGBA32I) $(D_INLINECODE GL_RGBA) i32 i32 i32 i32 $(D_INLINECODE GL_RGBA32UI) $(D_INLINECODE GL_RGBA) ui32 ui32 ui32 ui32 Finally, $(D_INLINECODE internalFormat) may also be one of the generic or compressed compressed texture formats shown in Table 3 below<h3> Compressed Internal Formats</h3> $(B Compressed Internal Format) $(B Base Internal Format) $(B Type) $(D_INLINECODE GL_COMPRESSED_RED) $(D_INLINECODE GL_RED) Generic $(D_INLINECODE GL_COMPRESSED_RG) $(D_INLINECODE GL_RG) Generic $(D_INLINECODE GL_COMPRESSED_RGB) $(D_INLINECODE GL_RGB) Generic $(D_INLINECODE GL_COMPRESSED_RGBA) $(D_INLINECODE GL_RGBA) Generic $(D_INLINECODE GL_COMPRESSED_SRGB) $(D_INLINECODE GL_RGB) Generic $(D_INLINECODE GL_COMPRESSED_SRGB_ALPHA) $(D_INLINECODE GL_RGBA) Generic $(D_INLINECODE GL_COMPRESSED_RED_RGTC1) $(D_INLINECODE GL_RED) Specific $(D_INLINECODE GL_COMPRESSED_SIGNED_RED_RGTC1) $(D_INLINECODE GL_RED) Specific $(D_INLINECODE GL_COMPRESSED_RG_RGTC2) $(D_INLINECODE GL_RG) Specific $(D_INLINECODE GL_COMPRESSED_SIGNED_RG_RGTC2) $(D_INLINECODE GL_RG) Specific $(D_INLINECODE GL_COMPRESSED_RGBA_BPTC_UNORM) $(D_INLINECODE GL_RGBA) Specific $(D_INLINECODE GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM) $(D_INLINECODE GL_RGBA) Specific $(D_INLINECODE GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT) $(D_INLINECODE GL_RGB) Specific $(D_INLINECODE GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT) $(D_INLINECODE GL_RGB) Specific If the $(D_INLINECODE internalFormat) parameter is one of the generic compressed formats, $(D_INLINECODE GL_COMPRESSED_RED), $(D_INLINECODE GL_COMPRESSED_RG), $(D_INLINECODE GL_COMPRESSED_RGB), or $(D_INLINECODE GL_COMPRESSED_RGBA), the GL will replace the internal format with the symbolic constant for a specific internal format and compress the texture before storage.  If no corresponding internal format is available, or the GL can not compress that image for any reason, the internal format is instead replaced with a corresponding base internal format. If the $(D_INLINECODE internalFormat) parameter is $(D_INLINECODE GL_SRGB), $(D_INLINECODE GL_SRGB8), $(D_INLINECODE GL_SRGB_ALPHA), or $(D_INLINECODE GL_SRGB8_ALPHA8), the texture is treated as if the red, green, or blue components are encoded in the sRGB color space.    Any alpha component is left unchanged.  The conversion from the sRGB encoded component c s to a linear component c l is: c l = { c s 12.92 if c s &le; 0.04045 ( c s + 0.055 1.055 ) 2.4 if c s &gt; 0.04045 Assume c s is the sRGB component in the range [0,1]. Use the $(D_INLINECODE GL_PROXY_TEXTURE_2D), $(D_INLINECODE GL_PROXY_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_PROXY_TEXTURE_RECTANGLE), or $(D_INLINECODE GL_PROXY_TEXTURE_CUBE_MAP) target to try out a resolution and format. The implementation will update and recompute its best match for the requested storage resolution and format. To then query this state, call $(D_INLINECODE glGetTexLevelParameter). If the texture cannot be accommodated, texture state is set to 0. A one-component texture image uses only the red component of the RGBA color extracted from $(D_INLINECODE data). A two-component image uses the R and G values. A three-component image uses the R, G, and B values. A four-component image uses all of the RGBA components. Image-based shadowing can be enabled by comparing texture r coordinates to depth texture values to generate a boolean result. See $(D_INLINECODE glTexParameter) for details on texture comparison.
     + 
     + The $(D_INLINECODE glPixelStore) mode affects texture images. $(D_INLINECODE data) may be a null pointer. In this case, texture memory is allocated to accommodate a texture of width $(D_INLINECODE width) and height $(D_INLINECODE height). You can then download subtextures to initialize this texture memory. The image is undefined if the user tries to apply an uninitialized portion of the texture image to a primitive. $(D_INLINECODE glTexImage2D) specifies the two-dimensional texture for the current texture unit, specified with $(D_INLINECODE glActiveTexture). $(D_INLINECODE GL_STENCIL_INDEX) may be used for $(D_INLINECODE format) only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     target         = Specifies the target texture. Must be $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_PROXY_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_PROXY_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_RECTANGLE), $(D_INLINECODE GL_PROXY_TEXTURE_RECTANGLE), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Z), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Z), or $(D_INLINECODE GL_PROXY_TEXTURE_CUBE_MAP).
     +     level          = Specifies the level-of-detail number. Level 0 is the base image level. Level is the th mipmap reduction image. If $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_RECTANGLE) or $(D_INLINECODE GL_PROXY_TEXTURE_RECTANGLE), $(D_INLINECODE level) must be 0.
     +     internalFormat = Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
     +     width          = Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide.
     +     height         = Specifies the height of the texture image, or the number of layers in a texture array, in the case of the $(D_INLINECODE GL_TEXTURE_1D_ARRAY) and $(D_INLINECODE GL_PROXY_TEXTURE_1D_ARRAY) targets. All implementations support 2D texture images that are at least 1024 texels high, and texture arrays that are at least 256 layers deep.
     +     border         = This value must be 0.
     +     format         = Specifies the format of the pixel data. The following symbolic values are accepted: $(D_INLINECODE GL_RED), $(D_INLINECODE GL_RG), $(D_INLINECODE GL_RGB), $(D_INLINECODE GL_BGR), $(D_INLINECODE GL_RGBA), $(D_INLINECODE GL_BGRA), $(D_INLINECODE GL_RED_INTEGER), $(D_INLINECODE GL_RG_INTEGER), $(D_INLINECODE GL_RGB_INTEGER), $(D_INLINECODE GL_BGR_INTEGER), $(D_INLINECODE GL_RGBA_INTEGER), $(D_INLINECODE GL_BGRA_INTEGER), $(D_INLINECODE GL_STENCIL_INDEX), $(D_INLINECODE GL_DEPTH_COMPONENT), $(D_INLINECODE GL_DEPTH_STENCIL).
     +     type           = Specifies the data type of the pixel data. The following symbolic values are accepted: $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), $(D_INLINECODE GL_SHORT), $(D_INLINECODE GL_UNSIGNED_INT), $(D_INLINECODE GL_INT), $(D_INLINECODE GL_FLOAT), $(D_INLINECODE GL_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GL_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GL_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GL_UNSIGNED_INT_10_10_10_2), and $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV).
     +     data           = Specifies a pointer to the image data in memory.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2011-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glPixelStore), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexImage2D glTexImage2D;
    alias fn_glTexImage2DMultisample = extern(System) void function(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) @system @nogc nothrow;

    /++
     + glTexImage2DMultisample: man4/glTexImage2DMultisample.xml
     + 
     + $(D_INLINECODE glTexImage2DMultisample) establishes the data storage, format, dimensions and number of samples of a multisample texture's image. $(D_INLINECODE target) must be $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE) or $(D_INLINECODE GL_PROXY_TEXTURE_2D_MULTISAMPLE). $(D_INLINECODE width) and $(D_INLINECODE height) are the dimensions in texels of the texture, and must be in the range zero to the value of $(D_INLINECODE GL_MAX_TEXTURE_SIZE) minus one. $(D_INLINECODE samples) specifies the number of samples in the image and must be in the range zero to the value of $(D_INLINECODE GL_MAX_SAMPLES) minus one. $(D_INLINECODE internalformat) must be a color-renderable, depth-renderable, or stencil-renderable format. If $(D_INLINECODE fixedsamplelocations) is $(D_INLINECODE GL_TRUE), the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. When a multisample texture is accessed in a shader, the access takes one vector of integers describing which texel to fetch and an integer corresponding to the sample numbers describing which sample within the texel to fetch. No standard sampling instructions are allowed on the multisample texture targets.
     + 
     + $(D_INLINECODE glTexImage2DMultisample) is available only if the GL version is 3.2 or greater.
     + 
     + Params:
     +     target               = Specifies the target of the operation. $(D_INLINECODE target) must be $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE) or $(D_INLINECODE GL_PROXY_TEXTURE_2D_MULTISAMPLE).
     +     samples              = The number of samples in the multisample texture's image.
     +     internalformat       = The internal format to be used to store the multisample texture's image. $(D_INLINECODE internalformat) must specify a color-renderable, depth-renderable, or stencil-renderable format.
     +     width                = The width of the multisample texture's image, in texels.
     +     height               = The height of the multisample texture's image, in texels.
     +     fixedsamplelocations = Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexImage2DMultisample)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_texture_multisample")
    fn_glTexImage2DMultisample glTexImage2DMultisample;
    alias fn_glTexImage3D = extern(System) void function(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const( GLvoid*) data) @system @nogc nothrow;

    /++
     + glTexImage3D: man4/glTexImage3D.xml
     + 
     + Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled. To enable and disable three-dimensional texturing, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_TEXTURE_3D). To define texture images, call $(D_INLINECODE glTexImage3D). The arguments describe the parameters of the texture image, such as height, width, depth, width of the border, level-of-detail number (see $(D_INLINECODE glTexParameter) ), and number of color components provided. The last three arguments describe how the image is represented in memory. If $(D_INLINECODE target) is $(D_INLINECODE GL_PROXY_TEXTURE_3D), no data is read from $(D_INLINECODE data), but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities. If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see $(D_INLINECODE glGetError) ). To query for an entire mipmap array, use an image array level greater than or equal to 1. If $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_3D), data is read from $(D_INLINECODE data) as a sequence of signed or unsigned bytes, shorts, or longs, or single-precision floating-point values, depending on $(D_INLINECODE type). These values are grouped into sets of one, two, three, or four values, depending on $(D_INLINECODE format), to form elements. Each data byte is treated as eight 1-bit elements, with bit ordering determined by $(D_INLINECODE GL_UNPACK_LSB_FIRST) (see $(D_INLINECODE glPixelStore) ). If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store. The first element corresponds to the lower left corner of the texture image. Subsequent elements progress left-to-right through the remaining texels in the lowest row of the texture image, and then in successively higher rows of the texture image. The final element corresponds to the upper right corner of the texture image. $(D_INLINECODE format) determines the composition of each element in $(D_INLINECODE data). It can assume one of these symbolic values: If an application wants to store the texture at a certain resolution or in a certain format, it can request the resolution and format with $(D_INLINECODE internalFormat). The GL will choose an internal representation that closely approximates that requested by $(D_INLINECODE internalFormat), but it may not match exactly. (The representations specified by $(D_INLINECODE GL_RED), $(D_INLINECODE GL_RG), $(D_INLINECODE GL_RGB), and $(D_INLINECODE GL_RGBA) must match exactly.) $(D_INLINECODE internalFormat) may be one of the base internal formats shown in Table 1, below<h3> Base Internal Formats</h3> $(B Base Internal Format) $(B RGBA, Depth and Stencil Values) $(B Internal Components) $(D_INLINECODE GL_DEPTH_COMPONENT) Depth D $(D_INLINECODE GL_DEPTH_STENCIL) Depth, Stencil D, S $(D_INLINECODE GL_RED) Red R $(D_INLINECODE GL_RG) Red, Green R, G $(D_INLINECODE GL_RGB) Red, Green, Blue R, G, B $(D_INLINECODE GL_RGBA) Red, Green, Blue, Alpha R, G, B, A $(D_INLINECODE internalFormat) may also be one of the sized internal formats shown in Table 2, below<h3> Sized Internal Formats</h3> $(B Sized Internal Format) $(B Base Internal Format) $(B Red Bits) $(B Green Bits) $(B Blue Bits) $(B Alpha Bits) $(B Shared Bits) $(D_INLINECODE GL_R8) $(D_INLINECODE GL_RED) 8 $(D_INLINECODE GL_R8_SNORM) $(D_INLINECODE GL_RED) s8 $(D_INLINECODE GL_R16) $(D_INLINECODE GL_RED) 16 $(D_INLINECODE GL_R16_SNORM) $(D_INLINECODE GL_RED) s16 $(D_INLINECODE GL_RG8) $(D_INLINECODE GL_RG) 8 8 $(D_INLINECODE GL_RG8_SNORM) $(D_INLINECODE GL_RG) s8 s8 $(D_INLINECODE GL_RG16) $(D_INLINECODE GL_RG) 16 16 $(D_INLINECODE GL_RG16_SNORM) $(D_INLINECODE GL_RG) s16 s16 $(D_INLINECODE GL_R3_G3_B2) $(D_INLINECODE GL_RGB) 3 3 2 $(D_INLINECODE GL_RGB4) $(D_INLINECODE GL_RGB) 4 4 4 $(D_INLINECODE GL_RGB5) $(D_INLINECODE GL_RGB) 5 5 5 $(D_INLINECODE GL_RGB8) $(D_INLINECODE GL_RGB) 8 8 8 $(D_INLINECODE GL_RGB8_SNORM) $(D_INLINECODE GL_RGB) s8 s8 s8 $(D_INLINECODE GL_RGB10) $(D_INLINECODE GL_RGB) 10 10 10 $(D_INLINECODE GL_RGB12) $(D_INLINECODE GL_RGB) 12 12 12 $(D_INLINECODE GL_RGB16_SNORM) $(D_INLINECODE GL_RGB) 16 16 16 $(D_INLINECODE GL_RGBA2) $(D_INLINECODE GL_RGB) 2 2 2 2 $(D_INLINECODE GL_RGBA4) $(D_INLINECODE GL_RGB) 4 4 4 4 $(D_INLINECODE GL_RGB5_A1) $(D_INLINECODE GL_RGBA) 5 5 5 1 $(D_INLINECODE GL_RGBA8) $(D_INLINECODE GL_RGBA) 8 8 8 8 $(D_INLINECODE GL_RGBA8_SNORM) $(D_INLINECODE GL_RGBA) s8 s8 s8 s8 $(D_INLINECODE GL_RGB10_A2) $(D_INLINECODE GL_RGBA) 10 10 10 2 $(D_INLINECODE GL_RGB10_A2UI) $(D_INLINECODE GL_RGBA) ui10 ui10 ui10 ui2 $(D_INLINECODE GL_RGBA12) $(D_INLINECODE GL_RGBA) 12 12 12 12 $(D_INLINECODE GL_RGBA16) $(D_INLINECODE GL_RGBA) 16 16 16 16 $(D_INLINECODE GL_SRGB8) $(D_INLINECODE GL_RGB) 8 8 8 $(D_INLINECODE GL_SRGB8_ALPHA8) $(D_INLINECODE GL_RGBA) 8 8 8 8 $(D_INLINECODE GL_R16F) $(D_INLINECODE GL_RED) f16 $(D_INLINECODE GL_RG16F) $(D_INLINECODE GL_RG) f16 f16 $(D_INLINECODE GL_RGB16F) $(D_INLINECODE GL_RGB) f16 f16 f16 $(D_INLINECODE GL_RGBA16F) $(D_INLINECODE GL_RGBA) f16 f16 f16 f16 $(D_INLINECODE GL_R32F) $(D_INLINECODE GL_RED) f32 $(D_INLINECODE GL_RG32F) $(D_INLINECODE GL_RG) f32 f32 $(D_INLINECODE GL_RGB32F) $(D_INLINECODE GL_RGB) f32 f32 f32 $(D_INLINECODE GL_RGBA32F) $(D_INLINECODE GL_RGBA) f32 f32 f32 f32 $(D_INLINECODE GL_R11F_G11F_B10F) $(D_INLINECODE GL_RGB) f11 f11 f10 $(D_INLINECODE GL_RGB9_E5) $(D_INLINECODE GL_RGB) 9 9 9 5 $(D_INLINECODE GL_R8I) $(D_INLINECODE GL_RED) i8 $(D_INLINECODE GL_R8UI) $(D_INLINECODE GL_RED) ui8 $(D_INLINECODE GL_R16I) $(D_INLINECODE GL_RED) i16 $(D_INLINECODE GL_R16UI) $(D_INLINECODE GL_RED) ui16 $(D_INLINECODE GL_R32I) $(D_INLINECODE GL_RED) i32 $(D_INLINECODE GL_R32UI) $(D_INLINECODE GL_RED) ui32 $(D_INLINECODE GL_RG8I) $(D_INLINECODE GL_RG) i8 i8 $(D_INLINECODE GL_RG8UI) $(D_INLINECODE GL_RG) ui8 ui8 $(D_INLINECODE GL_RG16I) $(D_INLINECODE GL_RG) i16 i16 $(D_INLINECODE GL_RG16UI) $(D_INLINECODE GL_RG) ui16 ui16 $(D_INLINECODE GL_RG32I) $(D_INLINECODE GL_RG) i32 i32 $(D_INLINECODE GL_RG32UI) $(D_INLINECODE GL_RG) ui32 ui32 $(D_INLINECODE GL_RGB8I) $(D_INLINECODE GL_RGB) i8 i8 i8 $(D_INLINECODE GL_RGB8UI) $(D_INLINECODE GL_RGB) ui8 ui8 ui8 $(D_INLINECODE GL_RGB16I) $(D_INLINECODE GL_RGB) i16 i16 i16 $(D_INLINECODE GL_RGB16UI) $(D_INLINECODE GL_RGB) ui16 ui16 ui16 $(D_INLINECODE GL_RGB32I) $(D_INLINECODE GL_RGB) i32 i32 i32 $(D_INLINECODE GL_RGB32UI) $(D_INLINECODE GL_RGB) ui32 ui32 ui32 $(D_INLINECODE GL_RGBA8I) $(D_INLINECODE GL_RGBA) i8 i8 i8 i8 $(D_INLINECODE GL_RGBA8UI) $(D_INLINECODE GL_RGBA) ui8 ui8 ui8 ui8 $(D_INLINECODE GL_RGBA16I) $(D_INLINECODE GL_RGBA) i16 i16 i16 i16 $(D_INLINECODE GL_RGBA16UI) $(D_INLINECODE GL_RGBA) ui16 ui16 ui16 ui16 $(D_INLINECODE GL_RGBA32I) $(D_INLINECODE GL_RGBA) i32 i32 i32 i32 $(D_INLINECODE GL_RGBA32UI) $(D_INLINECODE GL_RGBA) ui32 ui32 ui32 ui32 Finally, $(D_INLINECODE internalFormat) may also be one of the generic or compressed compressed texture formats shown in Table 3 below<h3> Compressed Internal Formats</h3> $(B Compressed Internal Format) $(B Base Internal Format) $(B Type) $(D_INLINECODE GL_COMPRESSED_RED) $(D_INLINECODE GL_RED) Generic $(D_INLINECODE GL_COMPRESSED_RG) $(D_INLINECODE GL_RG) Generic $(D_INLINECODE GL_COMPRESSED_RGB) $(D_INLINECODE GL_RGB) Generic $(D_INLINECODE GL_COMPRESSED_RGBA) $(D_INLINECODE GL_RGBA) Generic $(D_INLINECODE GL_COMPRESSED_SRGB) $(D_INLINECODE GL_RGB) Generic $(D_INLINECODE GL_COMPRESSED_SRGB_ALPHA) $(D_INLINECODE GL_RGBA) Generic $(D_INLINECODE GL_COMPRESSED_RED_RGTC1) $(D_INLINECODE GL_RED) Specific $(D_INLINECODE GL_COMPRESSED_SIGNED_RED_RGTC1) $(D_INLINECODE GL_RED) Specific $(D_INLINECODE GL_COMPRESSED_RG_RGTC2) $(D_INLINECODE GL_RG) Specific $(D_INLINECODE GL_COMPRESSED_SIGNED_RG_RGTC2) $(D_INLINECODE GL_RG) Specific $(D_INLINECODE GL_COMPRESSED_RGBA_BPTC_UNORM) $(D_INLINECODE GL_RGBA) Specific $(D_INLINECODE GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM) $(D_INLINECODE GL_RGBA) Specific $(D_INLINECODE GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT) $(D_INLINECODE GL_RGB) Specific $(D_INLINECODE GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT) $(D_INLINECODE GL_RGB) Specific If the $(D_INLINECODE internalFormat) parameter is one of the generic compressed formats, $(D_INLINECODE GL_COMPRESSED_RED), $(D_INLINECODE GL_COMPRESSED_RG), $(D_INLINECODE GL_COMPRESSED_RGB), or $(D_INLINECODE GL_COMPRESSED_RGBA), the GL will replace the internal format with the symbolic constant for a specific internal format and compress the texture before storage.  If no corresponding internal format is available, or the GL can not compress that image for any reason, the internal format is instead replaced with a corresponding base internal format. If the $(D_INLINECODE internalFormat) parameter is $(D_INLINECODE GL_SRGB), $(D_INLINECODE GL_SRGB8), $(D_INLINECODE GL_SRGB_ALPHA), or $(D_INLINECODE GL_SRGB8_ALPHA8), the texture is treated as if the red, green, blue, or luminance components are encoded in the sRGB color space.    Any alpha component is left unchanged.  The conversion from the sRGB encoded component c s to a linear component c l is: c l = { c s 12.92 if c s &le; 0.04045 ( c s + 0.055 1.055 ) 2.4 if c s &gt; 0.04045 Assume c s is the sRGB component in the range [0,1]. Use the $(D_INLINECODE GL_PROXY_TEXTURE_3D) target to try out a resolution and format. The implementation will update and recompute its best match for the requested storage resolution and format. To then query this state, call $(D_INLINECODE glGetTexLevelParameter). If the texture cannot be accommodated, texture state is set to 0. A one-component texture image uses only the red component of the RGBA color extracted from $(D_INLINECODE data). A two-component image uses the R and A values. A three-component image uses the R, G, and B values. A four-component image uses all of the RGBA components.
     + 
     + The $(D_INLINECODE glPixelStore) mode affects texture images. $(D_INLINECODE data) may be a null pointer. In this case texture memory is allocated to accommodate a texture of width $(D_INLINECODE width), height $(D_INLINECODE height), and depth $(D_INLINECODE depth). You can then download subtextures to initialize this texture memory. The image is undefined if the user tries to apply an uninitialized portion of the texture image to a primitive. $(D_INLINECODE glTexImage3D) specifies the three-dimensional texture for the current texture unit, specified with $(D_INLINECODE glActiveTexture). $(D_INLINECODE GL_STENCIL_INDEX) may be used for $(D_INLINECODE format) only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     target         = Specifies the target texture. Must be one of $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_PROXY_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_2D_ARRAY) or $(D_INLINECODE GL_PROXY_TEXTURE_2D_ARRAY).
     +     level          = Specifies the level-of-detail number. Level 0 is the base image level. Level n is the n th mipmap reduction image.
     +     internalFormat = Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.
     +     width          = Specifies the width of the texture image. All implementations support 3D texture images that are at least 16 texels wide.
     +     height         = Specifies the height of the texture image. All implementations support 3D texture images that are at least 256 texels high.
     +     depth          = Specifies the depth of the texture image, or the number of layers in a texture array. All implementations support 3D texture images that are at least 256 texels deep, and texture arrays that are at least 256 layers deep.
     +     border         = This value must be 0.
     +     format         = Specifies the format of the pixel data. The following symbolic values are accepted: $(D_INLINECODE GL_RED), $(D_INLINECODE GL_RG), $(D_INLINECODE GL_RGB), $(D_INLINECODE GL_BGR), $(D_INLINECODE GL_RGBA), $(D_INLINECODE GL_BGRA), $(D_INLINECODE GL_RED_INTEGER), $(D_INLINECODE GL_RG_INTEGER), $(D_INLINECODE GL_RGB_INTEGER), $(D_INLINECODE GL_BGR_INTEGER), $(D_INLINECODE GL_RGBA_INTEGER), $(D_INLINECODE GL_BGRA_INTEGER), $(D_INLINECODE GL_STENCIL_INDEX), $(D_INLINECODE GL_DEPTH_COMPONENT), $(D_INLINECODE GL_DEPTH_STENCIL).
     +     type           = Specifies the data type of the pixel data. The following symbolic values are accepted: $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), $(D_INLINECODE GL_SHORT), $(D_INLINECODE GL_UNSIGNED_INT), $(D_INLINECODE GL_INT), $(D_INLINECODE GL_FLOAT), $(D_INLINECODE GL_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GL_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GL_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GL_UNSIGNED_INT_10_10_10_2), and $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV).
     +     data           = Specifies a pointer to the image data in memory.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2011-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glCompressedTexImage1D), $(D_INLINECODE glCompressedTexImage2D), $(D_INLINECODE glCompressedTexImage3D), $(D_INLINECODE glCompressedTexSubImage1D), $(D_INLINECODE glCompressedTexSubImage2D), $(D_INLINECODE glCompressedTexSubImage3D), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glGetCompressedTexImage), $(D_INLINECODE glPixelStore), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P2)
    fn_glTexImage3D glTexImage3D;
    alias fn_glTexImage3DMultisample = extern(System) void function(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) @system @nogc nothrow;

    /++
     + glTexImage3DMultisample: man4/glTexImage3DMultisample.xml
     + 
     + $(D_INLINECODE glTexImage3DMultisample) establishes the data storage, format, dimensions and number of samples of a multisample texture's image. $(D_INLINECODE target) must be $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY) or $(D_INLINECODE GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY). $(D_INLINECODE width) and $(D_INLINECODE height) are the dimensions in texels of the texture, and must be in the range zero to the value of $(D_INLINECODE GL_MAX_TEXTURE_SIZE) minus one. $(D_INLINECODE depth) is the number of array slices in the array texture's image. $(D_INLINECODE samples) specifies the number of samples in the image and must be in the range zero to the value of $(D_INLINECODE GL_MAX_SAMPLES) minus one. $(D_INLINECODE internalformat) must be a color-renderable, depth-renderable, or stencil-renderable format. If $(D_INLINECODE fixedsamplelocations) is $(D_INLINECODE GL_TRUE), the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image. When a multisample texture is accessed in a shader, the access takes one vector of integers describing which texel to fetch and an integer corresponding to the sample numbers describing which sample within the texel to fetch. No standard sampling instructions are allowed on the multisample texture targets.
     + 
     + $(D_INLINECODE glTexImage2DMultisample) is available only if the GL version is 3.2 or greater.
     + 
     + Params:
     +     target               = Specifies the target of the operation. $(D_INLINECODE target) must be $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY) or $(D_INLINECODE GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY).
     +     samples              = The number of samples in the multisample texture's image.
     +     internalformat       = The internal format to be used to store the multisample texture's image. $(D_INLINECODE internalformat) must specify a color-renderable, depth-renderable, or stencil-renderable format.
     +     width                = The width of the multisample texture's image, in texels.
     +     height               = The height of the multisample texture's image, in texels.
     +     fixedsamplelocations = Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexImage2DMultisample)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_texture_multisample")
    fn_glTexImage3DMultisample glTexImage3DMultisample;
    alias fn_glTexParameterf = extern(System) void function(GLenum target, GLenum pname, GLfloat param) @system @nogc nothrow;

    /++
     + glTexParameter: man4/glTexParameter.xml
     + 
     + $(D_INLINECODE glTexParameter) and $(D_INLINECODE glTextureParameter) assign the value or values in $(D_INLINECODE params) to the texture parameter specified as $(D_INLINECODE pname). For $(D_INLINECODE glTexParameter), $(D_INLINECODE target) defines the target texture, either $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE), $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_CUBE_MAP), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY), or $(D_INLINECODE GL_TEXTURE_RECTANGLE). The following symbols are accepted in $(D_INLINECODE pname) :
     + 
     + Suppose that a program attempts to sample from a texture and has set $(D_INLINECODE GL_TEXTURE_MIN_FILTER) to one of the functions that requires a mipmap. If either the dimensions of the texture images currently defined (with previous calls to $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glCopyTexImage1D), or $(D_INLINECODE glCopyTexImage2D) ) do not follow the proper sequence for mipmaps (described above), or there are fewer texture images defined than are needed, or the set of texture images have differing numbers of texture components, then the texture is considered. Linear filtering accesses the four nearest texture elements only in 2D textures. In 1D textures, linear filtering accesses the two nearest texture elements. In 3D textures, linear filtering accesses the eight nearest texture elements. $(D_INLINECODE glTexParameter) specifies the texture parameters for the active texture unit, specified by calling $(D_INLINECODE glActiveTexture). $(D_INLINECODE glTextureParameter) specifies the texture parameters for the texture object with ID $(D_INLINECODE texture). $(D_INLINECODE GL_DEPTH_STENCIL_TEXTURE_MODE) is available only if the GL version is 4.3 or greater. $(D_INLINECODE GL_MIRROR_CLAMP_TO_EDGE) is available only if the GL version is 4.4 or greater.
     + 
     + Params:
     +     target  = Specifies the target to which the texture is bound for $(D_INLINECODE glTexParameter) functions. Must be one of $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE), $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_CUBE_MAP), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY), or $(D_INLINECODE GL_TEXTURE_RECTANGLE).
     +     texture = Specifies the texture object name for $(D_INLINECODE glTextureParameter) functions.
     +     pname   = Specifies the symbolic name of a single-valued texture parameter. $(D_INLINECODE pname) can be one of the following: $(D_INLINECODE GL_DEPTH_STENCIL_TEXTURE_MODE), $(D_INLINECODE GL_TEXTURE_BASE_LEVEL), $(D_INLINECODE GL_TEXTURE_COMPARE_FUNC), $(D_INLINECODE GL_TEXTURE_COMPARE_MODE), $(D_INLINECODE GL_TEXTURE_LOD_BIAS), $(D_INLINECODE GL_TEXTURE_MIN_FILTER), $(D_INLINECODE GL_TEXTURE_MAG_FILTER), $(D_INLINECODE GL_TEXTURE_MIN_LOD), $(D_INLINECODE GL_TEXTURE_MAX_LOD), $(D_INLINECODE GL_TEXTURE_MAX_LEVEL), $(D_INLINECODE GL_TEXTURE_SWIZZLE_R), $(D_INLINECODE GL_TEXTURE_SWIZZLE_G), $(D_INLINECODE GL_TEXTURE_SWIZZLE_B), $(D_INLINECODE GL_TEXTURE_SWIZZLE_A), $(D_INLINECODE GL_TEXTURE_WRAP_S), $(D_INLINECODE GL_TEXTURE_WRAP_T), or $(D_INLINECODE GL_TEXTURE_WRAP_R). For the vector commands ( $(D_INLINECODE glTexParameter*v) ), $(D_INLINECODE pname) can also be one of $(D_INLINECODE GL_TEXTURE_BORDER_COLOR) or $(D_INLINECODE GL_TEXTURE_SWIZZLE_RGBA).
     +     param   = For the scalar commands, specifies the value of $(D_INLINECODE pname).
     +     params  = For the vector commands, specifies a pointer to an array where the value or values of $(D_INLINECODE pname) are stored.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2012-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glBindTexture), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glPixelStore), $(D_INLINECODE glSamplerParameter), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexParameterf glTexParameterf;
    alias fn_glTexParameteri = extern(System) void function(GLenum target, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexParameteri glTexParameteri;
    alias fn_glTexStorage1D = extern(System) void function(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width) @system @nogc nothrow;

    /++
     + glTexStorage1D: man4/glTexStorage1D.xml
     + 
     + $(D_INLINECODE glTexStorage1D) and $(D_INLINECODE glTextureStorage1D) specify the storage requirements for all levels of a one-dimensional texture simultaneously. Once a texture is specified with this command, the format and dimensions of all levels become immutable unless it is a proxy texture. The contents of the image may still be modified, however, its storage requirements may not change. Such a texture is referred to as an texture. Calling $(D_INLINECODE glTexStorage1D) is equivalent, assuming no errors are generated, to executing the following pseudo-code:
     + 
     + ---
     + for (i = 0; i &lt; levels; i++) {
     +     glTexImage1D(target, i, internalformat, width, 0, format, type, NULL);
     +     width = max(1, (width / 2));
     + }
     + ---
     +  Calling $(D_INLINECODE glTextureStorage1D) is equivalent to the above pseudo-code, where $(D_INLINECODE target) is the effective target of $(D_INLINECODE texture) and it is as if $(D_INLINECODE texture) were bound to $(D_INLINECODE target) for the purposes of $(D_INLINECODE glTexImage1D). Since no texture data is actually provided, the values used in the pseudo-code for $(D_INLINECODE format) and $(D_INLINECODE type) are irrelevant and may be considered to be any values that are legal for the chosen $(D_INLINECODE internalformat) enumerant. $(D_INLINECODE internalformat) must be one of the sized internal formats given in Table 1 below, one of the sized depth-component formats $(D_INLINECODE GL_DEPTH_COMPONENT32F), $(D_INLINECODE GL_DEPTH_COMPONENT24), or $(D_INLINECODE GL_DEPTH_COMPONENT16), one of the combined depth-stencil formats, $(D_INLINECODE GL_DEPTH32F_STENCIL8), or $(D_INLINECODE GL_DEPTH24_STENCIL8), or the stencil-only format, $(D_INLINECODE GL_STENCIL_INDEX8). Upon success, the value of $(D_INLINECODE GL_TEXTURE_IMMUTABLE_FORMAT) becomes $(D_INLINECODE GL_TRUE). The value of $(D_INLINECODE GL_TEXTURE_IMMUTABLE_FORMAT) may be discovered by calling $(D_INLINECODE glGetTexParameter) with $(D_INLINECODE pname) set to $(D_INLINECODE GL_TEXTURE_IMMUTABLE_FORMAT). No further changes to the dimensions or format of the texture object may be made. Using any command that might alter the dimensions or format of the texture object (such as $(D_INLINECODE glTexImage1D) or another call to $(D_INLINECODE glTexStorage1D) ) will result in the generation of a $(D_INLINECODE GL_INVALID_OPERATION) error, even if it would not, in fact, alter the dimensions or format of the object.<h3> Sized Internal Formats</h3> $(B Sized Internal Format) $(B Base Internal Format) $(B Red Bits) $(B Green Bits) $(B Blue Bits) $(B Alpha Bits) $(B Shared Bits) $(D_INLINECODE GL_R8) $(D_INLINECODE GL_RED) 8 $(D_INLINECODE GL_R8_SNORM) $(D_INLINECODE GL_RED) s8 $(D_INLINECODE GL_R16) $(D_INLINECODE GL_RED) 16 $(D_INLINECODE GL_R16_SNORM) $(D_INLINECODE GL_RED) s16 $(D_INLINECODE GL_RG8) $(D_INLINECODE GL_RG) 8 8 $(D_INLINECODE GL_RG8_SNORM) $(D_INLINECODE GL_RG) s8 s8 $(D_INLINECODE GL_RG16) $(D_INLINECODE GL_RG) 16 16 $(D_INLINECODE GL_RG16_SNORM) $(D_INLINECODE GL_RG) s16 s16 $(D_INLINECODE GL_R3_G3_B2) $(D_INLINECODE GL_RGB) 3 3 2 $(D_INLINECODE GL_RGB4) $(D_INLINECODE GL_RGB) 4 4 4 $(D_INLINECODE GL_RGB5) $(D_INLINECODE GL_RGB) 5 5 5 $(D_INLINECODE GL_RGB8) $(D_INLINECODE GL_RGB) 8 8 8 $(D_INLINECODE GL_RGB8_SNORM) $(D_INLINECODE GL_RGB) s8 s8 s8 $(D_INLINECODE GL_RGB10) $(D_INLINECODE GL_RGB) 10 10 10 $(D_INLINECODE GL_RGB12) $(D_INLINECODE GL_RGB) 12 12 12 $(D_INLINECODE GL_RGB16_SNORM) $(D_INLINECODE GL_RGB) 16 16 16 $(D_INLINECODE GL_RGBA2) $(D_INLINECODE GL_RGB) 2 2 2 2 $(D_INLINECODE GL_RGBA4) $(D_INLINECODE GL_RGB) 4 4 4 4 $(D_INLINECODE GL_RGB5_A1) $(D_INLINECODE GL_RGBA) 5 5 5 1 $(D_INLINECODE GL_RGBA8) $(D_INLINECODE GL_RGBA) 8 8 8 8 $(D_INLINECODE GL_RGBA8_SNORM) $(D_INLINECODE GL_RGBA) s8 s8 s8 s8 $(D_INLINECODE GL_RGB10_A2) $(D_INLINECODE GL_RGBA) 10 10 10 2 $(D_INLINECODE GL_RGB10_A2UI) $(D_INLINECODE GL_RGBA) ui10 ui10 ui10 ui2 $(D_INLINECODE GL_RGBA12) $(D_INLINECODE GL_RGBA) 12 12 12 12 $(D_INLINECODE GL_RGBA16) $(D_INLINECODE GL_RGBA) 16 16 16 16 $(D_INLINECODE GL_SRGB8) $(D_INLINECODE GL_RGB) 8 8 8 $(D_INLINECODE GL_SRGB8_ALPHA8) $(D_INLINECODE GL_RGBA) 8 8 8 8 $(D_INLINECODE GL_R16F) $(D_INLINECODE GL_RED) f16 $(D_INLINECODE GL_RG16F) $(D_INLINECODE GL_RG) f16 f16 $(D_INLINECODE GL_RGB16F) $(D_INLINECODE GL_RGB) f16 f16 f16 $(D_INLINECODE GL_RGBA16F) $(D_INLINECODE GL_RGBA) f16 f16 f16 f16 $(D_INLINECODE GL_R32F) $(D_INLINECODE GL_RED) f32 $(D_INLINECODE GL_RG32F) $(D_INLINECODE GL_RG) f32 f32 $(D_INLINECODE GL_RGB32F) $(D_INLINECODE GL_RGB) f32 f32 f32 $(D_INLINECODE GL_RGBA32F) $(D_INLINECODE GL_RGBA) f32 f32 f32 f32 $(D_INLINECODE GL_R11F_G11F_B10F) $(D_INLINECODE GL_RGB) f11 f11 f10 $(D_INLINECODE GL_RGB9_E5) $(D_INLINECODE GL_RGB) 9 9 9 5 $(D_INLINECODE GL_R8I) $(D_INLINECODE GL_RED) i8 $(D_INLINECODE GL_R8UI) $(D_INLINECODE GL_RED) ui8 $(D_INLINECODE GL_R16I) $(D_INLINECODE GL_RED) i16 $(D_INLINECODE GL_R16UI) $(D_INLINECODE GL_RED) ui16 $(D_INLINECODE GL_R32I) $(D_INLINECODE GL_RED) i32 $(D_INLINECODE GL_R32UI) $(D_INLINECODE GL_RED) ui32 $(D_INLINECODE GL_RG8I) $(D_INLINECODE GL_RG) i8 i8 $(D_INLINECODE GL_RG8UI) $(D_INLINECODE GL_RG) ui8 ui8 $(D_INLINECODE GL_RG16I) $(D_INLINECODE GL_RG) i16 i16 $(D_INLINECODE GL_RG16UI) $(D_INLINECODE GL_RG) ui16 ui16 $(D_INLINECODE GL_RG32I) $(D_INLINECODE GL_RG) i32 i32 $(D_INLINECODE GL_RG32UI) $(D_INLINECODE GL_RG) ui32 ui32 $(D_INLINECODE GL_RGB8I) $(D_INLINECODE GL_RGB) i8 i8 i8 $(D_INLINECODE GL_RGB8UI) $(D_INLINECODE GL_RGB) ui8 ui8 ui8 $(D_INLINECODE GL_RGB16I) $(D_INLINECODE GL_RGB) i16 i16 i16 $(D_INLINECODE GL_RGB16UI) $(D_INLINECODE GL_RGB) ui16 ui16 ui16 $(D_INLINECODE GL_RGB32I) $(D_INLINECODE GL_RGB) i32 i32 i32 $(D_INLINECODE GL_RGB32UI) $(D_INLINECODE GL_RGB) ui32 ui32 ui32 $(D_INLINECODE GL_RGBA8I) $(D_INLINECODE GL_RGBA) i8 i8 i8 i8 $(D_INLINECODE GL_RGBA8UI) $(D_INLINECODE GL_RGBA) ui8 ui8 ui8 ui8 $(D_INLINECODE GL_RGBA16I) $(D_INLINECODE GL_RGBA) i16 i16 i16 i16 $(D_INLINECODE GL_RGBA16UI) $(D_INLINECODE GL_RGBA) ui16 ui16 ui16 ui16 $(D_INLINECODE GL_RGBA32I) $(D_INLINECODE GL_RGBA) i32 i32 i32 i32 $(D_INLINECODE GL_RGBA32UI) $(D_INLINECODE GL_RGBA) ui32 ui32 ui32 ui32
     + 
     + $(D_INLINECODE GL_STENCIL_INDEX8) is accepted for $(D_INLINECODE internalformat) only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     target         = Specifies the target to which the texture object is bound for $(D_INLINECODE glTexStorage1D). Must be one of $(D_INLINECODE GL_TEXTURE_1D) or $(D_INLINECODE GL_PROXY_TEXTURE_1D).
     +     texture        = Specifies the texture object name for $(D_INLINECODE glTextureStorage1D). The effective target of $(D_INLINECODE texture) must be one of the valid non-proxy $(D_INLINECODE target) values above.
     +     levels         = Specify the number of texture levels.
     +     internalformat = Specifies the sized internal format to be used to store texture image data.
     +     width          = Specifies the width of the texture, in texels.
     + 
     + Copyright:
     +     Copyright&copy; 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexStorage2D), $(D_INLINECODE glTexStorage3D).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P2)
    @OpenGL_Extension("GL_ARB_texture_storage")
    fn_glTexStorage1D glTexStorage1D;
    alias fn_glTextureStorage1D = extern(System) void function(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glTextureStorage1D glTextureStorage1D;
    alias fn_glTexStorage2D = extern(System) void function(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;

    /++
     + glTexStorage2D: man4/glTexStorage2D.xml
     + 
     + $(D_INLINECODE glTexStorage2D) and $(D_INLINECODE glTextureStorage2D) specify the storage requirements for all levels of a two-dimensional texture or one-dimensional texture array simultaneously. Once a texture is specified with this command, the format and dimensions of all levels become immutable unless it is a proxy texture. The contents of the image may still be modified, however, its storage requirements may not change. Such a texture is referred to as an texture. The behavior of $(D_INLINECODE glTexStorage2D) depends on the $(D_INLINECODE target) parameter. When $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_PROXY_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_RECTANGLE), $(D_INLINECODE GL_PROXY_TEXTURE_RECTANGLE) or $(D_INLINECODE GL_PROXY_TEXTURE_CUBE_MAP), calling $(D_INLINECODE glTexStorage2D) is equivalent, assuming no errors are generated, to executing the following pseudo-code:
     + 
     + ---
     + for (i = 0; i &lt; levels; i++) {
     +     glTexImage2D(target, i, internalformat, width, height, 0, format, type, NULL);
     +     width = max(1, (width / 2));
     +     height = max(1, (height / 2));
     + }
     + ---
     +  When $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_CUBE_MAP), $(D_INLINECODE glTexStorage2D) is equivalent to:
     + 
     + ---
     + for (i = 0; i &lt; levels; i++) {
     +     for (face in (+X, -X, +Y, -Y, +Z, -Z)) {
     +         glTexImage2D(face, i, internalformat, width, height, 0, format, type, NULL);
     +     }
     +     width = max(1, (width / 2));
     +     height = max(1, (height / 2));
     + }
     + ---
     +  When $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_1D) or $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE glTexStorage2D) is equivalent to:
     + 
     + ---
     + for (i = 0; i &lt; levels; i++) {
     +     glTexImage2D(target, i, internalformat, width, height, 0, format, type, NULL);
     +     width = max(1, (width / 2));
     + }
     + ---
     +  Calling $(D_INLINECODE glTextureStorage2D) is equivalent to the above pseudo-code, where $(D_INLINECODE target) is the effective target of $(D_INLINECODE texture) and it is as if $(D_INLINECODE texture) were bound to $(D_INLINECODE target) for the purposes of $(D_INLINECODE glTexImage2D). Since no texture data is actually provided, the values used in the pseudo-code for $(D_INLINECODE format) and $(D_INLINECODE type) are irrelevant and may be considered to be any values that are legal for the chosen $(D_INLINECODE internalformat) enumerant. $(D_INLINECODE internalformat) must be one of the sized internal formats given in Table 1 below, one of the sized depth-component formats $(D_INLINECODE GL_DEPTH_COMPONENT32F), $(D_INLINECODE GL_DEPTH_COMPONENT24), or $(D_INLINECODE GL_DEPTH_COMPONENT16), one of the combined depth-stencil formats, $(D_INLINECODE GL_DEPTH32F_STENCIL8), or $(D_INLINECODE GL_DEPTH24_STENCIL8), or the stencil-only format, $(D_INLINECODE GL_STENCIL_INDEX8). Upon success, the value of $(D_INLINECODE GL_TEXTURE_IMMUTABLE_FORMAT) becomes $(D_INLINECODE GL_TRUE). The value of $(D_INLINECODE GL_TEXTURE_IMMUTABLE_FORMAT) may be discovered by calling $(D_INLINECODE glGetTexParameter) with $(D_INLINECODE pname) set to $(D_INLINECODE GL_TEXTURE_IMMUTABLE_FORMAT). No further changes to the dimensions or format of the texture object may be made. Using any command that might alter the dimensions or format of the texture object (such as $(D_INLINECODE glTexImage2D) or another call to $(D_INLINECODE glTexStorage2D) ) will result in the generation of a $(D_INLINECODE GL_INVALID_OPERATION) error, even if it would not, in fact, alter the dimensions or format of the object.<h3> Sized Internal Formats</h3> $(B Sized Internal Format) $(B Base Internal Format) $(B Red Bits) $(B Green Bits) $(B Blue Bits) $(B Alpha Bits) $(B Shared Bits) $(D_INLINECODE GL_R8) $(D_INLINECODE GL_RED) 8 $(D_INLINECODE GL_R8_SNORM) $(D_INLINECODE GL_RED) s8 $(D_INLINECODE GL_R16) $(D_INLINECODE GL_RED) 16 $(D_INLINECODE GL_R16_SNORM) $(D_INLINECODE GL_RED) s16 $(D_INLINECODE GL_RG8) $(D_INLINECODE GL_RG) 8 8 $(D_INLINECODE GL_RG8_SNORM) $(D_INLINECODE GL_RG) s8 s8 $(D_INLINECODE GL_RG16) $(D_INLINECODE GL_RG) 16 16 $(D_INLINECODE GL_RG16_SNORM) $(D_INLINECODE GL_RG) s16 s16 $(D_INLINECODE GL_R3_G3_B2) $(D_INLINECODE GL_RGB) 3 3 2 $(D_INLINECODE GL_RGB4) $(D_INLINECODE GL_RGB) 4 4 4 $(D_INLINECODE GL_RGB5) $(D_INLINECODE GL_RGB) 5 5 5 $(D_INLINECODE GL_RGB8) $(D_INLINECODE GL_RGB) 8 8 8 $(D_INLINECODE GL_RGB8_SNORM) $(D_INLINECODE GL_RGB) s8 s8 s8 $(D_INLINECODE GL_RGB10) $(D_INLINECODE GL_RGB) 10 10 10 $(D_INLINECODE GL_RGB12) $(D_INLINECODE GL_RGB) 12 12 12 $(D_INLINECODE GL_RGB16_SNORM) $(D_INLINECODE GL_RGB) 16 16 16 $(D_INLINECODE GL_RGBA2) $(D_INLINECODE GL_RGB) 2 2 2 2 $(D_INLINECODE GL_RGBA4) $(D_INLINECODE GL_RGB) 4 4 4 4 $(D_INLINECODE GL_RGB5_A1) $(D_INLINECODE GL_RGBA) 5 5 5 1 $(D_INLINECODE GL_RGBA8) $(D_INLINECODE GL_RGBA) 8 8 8 8 $(D_INLINECODE GL_RGBA8_SNORM) $(D_INLINECODE GL_RGBA) s8 s8 s8 s8 $(D_INLINECODE GL_RGB10_A2) $(D_INLINECODE GL_RGBA) 10 10 10 2 $(D_INLINECODE GL_RGB10_A2UI) $(D_INLINECODE GL_RGBA) ui10 ui10 ui10 ui2 $(D_INLINECODE GL_RGBA12) $(D_INLINECODE GL_RGBA) 12 12 12 12 $(D_INLINECODE GL_RGBA16) $(D_INLINECODE GL_RGBA) 16 16 16 16 $(D_INLINECODE GL_SRGB8) $(D_INLINECODE GL_RGB) 8 8 8 $(D_INLINECODE GL_SRGB8_ALPHA8) $(D_INLINECODE GL_RGBA) 8 8 8 8 $(D_INLINECODE GL_R16F) $(D_INLINECODE GL_RED) f16 $(D_INLINECODE GL_RG16F) $(D_INLINECODE GL_RG) f16 f16 $(D_INLINECODE GL_RGB16F) $(D_INLINECODE GL_RGB) f16 f16 f16 $(D_INLINECODE GL_RGBA16F) $(D_INLINECODE GL_RGBA) f16 f16 f16 f16 $(D_INLINECODE GL_R32F) $(D_INLINECODE GL_RED) f32 $(D_INLINECODE GL_RG32F) $(D_INLINECODE GL_RG) f32 f32 $(D_INLINECODE GL_RGB32F) $(D_INLINECODE GL_RGB) f32 f32 f32 $(D_INLINECODE GL_RGBA32F) $(D_INLINECODE GL_RGBA) f32 f32 f32 f32 $(D_INLINECODE GL_R11F_G11F_B10F) $(D_INLINECODE GL_RGB) f11 f11 f10 $(D_INLINECODE GL_RGB9_E5) $(D_INLINECODE GL_RGB) 9 9 9 5 $(D_INLINECODE GL_R8I) $(D_INLINECODE GL_RED) i8 $(D_INLINECODE GL_R8UI) $(D_INLINECODE GL_RED) ui8 $(D_INLINECODE GL_R16I) $(D_INLINECODE GL_RED) i16 $(D_INLINECODE GL_R16UI) $(D_INLINECODE GL_RED) ui16 $(D_INLINECODE GL_R32I) $(D_INLINECODE GL_RED) i32 $(D_INLINECODE GL_R32UI) $(D_INLINECODE GL_RED) ui32 $(D_INLINECODE GL_RG8I) $(D_INLINECODE GL_RG) i8 i8 $(D_INLINECODE GL_RG8UI) $(D_INLINECODE GL_RG) ui8 ui8 $(D_INLINECODE GL_RG16I) $(D_INLINECODE GL_RG) i16 i16 $(D_INLINECODE GL_RG16UI) $(D_INLINECODE GL_RG) ui16 ui16 $(D_INLINECODE GL_RG32I) $(D_INLINECODE GL_RG) i32 i32 $(D_INLINECODE GL_RG32UI) $(D_INLINECODE GL_RG) ui32 ui32 $(D_INLINECODE GL_RGB8I) $(D_INLINECODE GL_RGB) i8 i8 i8 $(D_INLINECODE GL_RGB8UI) $(D_INLINECODE GL_RGB) ui8 ui8 ui8 $(D_INLINECODE GL_RGB16I) $(D_INLINECODE GL_RGB) i16 i16 i16 $(D_INLINECODE GL_RGB16UI) $(D_INLINECODE GL_RGB) ui16 ui16 ui16 $(D_INLINECODE GL_RGB32I) $(D_INLINECODE GL_RGB) i32 i32 i32 $(D_INLINECODE GL_RGB32UI) $(D_INLINECODE GL_RGB) ui32 ui32 ui32 $(D_INLINECODE GL_RGBA8I) $(D_INLINECODE GL_RGBA) i8 i8 i8 i8 $(D_INLINECODE GL_RGBA8UI) $(D_INLINECODE GL_RGBA) ui8 ui8 ui8 ui8 $(D_INLINECODE GL_RGBA16I) $(D_INLINECODE GL_RGBA) i16 i16 i16 i16 $(D_INLINECODE GL_RGBA16UI) $(D_INLINECODE GL_RGBA) ui16 ui16 ui16 ui16 $(D_INLINECODE GL_RGBA32I) $(D_INLINECODE GL_RGBA) i32 i32 i32 i32 $(D_INLINECODE GL_RGBA32UI) $(D_INLINECODE GL_RGBA) ui32 ui32 ui32 ui32
     + 
     + $(D_INLINECODE GL_STENCIL_INDEX8) is accepted for $(D_INLINECODE internalformat) only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     target         = Specifies the target to which the texture object is bound for $(D_INLINECODE glTexStorage2D). Must be one of $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_TEXTURE_RECTANGLE), $(D_INLINECODE GL_PROXY_TEXTURE_2D), $(D_INLINECODE GL_PROXY_TEXTURE_1D_ARRAY), $(D_INLINECODE GL_PROXY_TEXTURE_RECTANGLE), or $(D_INLINECODE GL_PROXY_TEXTURE_CUBE_MAP).
     +     texture        = Specifies the texture object name for $(D_INLINECODE glTextureStorage2D). The effective target of $(D_INLINECODE texture) must be one of the valid non-proxy $(D_INLINECODE target) values above.
     +     levels         = Specify the number of texture levels.
     +     internalformat = Specifies the sized internal format to be used to store texture image data.
     +     width          = Specifies the width of the texture, in texels.
     +     height         = Specifies the height of the texture, in texels.
     + 
     + Copyright:
     +     Copyright&copy; 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexStorage1D), $(D_INLINECODE glTexStorage3D).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P2)
    @OpenGL_Extension("GL_ARB_texture_storage")
    fn_glTexStorage2D glTexStorage2D;
    alias fn_glTextureStorage2D = extern(System) void function(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glTextureStorage2D glTextureStorage2D;
    alias fn_glTexStorage2DMultisample = extern(System) void function(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) @system @nogc nothrow;

    /++
     + glTexStorage2DMultisample: man4/glTexStorage2DMultisample.xml
     + 
     + $(D_INLINECODE glTexStorage2DMultisample) and $(D_INLINECODE glTextureStorage2DMultisample) specify the storage requirements for a two-dimensional multisample texture. Once a texture is specified with this command, its format and dimensions become immutable unless it is a proxy texture. The contents of the image may still be modified, however, its storage requirements may not change. Such a texture is referred to as an texture. $(D_INLINECODE samples) specifies the number of samples to be used for the texture and must be greater than zero and less than or equal to the value of $(D_INLINECODE GL_MAX_SAMPLES). $(D_INLINECODE internalformat) must be a color-renderable, depth-renderable, or stencil-renderable format. $(D_INLINECODE width) and $(D_INLINECODE height) specify the width and height, respectively, of the texture. If $(D_INLINECODE fixedsamplelocations) is $(D_INLINECODE GL_TRUE), the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.<h3> Sized Internal Formats</h3> $(B Sized Internal Format) $(B Base Internal Format) $(B Red Bits) $(B Green Bits) $(B Blue Bits) $(B Alpha Bits) $(B Shared Bits) $(D_INLINECODE GL_R8) $(D_INLINECODE GL_RED) 8 $(D_INLINECODE GL_R8_SNORM) $(D_INLINECODE GL_RED) s8 $(D_INLINECODE GL_R16) $(D_INLINECODE GL_RED) 16 $(D_INLINECODE GL_R16_SNORM) $(D_INLINECODE GL_RED) s16 $(D_INLINECODE GL_RG8) $(D_INLINECODE GL_RG) 8 8 $(D_INLINECODE GL_RG8_SNORM) $(D_INLINECODE GL_RG) s8 s8 $(D_INLINECODE GL_RG16) $(D_INLINECODE GL_RG) 16 16 $(D_INLINECODE GL_RG16_SNORM) $(D_INLINECODE GL_RG) s16 s16 $(D_INLINECODE GL_R3_G3_B2) $(D_INLINECODE GL_RGB) 3 3 2 $(D_INLINECODE GL_RGB4) $(D_INLINECODE GL_RGB) 4 4 4 $(D_INLINECODE GL_RGB5) $(D_INLINECODE GL_RGB) 5 5 5 $(D_INLINECODE GL_RGB8) $(D_INLINECODE GL_RGB) 8 8 8 $(D_INLINECODE GL_RGB8_SNORM) $(D_INLINECODE GL_RGB) s8 s8 s8 $(D_INLINECODE GL_RGB10) $(D_INLINECODE GL_RGB) 10 10 10 $(D_INLINECODE GL_RGB12) $(D_INLINECODE GL_RGB) 12 12 12 $(D_INLINECODE GL_RGB16_SNORM) $(D_INLINECODE GL_RGB) 16 16 16 $(D_INLINECODE GL_RGBA2) $(D_INLINECODE GL_RGB) 2 2 2 2 $(D_INLINECODE GL_RGBA4) $(D_INLINECODE GL_RGB) 4 4 4 4 $(D_INLINECODE GL_RGB5_A1) $(D_INLINECODE GL_RGBA) 5 5 5 1 $(D_INLINECODE GL_RGBA8) $(D_INLINECODE GL_RGBA) 8 8 8 8 $(D_INLINECODE GL_RGBA8_SNORM) $(D_INLINECODE GL_RGBA) s8 s8 s8 s8 $(D_INLINECODE GL_RGB10_A2) $(D_INLINECODE GL_RGBA) 10 10 10 2 $(D_INLINECODE GL_RGB10_A2UI) $(D_INLINECODE GL_RGBA) ui10 ui10 ui10 ui2 $(D_INLINECODE GL_RGBA12) $(D_INLINECODE GL_RGBA) 12 12 12 12 $(D_INLINECODE GL_RGBA16) $(D_INLINECODE GL_RGBA) 16 16 16 16 $(D_INLINECODE GL_SRGB8) $(D_INLINECODE GL_RGB) 8 8 8 $(D_INLINECODE GL_SRGB8_ALPHA8) $(D_INLINECODE GL_RGBA) 8 8 8 8 $(D_INLINECODE GL_R16F) $(D_INLINECODE GL_RED) f16 $(D_INLINECODE GL_RG16F) $(D_INLINECODE GL_RG) f16 f16 $(D_INLINECODE GL_RGB16F) $(D_INLINECODE GL_RGB) f16 f16 f16 $(D_INLINECODE GL_RGBA16F) $(D_INLINECODE GL_RGBA) f16 f16 f16 f16 $(D_INLINECODE GL_R32F) $(D_INLINECODE GL_RED) f32 $(D_INLINECODE GL_RG32F) $(D_INLINECODE GL_RG) f32 f32 $(D_INLINECODE GL_RGB32F) $(D_INLINECODE GL_RGB) f32 f32 f32 $(D_INLINECODE GL_RGBA32F) $(D_INLINECODE GL_RGBA) f32 f32 f32 f32 $(D_INLINECODE GL_R11F_G11F_B10F) $(D_INLINECODE GL_RGB) f11 f11 f10 $(D_INLINECODE GL_RGB9_E5) $(D_INLINECODE GL_RGB) 9 9 9 5 $(D_INLINECODE GL_R8I) $(D_INLINECODE GL_RED) i8 $(D_INLINECODE GL_R8UI) $(D_INLINECODE GL_RED) ui8 $(D_INLINECODE GL_R16I) $(D_INLINECODE GL_RED) i16 $(D_INLINECODE GL_R16UI) $(D_INLINECODE GL_RED) ui16 $(D_INLINECODE GL_R32I) $(D_INLINECODE GL_RED) i32 $(D_INLINECODE GL_R32UI) $(D_INLINECODE GL_RED) ui32 $(D_INLINECODE GL_RG8I) $(D_INLINECODE GL_RG) i8 i8 $(D_INLINECODE GL_RG8UI) $(D_INLINECODE GL_RG) ui8 ui8 $(D_INLINECODE GL_RG16I) $(D_INLINECODE GL_RG) i16 i16 $(D_INLINECODE GL_RG16UI) $(D_INLINECODE GL_RG) ui16 ui16 $(D_INLINECODE GL_RG32I) $(D_INLINECODE GL_RG) i32 i32 $(D_INLINECODE GL_RG32UI) $(D_INLINECODE GL_RG) ui32 ui32 $(D_INLINECODE GL_RGB8I) $(D_INLINECODE GL_RGB) i8 i8 i8 $(D_INLINECODE GL_RGB8UI) $(D_INLINECODE GL_RGB) ui8 ui8 ui8 $(D_INLINECODE GL_RGB16I) $(D_INLINECODE GL_RGB) i16 i16 i16 $(D_INLINECODE GL_RGB16UI) $(D_INLINECODE GL_RGB) ui16 ui16 ui16 $(D_INLINECODE GL_RGB32I) $(D_INLINECODE GL_RGB) i32 i32 i32 $(D_INLINECODE GL_RGB32UI) $(D_INLINECODE GL_RGB) ui32 ui32 ui32 $(D_INLINECODE GL_RGBA8I) $(D_INLINECODE GL_RGBA) i8 i8 i8 i8 $(D_INLINECODE GL_RGBA8UI) $(D_INLINECODE GL_RGBA) ui8 ui8 ui8 ui8 $(D_INLINECODE GL_RGBA16I) $(D_INLINECODE GL_RGBA) i16 i16 i16 i16 $(D_INLINECODE GL_RGBA16UI) $(D_INLINECODE GL_RGBA) ui16 ui16 ui16 ui16 $(D_INLINECODE GL_RGBA32I) $(D_INLINECODE GL_RGBA) i32 i32 i32 i32 $(D_INLINECODE GL_RGBA32UI) $(D_INLINECODE GL_RGBA) ui32 ui32 ui32 ui32
     + 
     + Params:
     +     target               = Specifies the target to which the texture object is bound for $(D_INLINECODE glTexStorage2DMultisample). Must be one of $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE) or $(D_INLINECODE GL_PROXY_TEXTURE_2D_MULTISAMPLE).
     +     texture              = Specifies the texture object name for $(D_INLINECODE glTextureStorage2DMultisample). The effective target of $(D_INLINECODE texture) must be one of the valid non-proxy $(D_INLINECODE target) values above.
     +     samples              = Specify the number of samples in the texture.
     +     internalformat       = Specifies the sized internal format to be used to store texture image data.
     +     width                = Specifies the width of the texture, in texels.
     +     height               = Specifies the height of the texture, in texels.
     +     fixedsamplelocations = Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage2DMultisample), $(D_INLINECODE glTexStorage1D), $(D_INLINECODE glTexStorage3D).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_texture_storage_multisample")
    fn_glTexStorage2DMultisample glTexStorage2DMultisample;
    alias fn_glTextureStorage2DMultisample = extern(System) void function(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glTextureStorage2DMultisample glTextureStorage2DMultisample;
    alias fn_glTexStorage3D = extern(System) void function(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) @system @nogc nothrow;

    /++
     + glTexStorage3D: man4/glTexStorage3D.xml
     + 
     + $(D_INLINECODE glTexStorage3D) and $(D_INLINECODE glTextureStorage3D) specify specify the storage requirements for all levels of a three-dimensional, two-dimensional array or cube-map array texture simultaneously. Once a texture is specified with this command, the format and dimensions of all levels become immutable unless it is a proxy texture. The contents of the image may still be modified, however, its storage requirements may not change. Such a texture is referred to as an texture. The behavior of $(D_INLINECODE glTexStorage3D) depends on the $(D_INLINECODE target) parameter. When $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_3D), or $(D_INLINECODE GL_PROXY_TEXTURE_3D), calling $(D_INLINECODE glTexStorage3D) is equivalent, assuming no errors are generated, to executing the following pseudo-code:
     + 
     + ---
     + for (i = 0; i &lt; levels; i++) {
     +     glTexImage3D(target, i, internalformat, width, height, depth, 0, format, type, NULL);
     +     width = max(1, (width / 2));
     +     height = max(1, (height / 2));
     +     depth = max(1, (depth / 2));
     + }
     + ---
     +  When $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_PROXY_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY), or $(D_INLINECODE GL_PROXY_TEXTURE_CUBE_MAP_ARRAY), $(D_INLINECODE glTexStorage3D) is equivalent to:
     + 
     + ---
     + for (i = 0; i &lt; levels; i++) {
     +     glTexImage3D(target, i, internalformat, width, height, depth, 0, format, type, NULL);
     +     width = max(1, (width / 2));
     +     height = max(1, (height / 2));
     + }
     + ---
     +  Calling $(D_INLINECODE glTextureStorage3D) is equivalent to the above pseudo-code, where $(D_INLINECODE target) is the effective target of $(D_INLINECODE texture) and it is as if $(D_INLINECODE texture) were bound to $(D_INLINECODE target) for the purposes of $(D_INLINECODE glTexImage3D). Since no texture data is actually provided, the values used in the pseudo-code for $(D_INLINECODE format) and $(D_INLINECODE type) are irrelevant and may be considered to be any values that are legal for the chosen $(D_INLINECODE internalformat) enumerant. $(D_INLINECODE internalformat) must be one of the sized internal formats given in Table 1 below, one of the sized depth-component formats $(D_INLINECODE GL_DEPTH_COMPONENT32F), $(D_INLINECODE GL_DEPTH_COMPONENT24), or $(D_INLINECODE GL_DEPTH_COMPONENT16), one of the combined depth-stencil formats, $(D_INLINECODE GL_DEPTH32F_STENCIL8), or $(D_INLINECODE GL_DEPTH24_STENCIL8), or the stencil-only format, $(D_INLINECODE GL_STENCIL_INDEX8). Upon success, the value of $(D_INLINECODE GL_TEXTURE_IMMUTABLE_FORMAT) becomes $(D_INLINECODE GL_TRUE). The value of $(D_INLINECODE GL_TEXTURE_IMMUTABLE_FORMAT) may be discovered by calling $(D_INLINECODE glGetTexParameter) with $(D_INLINECODE pname) set to $(D_INLINECODE GL_TEXTURE_IMMUTABLE_FORMAT). No further changes to the dimensions or format of the texture object may be made. Using any command that might alter the dimensions or format of the texture object (such as $(D_INLINECODE glTexImage3D) or another call to $(D_INLINECODE glTexStorage3D) ) will result in the generation of a $(D_INLINECODE GL_INVALID_OPERATION) error, even if it would not, in fact, alter the dimensions or format of the object.<h3> Sized Internal Formats</h3> $(B Sized Internal Format) $(B Base Internal Format) $(B Red Bits) $(B Green Bits) $(B Blue Bits) $(B Alpha Bits) $(B Shared Bits) $(D_INLINECODE GL_R8) $(D_INLINECODE GL_RED) 8 $(D_INLINECODE GL_R8_SNORM) $(D_INLINECODE GL_RED) s8 $(D_INLINECODE GL_R16) $(D_INLINECODE GL_RED) 16 $(D_INLINECODE GL_R16_SNORM) $(D_INLINECODE GL_RED) s16 $(D_INLINECODE GL_RG8) $(D_INLINECODE GL_RG) 8 8 $(D_INLINECODE GL_RG8_SNORM) $(D_INLINECODE GL_RG) s8 s8 $(D_INLINECODE GL_RG16) $(D_INLINECODE GL_RG) 16 16 $(D_INLINECODE GL_RG16_SNORM) $(D_INLINECODE GL_RG) s16 s16 $(D_INLINECODE GL_R3_G3_B2) $(D_INLINECODE GL_RGB) 3 3 2 $(D_INLINECODE GL_RGB4) $(D_INLINECODE GL_RGB) 4 4 4 $(D_INLINECODE GL_RGB5) $(D_INLINECODE GL_RGB) 5 5 5 $(D_INLINECODE GL_RGB8) $(D_INLINECODE GL_RGB) 8 8 8 $(D_INLINECODE GL_RGB8_SNORM) $(D_INLINECODE GL_RGB) s8 s8 s8 $(D_INLINECODE GL_RGB10) $(D_INLINECODE GL_RGB) 10 10 10 $(D_INLINECODE GL_RGB12) $(D_INLINECODE GL_RGB) 12 12 12 $(D_INLINECODE GL_RGB16_SNORM) $(D_INLINECODE GL_RGB) 16 16 16 $(D_INLINECODE GL_RGBA2) $(D_INLINECODE GL_RGB) 2 2 2 2 $(D_INLINECODE GL_RGBA4) $(D_INLINECODE GL_RGB) 4 4 4 4 $(D_INLINECODE GL_RGB5_A1) $(D_INLINECODE GL_RGBA) 5 5 5 1 $(D_INLINECODE GL_RGBA8) $(D_INLINECODE GL_RGBA) 8 8 8 8 $(D_INLINECODE GL_RGBA8_SNORM) $(D_INLINECODE GL_RGBA) s8 s8 s8 s8 $(D_INLINECODE GL_RGB10_A2) $(D_INLINECODE GL_RGBA) 10 10 10 2 $(D_INLINECODE GL_RGB10_A2UI) $(D_INLINECODE GL_RGBA) ui10 ui10 ui10 ui2 $(D_INLINECODE GL_RGBA12) $(D_INLINECODE GL_RGBA) 12 12 12 12 $(D_INLINECODE GL_RGBA16) $(D_INLINECODE GL_RGBA) 16 16 16 16 $(D_INLINECODE GL_SRGB8) $(D_INLINECODE GL_RGB) 8 8 8 $(D_INLINECODE GL_SRGB8_ALPHA8) $(D_INLINECODE GL_RGBA) 8 8 8 8 $(D_INLINECODE GL_R16F) $(D_INLINECODE GL_RED) f16 $(D_INLINECODE GL_RG16F) $(D_INLINECODE GL_RG) f16 f16 $(D_INLINECODE GL_RGB16F) $(D_INLINECODE GL_RGB) f16 f16 f16 $(D_INLINECODE GL_RGBA16F) $(D_INLINECODE GL_RGBA) f16 f16 f16 f16 $(D_INLINECODE GL_R32F) $(D_INLINECODE GL_RED) f32 $(D_INLINECODE GL_RG32F) $(D_INLINECODE GL_RG) f32 f32 $(D_INLINECODE GL_RGB32F) $(D_INLINECODE GL_RGB) f32 f32 f32 $(D_INLINECODE GL_RGBA32F) $(D_INLINECODE GL_RGBA) f32 f32 f32 f32 $(D_INLINECODE GL_R11F_G11F_B10F) $(D_INLINECODE GL_RGB) f11 f11 f10 $(D_INLINECODE GL_RGB9_E5) $(D_INLINECODE GL_RGB) 9 9 9 5 $(D_INLINECODE GL_R8I) $(D_INLINECODE GL_RED) i8 $(D_INLINECODE GL_R8UI) $(D_INLINECODE GL_RED) ui8 $(D_INLINECODE GL_R16I) $(D_INLINECODE GL_RED) i16 $(D_INLINECODE GL_R16UI) $(D_INLINECODE GL_RED) ui16 $(D_INLINECODE GL_R32I) $(D_INLINECODE GL_RED) i32 $(D_INLINECODE GL_R32UI) $(D_INLINECODE GL_RED) ui32 $(D_INLINECODE GL_RG8I) $(D_INLINECODE GL_RG) i8 i8 $(D_INLINECODE GL_RG8UI) $(D_INLINECODE GL_RG) ui8 ui8 $(D_INLINECODE GL_RG16I) $(D_INLINECODE GL_RG) i16 i16 $(D_INLINECODE GL_RG16UI) $(D_INLINECODE GL_RG) ui16 ui16 $(D_INLINECODE GL_RG32I) $(D_INLINECODE GL_RG) i32 i32 $(D_INLINECODE GL_RG32UI) $(D_INLINECODE GL_RG) ui32 ui32 $(D_INLINECODE GL_RGB8I) $(D_INLINECODE GL_RGB) i8 i8 i8 $(D_INLINECODE GL_RGB8UI) $(D_INLINECODE GL_RGB) ui8 ui8 ui8 $(D_INLINECODE GL_RGB16I) $(D_INLINECODE GL_RGB) i16 i16 i16 $(D_INLINECODE GL_RGB16UI) $(D_INLINECODE GL_RGB) ui16 ui16 ui16 $(D_INLINECODE GL_RGB32I) $(D_INLINECODE GL_RGB) i32 i32 i32 $(D_INLINECODE GL_RGB32UI) $(D_INLINECODE GL_RGB) ui32 ui32 ui32 $(D_INLINECODE GL_RGBA8I) $(D_INLINECODE GL_RGBA) i8 i8 i8 i8 $(D_INLINECODE GL_RGBA8UI) $(D_INLINECODE GL_RGBA) ui8 ui8 ui8 ui8 $(D_INLINECODE GL_RGBA16I) $(D_INLINECODE GL_RGBA) i16 i16 i16 i16 $(D_INLINECODE GL_RGBA16UI) $(D_INLINECODE GL_RGBA) ui16 ui16 ui16 ui16 $(D_INLINECODE GL_RGBA32I) $(D_INLINECODE GL_RGBA) i32 i32 i32 i32 $(D_INLINECODE GL_RGBA32UI) $(D_INLINECODE GL_RGBA) ui32 ui32 ui32 ui32
     + 
     + $(D_INLINECODE GL_STENCIL_INDEX8) is accepted for $(D_INLINECODE internalformat) only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     target         = Specifies the target to which the texture object is bound for $(D_INLINECODE glTexStorage3D). Must be one of $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTURE_CUBE_ARRAY), $(D_INLINECODE GL_PROXY_TEXTURE_3D), $(D_INLINECODE GL_PROXY_TEXTURE_2D_ARRAY) or $(D_INLINECODE GL_PROXY_TEXTURE_CUBE_ARRAY).
     +     texture        = Specifies the texture object name for $(D_INLINECODE glTextureStorage3D). The effective target of $(D_INLINECODE texture) must be one of the valid non-proxy $(D_INLINECODE target) values above.
     +     levels         = Specify the number of texture levels.
     +     internalformat = Specifies the sized internal format to be used to store texture image data.
     +     width          = Specifies the width of the texture, in texels.
     +     height         = Specifies the height of the texture, in texels.
     +     depth          = Specifies the depth of the texture, in texels.
     + 
     + Copyright:
     +     Copyright&copy; 2011-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexStorage1D), $(D_INLINECODE glTexStorage2D).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P2)
    @OpenGL_Extension("GL_ARB_texture_storage")
    fn_glTexStorage3D glTexStorage3D;
    alias fn_glTextureStorage3D = extern(System) void function(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glTextureStorage3D glTextureStorage3D;
    alias fn_glTexStorage3DMultisample = extern(System) void function(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) @system @nogc nothrow;

    /++
     + glTexStorage3DMultisample: man4/glTexStorage3DMultisample.xml
     + 
     + $(D_INLINECODE glTexStorage3DMultisample) and $(D_INLINECODE glTextureStorage3DMultisample) specify the storage requirements for a two-dimensional multisample array texture. Once a texture is specified with this command, its format and dimensions become immutable unless it is a proxy texture. The contents of the image may still be modified, however, its storage requirements may not change. Such a texture is referred to as an texture. $(D_INLINECODE samples) specifies the number of samples to be used for the texture and must be greater than zero and less than or equal to the value of $(D_INLINECODE GL_MAX_SAMPLES). $(D_INLINECODE internalformat) must be a color-renderable, depth-renderable, or stencil-renderable format. $(D_INLINECODE width) and $(D_INLINECODE height) specify the width and height, respectively, of the texture and $(D_INLINECODE depth) specifies the depth (or the number of layers) of the texture. If $(D_INLINECODE fixedsamplelocations) is $(D_INLINECODE GL_TRUE), the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.<h3> Sized Internal Formats</h3> $(B Sized Internal Format) $(B Base Internal Format) $(B Red Bits) $(B Green Bits) $(B Blue Bits) $(B Alpha Bits) $(B Shared Bits) $(D_INLINECODE GL_R8) $(D_INLINECODE GL_RED) 8 $(D_INLINECODE GL_R8_SNORM) $(D_INLINECODE GL_RED) s8 $(D_INLINECODE GL_R16) $(D_INLINECODE GL_RED) 16 $(D_INLINECODE GL_R16_SNORM) $(D_INLINECODE GL_RED) s16 $(D_INLINECODE GL_RG8) $(D_INLINECODE GL_RG) 8 8 $(D_INLINECODE GL_RG8_SNORM) $(D_INLINECODE GL_RG) s8 s8 $(D_INLINECODE GL_RG16) $(D_INLINECODE GL_RG) 16 16 $(D_INLINECODE GL_RG16_SNORM) $(D_INLINECODE GL_RG) s16 s16 $(D_INLINECODE GL_R3_G3_B2) $(D_INLINECODE GL_RGB) 3 3 2 $(D_INLINECODE GL_RGB4) $(D_INLINECODE GL_RGB) 4 4 4 $(D_INLINECODE GL_RGB5) $(D_INLINECODE GL_RGB) 5 5 5 $(D_INLINECODE GL_RGB8) $(D_INLINECODE GL_RGB) 8 8 8 $(D_INLINECODE GL_RGB8_SNORM) $(D_INLINECODE GL_RGB) s8 s8 s8 $(D_INLINECODE GL_RGB10) $(D_INLINECODE GL_RGB) 10 10 10 $(D_INLINECODE GL_RGB12) $(D_INLINECODE GL_RGB) 12 12 12 $(D_INLINECODE GL_RGB16_SNORM) $(D_INLINECODE GL_RGB) 16 16 16 $(D_INLINECODE GL_RGBA2) $(D_INLINECODE GL_RGB) 2 2 2 2 $(D_INLINECODE GL_RGBA4) $(D_INLINECODE GL_RGB) 4 4 4 4 $(D_INLINECODE GL_RGB5_A1) $(D_INLINECODE GL_RGBA) 5 5 5 1 $(D_INLINECODE GL_RGBA8) $(D_INLINECODE GL_RGBA) 8 8 8 8 $(D_INLINECODE GL_RGBA8_SNORM) $(D_INLINECODE GL_RGBA) s8 s8 s8 s8 $(D_INLINECODE GL_RGB10_A2) $(D_INLINECODE GL_RGBA) 10 10 10 2 $(D_INLINECODE GL_RGB10_A2UI) $(D_INLINECODE GL_RGBA) ui10 ui10 ui10 ui2 $(D_INLINECODE GL_RGBA12) $(D_INLINECODE GL_RGBA) 12 12 12 12 $(D_INLINECODE GL_RGBA16) $(D_INLINECODE GL_RGBA) 16 16 16 16 $(D_INLINECODE GL_SRGB8) $(D_INLINECODE GL_RGB) 8 8 8 $(D_INLINECODE GL_SRGB8_ALPHA8) $(D_INLINECODE GL_RGBA) 8 8 8 8 $(D_INLINECODE GL_R16F) $(D_INLINECODE GL_RED) f16 $(D_INLINECODE GL_RG16F) $(D_INLINECODE GL_RG) f16 f16 $(D_INLINECODE GL_RGB16F) $(D_INLINECODE GL_RGB) f16 f16 f16 $(D_INLINECODE GL_RGBA16F) $(D_INLINECODE GL_RGBA) f16 f16 f16 f16 $(D_INLINECODE GL_R32F) $(D_INLINECODE GL_RED) f32 $(D_INLINECODE GL_RG32F) $(D_INLINECODE GL_RG) f32 f32 $(D_INLINECODE GL_RGB32F) $(D_INLINECODE GL_RGB) f32 f32 f32 $(D_INLINECODE GL_RGBA32F) $(D_INLINECODE GL_RGBA) f32 f32 f32 f32 $(D_INLINECODE GL_R11F_G11F_B10F) $(D_INLINECODE GL_RGB) f11 f11 f10 $(D_INLINECODE GL_RGB9_E5) $(D_INLINECODE GL_RGB) 9 9 9 5 $(D_INLINECODE GL_R8I) $(D_INLINECODE GL_RED) i8 $(D_INLINECODE GL_R8UI) $(D_INLINECODE GL_RED) ui8 $(D_INLINECODE GL_R16I) $(D_INLINECODE GL_RED) i16 $(D_INLINECODE GL_R16UI) $(D_INLINECODE GL_RED) ui16 $(D_INLINECODE GL_R32I) $(D_INLINECODE GL_RED) i32 $(D_INLINECODE GL_R32UI) $(D_INLINECODE GL_RED) ui32 $(D_INLINECODE GL_RG8I) $(D_INLINECODE GL_RG) i8 i8 $(D_INLINECODE GL_RG8UI) $(D_INLINECODE GL_RG) ui8 ui8 $(D_INLINECODE GL_RG16I) $(D_INLINECODE GL_RG) i16 i16 $(D_INLINECODE GL_RG16UI) $(D_INLINECODE GL_RG) ui16 ui16 $(D_INLINECODE GL_RG32I) $(D_INLINECODE GL_RG) i32 i32 $(D_INLINECODE GL_RG32UI) $(D_INLINECODE GL_RG) ui32 ui32 $(D_INLINECODE GL_RGB8I) $(D_INLINECODE GL_RGB) i8 i8 i8 $(D_INLINECODE GL_RGB8UI) $(D_INLINECODE GL_RGB) ui8 ui8 ui8 $(D_INLINECODE GL_RGB16I) $(D_INLINECODE GL_RGB) i16 i16 i16 $(D_INLINECODE GL_RGB16UI) $(D_INLINECODE GL_RGB) ui16 ui16 ui16 $(D_INLINECODE GL_RGB32I) $(D_INLINECODE GL_RGB) i32 i32 i32 $(D_INLINECODE GL_RGB32UI) $(D_INLINECODE GL_RGB) ui32 ui32 ui32 $(D_INLINECODE GL_RGBA8I) $(D_INLINECODE GL_RGBA) i8 i8 i8 i8 $(D_INLINECODE GL_RGBA8UI) $(D_INLINECODE GL_RGBA) ui8 ui8 ui8 ui8 $(D_INLINECODE GL_RGBA16I) $(D_INLINECODE GL_RGBA) i16 i16 i16 i16 $(D_INLINECODE GL_RGBA16UI) $(D_INLINECODE GL_RGBA) ui16 ui16 ui16 ui16 $(D_INLINECODE GL_RGBA32I) $(D_INLINECODE GL_RGBA) i32 i32 i32 i32 $(D_INLINECODE GL_RGBA32UI) $(D_INLINECODE GL_RGBA) ui32 ui32 ui32 ui32
     + 
     + Params:
     +     target               = Specifies the target to which the texture object is bound for $(D_INLINECODE glTexStorage3DMultisample). Must be one of $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY) or $(D_INLINECODE GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY).
     +     texture              = Specifies the texture object name for $(D_INLINECODE glTextureStorage3DMultisample). The effective target of $(D_INLINECODE texture) must be one of the valid non-proxy $(D_INLINECODE target) values above.
     +     samples              = Specify the number of samples in the texture.
     +     internalformat       = Specifies the sized internal format to be used to store texture image data.
     +     width                = Specifies the width of the texture, in texels.
     +     height               = Specifies the height of the texture, in texels.
     +     depth                = Specifies the depth of the texture, in layers.
     +     fixedsamplelocations = Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexImage3DMultisample), $(D_INLINECODE glTexStorage1D), $(D_INLINECODE glTexStorage2DMultisample), $(D_INLINECODE glTexStorage3D).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_texture_storage_multisample")
    fn_glTexStorage3DMultisample glTexStorage3DMultisample;
    alias fn_glTextureStorage3DMultisample = extern(System) void function(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glTextureStorage3DMultisample glTextureStorage3DMultisample;
    alias fn_glTexSubImage1D = extern(System) void function(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const( GLvoid*) pixels) @system @nogc nothrow;

    /++
     + glTexSubImage1D: man4/glTexSubImage1D.xml
     + 
     + Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled. To enable or disable one-dimensional texturing, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_TEXTURE_1D). $(D_INLINECODE glTexSubImage1D) and $(D_INLINECODE glTextureSubImage1D) redefine a contiguous subregion of an existing one-dimensional texture image. The texels referenced by $(D_INLINECODE pixels) replace the portion of the existing texture array with x indices $(D_INLINECODE xoffset) and xoffset + width - 1, inclusive. This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with width of 0, but such a specification has no effect. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is specified, $(D_INLINECODE pixels) is treated as a byte offset into the buffer object's data store.
     + 
     + $(D_INLINECODE glPixelStore) modes affect texture images. $(D_INLINECODE glTexSubImage1D) and $(D_INLINECODE glTextureSubImage1D) specify a one-dimensional subtexture for the current texture unit, specified with $(D_INLINECODE glActiveTexture). $(D_INLINECODE GL_STENCIL_INDEX) is accepted for $(D_INLINECODE format) only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     target  = Specifies the target to which the texture is bound for $(D_INLINECODE glTexSubImage1D). Must be $(D_INLINECODE GL_TEXTURE_1D).
     +     texture = Specifies the texture object name for $(D_INLINECODE glTextureSubImage1D). The effective target of $(D_INLINECODE texture) must be one of the valid $(D_INLINECODE target) values above.
     +     level   = Specifies the level-of-detail number. Level 0 is the base image level. Level is the th mipmap reduction image.
     +     xoffset = Specifies a texel offset in the x direction within the texture array.
     +     width   = Specifies the width of the texture subimage.
     +     format  = Specifies the format of the pixel data. The following symbolic values are accepted: $(D_INLINECODE GL_RED), $(D_INLINECODE GL_RG), $(D_INLINECODE GL_RGB), $(D_INLINECODE GL_BGR), $(D_INLINECODE GL_RGBA), $(D_INLINECODE GL_DEPTH_COMPONENT), and $(D_INLINECODE GL_STENCIL_INDEX).
     +     type    = Specifies the data type of the pixel data. The following symbolic values are accepted: $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), $(D_INLINECODE GL_SHORT), $(D_INLINECODE GL_UNSIGNED_INT), $(D_INLINECODE GL_INT), $(D_INLINECODE GL_FLOAT), $(D_INLINECODE GL_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GL_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GL_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GL_UNSIGNED_INT_10_10_10_2), and $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV).
     +     pixels  = Specifies a pointer to the image data in memory.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glPixelStore), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexParameter), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    fn_glTexSubImage1D glTexSubImage1D;
    alias fn_glTextureSubImage1D = extern(System) void function(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const( void*) pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glTextureSubImage1D glTextureSubImage1D;
    alias fn_glTexSubImage2D = extern(System) void function(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const( GLvoid*) pixels) @system @nogc nothrow;

    /++
     + glTexSubImage2D: man4/glTexSubImage2D.xml
     + 
     + Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled. $(D_INLINECODE glTexSubImage2D) and $(D_INLINECODE glTextureSubImage2D) redefine a contiguous subregion of an existing two-dimensional or one-dimensional array texture image. The texels referenced by $(D_INLINECODE pixels) replace the portion of the existing texture array with x indices $(D_INLINECODE xoffset) and xoffset + width - 1, inclusive, and y indices $(D_INLINECODE yoffset) and yoffset + height - 1, inclusive. This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with zero width or height, but such a specification has no effect. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is specified, $(D_INLINECODE pixels) is treated as a byte offset into the buffer object's data store.
     + 
     + $(D_INLINECODE glPixelStore) modes affect texture images. $(D_INLINECODE glTexSubImage2D) and $(D_INLINECODE glTextureSubImage3D) specify a two-dimensional subtexture for the current texture unit, specified with $(D_INLINECODE glActiveTexture). $(D_INLINECODE GL_STENCIL_INDEX) is accepted for $(D_INLINECODE format) only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     target  = Specifies the target to which the texture is bound for $(D_INLINECODE glTexSubImage2D). Must be $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_X), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Y), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_POSITIVE_Z), $(D_INLINECODE GL_TEXTURE_CUBE_MAP_NEGATIVE_Z), or $(D_INLINECODE GL_TEXTURE_1D_ARRAY).
     +     texture = Specifies the texture object name for $(D_INLINECODE glTextureSubImage2D). The effective target of $(D_INLINECODE texture) must be one of the valid $(D_INLINECODE target) values above.
     +     level   = Specifies the level-of-detail number. Level 0 is the base image level. Level is the th mipmap reduction image.
     +     xoffset = Specifies a texel offset in the x direction within the texture array.
     +     yoffset = Specifies a texel offset in the y direction within the texture array.
     +     width   = Specifies the width of the texture subimage.
     +     height  = Specifies the height of the texture subimage.
     +     format  = Specifies the format of the pixel data. The following symbolic values are accepted: $(D_INLINECODE GL_RED), $(D_INLINECODE GL_RG), $(D_INLINECODE GL_RGB), $(D_INLINECODE GL_BGR), $(D_INLINECODE GL_RGBA), $(D_INLINECODE GL_BGRA), $(D_INLINECODE GL_DEPTH_COMPONENT), and $(D_INLINECODE GL_STENCIL_INDEX).
     +     type    = Specifies the data type of the pixel data. The following symbolic values are accepted: $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), $(D_INLINECODE GL_SHORT), $(D_INLINECODE GL_UNSIGNED_INT), $(D_INLINECODE GL_INT), $(D_INLINECODE GL_FLOAT), $(D_INLINECODE GL_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GL_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GL_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GL_UNSIGNED_INT_10_10_10_2), and $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV).
     +     pixels  = Specifies a pointer to the image data in memory.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glPixelStore), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    fn_glTexSubImage2D glTexSubImage2D;
    alias fn_glTextureSubImage2D = extern(System) void function(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const( void*) pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glTextureSubImage2D glTextureSubImage2D;
    alias fn_glTexSubImage3D = extern(System) void function(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const( GLvoid*) pixels) @system @nogc nothrow;

    /++
     + glTexSubImage3D: man4/glTexSubImage3D.xml
     + 
     + Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled. $(D_INLINECODE glTexSubImage3D) and $(D_INLINECODE glTextureSubImage3D) redefine a contiguous subregion of an existing three-dimensional or two-dimensioanl array texture image. The texels referenced by $(D_INLINECODE pixels) replace the portion of the existing texture array with x indices $(D_INLINECODE xoffset) and xoffset + width - 1, inclusive, y indices $(D_INLINECODE yoffset) and yoffset + height - 1, inclusive, and z indices $(D_INLINECODE zoffset) and zoffset + depth - 1, inclusive. For three-dimensional textures, the z index refers to the third dimension. For two-dimensional array textures, the z index refers to the slice index. This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with zero width, height, or depth but such a specification has no effect. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture image is specified, $(D_INLINECODE pixels) is treated as a byte offset into the buffer object's data store.
     + 
     + The $(D_INLINECODE glPixelStore) modes affect texture images. $(D_INLINECODE glTexSubImage3D) and $(D_INLINECODE glTextureSubImage3D) specify a three-dimensional or two-dimensional array subtexture for the current texture unit, specified with $(D_INLINECODE glActiveTexture). $(D_INLINECODE GL_STENCIL_INDEX) is accepted for $(D_INLINECODE format) only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     target  = Specifies the target to which the texture is bound for $(D_INLINECODE glTexSubImage3D). Must be $(D_INLINECODE GL_TEXTURE_3D) or $(D_INLINECODE GL_TEXTURE_2D_ARRAY).
     +     texture = Specifies the texture object name for $(D_INLINECODE glTextureSubImage3D). The effective target of $(D_INLINECODE texture) must be one of the valid $(D_INLINECODE target) values above.
     +     level   = Specifies the level-of-detail number. Level 0 is the base image level. Level is the th mipmap reduction image.
     +     xoffset = Specifies a texel offset in the x direction within the texture array.
     +     yoffset = Specifies a texel offset in the y direction within the texture array.
     +     zoffset = Specifies a texel offset in the z direction within the texture array.
     +     width   = Specifies the width of the texture subimage.
     +     height  = Specifies the height of the texture subimage.
     +     depth   = Specifies the depth of the texture subimage.
     +     format  = Specifies the format of the pixel data. The following symbolic values are accepted: $(D_INLINECODE GL_RED), $(D_INLINECODE GL_RG), $(D_INLINECODE GL_RGB), $(D_INLINECODE GL_BGR), $(D_INLINECODE GL_RGBA), $(D_INLINECODE GL_DEPTH_COMPONENT), and $(D_INLINECODE GL_STENCIL_INDEX).
     +     type    = Specifies the data type of the pixel data. The following symbolic values are accepted: $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), $(D_INLINECODE GL_SHORT), $(D_INLINECODE GL_UNSIGNED_INT), $(D_INLINECODE GL_INT), $(D_INLINECODE GL_FLOAT), $(D_INLINECODE GL_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GL_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GL_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GL_UNSIGNED_INT_10_10_10_2), and $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV).
     +     pixels  = Specifies a pointer to the image data in memory.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glPixelStore), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P2)
    fn_glTexSubImage3D glTexSubImage3D;
    alias fn_glTextureSubImage3D = extern(System) void function(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const( void*) pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glTextureSubImage3D glTextureSubImage3D;
    alias fn_glTextureBarrier = extern(System) void function() @system @nogc nothrow;

    /++
     + glTextureBarrier: man4/glTextureBarrier.xml
     + 
     + The values of rendered fragments are undefined when a shader stage fetches texels and the same texels are written via fragment shader outputs, even if the reads and writes are not in the same drawing command. To safely read the result of a written texel via a texel fetch in a subsequent drawing command, call $(D_INLINECODE glTextureBarrier) between the two drawing commands to guarantee that writes have completed and caches have been invalidated before subsequent drawing commands are executed.
     + 
     + The situation described above is referred to as a and is discussed in more detail in section 9.3 of the OpenGL 4.5 Specification.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glMemoryBarrier)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_texture_barrier")
    fn_glTextureBarrier glTextureBarrier;
    alias fn_glTextureView = extern(System) void function(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers) @system @nogc nothrow;

    /++
     + glTextureView: man4/glTextureView.xml
     + 
     + $(D_INLINECODE glTextureView) initializes a texture object as an alias, or view of another texture object, sharing some or all of the parent texture's data store with the initialized texture. $(D_INLINECODE texture) specifies a name previously reserved by a successful call to $(D_INLINECODE glGenTextures) but that has not yet been bound or given a target. $(D_INLINECODE target) specifies the target for the newly initialized texture and must be compatible with the target of the parent texture, given in $(D_INLINECODE origtexture) as specified in the following table: Original Target Compatible New Targets $(D_INLINECODE GL_TEXTURE_1D) $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY) $(D_INLINECODE GL_TEXTURE_2D) $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_2D_ARRAY) $(D_INLINECODE GL_TEXTURE_3D) $(D_INLINECODE GL_TEXTURE_3D) $(D_INLINECODE GL_TEXTURE_CUBE_MAP) $(D_INLINECODE GL_TEXTURE_CUBE_MAP), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTUER_CUBE_MAP_ARRAY) $(D_INLINECODE GL_TEXTURE_RECTANGLE) $(D_INLINECODE GL_TEXTURE_RECTANGLE) $(D_INLINECODE GL_TEXTURE_BUFFER) $(D_INLINECODE GL_TEXTURE_1D_ARRAY) $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_1D_ARRAY) $(D_INLINECODE GL_TEXTURE_2D_ARRAY) $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_2D_ARRAY) $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY) $(D_INLINECODE GL_TEXTURE_CUBE_MAP), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_2D_ARRAY), $(D_INLINECODE GL_TEXTUER_CUBE_MAP_ARRAY) $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE) $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE), $(D_INLINECODE GL_TEXTURE_MULTISAMPLE_ARRAY) $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE_ARRAY) $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE), $(D_INLINECODE GL_TEXTURE_MULTISAMPLE_ARRAY) The value of $(D_INLINECODE GL_TEXTURE_IMMUTABLE_FORMAT) for $(D_INLINECODE origtexture) must be $(D_INLINECODE GL_TRUE). After initialization, $(D_INLINECODE texture) inherits the data store of the parent texture, $(D_INLINECODE origtexture) and is usable as a normal texture object with target $(D_INLINECODE target). Data in the shared store is reinterpreted with the new internal format specified by $(D_INLINECODE internalformat). $(D_INLINECODE internalformat) must be compatible with the internal format of the parent texture as specified in the following table: Class Internal Formats 128-bit $(D_INLINECODE GL_RGBA32F), $(D_INLINECODE GL_RGBA32UI), $(D_INLINECODE GL_RGBA32I) 96-bit $(D_INLINECODE GL_RGB32F), $(D_INLINECODE GL_RGB32UI), $(D_INLINECODE GL_RGB32I) 64-bit $(D_INLINECODE GL_RGBA16F), $(D_INLINECODE GL_RG32F), $(D_INLINECODE GL_RGBA16UI), $(D_INLINECODE GL_RG32UI), $(D_INLINECODE GL_RGBA16I), $(D_INLINECODE GL_RG32I), $(D_INLINECODE GL_RGBA16), $(D_INLINECODE GL_RGBA16_SNORM) 48-bit $(D_INLINECODE GL_RGB16), $(D_INLINECODE GL_RGB16_SNORM), $(D_INLINECODE GL_RGB16F), $(D_INLINECODE GL_RGB16UI), $(D_INLINECODE GL_RGB16I) 32-bit $(D_INLINECODE GL_RG16F), $(D_INLINECODE GL_R11F_G11F_B10F), $(D_INLINECODE GL_R32F), $(D_INLINECODE GL_RGB10_A2UI), $(D_INLINECODE GL_RGBA8UI), $(D_INLINECODE GL_RG16UI), $(D_INLINECODE GL_R32UI), $(D_INLINECODE GL_RGBA8I), $(D_INLINECODE GL_RG16I), $(D_INLINECODE GL_R32I), $(D_INLINECODE GL_RGB10_A2), $(D_INLINECODE GL_RGBA8), $(D_INLINECODE GL_RG16), $(D_INLINECODE GL_RGBA8_SNORM), $(D_INLINECODE GL_RG16_SNORM), $(D_INLINECODE GL_SRGB8_ALPHA8), $(D_INLINECODE GL_RGB9_E5) 24-bit $(D_INLINECODE GL_RGB8), $(D_INLINECODE GL_RGB8_SNORM), $(D_INLINECODE GL_SRGB8), $(D_INLINECODE GL_RGB8UI), $(D_INLINECODE GL_RGB8I) 16-bit $(D_INLINECODE GL_R16F), $(D_INLINECODE GL_RG8UI), $(D_INLINECODE GL_R16UI), $(D_INLINECODE GL_RG8I), $(D_INLINECODE GL_R16I), $(D_INLINECODE GL_RG8), $(D_INLINECODE GL_R16), $(D_INLINECODE GL_RG8_SNORM), $(D_INLINECODE GL_R16_SNORM) 8-bit $(D_INLINECODE GL_R8UI), $(D_INLINECODE GL_R8I), $(D_INLINECODE GL_R8), $(D_INLINECODE GL_R8_SNORM) $(D_INLINECODE GL_RGTC1_RED) $(D_INLINECODE GL_COMPRESSED_RED_RGTC1), $(D_INLINECODE GL_COMPRESSED_SIGNED_RED_RGTC1) $(D_INLINECODE GL_RGTC2_RG) $(D_INLINECODE GL_COMPRESSED_RG_RGTC2), $(D_INLINECODE GL_COMPRESSED_SIGNED_RG_RGTC2) $(D_INLINECODE GL_BPTC_UNORM) $(D_INLINECODE GL_COMPRESSED_RGBA_BPTC_UNORM), $(D_INLINECODE GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM) $(D_INLINECODE GL_BPTC_FLOAT) $(D_INLINECODE GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT), $(D_INLINECODE GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT) If the original texture is an array or has multiple mipmap levels, the parameters $(D_INLINECODE minlayer), $(D_INLINECODE numlayers), $(D_INLINECODE minlevel), and $(D_INLINECODE numlevels) control which of those slices and levels are considered part of the texture. The $(D_INLINECODE minlevel) and $(D_INLINECODE minlayer) parameters are relative to the view of the original texture. If $(D_INLINECODE numlayers) or $(D_INLINECODE numlevels) extend beyond the original texture, they are clamped to the max extent of the original texture. If the new texture's target is $(D_INLINECODE GL_TEXTURE_CUBE_MAP), the clamped $(D_INLINECODE numlayers) must be equal to 6. If the new texture's target is $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY), then $(D_INLINECODE numlayers) counts layer-faces rather than layers, and the clamped $(D_INLINECODE numlayers) must be a multiple of 6. If the new texture's target is $(D_INLINECODE GL_TEXTURE_CUBE_MAP) or $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY), the width and height of the original texture's levels must be equal. When the original texture's target is $(D_INLINECODE GL_TEXTURE_CUBE_MAP), the layer parameters are interpreted in the same order as if it were a $(D_INLINECODE GL_TEXTURE_CUBE_MAP_ARRAY) with 6 layer-faces. If $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_1D), $(D_INLINECODE GL_TEXTURE_2D), $(D_INLINECODE GL_TEXTURE_3D), $(D_INLINECODE GL_TEXTURE_RECTANGLE), or $(D_INLINECODE GL_TEXTURE_2D_MULTISAMPLE), $(D_INLINECODE numlayers) must equal 1. The dimensions of the original texture must be less than or equal to the maximum supported dimensions of the new target. For example, if the original texture has a $(D_INLINECODE GL_TEXTURE_2D_ARRAY) target and its width is greater than $(D_INLINECODE GL_MAX_CUBE_MAP_TEXTURE_SIZE), an error will be generated if $(D_INLINECODE glTextureView) is called to create a $(D_INLINECODE GL_TEXTURE_CUBE_MAP) view. Texture commands that take a $(D_INLINECODE level) or $(D_INLINECODE layer) parameter, such as $(D_INLINECODE glTexSubImage2D), interpret that parameter to be relative to the view of the texture. i.e. the mipmap level of the data store that would be updated via $(D_INLINECODE glTexSubImage2D) would be the sum of $(D_INLINECODE level) and the value of $(D_INLINECODE GL_TEXTURE_VIEW_MIN_LEVEL).
     + 
     + Params:
     +     texture        = Specifies the texture object to be initialized as a view.
     +     target         = Specifies the target to be used for the newly initialized texture.
     +     origtexture    = Specifies the name of a texture object of which to make a view.
     +     internalFormat = Specifies the internal format for the newly created view.
     +     minlevel       = Specifies lowest level of detail of the view.
     +     numlevels      = Specifies the number of levels of detail to include in the view.
     +     minlayer       = Specifies the index of the first layer to include in the view.
     +     numlayers      = Specifies the number of layers to include in the view.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glTexStorage1D), $(D_INLINECODE glTexStorage2D), $(D_INLINECODE glTexStorage3D), $(D_INLINECODE glGetTexParameter).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_texture_view")
    fn_glTextureView glTextureView;
    alias fn_glTransformFeedbackBufferBase = extern(System) void function(GLuint xfb, GLuint index, GLuint buffer) @system @nogc nothrow;

    /++
     + glTransformFeedbackBufferBase: man4/glTransformFeedbackBufferBase.xml
     + 
     + $(D_INLINECODE glTransformFeedbackBufferBase) binds the buffer object $(D_INLINECODE buffer) to the binding point at index $(D_INLINECODE index) of the transform feedback object $(D_INLINECODE xfb).
     + 
     + Calling $(D_INLINECODE glTransformFeedbackBufferBase) is equivalent to calling $(D_INLINECODE glTransformFeedbackBufferRange) with $(D_INLINECODE offset) zero and $(D_INLINECODE size) equal to the size of $(D_INLINECODE buffer).
     + 
     + Params:
     +     xfb    = Name of the transform feedback buffer object.
     +     index  = Index of the binding point within $(D_INLINECODE xfb).
     +     buffer = Name of the buffer object to bind to the specified binding point.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBufferRange), $(D_INLINECODE glBindBufferBase), $(D_INLINECODE glTransformFeedbackBufferRange).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glTransformFeedbackBufferBase glTransformFeedbackBufferBase;
    alias fn_glTransformFeedbackBufferRange = extern(System) void function(GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizei size) @system @nogc nothrow;

    /++
     + glTransformFeedbackBufferRange: man4/glTransformFeedbackBufferRange.xml
     + 
     + $(D_INLINECODE glTransformFeedbackBufferRange) binds a range of the buffer object $(D_INLINECODE buffer) represented by $(D_INLINECODE offset) and $(D_INLINECODE size) to the binding point at index $(D_INLINECODE index) of the transform feedback object $(D_INLINECODE xfb). $(D_INLINECODE offset) specifies the offset in basic machine units into the buffer object $(D_INLINECODE buffer) and $(D_INLINECODE size) specifies the amount of data that can be read from the buffer object while used as an indexed target.
     + 
     + Params:
     +     xfb    = Name of the transform feedback buffer object.
     +     index  = Index of the binding point within $(D_INLINECODE xfb).
     +     buffer = Name of the buffer object to bind to the specified binding point.
     +     offset = The starting offset in basic machine units into the buffer object.
     +     size   = The amount of data in basic machine units that can be read from or written to the buffer object while used as an indexed target.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBufferRange), $(D_INLINECODE glBindBufferBase), $(D_INLINECODE glTransformFeedbackBufferBase).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glTransformFeedbackBufferRange glTransformFeedbackBufferRange;
    alias fn_glTransformFeedbackVaryings = extern(System) void function(GLuint program, GLsizei count, const( char**) varyings, GLenum bufferMode) @system @nogc nothrow;

    /++
     + glTransformFeedbackVaryings: man4/glTransformFeedbackVaryings.xml
     + 
     + The names of the vertex or geometry shader outputs to be recorded in transform feedback mode are specified using $(D_INLINECODE glTransformFeedbackVaryings). When a geometry shader is active, transform feedback records the values of selected geometry shader output variables from the emitted vertices. Otherwise, the values of the selected vertex shader outputs are recorded. The state set by $(D_INLINECODE glTranformFeedbackVaryings) is stored and takes effect next time $(D_INLINECODE glLinkProgram) is called on $(D_INLINECODE program). When $(D_INLINECODE glLinkProgram) is called, $(D_INLINECODE program) is linked so that the values of the specified varying variables for the vertices of each primitive generated by the GL are written to a single buffer object if $(D_INLINECODE bufferMode) is $(D_INLINECODE GL_INTERLEAVED_ATTRIBS) or multiple buffer objects if $(D_INLINECODE bufferMode) is $(D_INLINECODE GL_SEPARATE_ATTRIBS). In addition to the errors generated by $(D_INLINECODE glTransformFeedbackVaryings), the program $(D_INLINECODE program) will fail to link if: $(OL $(LI The count specified by $(D_INLINECODE glTransformFeedbackVaryings) is non-zero, but the program object has no vertex or geometry shader.) $(LI Any variable name specified in the $(D_INLINECODE varyings) array is not declared as an output in the vertex shader (or the geometry shader, if active).) $(LI Any two entries in the $(D_INLINECODE varyings) array specify the same varying variable.) $(LI The total number of components to capture in any varying variable in $(D_INLINECODE varyings) is greater than the constant $(D_INLINECODE GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS) and the buffer mode is $(D_INLINECODE GL_SEPARATE_ATTRIBS).) $(LI The total number of components to capture is greater than the constant $(D_INLINECODE GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS) and the buffer mode is $(D_INLINECODE GL_INTERLEAVED_ATTRIBS).))
     + 
     + $(D_INLINECODE glGetTransformFeedbackVarying) is available only if the GL version is 3.0 or greater.
     + 
     + Params:
     +     program    = The name of the target program object.
     +     count      = The number of varying variables used for transform feedback.
     +     varyings   = An array of $(D_INLINECODE count) zero-terminated strings specifying the names of the varying variables to use for transform feedback.
     +     bufferMode = Identifies the mode used to capture the varying variables when transform feedback is active. $(D_INLINECODE bufferMode) must be $(D_INLINECODE GL_INTERLEAVED_ATTRIBS) or $(D_INLINECODE GL_SEPARATE_ATTRIBS).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBeginTransformFeedback), $(D_INLINECODE glEndTransformFeedback), $(D_INLINECODE glGetTransformFeedbackVarying)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glTransformFeedbackVaryings glTransformFeedbackVaryings;
    alias fn_glUniform1f = extern(System) void function(GLint location, GLfloat v0) @system @nogc nothrow;

    /++
     + glUniform: man4/glUniform.xml
     + 
     + $(D_INLINECODE glUniform) modifies the value of a uniform variable or a uniform variable array. The location of the uniform variable to be modified is specified by $(D_INLINECODE location), which should be a value returned by $(D_INLINECODE glGetUniformLocation). $(D_INLINECODE glUniform) operates on the program object that was made part of current state by calling $(D_INLINECODE glUseProgram). The commands $(D_INLINECODE glUniform{1|2|3|4}{f|i|ui}) are used to change the value of the uniform variable specified by $(D_INLINECODE location) using the values passed as arguments. The number specified in the command should match the number of components in the data type of the specified uniform variable (e.g., $(D_INLINECODE 1) for $(D_INLINECODE float), $(D_INLINECODE int), $(D_INLINECODE unsigned int), $(D_INLINECODE bool); $(D_INLINECODE 2) for $(D_INLINECODE vec2), $(D_INLINECODE ivec2), $(D_INLINECODE uvec2), $(D_INLINECODE bvec2), etc.). The suffix $(D_INLINECODE f) indicates that floating-point values are being passed; the suffix $(D_INLINECODE i) indicates that integer values are being passed; the suffix $(D_INLINECODE ui) indicates that unsigned integer values are being passed, and this type should also match the data type of the specified uniform variable. The $(D_INLINECODE i) variants of this function should be used to provide values for uniform variables defined as $(D_INLINECODE int), $(D_INLINECODE ivec2), $(D_INLINECODE ivec3), $(D_INLINECODE ivec4), or arrays of these. The $(D_INLINECODE ui) variants of this function should be used to provide values for uniform variables defined as $(D_INLINECODE unsigned int), $(D_INLINECODE uvec2), $(D_INLINECODE uvec3), $(D_INLINECODE uvec4), or arrays of these. The $(D_INLINECODE f) variants should be used to provide values for uniform variables of type $(D_INLINECODE float), $(D_INLINECODE vec2), $(D_INLINECODE vec3), $(D_INLINECODE vec4), or arrays of these. Either the $(D_INLINECODE i), $(D_INLINECODE ui) or $(D_INLINECODE f) variants may be used to provide values for uniform variables of type $(D_INLINECODE bool), $(D_INLINECODE bvec2), $(D_INLINECODE bvec3), $(D_INLINECODE bvec4), or arrays of these. The uniform variable will be set to $(D_INLINECODE false) if the input value is 0 or 0.0f, and it will be set to $(D_INLINECODE true) otherwise. All active uniform variables defined in a program object are initialized to 0 when the program object is linked successfully. They retain the values assigned to them by a call to $(D_INLINECODE glUniform) until the next successful link operation occurs on the program object, when they are once again initialized to 0. The commands $(D_INLINECODE glUniform{1|2|3|4}{f|i|ui}v) can be used to modify a single uniform variable or a uniform variable array. These commands pass a count and a pointer to the values to be loaded into a uniform variable or a uniform variable array. A count of 1 should be used if modifying the value of a single uniform variable, and a count of 1 or greater can be used to modify an entire array or part of an array. When loading elements starting at an arbitrary position in a uniform variable array, elements + - 1 in the array will be replaced with the new values. If $(D_INLINECODE m) + $(D_INLINECODE n) - 1 is larger than the size of the uniform variable array, values for all array elements beyond the end of the array will be ignored. The number specified in the name of the command indicates the number of components for each element in $(D_INLINECODE value), and it should match the number of components in the data type of the specified uniform variable (e.g., $(D_INLINECODE 1) for float, int, bool; $(D_INLINECODE 2) for vec2, ivec2, bvec2, etc.). The data type specified in the name of the command must match the data type for the specified uniform variable as described previously for $(D_INLINECODE glUniform{1|2|3|4}{f|i|ui}). For uniform variable arrays, each element of the array is considered to be of the type indicated in the name of the command (e.g., $(D_INLINECODE glUniform3f) or $(D_INLINECODE glUniform3fv) can be used to load a uniform variable array of type vec3). The number of elements of the uniform variable array to be modified is specified by $(D_INLINECODE count) The commands $(D_INLINECODE glUniformMatrix{2|3|4|2x3|3x2|2x4|4x2|3x4|4x3}fv) are used to modify a matrix or an array of matrices. The numbers in the command name are interpreted as the dimensionality of the matrix. The number $(D_INLINECODE 2) indicates a 2 &#215; 2 matrix (i.e., 4 values), the number $(D_INLINECODE 3) indicates a 3 &#215; 3 matrix (i.e., 9 values), and the number $(D_INLINECODE 4) indicates a 4 &#215; 4 matrix (i.e., 16 values). Non-square matrix dimensionality is explicit, with the first number representing the number of columns and the second number representing the number of rows.  For example, $(D_INLINECODE 2x4) indicates a 2 &#215; 4 matrix with 2 columns and 4 rows (i.e., 8 values). If $(D_INLINECODE transpose) is $(D_INLINECODE GL_FALSE), each matrix is assumed to be supplied in column major order. If $(D_INLINECODE transpose) is $(D_INLINECODE GL_TRUE), each matrix is assumed to be supplied in row major order. The $(D_INLINECODE count) argument indicates the number of matrices to be passed. A count of 1 should be used if modifying the value of a single matrix, and a count greater than 1 can be used to modify an array of matrices.
     + 
     + $(D_INLINECODE glUniform1i) and $(D_INLINECODE glUniform1iv) are the only two functions that may be used to load uniform variables defined as sampler types. Loading samplers with any other function will result in a $(D_INLINECODE GL_INVALID_OPERATION) error. If $(D_INLINECODE count) is greater than 1 and the indicated uniform variable is not an array, a $(D_INLINECODE GL_INVALID_OPERATION) error is generated and the specified uniform variable will remain unchanged. Other than the preceding exceptions, if the type and size of the uniform variable as defined in the shader do not match the type and size specified in the name of the command used to load its value, a $(D_INLINECODE GL_INVALID_OPERATION) error will be generated and the specified uniform variable will remain unchanged. If $(D_INLINECODE location) is a value other than -1 and it does not represent a valid uniform variable location in the current program object, an error will be generated, and no changes will be made to the uniform variable storage of the current program object. If $(D_INLINECODE location) is equal to -1, the data passed in will be silently ignored and the specified uniform variable will not be changed.
     + 
     + Params:
     +     location       = Specifies the location of the uniform variable to be modified.
     +     count          = For the vector ( $(D_INLINECODE glUniform*v) ) commands, specifies the number of elements that are to be modified. This should be 1 if the targeted uniform variable is not an array, and 1 or more if it is an array. For the matrix ( $(D_INLINECODE glUniformMatrix*) ) commands, specifies the number of matrices that are to be modified. This should be 1 if the targeted uniform variable is not an array of matrices, and 1 or more if it is an array of matrices.
     +     transpose      = For the matrix commands, specifies whether to transpose the matrix as the values are loaded into the uniform variable.
     +     v0, v1, v2, v3 = For the scalar commands, specifies the new values to be used for the specified uniform variable.
     +     value          = For the vector and matrix commands, specifies a pointer to an array of $(D_INLINECODE count) values that will be used to update the specified uniform variable.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glLinkProgram), $(D_INLINECODE glUseProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glUniform1f glUniform1f;
    alias fn_glUniform2f = extern(System) void function(GLint location, GLfloat v0, GLfloat v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glUniform2f glUniform2f;
    alias fn_glUniform3f = extern(System) void function(GLint location, GLfloat v0, GLfloat v1, GLfloat v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glUniform3f glUniform3f;
    alias fn_glUniform4f = extern(System) void function(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glUniform4f glUniform4f;
    alias fn_glUniform1i = extern(System) void function(GLint location, GLint v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glUniform1i glUniform1i;
    alias fn_glUniform2i = extern(System) void function(GLint location, GLint v0, GLint v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glUniform2i glUniform2i;
    alias fn_glUniform3i = extern(System) void function(GLint location, GLint v0, GLint v1, GLint v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glUniform3i glUniform3i;
    alias fn_glUniform4i = extern(System) void function(GLint location, GLint v0, GLint v1, GLint v2, GLint v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glUniform4i glUniform4i;
    alias fn_glUniform1ui = extern(System) void function(GLint location, GLuint v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glUniform1ui glUniform1ui;
    alias fn_glUniform2ui = extern(System) void function(GLint location, GLuint v0, GLuint v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glUniform2ui glUniform2ui;
    alias fn_glUniform3ui = extern(System) void function(GLint location, GLuint v0, GLuint v1, GLuint v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glUniform3ui glUniform3ui;
    alias fn_glUniform4ui = extern(System) void function(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glUniform4ui glUniform4ui;
    alias fn_glUniform1fv = extern(System) void function(GLint location, GLsizei count, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glUniform1fv glUniform1fv;
    alias fn_glUniform2fv = extern(System) void function(GLint location, GLsizei count, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glUniform2fv glUniform2fv;
    alias fn_glUniform3fv = extern(System) void function(GLint location, GLsizei count, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glUniform3fv glUniform3fv;
    alias fn_glUniform4fv = extern(System) void function(GLint location, GLsizei count, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glUniform4fv glUniform4fv;
    alias fn_glUniform1iv = extern(System) void function(GLint location, GLsizei count, const( GLint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glUniform1iv glUniform1iv;
    alias fn_glUniform2iv = extern(System) void function(GLint location, GLsizei count, const( GLint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glUniform2iv glUniform2iv;
    alias fn_glUniform3iv = extern(System) void function(GLint location, GLsizei count, const( GLint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glUniform3iv glUniform3iv;
    alias fn_glUniform4iv = extern(System) void function(GLint location, GLsizei count, const( GLint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glUniform4iv glUniform4iv;
    alias fn_glUniform1uiv = extern(System) void function(GLint location, GLsizei count, const( GLuint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glUniform1uiv glUniform1uiv;
    alias fn_glUniform2uiv = extern(System) void function(GLint location, GLsizei count, const( GLuint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glUniform2uiv glUniform2uiv;
    alias fn_glUniform3uiv = extern(System) void function(GLint location, GLsizei count, const( GLuint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glUniform3uiv glUniform3uiv;
    alias fn_glUniform4uiv = extern(System) void function(GLint location, GLsizei count, const( GLuint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glUniform4uiv glUniform4uiv;
    alias fn_glUniformMatrix2fv = extern(System) void function(GLint location, GLsizei count, GLboolean transpose, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glUniformMatrix2fv glUniformMatrix2fv;
    alias fn_glUniformMatrix3fv = extern(System) void function(GLint location, GLsizei count, GLboolean transpose, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glUniformMatrix3fv glUniformMatrix3fv;
    alias fn_glUniformMatrix4fv = extern(System) void function(GLint location, GLsizei count, GLboolean transpose, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glUniformMatrix4fv glUniformMatrix4fv;
    alias fn_glUniformMatrix2x3fv = extern(System) void function(GLint location, GLsizei count, GLboolean transpose, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P1)
    fn_glUniformMatrix2x3fv glUniformMatrix2x3fv;
    alias fn_glUniformMatrix3x2fv = extern(System) void function(GLint location, GLsizei count, GLboolean transpose, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P1)
    fn_glUniformMatrix3x2fv glUniformMatrix3x2fv;
    alias fn_glUniformMatrix2x4fv = extern(System) void function(GLint location, GLsizei count, GLboolean transpose, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P1)
    fn_glUniformMatrix2x4fv glUniformMatrix2x4fv;
    alias fn_glUniformMatrix4x2fv = extern(System) void function(GLint location, GLsizei count, GLboolean transpose, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P1)
    fn_glUniformMatrix4x2fv glUniformMatrix4x2fv;
    alias fn_glUniformMatrix3x4fv = extern(System) void function(GLint location, GLsizei count, GLboolean transpose, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P1)
    fn_glUniformMatrix3x4fv glUniformMatrix3x4fv;
    alias fn_glUniformMatrix4x3fv = extern(System) void function(GLint location, GLsizei count, GLboolean transpose, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P1)
    fn_glUniformMatrix4x3fv glUniformMatrix4x3fv;
    alias fn_glUniformBlockBinding = extern(System) void function(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding) @system @nogc nothrow;

    /++
     + glUniformBlockBinding: man4/glUniformBlockBinding.xml
     + 
     + Binding points for active uniform blocks are assigned using $(D_INLINECODE glUniformBlockBinding). Each of a program's active uniform blocks has a corresponding uniform buffer binding point. $(D_INLINECODE program) is the name of a program object for which the command $(D_INLINECODE glLinkProgram) has been issued in the past. If successful, $(D_INLINECODE glUniformBlockBinding) specifies that $(D_INLINECODE program) will use the data store of the buffer object bound to the binding point $(D_INLINECODE uniformBlockBinding) to extract the values of the uniforms in the uniform block identified by $(D_INLINECODE uniformBlockIndex). When a program object is linked or re-linked, the uniform buffer object binding point assigned to each of its active uniform blocks is reset to zero.
     + 
     + $(D_INLINECODE glUniformBlockBinding) is available only if the GL version is 3.1 or greater.
     + 
     + Params:
     +     program             = The name of a program object containing the active uniform block whose binding to assign.
     +     uniformBlockIndex   = The index of the active uniform block within $(D_INLINECODE program) whose binding to assign.
     +     uniformBlockBinding = Specifies the binding point to which to bind the uniform block with index $(D_INLINECODE uniformBlockIndex) within $(D_INLINECODE program).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glLinkProgram), $(D_INLINECODE glBindBufferBase), $(D_INLINECODE glBindBufferRange), $(D_INLINECODE glGetActiveUniformBlock)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P1)
    @OpenGL_Extension("GL_ARB_uniform_buffer_object")
    fn_glUniformBlockBinding glUniformBlockBinding;
    alias fn_glUniformSubroutinesuiv = extern(System) void function(GLenum shadertype, GLsizei count, const( GLuint*) indices) @system @nogc nothrow;

    /++
     + glUniformSubroutines: man4/glUniformSubroutines.xml
     + 
     + $(D_INLINECODE glUniformSubroutines) loads all active subroutine uniforms for shader stage $(D_INLINECODE shadertype) of the current program with subroutine indices from $(D_INLINECODE indices), storing $(D_INLINECODE indices[i]) into the uniform at location $(D_INLINECODE i). $(D_INLINECODE count) must be equal to the value of $(D_INLINECODE GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS) for the program currently in use at shader stage $(D_INLINECODE shadertype). Furthermore, all values in $(D_INLINECODE indices) must be less than the value of $(D_INLINECODE GL_ACTIVE_SUBROUTINES) for the shader stage.
     + 
     + Params:
     +     shadertype = Specifies the shader stage from which to query for subroutine uniform index. $(D_INLINECODE shadertype) must be one of $(D_INLINECODE GL_VERTEX_SHADER), $(D_INLINECODE GL_TESS_CONTROL_SHADER), $(D_INLINECODE GL_TESS_EVALUATION_SHADER), $(D_INLINECODE GL_GEOMETRY_SHADER) or $(D_INLINECODE GL_FRAGMENT_SHADER).
     +     count      = Specifies the number of uniform indices stored in $(D_INLINECODE indices).
     +     indices    = Specifies the address of an array holding the indices to load into the shader subroutine variables.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetProgram), $(D_INLINECODE glGetActiveSubroutineUniform), $(D_INLINECODE glGetActiveSubroutineUniformName), $(D_INLINECODE glGetProgramStage)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_shader_subroutine")
    fn_glUniformSubroutinesuiv glUniformSubroutinesuiv;
    alias fn_glUnmapBuffer = extern(System) GLboolean function(GLenum target) @system @nogc nothrow;

    /++
     + glUnmapBuffer: man4/glUnmapBuffer.xml
     + 
     + $(D_INLINECODE glUnmapBuffer) and $(D_INLINECODE glUnmapNamedBuffer) unmap (release) any mapping of a specified buffer object into the client's address space (see $(D_INLINECODE glMapBufferRange) and $(D_INLINECODE glMapBuffer) ). If a mapping is not unmapped before the corresponding buffer object's data store is used by the GL, an error will be generated by any GL command that attempts to dereference the buffer object's data store, unless the buffer was successfully mapped with $(D_INLINECODE GL_MAP_PERSISTENT_BIT) (see $(D_INLINECODE glMapBufferRange) ). When a data store is unmapped, the mapped pointer becomes invalid. $(D_INLINECODE glUnmapBuffer) returns $(D_INLINECODE GL_TRUE) unless the data store contents have become corrupt during the time the data store was mapped. This can occur for system-specific reasons that affect the availability of graphics memory, such as screen mode changes. In such situations, $(D_INLINECODE GL_FALSE) is returned and the data store contents are undefined. An application must detect this rare condition and reinitialize the data store. A buffer object's mapped data store is automatically unmapped when the buffer object is deleted or its data store is recreated with $(D_INLINECODE glBufferData) ).
     + 
     + If an error is generated, $(D_INLINECODE glUnmapBuffer) returns $(D_INLINECODE GL_FALSE). The $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) target is accepted only if the GL version is 4.2 or greater. The $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) and $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) targets are available only if the GL version is 4.3 or greater. The $(D_INLINECODE GL_QUERY_BUFFER) target is available only if the GL version is 4.4 or greater.
     + 
     + Params:
     +     target = Specifies the target to which the buffer object is bound for $(D_INLINECODE glUnmapBuffer), which must be one of the buffer binding targets in the following table: $(B Buffer Binding Target) $(B Purpose) $(D_INLINECODE GL_ARRAY_BUFFER) Vertex attributes $(D_INLINECODE GL_ATOMIC_COUNTER_BUFFER) Atomic counter storage $(D_INLINECODE GL_COPY_READ_BUFFER) Buffer copy source $(D_INLINECODE GL_COPY_WRITE_BUFFER) Buffer copy destination $(D_INLINECODE GL_DISPATCH_INDIRECT_BUFFER) Indirect compute dispatch commands $(D_INLINECODE GL_DRAW_INDIRECT_BUFFER) Indirect command arguments $(D_INLINECODE GL_ELEMENT_ARRAY_BUFFER) Vertex array indices $(D_INLINECODE GL_PIXEL_PACK_BUFFER) Pixel read target $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) Texture data source $(D_INLINECODE GL_QUERY_BUFFER) Query result buffer $(D_INLINECODE GL_SHADER_STORAGE_BUFFER) Read-write storage for shaders $(D_INLINECODE GL_TEXTURE_BUFFER) Texture data buffer $(D_INLINECODE GL_TRANSFORM_FEEDBACK_BUFFER) Transform feedback buffer $(D_INLINECODE GL_UNIFORM_BUFFER) Uniform block storage
     +     buffer = Specifies the name of the buffer object for $(D_INLINECODE glUnmapNamedBuffer).
     + 
     + Copyright:
     +     Copyright&copy; 2005 Addison-Wesley. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBufferData), $(D_INLINECODE glDeleteBuffers), $(D_INLINECODE glMapBuffer), $(D_INLINECODE glMapBufferRange)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    fn_glUnmapBuffer glUnmapBuffer;
    alias fn_glUnmapNamedBuffer = extern(System) GLboolean function(GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glUnmapNamedBuffer glUnmapNamedBuffer;
    alias fn_glUseProgram = extern(System) void function(GLuint program) @system @nogc nothrow;

    /++
     + glUseProgram: man4/glUseProgram.xml
     + 
     + $(D_INLINECODE glUseProgram) installs the program object specified by $(D_INLINECODE program) as part of current rendering state. One or more executables are created in a program object by successfully attaching shader objects to it with $(D_INLINECODE glAttachShader), successfully compiling the shader objects with $(D_INLINECODE glCompileShader), and successfully linking the program object with $(D_INLINECODE glLinkProgram). A program object will contain an executable that will run on the vertex processor if it contains one or more shader objects of type $(D_INLINECODE GL_VERTEX_SHADER) that have been successfully compiled and linked. A program object will contain an executable that will run on the geometry processor if it contains one or more shader objects of type $(D_INLINECODE GL_GEOMETRY_SHADER) that have been successfully compiled and linked. Similarly, a program object will contain an executable that will run on the fragment processor if it contains one or more shader objects of type $(D_INLINECODE GL_FRAGMENT_SHADER) that have been successfully compiled and linked. While a program object is in use, applications are free to modify attached shader objects, compile attached shader objects, attach additional shader objects, and detach or delete shader objects. None of these operations will affect the executables that are part of the current state. However, relinking the program object that is currently in use will install the program object as part of the current rendering state if the link operation was successful (see $(D_INLINECODE glLinkProgram) ). If the program object currently in use is relinked unsuccessfully, its link status will be set to $(D_INLINECODE GL_FALSE), but the executables and associated state will remain part of the current state until a subsequent call to $(D_INLINECODE glUseProgram) removes it from use. After it is removed from use, it cannot be made part of current state until it has been successfully relinked. If $(D_INLINECODE program) is zero, then the current rendering state refers to an program object and the results of shader execution are undefined. However, this is not an error. If $(D_INLINECODE program) does not contain shader objects of type $(D_INLINECODE GL_FRAGMENT_SHADER), an executable will be installed on the vertex, and possibly geometry processors, but the results of fragment shader execution will be undefined.
     + 
     + Like buffer and texture objects, the name space for program objects may be shared across a set of contexts, as long as the server sides of the contexts share the same address space. If the name space is shared across contexts, any attached objects and the data associated with those attached objects are shared as well. Applications are responsible for providing the synchronization across API calls when objects are accessed from different execution threads.
     + 
     + Params:
     +     program = Specifies the handle of the program object whose executables are to be used as part of current rendering state.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAttachShader), $(D_INLINECODE glBindAttribLocation), $(D_INLINECODE glCompileShader), $(D_INLINECODE glCreateProgram), $(D_INLINECODE glDeleteProgram), $(D_INLINECODE glDetachShader), $(D_INLINECODE glLinkProgram), $(D_INLINECODE glUniform), $(D_INLINECODE glValidateProgram), $(D_INLINECODE glVertexAttrib)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glUseProgram glUseProgram;
    alias fn_glUseProgramStages = extern(System) void function(GLuint pipeline, GLbitfield stages, GLuint program) @system @nogc nothrow;

    /++
     + glUseProgramStages: man4/glUseProgramStages.xml
     + 
     + $(D_INLINECODE glUseProgramStages) binds executables from a program object associated with a specified set of shader stages to the program pipeline object given by $(D_INLINECODE pipeline). $(D_INLINECODE pipeline) specifies the program pipeline object to which to bind the executables. $(D_INLINECODE stages) contains a logical combination of bits indicating the shader stages to use within $(D_INLINECODE program) with the program pipeline object $(D_INLINECODE pipeline). $(D_INLINECODE stages) must be a logical combination of $(D_INLINECODE GL_VERTEX_SHADER_BIT), $(D_INLINECODE GL_TESS_CONTROL_SHADER_BIT), $(D_INLINECODE GL_TESS_EVALUATION_SHADER_BIT), $(D_INLINECODE GL_GEOMETRY_SHADER_BIT), $(D_INLINECODE GL_FRAGMENT_SHADER_BIT) and $(D_INLINECODE GL_COMPUTE_SHADER_BIT). Additionally, the special value $(D_INLINECODE GL_ALL_SHADER_BITS) may be specified to indicate that all executables contained in $(D_INLINECODE program) should be installed in $(D_INLINECODE pipeline). If $(D_INLINECODE program) refers to a program object with a valid shader attached for an indicated shader stage, $(D_INLINECODE glUseProgramStages) installs the executable code for that stage in the indicated program pipeline object $(D_INLINECODE pipeline). If $(D_INLINECODE program) is zero, or refers to a program object with no valid shader executable for a given stage, it is as if the pipeline object has no programmable stage configured for the indicated shader stages. If $(D_INLINECODE stages) contains bits other than those listed above, and is not equal to $(D_INLINECODE GL_ALL_SHADER_BITS), an error is generated.
     + 
     + The $(D_INLINECODE GL_COMPUTE_SHADER_BIT) bit is available only if the GL version is 4.3 or greater.
     + 
     + Params:
     +     pipeline = Specifies the program pipeline object to which to bind stages from $(D_INLINECODE program).
     +     stages   = Specifies a set of program stages to bind to the program pipeline object.
     +     program  = Specifies the program object containing the shader executables to use in $(D_INLINECODE pipeline).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenProgramPipelines), $(D_INLINECODE glDeleteProgramPipelines), $(D_INLINECODE glIsProgramPipeline)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glUseProgramStages glUseProgramStages;
    alias fn_glValidateProgram = extern(System) void function(GLuint program) @system @nogc nothrow;

    /++
     + glValidateProgram: man4/glValidateProgram.xml
     + 
     + $(D_INLINECODE glValidateProgram) checks to see whether the executables contained in $(D_INLINECODE program) can execute given the current OpenGL state. The information generated by the validation process will be stored in $(D_INLINECODE program) 's information log. The validation information may consist of an empty string, or it may be a string containing information about how the current program object interacts with the rest of current OpenGL state. This provides a way for OpenGL implementers to convey more information about why the current program is inefficient, suboptimal, failing to execute, and so on. The status of the validation operation will be stored as part of the program object's state. This value will be set to $(D_INLINECODE GL_TRUE) if the validation succeeded, and $(D_INLINECODE GL_FALSE) otherwise. It can be queried by calling $(D_INLINECODE glGetProgram) with arguments $(D_INLINECODE program) and $(D_INLINECODE GL_VALIDATE_STATUS). If validation is successful, $(D_INLINECODE program) is guaranteed to execute given the current state. Otherwise, $(D_INLINECODE program) is guaranteed to not execute. This function is typically useful only during application development. The informational string stored in the information log is completely implementation dependent; therefore, an application should not expect different OpenGL implementations to produce identical information strings.
     + 
     + This function mimics the validation operation that OpenGL implementations must perform when rendering commands are issued while programmable shaders are part of current state. The error $(D_INLINECODE GL_INVALID_OPERATION) will be generated by any command that triggers the rendering of geometry if: $(OL $(LI any two active samplers in the current program object are of different types, but refer to the same texture image unit,) $(LI the number of active samplers in the program exceeds the maximum number of texture image units allowed.)) It may be difficult or cause a performance degradation for applications to catch these errors when rendering commands are issued. Therefore, applications are advised to make calls to $(D_INLINECODE glValidateProgram) to detect these issues during application development.
     + 
     + Params:
     +     program = Specifies the handle of the program object to be validated.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glLinkProgram), $(D_INLINECODE glUseProgram)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glValidateProgram glValidateProgram;
    alias fn_glValidateProgramPipeline = extern(System) void function(GLuint pipeline) @system @nogc nothrow;

    /++
     + glValidateProgramPipeline: man4/glValidateProgramPipeline.xml
     + 
     + $(D_INLINECODE glValidateProgramPipeline) instructs the implementation to validate the shader executables contained in $(D_INLINECODE pipeline) against the current GL state. The implementation may use this as an opportunity to perform any internal shader modifications that may be required to ensure correct operation of the installed shaders given the current GL state. After a program pipeline has been validated, its validation status is set to $(D_INLINECODE GL_TRUE). The validation status of a program pipeline object may be queried by calling $(D_INLINECODE glGetProgramPipeline) with parameter $(D_INLINECODE GL_VALIDATE_STATUS). If $(D_INLINECODE pipeline) is a name previously returned from a call to $(D_INLINECODE glGenProgramPipelines) but that has not yet been bound by a call to $(D_INLINECODE glBindProgramPipeline), a new program pipeline object is created with name $(D_INLINECODE pipeline) and the default state vector.
     + 
     + Params:
     +     pipeline = Specifies the name of a program pipeline object to validate.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGenProgramPipelines), $(D_INLINECODE glBindProgramPipeline), $(D_INLINECODE glDeleteProgramPipelines)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glValidateProgramPipeline glValidateProgramPipeline;
    alias fn_glVertexAttribBinding = extern(System) void function(GLuint attribindex, GLuint bindingindex) @system @nogc nothrow;

    /++
     + glVertexArrayAttribBinding: man4/glVertexAttribBinding.xml
     + 
     + $(D_INLINECODE glVertexAttribBinding) and $(D_INLINECODE glVertexArrayAttribBinding) establishes an association between the generic vertex attribute of a vertex array object whose index is given by $(D_INLINECODE attribindex), and a vertex buffer binding whose index is given by $(D_INLINECODE bindingindex). For $(D_INLINECODE glVertexAttribBinding), the vertex array object affected is that currently bound. For $(D_INLINECODE glVertexArrayAttribBinding), $(D_INLINECODE vaobj) is the name of the vertex array object. $(D_INLINECODE attribindex) must be less than the value of $(D_INLINECODE GL_MAX_VERTEX_ATTRIBS) and $(D_INLINECODE bindingindex) must be less than the value of $(D_INLINECODE GL_MAX_VERTEX_ATTRIB_BINDINGS).
     + 
     + Params:
     +     vaobj        = Specifies the name of the vertex array object for $(D_INLINECODE glVertexArrayAttribBinding).
     +     attribindex  = The index of the attribute to associate with a vertex buffer binding.
     +     bindingindex = The index of the vertex buffer binding with which to associate the generic vertex attribute.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindVertexBuffer), $(D_INLINECODE glVertexAttribFormat), $(D_INLINECODE glVertexBindingDivisor), $(D_INLINECODE glVertexAttribPointer).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_vertex_attrib_binding")
    fn_glVertexAttribBinding glVertexAttribBinding;
    alias fn_glVertexArrayAttribBinding = extern(System) void function(GLuint vaobj, GLuint attribindex, GLuint bindingindex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glVertexArrayAttribBinding glVertexArrayAttribBinding;
    alias fn_glVertexAttribFormat = extern(System) void function(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset) @system @nogc nothrow;

    /++
     + glVertexArrayAttribFormat: man4/glVertexAttribFormat.xml
     + 
     + $(D_INLINECODE glVertexAttribFormat), $(D_INLINECODE glVertexAttribIFormat) and $(D_INLINECODE glVertexAttribLFormat), as well as $(D_INLINECODE glVertexArrayAttribFormat), $(D_INLINECODE glVertexArrayAttribIFormat) and $(D_INLINECODE glVertexArrayAttribLFormat) specify the organization of data in vertex arrays. The first three calls operate on the bound vertex array object, whereas the last three ones modify the state of a vertex array object with ID $(D_INLINECODE vaobj). $(D_INLINECODE attribindex) specifies the index of the generic vertex attribute array whose data layout is being described, and must be less than the value of $(D_INLINECODE GL_MAX_VERTEX_ATTRIBS). $(D_INLINECODE size) determines the number of components per vertex are allocated to the specified attribute and must be 1, 2, 3 or 4. $(D_INLINECODE type) indicates the type of the data. If $(D_INLINECODE type) is one of $(D_INLINECODE GL_BYTE), $(D_INLINECODE GL_SHORT), $(D_INLINECODE GL_INT), $(D_INLINECODE GL_FIXED), $(D_INLINECODE GL_FLOAT), $(D_INLINECODE GL_HALF_FLOAT), and $(D_INLINECODE GL_DOUBLE) indicate types $(D_INLINECODE GLbyte), $(D_INLINECODE GLshort), $(D_INLINECODE GLint), $(D_INLINECODE GLfixed), $(D_INLINECODE GLfloat), $(D_INLINECODE GLhalf), and $(D_INLINECODE GLdouble), respectively; the values $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), and $(D_INLINECODE GL_UNSIGNED_INT) indicate types $(D_INLINECODE GLubyte), $(D_INLINECODE GLushort), and $(D_INLINECODE GLuint), respectively; the values $(D_INLINECODE GL_INT_2_10_10_10_REV) and $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV) indicating respectively four signed or unsigned elements packed into a single $(D_INLINECODE GLuint); and the value $(D_INLINECODE GL_UNSIGNED_INT_10F_11F_11F_REV) indicating three floating point values packed into a single $(D_INLINECODE GLuint). $(D_INLINECODE glVertexAttribLFormat) and $(D_INLINECODE glVertexArrayAttribLFormat) is used to specify layout for data associated with a generic attribute variable declared as 64-bit double precision components. For $(D_INLINECODE glVertexAttribLFormat) and $(D_INLINECODE glVertexArrayAttribLFormat), $(D_INLINECODE type) must be $(D_INLINECODE GL_DOUBLE). In contrast to $(D_INLINECODE glVertexAttribFormat) or $(D_INLINECODE glVertexArrayAttribFormat), which will cause data declared as $(D_INLINECODE GL_DOUBLE) to be converted to 32-bit representation, $(D_INLINECODE glVertexAttribLFormat) and $(D_INLINECODE glVertexArrayAttribLFormat) cause such data to be left in its natural, 64-bit representation. For $(D_INLINECODE glVertexAttribFormat) and $(D_INLINECODE glVertexArrayAttribFormat), if $(D_INLINECODE normalized) is $(D_INLINECODE GL_TRUE), then integer data is normalized to the range [-1, 1] or [0, 1] if it is signed or unsigned, respectively. If $(D_INLINECODE normalized) is $(D_INLINECODE GL_FALSE) then integer data is directly converted to floating point. $(D_INLINECODE relativeoffset) is the offset, measured in basic machine units of the first element relative to the start of the vertex buffer binding this attribute fetches from. $(D_INLINECODE glVertexAttribFormat) and $(D_INLINECODE glVertexArrayAttribFormat) should be used to describe vertex attribute layout for floating-point vertex attributes, $(D_INLINECODE glVertexAttribIFormat) and $(D_INLINECODE glVertexArrayAttribIFormat) should be used to describe vertex attribute layout for integer vertex attribute, and $(D_INLINECODE glVertexAttribLFormat) and $(D_INLINECODE glVertexArrayAttribLFormat) should be used to describe the layout for 64-bit vertex attributes. Data for an array specified by $(D_INLINECODE glVertexAttribIFormat) and $(D_INLINECODE glVertexArrayAttribIFormat) will always be left as integer values; such data are referred to as pure integers.
     + 
     + $(D_INLINECODE GL_UNSIGNED_INT_10F_11F_11F_REV) is accepted for $(D_INLINECODE type) only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     vaobj          = Specifies the name of the vertex array object for $(D_INLINECODE glVertexArrayAttrib{I, L}Format) functions.
     +     attribindex    = The generic vertex attribute array being described.
     +     size           = The number of values per vertex that are stored in the array.
     +     type           = The type of the data stored in the array.
     +     normalized     = The distance between elements within the buffer.
     +     relativeoffset = The distance between elements within the buffer.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindVertexBuffer), $(D_INLINECODE glVertexAttribBinding), $(D_INLINECODE glVertexAttribPointer), $(D_INLINECODE glVertexBindingDivisor), $(D_INLINECODE glVertexAttribPointer).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_vertex_attrib_binding")
    fn_glVertexAttribFormat glVertexAttribFormat;
    alias fn_glVertexAttribIFormat = extern(System) void function(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_vertex_attrib_binding")
    fn_glVertexAttribIFormat glVertexAttribIFormat;
    alias fn_glVertexAttribLFormat = extern(System) void function(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_vertex_attrib_binding")
    fn_glVertexAttribLFormat glVertexAttribLFormat;
    alias fn_glVertexArrayAttribFormat = extern(System) void function(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glVertexArrayAttribFormat glVertexArrayAttribFormat;
    alias fn_glVertexArrayAttribIFormat = extern(System) void function(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glVertexArrayAttribIFormat glVertexArrayAttribIFormat;
    alias fn_glVertexArrayAttribLFormat = extern(System) void function(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glVertexArrayAttribLFormat glVertexArrayAttribLFormat;
    alias fn_glVertexBindingDivisor = extern(System) void function(GLuint bindingindex, GLuint divisor) @system @nogc nothrow;

    /++
     + glVertexArrayBindingDivisor: man4/glVertexBindingDivisor.xml
     + 
     + $(D_INLINECODE glVertexBindingDivisor) and $(D_INLINECODE glVertexArrayBindingDivisor) modify the rate at which generic vertex attributes advance when rendering multiple instances of primitives in a single draw command. If $(D_INLINECODE divisor) is zero, the attributes using the buffer bound to $(D_INLINECODE bindingindex) advance once per vertex. If $(D_INLINECODE divisor) is non-zero, the attributes advance once per $(D_INLINECODE divisor) instances of the set(s) of vertices being rendered. An attribute is referred to as if the corresponding $(D_INLINECODE divisor) value is non-zero. $(D_INLINECODE glVertexBindingDivisor) uses currently bound vertex array object , whereas $(D_INLINECODE glVertexArrayBindingDivisor) updates state of the vertex array object with ID $(D_INLINECODE vaobj).
     + 
     + Params:
     +     vaobj        = Specifies the name of the vertex array object for $(D_INLINECODE glVertexArrayBindingDivisor) function.
     +     bindingindex = The index of the binding whose divisor to modify.
     +     divisor      = The new value for the instance step rate to apply.
     + 
     + Copyright:
     +     Copyright&copy; 2013-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindVertexBuffer), $(D_INLINECODE glVertexAttribBinding), $(D_INLINECODE glVertexAttribPointer), $(D_INLINECODE glVertexBindingDivisor), $(D_INLINECODE glVertexAttribPointer).
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P3)
    @OpenGL_Extension("GL_ARB_vertex_attrib_binding")
    fn_glVertexBindingDivisor glVertexBindingDivisor;
    alias fn_glVertexArrayBindingDivisor = extern(System) void function(GLuint vaobj, GLuint bindingindex, GLuint divisor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glVertexArrayBindingDivisor glVertexArrayBindingDivisor;
    alias fn_glVertexArrayElementBuffer = extern(System) void function(GLuint vaobj, GLuint buffer) @system @nogc nothrow;

    /++
     + glVertexArrayElementBuffer: man4/glVertexArrayElementBuffer.xml
     + 
     + $(D_INLINECODE glVertexArrayElementBuffer) binds a buffer object with id $(D_INLINECODE buffer) to the element array buffer bind point of a vertex array object with id $(D_INLINECODE vaobj). If $(D_INLINECODE buffer) is zero, any existing element array buffer binding to $(D_INLINECODE vaobj) is removed.
     + 
     + Params:
     +     vaobj  = Specifies the name of the vertex array object.
     +     buffer = Specifies the name of the buffer object to use for the element array buffer binding.
     + 
     + Copyright:
     +     Copyright&copy; 2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGet), $(D_INLINECODE glGetVertexArrayiv)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glVertexArrayElementBuffer glVertexArrayElementBuffer;
    alias fn_glVertexAttrib1f = extern(System) void function(GLuint index, GLfloat v0) @system @nogc nothrow;

    /++
     + glVertexAttrib: man4/glVertexAttrib.xml
     + 
     + The $(D_INLINECODE glVertexAttrib) family of entry points allows an application to pass generic vertex attributes in numbered locations. Generic attributes are defined as four-component values that are organized into an array. The first entry of this array is numbered 0, and the size of the array is specified by the implementation-dependent constant $(D_INLINECODE GL_MAX_VERTEX_ATTRIBS). Individual elements of this array can be modified with a $(D_INLINECODE glVertexAttrib) call that specifies the index of the element to be modified and a value for that element. These commands can be used to specify one, two, three, or all four components of the generic vertex attribute specified by $(D_INLINECODE index). A $(D_INLINECODE 1) in the name of the command indicates that only one value is passed, and it will be used to modify the first component of the generic vertex attribute. The second and third components will be set to 0, and the fourth component will be set to 1. Similarly, a $(D_INLINECODE 2) in the name of the command indicates that values are provided for the first two components, the third component will be set to 0, and the fourth component will be set to 1. A $(D_INLINECODE 3) in the name of the command indicates that values are provided for the first three components and the fourth component will be set to 1, whereas a $(D_INLINECODE 4) in the name indicates that values are provided for all four components. The letters $(D_INLINECODE s), $(D_INLINECODE f), $(D_INLINECODE i), $(D_INLINECODE d), $(D_INLINECODE ub), $(D_INLINECODE us), and $(D_INLINECODE ui) indicate whether the arguments are of type short, float, int, double, unsigned byte, unsigned short, or unsigned int. When $(D_INLINECODE v) is appended to the name, the commands can take a pointer to an array of such values. Additional capitalized letters can indicate further alterations to the default behavior of the glVertexAttrib function: The commands containing $(D_INLINECODE N) indicate that the arguments will be passed as fixed-point values that are scaled to a normalized range according to the component conversion rules defined by the OpenGL specification. Signed values are understood to represent fixed-point values in the range [-1,1], and unsigned values are understood to represent fixed-point values in the range [0,1]. The commands containing $(D_INLINECODE I) indicate that the arguments are extended to full signed or unsigned integers. The commands containing $(D_INLINECODE P) indicate that the arguments are stored as packed components within a larger natural type. The commands containing $(D_INLINECODE L) indicate that the arguments are full 64-bit quantities and should be passed directly to shader inputs declared as 64-bit double precision types. OpenGL Shading Language attribute variables are allowed to be of type mat2, mat3, or mat4. Attributes of these types may be loaded using the $(D_INLINECODE glVertexAttrib) entry points. Matrices must be loaded into successive generic attribute slots in column major order, with one column of the matrix in each generic attribute slot. A user-defined attribute variable declared in a vertex shader can be bound to a generic attribute index by calling $(D_INLINECODE glBindAttribLocation). This allows an application to use more descriptive variable names in a vertex shader. A subsequent change to the specified generic vertex attribute will be immediately reflected as a change to the corresponding attribute variable in the vertex shader. The binding between a generic vertex attribute index and a user-defined attribute variable in a vertex shader is part of the state of a program object, but the current value of the generic vertex attribute is not. The value of each generic vertex attribute is part of current state, just like standard vertex attributes, and it is maintained even if a different program object is used. An application may freely modify generic vertex attributes that are not bound to a named vertex shader attribute variable. These values are simply maintained as part of current state and will not be accessed by the vertex shader. If a generic vertex attribute bound to an attribute variable in a vertex shader is not updated while the vertex shader is executing, the vertex shader will repeatedly use the current value for the generic vertex attribute.
     + 
     + Generic vertex attributes can be updated at any time. It is possible for an application to bind more than one attribute name to the same generic vertex attribute index. This is referred to as aliasing, and it is allowed only if just one of the aliased attribute variables is active in the vertex shader, or if no path through the vertex shader consumes more than one of the attributes aliased to the same location. OpenGL implementations are not required to do error checking to detect aliasing, they are allowed to assume that aliasing will not occur, and they are allowed to employ optimizations that work only in the absence of aliasing. There is no provision for binding standard vertex attributes; therefore, it is not possible to alias generic attributes with standard attributes. $(D_INLINECODE glVertexAttribL) versions are available only if the GL version is 4.1 or higher. $(D_INLINECODE GL_UNSIGNED_INT_10F_11F_11F_REV) is accepted for $(D_INLINECODE type) by $(D_INLINECODE glVertexAttribP*) only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     index          = Specifies the index of the generic vertex attribute to be modified.
     +     v0, v1, v2, v3 = For the scalar commands, specifies the new values to be used for the specified vertex attribute.
     +     v              = For the vector commands ( $(D_INLINECODE glVertexAttrib*v) ), specifies a pointer to an array of values to be used for the generic vertex attribute.
     +     type           = For the packed commands ( $(D_INLINECODE glVertexAttribP*) ), specified the type of packing used on the data. This parameter must be $(D_INLINECODE GL_INT_2_10_10_10_REV) or $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV), to specify signed or unsigned data, respectively, or $(D_INLINECODE GL_UNSIGNED_INT_10F_11F_11F_REV) to specify floating point data.
     +     normalized     = For the packed commands, if $(D_INLINECODE GL_TRUE), then the values are to be converted to floating point values by normalizing. Otherwise, they are converted directly to floating-point values. If $(D_INLINECODE type) indicates a floating-pont format, then $(D_INLINECODE normalized) value must be $(D_INLINECODE GL_FALSE).
     +     value          = For the packed commands, specifies the new packed value to be used for the specified vertex attribute.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindAttribLocation), $(D_INLINECODE glVertexAttribPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glVertexAttrib1f glVertexAttrib1f;
    alias fn_glVertexAttrib1s = extern(System) void function(GLuint index, GLshort v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glVertexAttrib1s glVertexAttrib1s;
    alias fn_glVertexAttrib1d = extern(System) void function(GLuint index, GLdouble v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glVertexAttrib1d glVertexAttrib1d;
    alias fn_glVertexAttribI1i = extern(System) void function(GLuint index, GLint v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glVertexAttribI1i glVertexAttribI1i;
    alias fn_glVertexAttribI1ui = extern(System) void function(GLuint index, GLuint v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glVertexAttribI1ui glVertexAttribI1ui;
    alias fn_glVertexAttrib2f = extern(System) void function(GLuint index, GLfloat v0, GLfloat v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glVertexAttrib2f glVertexAttrib2f;
    alias fn_glVertexAttrib2s = extern(System) void function(GLuint index, GLshort v0, GLshort v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glVertexAttrib2s glVertexAttrib2s;
    alias fn_glVertexAttrib2d = extern(System) void function(GLuint index, GLdouble v0, GLdouble v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glVertexAttrib2d glVertexAttrib2d;
    alias fn_glVertexAttribI2i = extern(System) void function(GLuint index, GLint v0, GLint v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glVertexAttribI2i glVertexAttribI2i;
    alias fn_glVertexAttribI2ui = extern(System) void function(GLuint index, GLuint v0, GLuint v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glVertexAttribI2ui glVertexAttribI2ui;
    alias fn_glVertexAttrib3f = extern(System) void function(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glVertexAttrib3f glVertexAttrib3f;
    alias fn_glVertexAttrib3s = extern(System) void function(GLuint index, GLshort v0, GLshort v1, GLshort v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glVertexAttrib3s glVertexAttrib3s;
    alias fn_glVertexAttrib3d = extern(System) void function(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glVertexAttrib3d glVertexAttrib3d;
    alias fn_glVertexAttribI3i = extern(System) void function(GLuint index, GLint v0, GLint v1, GLint v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glVertexAttribI3i glVertexAttribI3i;
    alias fn_glVertexAttribI3ui = extern(System) void function(GLuint index, GLuint v0, GLuint v1, GLuint v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glVertexAttribI3ui glVertexAttribI3ui;
    alias fn_glVertexAttrib4f = extern(System) void function(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glVertexAttrib4f glVertexAttrib4f;
    alias fn_glVertexAttrib4s = extern(System) void function(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glVertexAttrib4s glVertexAttrib4s;
    alias fn_glVertexAttrib4d = extern(System) void function(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glVertexAttrib4d glVertexAttrib4d;
    alias fn_glVertexAttrib4Nub = extern(System) void function(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glVertexAttrib4Nub glVertexAttrib4Nub;
    alias fn_glVertexAttribI4i = extern(System) void function(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glVertexAttribI4i glVertexAttribI4i;
    alias fn_glVertexAttribI4ui = extern(System) void function(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glVertexAttribI4ui glVertexAttribI4ui;
    alias fn_glVertexAttribL1d = extern(System) void function(GLuint index, GLdouble v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_vertex_attrib_64bit")
    fn_glVertexAttribL1d glVertexAttribL1d;
    alias fn_glVertexAttribL2d = extern(System) void function(GLuint index, GLdouble v0, GLdouble v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_vertex_attrib_64bit")
    fn_glVertexAttribL2d glVertexAttribL2d;
    alias fn_glVertexAttribL3d = extern(System) void function(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_vertex_attrib_64bit")
    fn_glVertexAttribL3d glVertexAttribL3d;
    alias fn_glVertexAttribL4d = extern(System) void function(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_vertex_attrib_64bit")
    fn_glVertexAttribL4d glVertexAttribL4d;
    alias fn_glVertexAttrib1fv = extern(System) void function(GLuint index, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glVertexAttrib1fv glVertexAttrib1fv;
    alias fn_glVertexAttrib1sv = extern(System) void function(GLuint index, const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glVertexAttrib1sv glVertexAttrib1sv;
    alias fn_glVertexAttrib1dv = extern(System) void function(GLuint index, const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glVertexAttrib1dv glVertexAttrib1dv;
    alias fn_glVertexAttribI1iv = extern(System) void function(GLuint index, const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glVertexAttribI1iv glVertexAttribI1iv;
    alias fn_glVertexAttribI1uiv = extern(System) void function(GLuint index, const( GLuint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glVertexAttribI1uiv glVertexAttribI1uiv;
    alias fn_glVertexAttrib2fv = extern(System) void function(GLuint index, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glVertexAttrib2fv glVertexAttrib2fv;
    alias fn_glVertexAttrib2sv = extern(System) void function(GLuint index, const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glVertexAttrib2sv glVertexAttrib2sv;
    alias fn_glVertexAttrib2dv = extern(System) void function(GLuint index, const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glVertexAttrib2dv glVertexAttrib2dv;
    alias fn_glVertexAttribI2iv = extern(System) void function(GLuint index, const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glVertexAttribI2iv glVertexAttribI2iv;
    alias fn_glVertexAttribI2uiv = extern(System) void function(GLuint index, const( GLuint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glVertexAttribI2uiv glVertexAttribI2uiv;
    alias fn_glVertexAttrib3fv = extern(System) void function(GLuint index, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glVertexAttrib3fv glVertexAttrib3fv;
    alias fn_glVertexAttrib3sv = extern(System) void function(GLuint index, const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glVertexAttrib3sv glVertexAttrib3sv;
    alias fn_glVertexAttrib3dv = extern(System) void function(GLuint index, const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glVertexAttrib3dv glVertexAttrib3dv;
    alias fn_glVertexAttribI3iv = extern(System) void function(GLuint index, const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glVertexAttribI3iv glVertexAttribI3iv;
    alias fn_glVertexAttribI3uiv = extern(System) void function(GLuint index, const( GLuint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glVertexAttribI3uiv glVertexAttribI3uiv;
    alias fn_glVertexAttrib4fv = extern(System) void function(GLuint index, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glVertexAttrib4fv glVertexAttrib4fv;
    alias fn_glVertexAttrib4sv = extern(System) void function(GLuint index, const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glVertexAttrib4sv glVertexAttrib4sv;
    alias fn_glVertexAttrib4dv = extern(System) void function(GLuint index, const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glVertexAttrib4dv glVertexAttrib4dv;
    alias fn_glVertexAttrib4iv = extern(System) void function(GLuint index, const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glVertexAttrib4iv glVertexAttrib4iv;
    alias fn_glVertexAttrib4bv = extern(System) void function(GLuint index, const( GLbyte*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glVertexAttrib4bv glVertexAttrib4bv;
    alias fn_glVertexAttrib4ubv = extern(System) void function(GLuint index, const(GLubyte)* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glVertexAttrib4ubv glVertexAttrib4ubv;
    alias fn_glVertexAttrib4usv = extern(System) void function(GLuint index, const( GLushort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glVertexAttrib4usv glVertexAttrib4usv;
    alias fn_glVertexAttrib4uiv = extern(System) void function(GLuint index, const( GLuint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glVertexAttrib4uiv glVertexAttrib4uiv;
    alias fn_glVertexAttrib4Nbv = extern(System) void function(GLuint index, const( GLbyte*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glVertexAttrib4Nbv glVertexAttrib4Nbv;
    alias fn_glVertexAttrib4Nsv = extern(System) void function(GLuint index, const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glVertexAttrib4Nsv glVertexAttrib4Nsv;
    alias fn_glVertexAttrib4Niv = extern(System) void function(GLuint index, const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glVertexAttrib4Niv glVertexAttrib4Niv;
    alias fn_glVertexAttrib4Nubv = extern(System) void function(GLuint index, const(GLubyte)* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glVertexAttrib4Nubv glVertexAttrib4Nubv;
    alias fn_glVertexAttrib4Nusv = extern(System) void function(GLuint index, const( GLushort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glVertexAttrib4Nusv glVertexAttrib4Nusv;
    alias fn_glVertexAttrib4Nuiv = extern(System) void function(GLuint index, const( GLuint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glVertexAttrib4Nuiv glVertexAttrib4Nuiv;
    alias fn_glVertexAttribI4bv = extern(System) void function(GLuint index, const( GLbyte*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glVertexAttribI4bv glVertexAttribI4bv;
    alias fn_glVertexAttribI4ubv = extern(System) void function(GLuint index, const(GLubyte)* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glVertexAttribI4ubv glVertexAttribI4ubv;
    alias fn_glVertexAttribI4sv = extern(System) void function(GLuint index, const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glVertexAttribI4sv glVertexAttribI4sv;
    alias fn_glVertexAttribI4usv = extern(System) void function(GLuint index, const( GLushort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glVertexAttribI4usv glVertexAttribI4usv;
    alias fn_glVertexAttribI4iv = extern(System) void function(GLuint index, const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glVertexAttribI4iv glVertexAttribI4iv;
    alias fn_glVertexAttribI4uiv = extern(System) void function(GLuint index, const( GLuint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glVertexAttribI4uiv glVertexAttribI4uiv;
    alias fn_glVertexAttribL1dv = extern(System) void function(GLuint index, const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_vertex_attrib_64bit")
    fn_glVertexAttribL1dv glVertexAttribL1dv;
    alias fn_glVertexAttribL2dv = extern(System) void function(GLuint index, const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_vertex_attrib_64bit")
    fn_glVertexAttribL2dv glVertexAttribL2dv;
    alias fn_glVertexAttribL3dv = extern(System) void function(GLuint index, const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_vertex_attrib_64bit")
    fn_glVertexAttribL3dv glVertexAttribL3dv;
    alias fn_glVertexAttribL4dv = extern(System) void function(GLuint index, const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_vertex_attrib_64bit")
    fn_glVertexAttribL4dv glVertexAttribL4dv;
    alias fn_glVertexAttribP1ui = extern(System) void function(GLuint index, GLenum type, GLboolean normalized, GLuint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glVertexAttribP1ui glVertexAttribP1ui;
    alias fn_glVertexAttribP2ui = extern(System) void function(GLuint index, GLenum type, GLboolean normalized, GLuint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glVertexAttribP2ui glVertexAttribP2ui;
    alias fn_glVertexAttribP3ui = extern(System) void function(GLuint index, GLenum type, GLboolean normalized, GLuint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glVertexAttribP3ui glVertexAttribP3ui;
    alias fn_glVertexAttribP4ui = extern(System) void function(GLuint index, GLenum type, GLboolean normalized, GLuint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glVertexAttribP4ui glVertexAttribP4ui;
    alias fn_glVertexAttribDivisor = extern(System) void function(GLuint index, GLuint divisor) @system @nogc nothrow;

    /++
     + glVertexAttribDivisor: man4/glVertexAttribDivisor.xml
     + 
     + $(D_INLINECODE glVertexAttribDivisor) modifies the rate at which generic vertex attributes advance when rendering multiple instances of primitives in a single draw call. If $(D_INLINECODE divisor) is zero, the attribute at slot $(D_INLINECODE index) advances once per vertex. If $(D_INLINECODE divisor) is non-zero, the attribute advances once per $(D_INLINECODE divisor) instances of the set(s) of vertices being rendered.  An attribute is referred to as instanced if its $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_DIVISOR) value is non-zero. $(D_INLINECODE index) must be less than the value of $(D_INLINECODE GL_MAX_VERTEX_ATTRIBS).
     + 
     + $(D_INLINECODE glVertexAttribDivisor) is available only if the GL version is 3.3 or higher.
     + 
     + Params:
     +     index   = Specify the index of the generic vertex attribute.
     +     divisor = Specify the number of instances that will pass between updates of the generic attribute at slot $(D_INLINECODE index).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glVertexAttribPointer), $(D_INLINECODE glEnableVertexAttribArray), $(D_INLINECODE glDisableVertexAttribArray)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    fn_glVertexAttribDivisor glVertexAttribDivisor;
    alias fn_glVertexAttribPointer = extern(System) void function(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const( GLvoid*) pointer) @system @nogc nothrow;

    /++
     + glVertexAttribIPointer: man4/glVertexAttribPointer.xml
     + 
     + $(D_INLINECODE glVertexAttribPointer), $(D_INLINECODE glVertexAttribIPointer) and $(D_INLINECODE glVertexAttribLPointer) specify the location and data format of the array of generic vertex attributes at index $(D_INLINECODE index) to use when rendering. $(D_INLINECODE size) specifies the number of components per attribute and must be 1, 2, 3, 4, or $(D_INLINECODE GL_BGRA). $(D_INLINECODE type) specifies the data type of each component, and $(D_INLINECODE stride) specifies the byte stride from one attribute to the next, allowing vertices and attributes to be packed into a single array or stored in separate arrays. For $(D_INLINECODE glVertexAttribPointer), if $(D_INLINECODE normalized) is set to $(D_INLINECODE GL_TRUE), it indicates that values stored in an integer format are to be mapped to the range [-1,1] (for signed values) or [0,1] (for unsigned values) when they are accessed and converted to floating point. Otherwise, values will be converted to floats directly without normalization. For $(D_INLINECODE glVertexAttribIPointer), only the integer types $(D_INLINECODE GL_BYTE), $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_SHORT), $(D_INLINECODE GL_UNSIGNED_SHORT), $(D_INLINECODE GL_INT), $(D_INLINECODE GL_UNSIGNED_INT) are accepted. Values are always left as integer values. $(D_INLINECODE glVertexAttribLPointer) specifies state for a generic vertex attribute array associated with a shader attribute variable declared with 64-bit double precision components. $(D_INLINECODE type) must be $(D_INLINECODE GL_DOUBLE). $(D_INLINECODE index), $(D_INLINECODE size), and $(D_INLINECODE stride) behave as described for $(D_INLINECODE glVertexAttribPointer) and $(D_INLINECODE glVertexAttribIPointer). If $(D_INLINECODE pointer) is not $(D_INLINECODE null
     + ), a non-zero named buffer object must be bound to the $(D_INLINECODE GL_ARRAY_BUFFER) target (see $(D_INLINECODE glBindBuffer) ), otherwise an error is generated. $(D_INLINECODE pointer) is treated as a byte offset into the buffer object's data store. The buffer object binding ( $(D_INLINECODE GL_ARRAY_BUFFER_BINDING) ) is saved as generic vertex attribute array state ( $(D_INLINECODE GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING) ) for index $(D_INLINECODE index). When a generic vertex attribute array is specified, $(D_INLINECODE size), $(D_INLINECODE type), $(D_INLINECODE normalized), $(D_INLINECODE stride), and $(D_INLINECODE pointer) are saved as vertex array state, in addition to the current vertex array buffer object binding. To enable and disable a generic vertex attribute array, call $(D_INLINECODE glEnableVertexAttribArray) and $(D_INLINECODE glDisableVertexAttribArray) with $(D_INLINECODE index). If enabled, the generic vertex attribute array is used when $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glMultiDrawElements), or $(D_INLINECODE glDrawRangeElements) is called.
     + 
     + Each generic vertex attribute array is initially disabled and isn't accessed when $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), or $(D_INLINECODE glMultiDrawElements) is called. $(D_INLINECODE GL_UNSIGNED_INT_10F_11F_11F_REV) is accepted for $(D_INLINECODE type) only if the GL version is 4.4 or higher.
     + 
     + Params:
     +     index      = Specifies the index of the generic vertex attribute to be modified.
     +     size       = Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant $(D_INLINECODE GL_BGRA) is accepted by $(D_INLINECODE glVertexAttribPointer). The initial value is 4.
     +     type       = Specifies the data type of each component in the array. The symbolic constants $(D_INLINECODE GL_BYTE), $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_SHORT), $(D_INLINECODE GL_UNSIGNED_SHORT), $(D_INLINECODE GL_INT), and $(D_INLINECODE GL_UNSIGNED_INT) are accepted by $(D_INLINECODE glVertexAttribPointer) and $(D_INLINECODE glVertexAttribIPointer). Additionally $(D_INLINECODE GL_HALF_FLOAT), $(D_INLINECODE GL_FLOAT), $(D_INLINECODE GL_DOUBLE), $(D_INLINECODE GL_FIXED), $(D_INLINECODE GL_INT_2_10_10_10_REV), $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV) and $(D_INLINECODE GL_UNSIGNED_INT_10F_11F_11F_REV) are accepted by $(D_INLINECODE glVertexAttribPointer). $(D_INLINECODE GL_DOUBLE) is also accepted by $(D_INLINECODE glVertexAttribLPointer) and is the only token accepted by the $(D_INLINECODE type) parameter for that function. The initial value is $(D_INLINECODE GL_FLOAT).
     +     normalized = For $(D_INLINECODE glVertexAttribPointer), specifies whether fixed-point data values should be normalized ( $(D_INLINECODE GL_TRUE) ) or converted directly as fixed-point values ( $(D_INLINECODE GL_FALSE) ) when they are accessed.
     +     stride     = Specifies the byte offset between consecutive generic vertex attributes. If $(D_INLINECODE stride) is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
     +     pointer    = Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the $(D_INLINECODE GL_ARRAY_BUFFER) target. The initial value is 0.
     + 
     + Copyright:
     +     Copyright&copy; 2003-2005 3Dlabs Inc. Ltd. Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindAttribLocation), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glDisableVertexAttribArray), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glEnableVertexAttribArray), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glMultiDrawElements), $(D_INLINECODE glVertexAttrib)
     +/
    @OpenGL_Version(OGLIntroducedIn.V2P0)
    fn_glVertexAttribPointer glVertexAttribPointer;
    alias fn_glVertexAttribIPointer = extern(System) void function(GLuint index, GLint size, GLenum type, GLsizei stride, const( GLvoid*) pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glVertexAttribIPointer glVertexAttribIPointer;
    alias fn_glVertexAttribLPointer = extern(System) void function(GLuint index, GLint size, GLenum type, GLsizei stride, const( GLvoid*) pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_vertex_attrib_64bit")
    fn_glVertexAttribLPointer glVertexAttribLPointer;
    alias fn_glViewport = extern(System) void function(GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;

    /++
     + glViewport: man4/glViewport.xml
     + 
     + $(D_INLINECODE glViewport) specifies the affine transformation of x and y from normalized device coordinates to window coordinates. Let x nd y nd be normalized device coordinates. Then the window coordinates x w y w are computed as follows: x w = x nd + 1 &it; width 2 + x y w = y nd + 1 &it; height 2 + y Viewport width and height are silently clamped to a range that depends on the implementation. To query this range, call $(D_INLINECODE glGet) with argument $(D_INLINECODE GL_MAX_VIEWPORT_DIMS).
     + 
     + Params:
     +     x     = Specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0).
     +     width = Specify the width and height of the viewport. When a GL context is first attached to a window, $(D_INLINECODE width) and $(D_INLINECODE height) are set to the dimensions of that window.
     + 
     + Copyright:
     +     Copyright&copy; 1991-2006 Silicon Graphics, Inc. Copyright&copy; 2010-2014 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDepthRange)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glViewport glViewport;
    alias fn_glViewportArrayv = extern(System) void function(GLuint first, GLsizei count, const( GLfloat*) v) @system @nogc nothrow;

    /++
     + glViewportArray: man4/glViewportArray.xml
     + 
     + $(D_INLINECODE glViewportArrayv) specifies the parameters for multiple viewports simulataneously. $(D_INLINECODE first) specifies the index of the first viewport to modify and $(D_INLINECODE count) specifies the number of viewports to modify. $(D_INLINECODE first) must be less than the value of $(D_INLINECODE GL_MAX_VIEWPORTS), and $(D_INLINECODE first) + $(D_INLINECODE count) must be less than or equal to the value of $(D_INLINECODE GL_MAX_VIEWPORTS). Viewports whose indices lie outside the range [ $(D_INLINECODE first), $(D_INLINECODE first) + $(D_INLINECODE count) ) are not modified. $(D_INLINECODE v) contains the address of an array of floating point values specifying the left ( x ), bottom ( y ), width ( w ), and height ( h ) of each viewport, in that order. x and y give the location of the viewport's lower left corner, and w and h give the width and height of the viewport, respectively. The viewport specifies the affine transformation of x and y from normalized device coordinates to window coordinates. Let x nd y nd be normalized device coordinates. Then the window coordinates x w y w are computed as follows: x w = x nd + 1 &it; width 2 + x y w = y nd + 1 &it; height 2 + y The location of the viewport's bottom left corner, given by ( x, y ) is clamped to be within the implementaiton-dependent viewport bounds range. The viewport bounds range [ min, max ] can be determined by calling $(D_INLINECODE glGet) with argument $(D_INLINECODE GL_VIEWPORT_BOUNDS_RANGE). Viewport width and height are silently clamped to a range that depends on the implementation. To query this range, call $(D_INLINECODE glGet) with argument $(D_INLINECODE GL_MAX_VIEWPORT_DIMS). The precision with which the GL interprets the floating point viewport bounds is implementation-dependent and may be determined by querying the impementation-defined constant $(D_INLINECODE GL_VIEWPORT_SUBPIXEL_BITS).
     + 
     + Params:
     +     first = Specify the first viewport to set.
     +     count = Specify the number of viewports to set.
     +     v     = Specify the address of an array containing the viewport parameters.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDepthRange), $(D_INLINECODE glViewport), $(D_INLINECODE glViewportIndexed)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_viewport_array")
    fn_glViewportArrayv glViewportArrayv;
    alias fn_glViewportIndexedf = extern(System) void function(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h) @system @nogc nothrow;

    /++
     + glViewportIndexed: man4/glViewportIndexed.xml
     + 
     + $(D_INLINECODE glViewportIndexedf) and $(D_INLINECODE glViewportIndexedfv) specify the parameters for a single viewport. $(D_INLINECODE index) specifies the index of the viewport to modify. $(D_INLINECODE index) must be less than the value of $(D_INLINECODE GL_MAX_VIEWPORTS). For $(D_INLINECODE glViewportIndexedf), $(D_INLINECODE x), $(D_INLINECODE y), $(D_INLINECODE w), and $(D_INLINECODE h) specify the left, bottom, width and height of the viewport in pixels, respectively. For $(D_INLINECODE glViewportIndexedfv), $(D_INLINECODE v) contains the address of an array of floating point values specifying the left ( x ), bottom ( y ), width ( w ), and height ( h ) of each viewport, in that order. x and y give the location of the viewport's lower left corner, and w and h give the width and height of the viewport, respectively. The viewport specifies the affine transformation of x and y from normalized device coordinates to window coordinates. Let x nd y nd be normalized device coordinates. Then the window coordinates x w y w are computed as follows: x w = x nd + 1 &it; width 2 + x y w = y nd + 1 &it; height 2 + y The location of the viewport's bottom left corner, given by ( x, y ) is clamped to be within the implementaiton-dependent viewport bounds range. The viewport bounds range [ min, max ] can be determined by calling $(D_INLINECODE glGet) with argument $(D_INLINECODE GL_VIEWPORT_BOUNDS_RANGE). Viewport width and height are silently clamped to a range that depends on the implementation. To query this range, call $(D_INLINECODE glGet) with argument $(D_INLINECODE GL_MAX_VIEWPORT_DIMS). The precision with which the GL interprets the floating point viewport bounds is implementation-dependent and may be determined by querying the impementation-defined constant $(D_INLINECODE GL_VIEWPORT_SUBPIXEL_BITS). Calling $(D_INLINECODE glViewportIndexedfv) is equivalent to calling $(D_INLINECODE glViewportArray) with $(D_INLINECODE first) set to $(D_INLINECODE index), $(D_INLINECODE count) set to 1 and $(D_INLINECODE v) passsed directly. $(D_INLINECODE glViewportIndexedf) is equivalent to:
     + 
     + ---
     + void glViewportIndexedf(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h) {
     +     const float v[4]  = { x, y, w, h };
     +     glViewportArrayv(index, 1, v);
     + }
     + ---
     + 
     + Params:
     +     index = Specify the first viewport to set.
     +     x     = For $(D_INLINECODE glViewportIndexedf), specifies the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0).
     +     width = For $(D_INLINECODE glViewportIndexedf), specifies the width and height of the viewport. When a GL context is first attached to a window, $(D_INLINECODE width) and $(D_INLINECODE height) are set to the dimensions of that window.
     +     v     = For $(D_INLINECODE glViewportIndexedfv), specifies the address of an array containing the viewport parameters.
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDepthRange), $(D_INLINECODE glViewport), $(D_INLINECODE glViewportArray)
     +/
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_viewport_array")
    fn_glViewportIndexedf glViewportIndexedf;
    alias fn_glWaitSync = extern(System) void function(GLsync sync, GLbitfield flags, GLuint64 timeout) @system @nogc nothrow;

    /++
     + glWaitSync: man4/glWaitSync.xml
     + 
     + $(D_INLINECODE glWaitSync) causes the GL server to block and wait until $(D_INLINECODE sync) becomes signaled. $(D_INLINECODE sync) is the name of an existing sync object upon which to wait. $(D_INLINECODE flags) and $(D_INLINECODE timeout) are currently not used and must be set to zero and the special value $(D_INLINECODE GL_TIMEOUT_IGNORED), respectively $(D_INLINECODE flags) and $(D_INLINECODE timeout) are placeholders for anticipated future extensions of sync object capabilities. They must have these reserved values in order that existing code calling $(D_INLINECODE glWaitSync) operate properly in the presence of such extensions.. $(D_INLINECODE glWaitSync) will always wait no longer than an implementation-dependent timeout. The duration of this timeout in nanoseconds may be queried by calling $(D_INLINECODE glGet) with the parameter $(D_INLINECODE GL_MAX_SERVER_WAIT_TIMEOUT). There is currently no way to determine whether $(D_INLINECODE glWaitSync) unblocked because the timeout expired or because the sync object being waited on was signaled. If an error occurs, $(D_INLINECODE glWaitSync) does not cause the GL server to block.
     + 
     + $(D_INLINECODE glWaitSync) is available only if the GL version is 3.2 or higher.
     + 
     + Params:
     +     sync    = Specifies the sync object whose status to wait on.
     +     flags   = A bitfield controlling the command flushing behavior. $(D_INLINECODE flags) may be zero.
     +     timeout = Specifies the timeout that the server should wait before continuing. $(D_INLINECODE timeout) must be $(D_INLINECODE GL_TIMEOUT_IGNORED).
     + 
     + Copyright:
     +     Copyright&copy; 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. $(LINK2 http://opencontent.org/openpub/, http://opencontent.org/openpub/).
     + 
     + See_Also:
     +     $(D_INLINECODE glFenceSync), $(D_INLINECODE glClientWaitSync)
     +/
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_sync")
    fn_glWaitSync glWaitSync;
    alias fn_glDisable = extern(System) void function(GLenum cap) @system @nogc nothrow;

    /++
     + glEnable: man3/glEnable.xml
     + 
     + $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) enable and disable various capabilities. Use $(D_INLINECODE glIsEnabled) or $(D_INLINECODE glGet) to determine the current setting of any capability. The initial value for each capability with the exception of $(D_INLINECODE GL_DITHER) and $(D_INLINECODE GL_MULTISAMPLE) is $(D_INLINECODE GL_FALSE). The initial value for $(D_INLINECODE GL_DITHER) and $(D_INLINECODE GL_MULTISAMPLE) is $(D_INLINECODE GL_TRUE). Both $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) take a single argument, $(D_INLINECODE cap), which can assume one of the following values: Some of the GL's capabilities are indicated. $(D_INLINECODE glEnablei) and $(D_INLINECODE glDisablei) enable and disable indexed capabilities.
     + 
     + $(D_INLINECODE GL_PRIMITIVE_RESTART) is available only if the GL version is 3.1 or greater. $(D_INLINECODE GL_TEXTURE_CUBE_MAP_SEAMLESS) is available only if the GL version is 3.2 or greater. Any token accepted by $(D_INLINECODE glEnable) or $(D_INLINECODE glDisable) is also accepted by $(D_INLINECODE glEnablei) and $(D_INLINECODE glDisablei), but if the capability is not indexed, the maximum value that $(D_INLINECODE index) may take is zero. In general, passing an indexed capability to $(D_INLINECODE glEnable) or $(D_INLINECODE glDisable) will enable or disable that capability for all indices, resepectively.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. Copyright 2010 Khronos Group. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glBlendFunc), $(D_INLINECODE glCullFace), $(D_INLINECODE glDepthFunc), $(D_INLINECODE glDepthRange), $(D_INLINECODE glGet), $(D_INLINECODE glIsEnabled), $(D_INLINECODE glLineWidth), $(D_INLINECODE glLogicOp), $(D_INLINECODE glPointSize), $(D_INLINECODE glPolygonMode), $(D_INLINECODE glPolygonOffset), $(D_INLINECODE glSampleCoverage), $(D_INLINECODE glScissor), $(D_INLINECODE glStencilFunc), $(D_INLINECODE glStencilOp), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glDisable glDisable;
    alias fn_glEnablei = extern(System) void function(GLenum cap, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glEnablei glEnablei;
    alias fn_glDisablei = extern(System) void function(GLenum cap, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glDisablei glDisablei;
    alias fn_glMultiTexCoord1s = extern(System) void function(GLenum target, GLshort s) @system @nogc nothrow;

    /++
     + glMultiTexCoord: man3/glMultiTexCoord.xml
     + 
     + $(D_INLINECODE glMultiTexCoord) specifies texture coordinates in one, two, three, or four dimensions. $(D_INLINECODE glMultiTexCoord1) sets the current texture coordinates to s 0 0 1; a call to $(D_INLINECODE glMultiTexCoord2) sets them to s t 0 1. Similarly, $(D_INLINECODE glMultiTexCoord3) specifies the texture coordinates as s t r 1, and $(D_INLINECODE glMultiTexCoord4) defines all four components explicitly as s t r q. The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for s t r q are 0 0 0 1.
     + 
     + The current texture coordinates can be updated at any time. It is always the case that $(D_INLINECODE GL_TEXTURE) i = $(D_INLINECODE GL_TEXTURE0) + i.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glTexCoord), $(D_INLINECODE glVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glMultiTexCoord1s glMultiTexCoord1s;
    alias fn_glMultiTexCoord1i = extern(System) void function(GLenum target, GLint s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glMultiTexCoord1i glMultiTexCoord1i;
    alias fn_glMultiTexCoord1f = extern(System) void function(GLenum target, GLfloat s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glMultiTexCoord1f glMultiTexCoord1f;
    alias fn_glMultiTexCoord1d = extern(System) void function(GLenum target, GLdouble s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glMultiTexCoord1d glMultiTexCoord1d;
    alias fn_glMultiTexCoord2s = extern(System) void function(GLenum target, GLshort s, GLshort t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glMultiTexCoord2s glMultiTexCoord2s;
    alias fn_glMultiTexCoord2i = extern(System) void function(GLenum target, GLint s, GLint t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glMultiTexCoord2i glMultiTexCoord2i;
    alias fn_glMultiTexCoord2f = extern(System) void function(GLenum target, GLfloat s, GLfloat t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glMultiTexCoord2f glMultiTexCoord2f;
    alias fn_glMultiTexCoord2d = extern(System) void function(GLenum target, GLdouble s, GLdouble t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glMultiTexCoord2d glMultiTexCoord2d;
    alias fn_glMultiTexCoord3s = extern(System) void function(GLenum target, GLshort s, GLshort t, GLshort r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glMultiTexCoord3s glMultiTexCoord3s;
    alias fn_glMultiTexCoord3i = extern(System) void function(GLenum target, GLint s, GLint t, GLint r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glMultiTexCoord3i glMultiTexCoord3i;
    alias fn_glMultiTexCoord3f = extern(System) void function(GLenum target, GLfloat s, GLfloat t, GLfloat r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glMultiTexCoord3f glMultiTexCoord3f;
    alias fn_glMultiTexCoord3d = extern(System) void function(GLenum target, GLdouble s, GLdouble t, GLdouble r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glMultiTexCoord3d glMultiTexCoord3d;
    alias fn_glMultiTexCoord4s = extern(System) void function(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glMultiTexCoord4s glMultiTexCoord4s;
    alias fn_glMultiTexCoord4i = extern(System) void function(GLenum target, GLint s, GLint t, GLint r, GLint q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glMultiTexCoord4i glMultiTexCoord4i;
    alias fn_glMultiTexCoord4f = extern(System) void function(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glMultiTexCoord4f glMultiTexCoord4f;
    alias fn_glMultiTexCoord4d = extern(System) void function(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glMultiTexCoord4d glMultiTexCoord4d;
    alias fn_glMultiTexCoord1sv = extern(System) void function(GLenum target, const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glMultiTexCoord1sv glMultiTexCoord1sv;
    alias fn_glMultiTexCoord1iv = extern(System) void function(GLenum target, const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glMultiTexCoord1iv glMultiTexCoord1iv;
    alias fn_glMultiTexCoord1fv = extern(System) void function(GLenum target, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glMultiTexCoord1fv glMultiTexCoord1fv;
    alias fn_glMultiTexCoord1dv = extern(System) void function(GLenum target, const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glMultiTexCoord1dv glMultiTexCoord1dv;
    alias fn_glMultiTexCoord2sv = extern(System) void function(GLenum target, const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glMultiTexCoord2sv glMultiTexCoord2sv;
    alias fn_glMultiTexCoord2iv = extern(System) void function(GLenum target, const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glMultiTexCoord2iv glMultiTexCoord2iv;
    alias fn_glMultiTexCoord2fv = extern(System) void function(GLenum target, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glMultiTexCoord2fv glMultiTexCoord2fv;
    alias fn_glMultiTexCoord2dv = extern(System) void function(GLenum target, const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glMultiTexCoord2dv glMultiTexCoord2dv;
    alias fn_glMultiTexCoord3sv = extern(System) void function(GLenum target, const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glMultiTexCoord3sv glMultiTexCoord3sv;
    alias fn_glMultiTexCoord3iv = extern(System) void function(GLenum target, const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glMultiTexCoord3iv glMultiTexCoord3iv;
    alias fn_glMultiTexCoord3fv = extern(System) void function(GLenum target, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glMultiTexCoord3fv glMultiTexCoord3fv;
    alias fn_glMultiTexCoord3dv = extern(System) void function(GLenum target, const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glMultiTexCoord3dv glMultiTexCoord3dv;
    alias fn_glMultiTexCoord4sv = extern(System) void function(GLenum target, const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glMultiTexCoord4sv glMultiTexCoord4sv;
    alias fn_glMultiTexCoord4iv = extern(System) void function(GLenum target, const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glMultiTexCoord4iv glMultiTexCoord4iv;
    alias fn_glMultiTexCoord4fv = extern(System) void function(GLenum target, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glMultiTexCoord4fv glMultiTexCoord4fv;
    alias fn_glMultiTexCoord4dv = extern(System) void function(GLenum target, const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glMultiTexCoord4dv glMultiTexCoord4dv;
    alias fn_glAccum = extern(System) void function(GLenum op, GLfloat value) @system @nogc nothrow;

    /++
     + glAccum: man2/glAccum.xml
     + 
     + The accumulation buffer is an extended-range color buffer. Images are not rendered into it. Rather, images rendered into one of the color buffers are added to the contents of the accumulation buffer after rendering. Effects such as antialiasing (of points, lines, and polygons), motion blur, and depth of field can be created by accumulating images generated with different transformation matrices. Each pixel in the accumulation buffer consists of red, green, blue, and alpha values. The number of bits per component in the accumulation buffer depends on the implementation. You can examine this number by calling $(D_INLINECODE glGetIntegerv) four times, with arguments $(D_INLINECODE GL_ACCUM_RED_BITS), $(D_INLINECODE GL_ACCUM_GREEN_BITS), $(D_INLINECODE GL_ACCUM_BLUE_BITS), and $(D_INLINECODE GL_ACCUM_ALPHA_BITS). Regardless of the number of bits per component, the range of values stored by each component is -1 1. The accumulation buffer pixels are mapped one-to-one with frame buffer pixels. $(D_INLINECODE glAccum) operates on the accumulation buffer. The first argument, $(D_INLINECODE op), is a symbolic constant that selects an accumulation buffer operation. The second argument, $(D_INLINECODE value), is a floating-point value to be used in that operation. Five operations are specified: $(D_INLINECODE GL_ACCUM), $(D_INLINECODE GL_LOAD), $(D_INLINECODE GL_ADD), $(D_INLINECODE GL_MULT), and $(D_INLINECODE GL_RETURN). All accumulation buffer operations are limited to the area of the current scissor box and applied identically to the red, green, blue, and alpha components of each pixel. If a $(D_INLINECODE glAccum) operation results in a value outside the range -1 1, the contents of an accumulation buffer pixel component are undefined. The operations are as follows: To clear the accumulation buffer, call $(D_INLINECODE glClearAccum) with R, G, B, and A values to set it to, then call $(D_INLINECODE glClear) with the accumulation buffer enabled.
     + 
     + Only pixels within the current scissor box are updated by a $(D_INLINECODE glAccum) operation.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glClear), $(D_INLINECODE glClearAccum), $(D_INLINECODE glCopyPixels), $(D_INLINECODE glDrawBuffer), $(D_INLINECODE glGet), $(D_INLINECODE glReadBuffer), $(D_INLINECODE glReadPixels), $(D_INLINECODE glScissor), $(D_INLINECODE glStencilOp)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glAccum glAccum;
    alias fn_glAlphaFunc = extern(System) void function(GLenum func, GLclampf ref_) @system @nogc nothrow;

    /++
     + glAlphaFunc: man2/glAlphaFunc.xml
     + 
     + The alpha test discards fragments depending on the outcome of a comparison between an incoming fragment's alpha value and a constant reference value. $(D_INLINECODE glAlphaFunc) specifies the reference value and the comparison function. The comparison is performed only if alpha testing is enabled. By default, it is not enabled. (See $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) of $(D_INLINECODE GL_ALPHA_TEST).) $(D_INLINECODE func) and $(D_INLINECODE ref) specify the conditions under which the pixel is drawn. The incoming alpha value is compared to $(D_INLINECODE ref) using the function specified by $(D_INLINECODE func). If the value passes the comparison, the incoming fragment is drawn if it also passes subsequent stencil and depth buffer tests. If the value fails the comparison, no change is made to the frame buffer at that pixel location. The comparison functions are as follows: $(D_INLINECODE glAlphaFunc) operates on all pixel write operations, including those resulting from the scan conversion of points, lines, polygons, and bitmaps, and from pixel draw and copy operations. $(D_INLINECODE glAlphaFunc) does not affect screen clear operations.
     + 
     + Alpha testing is performed only in RGBA mode.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBlendFunc), $(D_INLINECODE glClear), $(D_INLINECODE glDepthFunc), $(D_INLINECODE glEnable), $(D_INLINECODE glStencilFunc)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glAlphaFunc glAlphaFunc;
    alias fn_glAreTexturesResident = extern(System) GLboolean function(GLsizei n, const( GLuint*) textures, GLboolean* residences) @system @nogc nothrow;

    /++
     + glAreTexturesResident: man2/glAreTexturesResident.xml
     + 
     + GL establishes a ``working set'' of textures that are resident in texture memory. These textures can be bound to a texture target much more efficiently than textures that are not resident. $(D_INLINECODE glAreTexturesResident) queries the texture residence status of the $(D_INLINECODE n) textures named by the elements of $(D_INLINECODE textures). If all the named textures are resident, $(D_INLINECODE glAreTexturesResident) returns $(D_INLINECODE GL_TRUE), and the contents of $(D_INLINECODE residences) are undisturbed. If not all the named textures are resident, $(D_INLINECODE glAreTexturesResident) returns $(D_INLINECODE GL_FALSE), and detailed status is returned in the $(D_INLINECODE n) elements of $(D_INLINECODE residences). If an element of $(D_INLINECODE residences) is $(D_INLINECODE GL_TRUE), then the texture named by the corresponding element of $(D_INLINECODE textures) is resident. The residence status of a single bound texture may also be queried by calling $(D_INLINECODE glGetTexParameter) with the argument set to the target to which the texture is bound, and the argument set to $(D_INLINECODE GL_TEXTURE_RESIDENT). This is the only way that the residence status of a default texture can be queried.
     + 
     + $(D_INLINECODE glAreTexturesResident) is available only if the GL version is 1.1 or greater. $(D_INLINECODE glAreTexturesResident) returns the residency status of the textures at the time of invocation. It does not guarantee that the textures will remain resident at any other time. If textures reside in virtual memory (there is no texture memory), they are considered always resident. Some implementations may not load a texture until the first use of that texture.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindTexture), $(D_INLINECODE glGetTexParameter), $(D_INLINECODE glPrioritizeTextures), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    fn_glAreTexturesResident glAreTexturesResident;
    alias fn_glArrayElement = extern(System) void function(GLint i) @system @nogc nothrow;

    /++
     + glArrayElement: man2/glArrayElement.xml
     + 
     + $(D_INLINECODE glArrayElement) commands are used within $(D_INLINECODE glBegin) / $(D_INLINECODE glEnd) pairs to specify vertex and attribute data for point, line, and polygon primitives. If $(D_INLINECODE GL_VERTEX_ARRAY) is enabled when $(D_INLINECODE glArrayElement) is called, a single vertex is drawn, using vertex and attribute data taken from location $(D_INLINECODE i) of the enabled arrays. If $(D_INLINECODE GL_VERTEX_ARRAY) is not enabled, no drawing occurs but the attributes corresponding to the enabled arrays are modified. Use $(D_INLINECODE glArrayElement) to construct primitives by indexing vertex data, rather than by streaming through arrays of data in first-to-last order. Because each call specifies only a single vertex, it is possible to explicitly specify per-primitive attributes such as a single normal for each triangle. Changes made to array data between the execution of $(D_INLINECODE glBegin) and the corresponding execution of $(D_INLINECODE glEnd) may affect calls to $(D_INLINECODE glArrayElement) that are made within the same $(D_INLINECODE glBegin) / $(D_INLINECODE glEnd) period in nonsequential ways. That is, a call to $(D_INLINECODE glArrayElement) that precedes a change to array data may access the changed data, and a call that follows a change to array data may access original data.
     + 
     + $(D_INLINECODE glArrayElement) is available only if the GL version is 1.1 or greater. $(D_INLINECODE glArrayElement) is included in display lists. If $(D_INLINECODE glArrayElement) is entered into a display list, the necessary array data (determined by the array pointers and enables) is also entered into the display list. Because the array pointers and enables are client-side state, their values affect display lists when the lists are created, not when the lists are executed.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glClientActiveTexture), $(D_INLINECODE glColorPointer), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glEdgeFlagPointer), $(D_INLINECODE glFogCoordPointer), $(D_INLINECODE glGetPointerv), $(D_INLINECODE glIndexPointer), $(D_INLINECODE glInterleavedArrays), $(D_INLINECODE glNormalPointer), $(D_INLINECODE glSecondaryColorPointer), $(D_INLINECODE glTexCoordPointer), $(D_INLINECODE glVertexPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    fn_glArrayElement glArrayElement;
    alias fn_glBegin = extern(System) void function(GLenum mode) @system @nogc nothrow;

    /++
     + glBegin: man2/glBegin.xml
     + 
     + $(D_INLINECODE glBegin) and $(D_INLINECODE glEnd) delimit the vertices that define a primitive or a group of like primitives. $(D_INLINECODE glBegin) accepts a single argument that specifies in which of ten ways the vertices are interpreted. Taking n as an integer count starting at one, and N as the total number of vertices specified, the interpretations are as follows: Only a subset of GL commands can be used between $(D_INLINECODE glBegin) and $(D_INLINECODE glEnd). The commands are $(D_INLINECODE glVertex), $(D_INLINECODE glColor), $(D_INLINECODE glSecondaryColor), $(D_INLINECODE glIndex), $(D_INLINECODE glNormal), $(D_INLINECODE glFogCoord), $(D_INLINECODE glTexCoord), $(D_INLINECODE glMultiTexCoord), $(D_INLINECODE glVertexAttrib), $(D_INLINECODE glEvalCoord), $(D_INLINECODE glEvalPoint), $(D_INLINECODE glArrayElement), $(D_INLINECODE glMaterial), and $(D_INLINECODE glEdgeFlag). Also, it is acceptable to use $(D_INLINECODE glCallList) or $(D_INLINECODE glCallLists) to execute display lists that include only the preceding commands. If any other GL command is executed between $(D_INLINECODE glBegin) and $(D_INLINECODE glEnd), the error flag is set and the command is ignored. Regardless of the value chosen for $(D_INLINECODE mode), there is no limit to the number of vertices that can be defined between $(D_INLINECODE glBegin) and $(D_INLINECODE glEnd). Lines, triangles, quadrilaterals, and polygons that are incompletely specified are not drawn. Incomplete specification results when either too few vertices are provided to specify even a single primitive or when an incorrect multiple of vertices is specified. The incomplete primitive is ignored; the rest are drawn. The minimum specification of vertices for each primitive is as follows: 1 for a point, 2 for a line, 3 for a triangle, 4 for a quadrilateral, and 3 for a polygon. Modes that require a certain multiple of vertices are $(D_INLINECODE GL_LINES) (2), $(D_INLINECODE GL_TRIANGLES) (3), $(D_INLINECODE GL_QUADS) (4), and $(D_INLINECODE GL_QUAD_STRIP) (2).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glArrayElement), $(D_INLINECODE glCallList), $(D_INLINECODE glCallLists), $(D_INLINECODE glColor), $(D_INLINECODE glEdgeFlag), $(D_INLINECODE glEvalCoord), $(D_INLINECODE glEvalPoint), $(D_INLINECODE glFogCoord), $(D_INLINECODE glIndex), $(D_INLINECODE glMaterial), $(D_INLINECODE glMultiTexCoord), $(D_INLINECODE glNormal), $(D_INLINECODE glSecondaryColor), $(D_INLINECODE glTexCoord), $(D_INLINECODE glVertex), $(D_INLINECODE glVertexAttrib)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glBegin glBegin;
    alias fn_glEnd = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glEnd glEnd;
    alias fn_glBitmap = extern(System) void function(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const(GLubyte)* bitmap) @system @nogc nothrow;

    /++
     + glBitmap: man2/glBitmap.xml
     + 
     + A bitmap is a binary image. When drawn, the bitmap is positioned relative to the current raster position, and frame buffer pixels corresponding to 1's in the bitmap are written using the current raster color or index. Frame buffer pixels corresponding to 0's in the bitmap are not modified. $(D_INLINECODE glBitmap) takes seven arguments. The first pair specifies the width and height of the bitmap image. The second pair specifies the location of the bitmap origin relative to the lower left corner of the bitmap image. The third pair of arguments specifies and offsets to be added to the current raster position after the bitmap has been drawn. The final argument is a pointer to the bitmap image itself. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a bitmap image is specified, $(D_INLINECODE bitmap) is treated as a byte offset into the buffer object's data store. The bitmap image is interpreted like image data for the $(D_INLINECODE glDrawPixels) command, with $(D_INLINECODE width) and $(D_INLINECODE height) corresponding to the width and height arguments of that command, and with set to $(D_INLINECODE GL_BITMAP) and set to $(D_INLINECODE GL_COLOR_INDEX). Modes specified using $(D_INLINECODE glPixelStore) affect the interpretation of bitmap image data; modes specified using $(D_INLINECODE glPixelTransfer) do not. If the current raster position is invalid, $(D_INLINECODE glBitmap) is ignored. Otherwise, the lower left corner of the bitmap image is positioned at the window coordinates x w = x r - x o y w = y r - y o where x r y r is the raster position and x o y o is the bitmap origin. Fragments are then generated for each pixel corresponding to a 1 (one) in the bitmap image. These fragments are generated using the current raster coordinate, color or color index, and current raster texture coordinates. They are then treated just as if they had been generated by a point, line, or polygon, including texture mapping, fogging, and all per-fragment operations such as alpha and depth testing. After the bitmap has been drawn, the and coordinates of the current raster position are offset by $(D_INLINECODE xmove) and $(D_INLINECODE ymove). No change is made to the coordinate of the current raster position, or to the current raster color, texture coordinates, or index.
     + 
     + To set a valid raster position outside the viewport, first set a valid raster position inside the viewport, then call $(D_INLINECODE glBitmap) with null
     +  as the
     +  $(D_INLINECODE bitmap) parameter and with $(D_INLINECODE xmove) and $(D_INLINECODE ymove) set to the offsets of the new raster position. This technique is useful when panning an image around the viewport.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBindBuffer), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glPixelStore), $(D_INLINECODE glPixelTransfer), $(D_INLINECODE glRasterPos), $(D_INLINECODE glWindowPos)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glBitmap glBitmap;
    alias fn_glCallList = extern(System) void function(GLuint list) @system @nogc nothrow;

    /++
     + glCallList: man2/glCallList.xml
     + 
     + $(D_INLINECODE glCallList) causes the named display list to be executed. The commands saved in the display list are executed in order, just as if they were called without using a display list. If $(D_INLINECODE list) has not been defined as a display list, $(D_INLINECODE glCallList) is ignored. $(D_INLINECODE glCallList) can appear inside a display list. To avoid the possibility of infinite recursion resulting from display lists calling one another, a limit is placed on the nesting level of display lists during display-list execution. This limit is at least 64, and it depends on the implementation. GL state is not saved and restored across a call to $(D_INLINECODE glCallList). Thus, changes made to GL state during the execution of a display list remain after execution of the display list is completed. Use $(D_INLINECODE glPushAttrib), $(D_INLINECODE glPopAttrib), $(D_INLINECODE glPushMatrix), and $(D_INLINECODE glPopMatrix) to preserve GL state across $(D_INLINECODE glCallList) calls.
     + 
     + Display lists can be executed between a call to $(D_INLINECODE glBegin) and the corresponding call to $(D_INLINECODE glEnd), as long as the display list includes only commands that are allowed in this interval.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCallLists), $(D_INLINECODE glDeleteLists), $(D_INLINECODE glGenLists), $(D_INLINECODE glNewList), $(D_INLINECODE glPushAttrib), $(D_INLINECODE glPushMatrix)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glCallList glCallList;
    alias fn_glCallLists = extern(System) void function(GLsizei n, GLenum type, const( GLvoid*) lists) @system @nogc nothrow;

    /++
     + glCallLists: man2/glCallLists.xml
     + 
     + $(D_INLINECODE glCallLists) causes each display list in the list of names passed as $(D_INLINECODE lists) to be executed. As a result, the commands saved in each display list are executed in order, just as if they were called without using a display list. Names of display lists that have not been defined are ignored. $(D_INLINECODE glCallLists) provides an efficient means for executing more than one display list. $(D_INLINECODE type) allows lists with various name formats to be accepted. The formats are as follows: The list of display-list names is not null-terminated. Rather, $(D_INLINECODE n) specifies how many names are to be taken from $(D_INLINECODE lists). An additional level of indirection is made available with the $(D_INLINECODE glListBase) command, which specifies an unsigned offset that is added to each display-list name specified in $(D_INLINECODE lists) before that display list is executed. $(D_INLINECODE glCallLists) can appear inside a display list. To avoid the possibility of infinite recursion resulting from display lists calling one another, a limit is placed on the nesting level of display lists during display-list execution. This limit must be at least 64, and it depends on the implementation. GL state is not saved and restored across a call to $(D_INLINECODE glCallLists). Thus, changes made to GL state during the execution of the display lists remain after execution is completed. Use $(D_INLINECODE glPushAttrib), $(D_INLINECODE glPopAttrib), $(D_INLINECODE glPushMatrix), and $(D_INLINECODE glPopMatrix) to preserve GL state across $(D_INLINECODE glCallLists) calls.
     + 
     + Display lists can be executed between a call to $(D_INLINECODE glBegin) and the corresponding call to $(D_INLINECODE glEnd), as long as the display list includes only commands that are allowed in this interval.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCallList), $(D_INLINECODE glDeleteLists), $(D_INLINECODE glGenLists), $(D_INLINECODE glListBase), $(D_INLINECODE glNewList), $(D_INLINECODE glPushAttrib), $(D_INLINECODE glPushMatrix)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glCallLists glCallLists;
    alias fn_glClearAccum = extern(System) void function(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) @system @nogc nothrow;

    /++
     + glClearAccum: man2/glClearAccum.xml
     + 
     + $(D_INLINECODE glClearAccum) specifies the red, green, blue, and alpha values used by $(D_INLINECODE glClear) to clear the accumulation buffer. Values specified by $(D_INLINECODE glClearAccum) are clamped to the range -1 1.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAccum), $(D_INLINECODE glClear)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glClearAccum glClearAccum;
    alias fn_glClearIndex = extern(System) void function(GLfloat c) @system @nogc nothrow;

    /++
     + glClearIndex: man2/glClearIndex.xml
     + 
     + $(D_INLINECODE glClearIndex) specifies the index used by $(D_INLINECODE glClear) to clear the color index buffers. $(D_INLINECODE c) is not clamped. Rather, $(D_INLINECODE c) is converted to a fixed-point value with unspecified precision to the right of the binary point. The integer part of this value is then masked with 2 m - 1, where m is the number of bits in a color index stored in the frame buffer.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glClear)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glClearIndex glClearIndex;
    alias fn_glClientActiveTexture = extern(System) void function(GLenum texture) @system @nogc nothrow;

    /++
     + glClientActiveTexture: man2/glClientActiveTexture.xml
     + 
     + $(D_INLINECODE glClientActiveTexture) selects the vertex array client state parameters to be modified by $(D_INLINECODE glTexCoordPointer), and enabled or disabled with $(D_INLINECODE glEnableClientState) or $(D_INLINECODE glDisableClientState), respectively, when called with a parameter of $(D_INLINECODE GL_TEXTURE_COORD_ARRAY).
     + 
     + $(D_INLINECODE glClientActiveTexture) is supported only if the GL version is 1.3 or greater, or $(D_INLINECODE ARB_multitexture) is included in the string returned by $(D_INLINECODE glGetString) when called with the argument $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glDisableClientState), $(D_INLINECODE glEnableClientState), $(D_INLINECODE glMultiTexCoord), $(D_INLINECODE glTexCoordPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glClientActiveTexture glClientActiveTexture;
    alias fn_glClipPlane = extern(System) void function(GLenum plane, const( GLdouble*) equation) @system @nogc nothrow;

    /++
     + glClipPlane: man2/glClipPlane.xml
     + 
     + Geometry is always clipped against the boundaries of a six-plane frustum in,, and. $(D_INLINECODE glClipPlane) allows the specification of additional planes, not necessarily perpendicular to the,, or axis, against which all geometry is clipped. To determine the maximum number of additional clipping planes, call $(D_INLINECODE glGetIntegerv) with argument $(D_INLINECODE GL_MAX_CLIP_PLANES). All implementations support at least six such clipping planes. Because the resulting clipping region is the intersection of the defined half-spaces, it is always convex. $(D_INLINECODE glClipPlane) specifies a half-space using a four-component plane equation. When $(D_INLINECODE glClipPlane) is called, $(D_INLINECODE equation) is transformed by the inverse of the modelview matrix and stored in the resulting eye coordinates. Subsequent changes to the modelview matrix have no effect on the stored plane-equation components. If the dot product of the eye coordinates of a vertex with the stored plane equation components is positive or zero, the vertex is with respect to that clipping plane. Otherwise, it is. To enable and disable clipping planes, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with the argument $(D_INLINECODE GL_CLIP_PLANE), where is the plane number. All clipping planes are initially defined as (0, 0, 0, 0) in eye coordinates and are disabled.
     + 
     + It is always the case that $(D_INLINECODE GL_CLIP_PLANE) i = $(D_INLINECODE GL_CLIP_PLANE0) + i.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glEnable)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glClipPlane glClipPlane;
    alias fn_glColor3b = extern(System) void function(GLbyte red, GLbyte green, GLbyte blue) @system @nogc nothrow;

    /++
     + glColor: man2/glColor.xml
     + 
     + The GL stores both a current single-valued color index and a current four-valued RGBA color. $(D_INLINECODE glColor) sets a new four-valued RGBA color. $(D_INLINECODE glColor) has two major variants: $(D_INLINECODE glColor3) and $(D_INLINECODE glColor4). $(D_INLINECODE glColor3) variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. $(D_INLINECODE glColor4) variants specify all four color components explicitly. $(D_INLINECODE glColor3b), $(D_INLINECODE glColor4b), $(D_INLINECODE glColor3s), $(D_INLINECODE glColor4s), $(D_INLINECODE glColor3i), and $(D_INLINECODE glColor4i) take three or four signed byte, short, or long integers as arguments. When $(B v) is appended to the name, the color commands can take a pointer to an array of such values. Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly. Neither floating-point nor signed integer values are clamped to the range 0 1 before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
     + 
     + The initial value for the current color is (1, 1, 1, 1). The current color can be updated at any time. In particular, $(D_INLINECODE glColor) can be called between a call to $(D_INLINECODE glBegin) and the corresponding call to $(D_INLINECODE glEnd).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorPointer), $(D_INLINECODE glIndex), $(D_INLINECODE glSecondaryColor)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glColor3b glColor3b;
    alias fn_glColor3s = extern(System) void function(GLshort red, GLshort green, GLshort blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glColor3s glColor3s;
    alias fn_glColor3i = extern(System) void function(GLint red, GLint green, GLint blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glColor3i glColor3i;
    alias fn_glColor3f = extern(System) void function(GLfloat red, GLfloat green, GLfloat blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glColor3f glColor3f;
    alias fn_glColor3d = extern(System) void function(GLdouble red, GLdouble green, GLdouble blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glColor3d glColor3d;
    alias fn_glColor3ub = extern(System) void function(GLubyte red, GLubyte green, GLubyte blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glColor3ub glColor3ub;
    alias fn_glColor3us = extern(System) void function(GLushort red, GLushort green, GLushort blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glColor3us glColor3us;
    alias fn_glColor3ui = extern(System) void function(GLuint red, GLuint green, GLuint blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glColor3ui glColor3ui;
    alias fn_glColor4b = extern(System) void function(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glColor4b glColor4b;
    alias fn_glColor4s = extern(System) void function(GLshort red, GLshort green, GLshort blue, GLshort alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glColor4s glColor4s;
    alias fn_glColor4i = extern(System) void function(GLint red, GLint green, GLint blue, GLint alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glColor4i glColor4i;
    alias fn_glColor4f = extern(System) void function(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glColor4f glColor4f;
    alias fn_glColor4d = extern(System) void function(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glColor4d glColor4d;
    alias fn_glColor4ub = extern(System) void function(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glColor4ub glColor4ub;
    alias fn_glColor4us = extern(System) void function(GLushort red, GLushort green, GLushort blue, GLushort alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glColor4us glColor4us;
    alias fn_glColor4ui = extern(System) void function(GLuint red, GLuint green, GLuint blue, GLuint alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glColor4ui glColor4ui;
    alias fn_glColor3bv = extern(System) void function(const( GLbyte*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glColor3bv glColor3bv;
    alias fn_glColor3sv = extern(System) void function(const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glColor3sv glColor3sv;
    alias fn_glColor3iv = extern(System) void function(const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glColor3iv glColor3iv;
    alias fn_glColor3fv = extern(System) void function(const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glColor3fv glColor3fv;
    alias fn_glColor3dv = extern(System) void function(const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glColor3dv glColor3dv;
    alias fn_glColor3ubv = extern(System) void function(const(GLubyte)* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glColor3ubv glColor3ubv;
    alias fn_glColor3usv = extern(System) void function(const( GLushort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glColor3usv glColor3usv;
    alias fn_glColor3uiv = extern(System) void function(const( GLuint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glColor3uiv glColor3uiv;
    alias fn_glColor4bv = extern(System) void function(const( GLbyte*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glColor4bv glColor4bv;
    alias fn_glColor4sv = extern(System) void function(const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glColor4sv glColor4sv;
    alias fn_glColor4iv = extern(System) void function(const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glColor4iv glColor4iv;
    alias fn_glColor4fv = extern(System) void function(const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glColor4fv glColor4fv;
    alias fn_glColor4dv = extern(System) void function(const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glColor4dv glColor4dv;
    alias fn_glColor4ubv = extern(System) void function(const(GLubyte)* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glColor4ubv glColor4ubv;
    alias fn_glColor4usv = extern(System) void function(const( GLushort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glColor4usv glColor4usv;
    alias fn_glColor4uiv = extern(System) void function(const( GLuint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glColor4uiv glColor4uiv;
    alias fn_glColorMaterial = extern(System) void function(GLenum face, GLenum mode) @system @nogc nothrow;

    /++
     + glColorMaterial: man2/glColorMaterial.xml
     + 
     + $(D_INLINECODE glColorMaterial) specifies which material parameters track the current color. When $(D_INLINECODE GL_COLOR_MATERIAL) is enabled, the material parameter or parameters specified by $(D_INLINECODE mode), of the material or materials specified by $(D_INLINECODE face), track the current color at all times. To enable and disable $(D_INLINECODE GL_COLOR_MATERIAL), call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_COLOR_MATERIAL). $(D_INLINECODE GL_COLOR_MATERIAL) is initially disabled.
     + 
     + $(D_INLINECODE glColorMaterial) makes it possible to change a subset of material parameters for each vertex using only the $(D_INLINECODE glColor) command, without calling $(D_INLINECODE glMaterial). If only such a subset of parameters is to be specified for each vertex, calling $(D_INLINECODE glColorMaterial) is preferable to calling $(D_INLINECODE glMaterial). Call $(D_INLINECODE glColorMaterial) before enabling $(D_INLINECODE GL_COLOR_MATERIAL). Calling $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawArrays), or $(D_INLINECODE glDrawRangeElements) may leave the current color indeterminate, if the color array is enabled. If $(D_INLINECODE glColorMaterial) is enabled while the current color is indeterminate, the lighting material state specified by $(D_INLINECODE face) and $(D_INLINECODE mode) is also indeterminate. If the GL version is 1.1 or greater, and $(D_INLINECODE GL_COLOR_MATERIAL) is enabled, evaluated color values affect the results of the lighting equation as if the current color were being modified, but no change is made to the tracking lighting parameter of the current color.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColor), $(D_INLINECODE glColorPointer), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glEnable), $(D_INLINECODE glLight), $(D_INLINECODE glLightModel), $(D_INLINECODE glMaterial)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glColorMaterial glColorMaterial;
    alias fn_glColorPointer = extern(System) void function(GLint size, GLenum type, GLsizei stride, const( GLvoid*) pointer) @system @nogc nothrow;

    /++
     + glColorPointer: man2/glColorPointer.xml
     + 
     + $(D_INLINECODE glColorPointer) specifies the location and data format of an array of color components to use when rendering. $(D_INLINECODE size) specifies the number of components per color, and must be 3 or 4. $(D_INLINECODE type) specifies the data type of each color component, and $(D_INLINECODE stride) specifies the byte stride from one color to the next, allowing vertices and attributes to be packed into a single array or stored in separate arrays. (Single-array storage may be more efficient on some implementations; see $(D_INLINECODE glInterleavedArrays).) If a non-zero named buffer object is bound to the $(D_INLINECODE GL_ARRAY_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a color array is specified, $(D_INLINECODE pointer) is treated as a byte offset into the buffer object's data store. Also, the buffer object binding ( $(D_INLINECODE GL_ARRAY_BUFFER_BINDING) ) is saved as color vertex array client-side state ( $(D_INLINECODE GL_COLOR_ARRAY_BUFFER_BINDING) ). When a color array is specified, $(D_INLINECODE size), $(D_INLINECODE type), $(D_INLINECODE stride), and $(D_INLINECODE pointer) are saved as client-side state, in addition to the current vertex array buffer object binding. To enable and disable the color array, call $(D_INLINECODE glEnableClientState) and $(D_INLINECODE glDisableClientState) with the argument $(D_INLINECODE GL_COLOR_ARRAY). If enabled, the color array is used when $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glMultiDrawElements), $(D_INLINECODE glDrawRangeElements), or $(D_INLINECODE glArrayElement) is called.
     + 
     + $(D_INLINECODE glColorPointer) is available only if the GL version is 1.1 or greater. The color array is initially disabled and isn't accessed when $(D_INLINECODE glArrayElement), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), or $(D_INLINECODE glMultiDrawElements) is called. Execution of $(D_INLINECODE glColorPointer) is not allowed between the execution of $(D_INLINECODE glBegin) and the corresponding execution of $(D_INLINECODE glEnd), but an error may or may not be generated. If no error is generated, the operation is undefined. $(D_INLINECODE glColorPointer) is typically implemented on the client side. Color array parameters are client-side state and are therefore not saved or restored by $(D_INLINECODE glPushAttrib) and $(D_INLINECODE glPopAttrib). Use $(D_INLINECODE glPushClientAttrib) and $(D_INLINECODE glPopClientAttrib) instead.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glArrayElement), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glColor), $(D_INLINECODE glDisableClientState), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glEdgeFlagPointer), $(D_INLINECODE glEnableClientState), $(D_INLINECODE glFogCoordPointer), $(D_INLINECODE glIndexPointer), $(D_INLINECODE glInterleavedArrays), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glMultiDrawElements), $(D_INLINECODE glNormalPointer), $(D_INLINECODE glPopClientAttrib), $(D_INLINECODE glPushClientAttrib), $(D_INLINECODE glSecondaryColorPointer), $(D_INLINECODE glTexCoordPointer), $(D_INLINECODE glVertexAttribPointer), $(D_INLINECODE glVertexPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    fn_glColorPointer glColorPointer;
    alias fn_glColorSubTable = extern(System) void function(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const( GLvoid*) data) @system @nogc nothrow;

    /++
     + glColorSubTable: man2/glColorSubTable.xml
     + 
     + $(D_INLINECODE glColorSubTable) is used to respecify a contiguous portion of a color table previously defined using $(D_INLINECODE glColorTable).  The pixels referenced by $(D_INLINECODE data) replace the portion of the existing table from indices $(D_INLINECODE start) to start + count - 1, inclusive.  This region may not include any entries outside the range of the color table as it was originally specified. It is not an error to specify a subtexture with width of 0, but such a specification has no effect. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a portion of a color table is respecified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store.
     + 
     + $(D_INLINECODE glColorSubTable) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorTable), $(D_INLINECODE glColorTableParameter), $(D_INLINECODE glCopyColorTable), $(D_INLINECODE glCopyColorSubTable), $(D_INLINECODE glGetColorTable)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    fn_glColorSubTable glColorSubTable;
    alias fn_glColorTable = extern(System) void function(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const( GLvoid*) data) @system @nogc nothrow;

    /++
     + glColorTable: man2/glColorTable.xml
     + 
     + $(D_INLINECODE glColorTable) may be used in two ways: to test the actual size and color resolution of a lookup table given a particular set of parameters, or to load the contents of a color lookup table. Use the targets $(D_INLINECODE GL_PROXY_*) for the first case and the other targets for the second case. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a color table is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store. If $(D_INLINECODE target) is $(D_INLINECODE GL_COLOR_TABLE), $(D_INLINECODE GL_POST_CONVOLUTION_COLOR_TABLE), or $(D_INLINECODE GL_POST_COLOR_MATRIX_COLOR_TABLE), $(D_INLINECODE glColorTable) builds a color lookup table from an array of pixels. The pixel array specified by $(D_INLINECODE width), $(D_INLINECODE format), $(D_INLINECODE type), and $(D_INLINECODE data) is extracted from memory and processed just as if $(D_INLINECODE glDrawPixels) were called, but processing stops after the final expansion to RGBA is completed. The four scale parameters and the four bias parameters that are defined for the table are then used to scale and bias the R, G, B, and A components of each pixel. (Use $(D_INLINECODE glColorTableParameter) to set these scale and bias parameters.) Next, the R, G, B, and A values are clamped to the range 0 1. Each pixel is then converted to the internal format specified by $(D_INLINECODE internalformat). This conversion simply maps the component values of the pixel (R, G, B, and A) to the values included in the internal format (red, green, blue, alpha, luminance, and intensity).  The mapping is as follows: $(B Internal Format) $(B Red) $(B Green) $(B Blue) $(B Alpha) $(B Luminance) $(B Intensity) $(D_INLINECODE GL_ALPHA) A $(D_INLINECODE GL_LUMINANCE) R $(D_INLINECODE GL_LUMINANCE_ALPHA) A R $(D_INLINECODE GL_INTENSITY) R $(D_INLINECODE GL_RGB) R G B $(D_INLINECODE GL_RGBA) R G B A Finally, the red, green, blue, alpha, luminance, and/or intensity components of the resulting pixels are stored in the color table. They form a one-dimensional table with indices in the range 0 width - 1. If $(D_INLINECODE target) is $(D_INLINECODE GL_PROXY_*), $(D_INLINECODE glColorTable) recomputes and stores the values of the proxy color table's state variables $(D_INLINECODE GL_COLOR_TABLE_FORMAT), $(D_INLINECODE GL_COLOR_TABLE_WIDTH), $(D_INLINECODE GL_COLOR_TABLE_RED_SIZE), $(D_INLINECODE GL_COLOR_TABLE_GREEN_SIZE), $(D_INLINECODE GL_COLOR_TABLE_BLUE_SIZE), $(D_INLINECODE GL_COLOR_TABLE_ALPHA_SIZE), $(D_INLINECODE GL_COLOR_TABLE_LUMINANCE_SIZE), and $(D_INLINECODE GL_COLOR_TABLE_INTENSITY_SIZE). There is no effect on the image or state of any actual color table. If the specified color table is too large to be supported, then all the proxy state variables listed above are set to zero. Otherwise, the color table could be supported by $(D_INLINECODE glColorTable) using the corresponding non-proxy target, and the proxy state variables are set as if that target were being defined. The proxy state variables can be retrieved by calling $(D_INLINECODE glGetColorTableParameter) with a target of $(D_INLINECODE GL_PROXY_*). This allows the application to decide if a particular $(D_INLINECODE glColorTable) command would succeed, and to determine what the resulting color table attributes would be. If a color table is enabled, and its width is non-zero, then its contents are used to replace a subset of the components of each RGBA pixel group, based on the internal format of the table. Each pixel group has color components (R, G, B, A) that are in the range 0.0 1.0. The color components are rescaled to the size of the color lookup table to form an index. Then a subset of the components based on the internal format of the table are replaced by the table entry selected by that index. If the color components and contents of the table are represented as follows: $(B Representation) $(B Meaning) $(D_INLINECODE r) Table index computed from $(D_INLINECODE R) $(D_INLINECODE g) Table index computed from $(D_INLINECODE G) $(D_INLINECODE b) Table index computed from $(D_INLINECODE B) $(D_INLINECODE a) Table index computed from $(D_INLINECODE A) $(D_INLINECODE L[i]) Luminance value at table index $(D_INLINECODE i) $(D_INLINECODE I[i]) Intensity value at table index $(D_INLINECODE i) $(D_INLINECODE R[i]) Red value at table index $(D_INLINECODE i) $(D_INLINECODE G[i]) Green value at table index $(D_INLINECODE i) $(D_INLINECODE B[i]) Blue value at table index $(D_INLINECODE i) $(D_INLINECODE A[i]) Alpha value at table index $(D_INLINECODE i) then the result of color table lookup is as follows: $(B Resulting Texture Components) $(B Table Internal Format) $(B R) $(B G) $(B B) $(B A) $(D_INLINECODE GL_ALPHA) $(D_INLINECODE R) $(D_INLINECODE G) $(D_INLINECODE B) $(D_INLINECODE A[a]) $(D_INLINECODE GL_LUMINANCE) $(D_INLINECODE L[r]) $(D_INLINECODE L[g]) $(D_INLINECODE L[b]) $(D_INLINECODE At) $(D_INLINECODE GL_LUMINANCE_ALPHA) $(D_INLINECODE L[r]) $(D_INLINECODE L[g]) $(D_INLINECODE L[b]) $(D_INLINECODE A[a]) $(D_INLINECODE GL_INTENSITY) $(D_INLINECODE I[r]) $(D_INLINECODE I[g]) $(D_INLINECODE I[b]) $(D_INLINECODE I[a]) $(D_INLINECODE GL_RGB) $(D_INLINECODE R[r]) $(D_INLINECODE G[g]) $(D_INLINECODE B[b]) $(D_INLINECODE A) $(D_INLINECODE GL_RGBA) $(D_INLINECODE R[r]) $(D_INLINECODE G[g]) $(D_INLINECODE B[b]) $(D_INLINECODE A[a]) When $(D_INLINECODE GL_COLOR_TABLE) is enabled, the colors resulting from the pixel map operation (if it is enabled) are mapped by the color lookup table before being passed to the convolution operation. The colors resulting from the convolution operation are modified by the post convolution color lookup table when $(D_INLINECODE GL_POST_CONVOLUTION_COLOR_TABLE) is enabled. These modified colors are then sent to the color matrix operation. Finally, if $(D_INLINECODE GL_POST_COLOR_MATRIX_COLOR_TABLE) is enabled, the colors resulting from the color matrix operation are mapped by the post color matrix color lookup table before being used by the histogram operation.
     + 
     + $(D_INLINECODE glColorTable) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS). If $(D_INLINECODE target) is set to $(D_INLINECODE GL_COLOR_TABLE), $(D_INLINECODE GL_POST_CONVOLUTION_COLOR_TABLE), or $(D_INLINECODE GL_POST_COLOR_MATRIX_COLOR_TABLE), then $(D_INLINECODE width) must be a power of two or a $(D_INLINECODE GL_INVALID_VALUE) error is generated.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorSubTable), $(D_INLINECODE glColorTableParameter), $(D_INLINECODE glCopyColorTable), $(D_INLINECODE glCopyColorSubTable), $(D_INLINECODE glGetColorTable)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    fn_glColorTable glColorTable;
    alias fn_glColorTableParameterfv = extern(System) void function(GLenum target, GLenum pname, const( GLfloat*) params) @system @nogc nothrow;

    /++
     + glColorTableParameter: man2/glColorTableParameter.xml
     + 
     + $(D_INLINECODE glColorTableParameter) is used to specify the scale factors and bias terms applied to color components when they are loaded into a color table. $(D_INLINECODE target) indicates which color table the scale and bias terms apply to; it must be set to $(D_INLINECODE GL_COLOR_TABLE), $(D_INLINECODE GL_POST_CONVOLUTION_COLOR_TABLE), or $(D_INLINECODE GL_POST_COLOR_MATRIX_COLOR_TABLE). $(D_INLINECODE pname) must be $(D_INLINECODE GL_COLOR_TABLE_SCALE) to set the scale factors. In this case, $(D_INLINECODE params) points to an array of four values, which are the scale factors for red, green, blue, and alpha, in that order. $(D_INLINECODE pname) must be $(D_INLINECODE GL_COLOR_TABLE_BIAS) to set the bias terms. In this case, $(D_INLINECODE params) points to an array of four values, which are the bias terms for red, green, blue, and alpha, in that order. The color tables themselves are specified by calling $(D_INLINECODE glColorTable).
     + 
     + $(D_INLINECODE glColorTableParameter) is available only if $(D_INLINECODE ARB_imaging) is returned from calling $(D_INLINECODE glGetString) with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorTable), $(D_INLINECODE glPixelTransfer)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    fn_glColorTableParameterfv glColorTableParameterfv;
    alias fn_glColorTableParameteriv = extern(System) void function(GLenum target, GLenum pname, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    fn_glColorTableParameteriv glColorTableParameteriv;
    alias fn_glConvolutionFilter1D = extern(System) void function(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const( GLvoid*) data) @system @nogc nothrow;

    /++
     + glConvolutionFilter1D: man2/glConvolutionFilter1D.xml
     + 
     + $(D_INLINECODE glConvolutionFilter1D) builds a one-dimensional convolution filter kernel from an array of pixels. The pixel array specified by $(D_INLINECODE width), $(D_INLINECODE format), $(D_INLINECODE type), and $(D_INLINECODE data) is extracted from memory and processed just as if $(D_INLINECODE glDrawPixels) were called, but processing stops after the final expansion to RGBA is completed. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a convolution filter is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store. The R, G, B, and A components of each pixel are next scaled by the four 1D $(D_INLINECODE GL_CONVOLUTION_FILTER_SCALE) parameters and biased by the four 1D $(D_INLINECODE GL_CONVOLUTION_FILTER_BIAS) parameters. (The scale and bias parameters are set by $(D_INLINECODE glConvolutionParameter) using the $(D_INLINECODE GL_CONVOLUTION_1D) target and the names $(D_INLINECODE GL_CONVOLUTION_FILTER_SCALE) and $(D_INLINECODE GL_CONVOLUTION_FILTER_BIAS). The parameters themselves are vectors of four values that are applied to red, green, blue, and alpha, in that order.) The R, G, B, and A values are not clamped to [0,1] at any time during this process. Each pixel is then converted to the internal format specified by $(D_INLINECODE internalformat). This conversion simply maps the component values of the pixel (R, G, B, and A) to the values included in the internal format (red, green, blue, alpha, luminance, and intensity).  The mapping is as follows: $(B Internal Format) $(B Red) $(B Green) $(B Blue) $(B Alpha) $(B Luminance) $(B Intensity) $(D_INLINECODE GL_ALPHA) A $(D_INLINECODE GL_LUMINANCE) R $(D_INLINECODE GL_LUMINANCE_ALPHA) A R $(D_INLINECODE GL_INTENSITY) R $(D_INLINECODE GL_RGB) R G B $(D_INLINECODE GL_RGBA) R G B A The red, green, blue, alpha, luminance, and/or intensity components of the resulting pixels are stored in floating-point rather than integer format. They form a one-dimensional filter kernel image indexed with coordinate such that starts at 0 and increases from left to right. Kernel location is derived from the th pixel, counting from 0. Note that after a convolution is performed, the resulting color components are also scaled by their corresponding $(D_INLINECODE GL_POST_CONVOLUTION_c_SCALE) parameters and biased by their corresponding $(D_INLINECODE GL_POST_CONVOLUTION_c_BIAS) parameters (where takes on the values $(B RED), $(B GREEN), $(B BLUE), and $(B ALPHA) ). These parameters are set by $(D_INLINECODE glPixelTransfer).
     + 
     + $(D_INLINECODE glConvolutionFilter1D) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glConvolutionFilter2D), $(D_INLINECODE glSeparableFilter2D), $(D_INLINECODE glConvolutionParameter), $(D_INLINECODE glPixelTransfer)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    fn_glConvolutionFilter1D glConvolutionFilter1D;
    alias fn_glConvolutionFilter2D = extern(System) void function(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const( GLvoid*) data) @system @nogc nothrow;

    /++
     + glConvolutionFilter2D: man2/glConvolutionFilter2D.xml
     + 
     + $(D_INLINECODE glConvolutionFilter2D) builds a two-dimensional convolution filter kernel from an array of pixels. The pixel array specified by $(D_INLINECODE width), $(D_INLINECODE height), $(D_INLINECODE format), $(D_INLINECODE type), and $(D_INLINECODE data) is extracted from memory and processed just as if $(D_INLINECODE glDrawPixels) were called, but processing stops after the final expansion to RGBA is completed. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a convolution filter is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store. The R, G, B, and A components of each pixel are next scaled by the four 2D $(D_INLINECODE GL_CONVOLUTION_FILTER_SCALE) parameters and biased by the four 2D $(D_INLINECODE GL_CONVOLUTION_FILTER_BIAS) parameters. (The scale and bias parameters are set by $(D_INLINECODE glConvolutionParameter) using the $(D_INLINECODE GL_CONVOLUTION_2D) target and the names $(D_INLINECODE GL_CONVOLUTION_FILTER_SCALE) and $(D_INLINECODE GL_CONVOLUTION_FILTER_BIAS). The parameters themselves are vectors of four values that are applied to red, green, blue, and alpha, in that order.) The R, G, B, and A values are not clamped to [0,1] at any time during this process. Each pixel is then converted to the internal format specified by $(D_INLINECODE internalformat). This conversion simply maps the component values of the pixel (R, G, B, and A) to the values included in the internal format (red, green, blue, alpha, luminance, and intensity).  The mapping is as follows: $(B Internal Format) $(B Red) $(B Green) $(B Blue) $(B Alpha) $(B Luminance) $(B Intensity) $(D_INLINECODE GL_ALPHA) A $(D_INLINECODE GL_LUMINANCE) R $(D_INLINECODE GL_LUMINANCE_ALPHA) A R $(D_INLINECODE GL_INTENSITY) R $(D_INLINECODE GL_RGB) R G B $(D_INLINECODE GL_RGBA) R G B A The red, green, blue, alpha, luminance, and/or intensity components of the resulting pixels are stored in floating-point rather than integer format. They form a two-dimensional filter kernel image indexed with coordinates and such that starts at zero and increases from left to right, and starts at zero and increases from bottom to top. Kernel location is derived from the th pixel, where is + * $(D_INLINECODE width). Note that after a convolution is performed, the resulting color components are also scaled by their corresponding $(D_INLINECODE GL_POST_CONVOLUTION_c_SCALE) parameters and biased by their corresponding $(D_INLINECODE GL_POST_CONVOLUTION_c_BIAS) parameters (where takes on the values $(B RED), $(B GREEN), $(B BLUE), and $(B ALPHA) ). These parameters are set by $(D_INLINECODE glPixelTransfer).
     + 
     + $(D_INLINECODE glConvolutionFilter2D) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glSeparableFilter2D), $(D_INLINECODE glConvolutionParameter), $(D_INLINECODE glPixelTransfer)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    fn_glConvolutionFilter2D glConvolutionFilter2D;
    alias fn_glConvolutionParameterf = extern(System) void function(GLenum target, GLenum pname, GLfloat params) @system @nogc nothrow;

    /++
     + glConvolutionParameter: man2/glConvolutionParameter.xml
     + 
     + $(D_INLINECODE glConvolutionParameter) sets the value of a convolution parameter. $(D_INLINECODE target) selects the convolution filter to be affected: $(D_INLINECODE GL_CONVOLUTION_1D), $(D_INLINECODE GL_CONVOLUTION_2D), or $(D_INLINECODE GL_SEPARABLE_2D) for the 1D, 2D, or separable 2D filter, respectively. $(D_INLINECODE pname) selects the parameter to be changed. $(D_INLINECODE GL_CONVOLUTION_FILTER_SCALE) and $(D_INLINECODE GL_CONVOLUTION_FILTER_BIAS) affect the definition of the convolution filter kernel; see $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glConvolutionFilter2D), and $(D_INLINECODE glSeparableFilter2D) for details. In these cases, $(D_INLINECODE params) v is an array of four values to be applied to red, green, blue, and alpha values, respectively. The initial value for $(D_INLINECODE GL_CONVOLUTION_FILTER_SCALE) is (1, 1, 1, 1), and the initial value for $(D_INLINECODE GL_CONVOLUTION_FILTER_BIAS) is (0, 0, 0, 0). A $(D_INLINECODE pname) value of $(D_INLINECODE GL_CONVOLUTION_BORDER_MODE) controls the convolution border mode. The accepted modes are:
     + 
     + $(D_INLINECODE glConvolutionParameter) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS). In cases where errors can result from the specification of invalid image dimensions, it is the dimensions after convolution that are tested, not the dimensions of the source image. For example, $(D_INLINECODE glTexImage1D) requires power-of-two image size. When $(D_INLINECODE GL_REDUCE) border mode is in effect, the source image must be larger than the final power-of-two size by one less than the size of the 1D filter kernel.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glConvolutionFilter2D), $(D_INLINECODE glSeparableFilter2D), $(D_INLINECODE glGetConvolutionParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    fn_glConvolutionParameterf glConvolutionParameterf;
    alias fn_glConvolutionParameteri = extern(System) void function(GLenum target, GLenum pname, GLint params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    fn_glConvolutionParameteri glConvolutionParameteri;
    alias fn_glConvolutionParameterfv = extern(System) void function(GLenum target, GLenum pname, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    fn_glConvolutionParameterfv glConvolutionParameterfv;
    alias fn_glConvolutionParameteriv = extern(System) void function(GLenum target, GLenum pname, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    fn_glConvolutionParameteriv glConvolutionParameteriv;
    alias fn_glCopyColorSubTable = extern(System) void function(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width) @system @nogc nothrow;

    /++
     + glCopyColorSubTable: man2/glCopyColorSubTable.xml
     + 
     + $(D_INLINECODE glCopyColorSubTable) is used to respecify a contiguous portion of a color table previously defined using $(D_INLINECODE glColorTable).  The pixels copied from the framebuffer replace the portion of the existing table from indices $(D_INLINECODE start) to start + x - 1, inclusive.  This region may not include any entries outside the range of the color table, as was originally specified. It is not an error to specify a subtexture with width of 0, but such a specification has no effect.
     + 
     + $(D_INLINECODE glCopyColorSubTable) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorSubTable), $(D_INLINECODE glColorTableParameter), $(D_INLINECODE glCopyColorTable), $(D_INLINECODE glCopyColorSubTable), $(D_INLINECODE glGetColorTable)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    fn_glCopyColorSubTable glCopyColorSubTable;
    alias fn_glCopyColorTable = extern(System) void function(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) @system @nogc nothrow;

    /++
     + glCopyColorTable: man2/glCopyColorTable.xml
     + 
     + $(D_INLINECODE glCopyColorTable) loads a color table with pixels from the current $(D_INLINECODE GL_READ_BUFFER) (rather than from main memory, as is the case for $(D_INLINECODE glColorTable) ). The screen-aligned pixel rectangle with lower-left corner at ( $(D_INLINECODE x),\ $(D_INLINECODE y) ) having width $(D_INLINECODE width) and height 1 is loaded into the color table. If any pixels within this region are outside the window that is associated with the GL context, the values obtained for those pixels are undefined. The pixels in the rectangle are processed just as if $(D_INLINECODE glReadPixels) were called, with $(D_INLINECODE internalformat) set to RGBA, but processing stops after the final conversion to RGBA. The four scale parameters and the four bias parameters that are defined for the table are then used to scale and bias the R, G, B, and A components of each pixel. The scale and bias parameters are set by calling $(D_INLINECODE glColorTableParameter). Next, the R, G, B, and A values are clamped to the range 0 1. Each pixel is then converted to the internal format specified by $(D_INLINECODE internalformat). This conversion simply maps the component values of the pixel (R, G, B, and A) to the values included in the internal format (red, green, blue, alpha, luminance, and intensity).  The mapping is as follows: $(B Internal Format) $(B Red) $(B Green) $(B Blue) $(B Alpha) $(B Luminance) $(B Intensity) $(D_INLINECODE GL_ALPHA) A $(D_INLINECODE GL_LUMINANCE) R $(D_INLINECODE GL_LUMINANCE_ALPHA) A R $(D_INLINECODE GL_INTENSITY) R $(D_INLINECODE GL_RGB) R G B $(D_INLINECODE GL_RGBA) R G B A Finally, the red, green, blue, alpha, luminance, and/or intensity components of the resulting pixels are stored in the color table. They form a one-dimensional table with indices in the range 0 width - 1.
     + 
     + $(D_INLINECODE glCopyColorTable) is available only if $(D_INLINECODE ARB_imaging) is returned from calling $(D_INLINECODE glGetString) with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorTable), $(D_INLINECODE glColorTableParameter), $(D_INLINECODE glReadPixels)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    fn_glCopyColorTable glCopyColorTable;
    alias fn_glCopyConvolutionFilter1D = extern(System) void function(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) @system @nogc nothrow;

    /++
     + glCopyConvolutionFilter1D: man2/glCopyConvolutionFilter1D.xml
     + 
     + $(D_INLINECODE glCopyConvolutionFilter1D) defines a one-dimensional convolution filter kernel with pixels from the current $(D_INLINECODE GL_READ_BUFFER) (rather than from main memory, as is the case for $(D_INLINECODE glConvolutionFilter1D) ). The screen-aligned pixel rectangle with lower-left corner at ( $(D_INLINECODE x),\ $(D_INLINECODE y) ), width $(D_INLINECODE width) and height 1 is used to define the convolution filter.  If any pixels within this region are outside the window that is associated with the GL context, the values obtained for those pixels are undefined. The pixels in the rectangle are processed exactly as if $(D_INLINECODE glReadPixels) had been called with set to RGBA, but the process stops just before final conversion. The R, G, B, and A components of each pixel are next scaled by the four 1D $(D_INLINECODE GL_CONVOLUTION_FILTER_SCALE) parameters and biased by the four 1D $(D_INLINECODE GL_CONVOLUTION_FILTER_BIAS) parameters. (The scale and bias parameters are set by $(D_INLINECODE glConvolutionParameter) using the $(D_INLINECODE GL_CONVOLUTION_1D) target and the names $(D_INLINECODE GL_CONVOLUTION_FILTER_SCALE) and $(D_INLINECODE GL_CONVOLUTION_FILTER_BIAS). The parameters themselves are vectors of four values that are applied to red, green, blue, and alpha, in that order.) The R, G, B, and A values are not clamped to [0,1] at any time during this process. Each pixel is then converted to the internal format specified by $(D_INLINECODE internalformat). This conversion simply maps the component values of the pixel (R, G, B, and A) to the values included in the internal format (red, green, blue, alpha, luminance, and intensity).  The mapping is as follows: $(B Internal Format) $(B Red) $(B Green) $(B Blue) $(B Alpha) $(B Luminance) $(B Intensity) $(D_INLINECODE GL_ALPHA) A $(D_INLINECODE GL_LUMINANCE) R $(D_INLINECODE GL_LUMINANCE_ALPHA) A R $(D_INLINECODE GL_INTENSITY) R $(D_INLINECODE GL_RGB) R G B $(D_INLINECODE GL_RGBA) R G B A The red, green, blue, alpha, luminance, and/or intensity components of the resulting pixels are stored in floating-point rather than integer format. Pixel ordering is such that lower x screen coordinates correspond to lower filter image coordinates. Note that after a convolution is performed, the resulting color components are also scaled by their corresponding $(D_INLINECODE GL_POST_CONVOLUTION_c_SCALE) parameters and biased by their corresponding $(D_INLINECODE GL_POST_CONVOLUTION_c_BIAS) parameters (where takes on the values $(B RED), $(B GREEN), $(B BLUE), and $(B ALPHA) ). These parameters are set by $(D_INLINECODE glPixelTransfer).
     + 
     + $(D_INLINECODE glCopyConvolutionFilter1D) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glConvolutionParameter), $(D_INLINECODE glPixelTransfer)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    fn_glCopyConvolutionFilter1D glCopyConvolutionFilter1D;
    alias fn_glCopyConvolutionFilter2D = extern(System) void function(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;

    /++
     + glCopyConvolutionFilter2D: man2/glCopyConvolutionFilter2D.xml
     + 
     + $(D_INLINECODE glCopyConvolutionFilter2D) defines a two-dimensional convolution filter kernel with pixels from the current $(D_INLINECODE GL_READ_BUFFER) (rather than from main memory, as is the case for $(D_INLINECODE glConvolutionFilter2D) ). The screen-aligned pixel rectangle with lower-left corner at ( $(D_INLINECODE x),\ $(D_INLINECODE y) ), width $(D_INLINECODE width) and height $(D_INLINECODE height) is used to define the convolution filter. If any pixels within this region are outside the window that is associated with the GL context, the values obtained for those pixels are undefined. The pixels in the rectangle are processed exactly as if $(D_INLINECODE glReadPixels) had been called with set to RGBA, but the process stops just before final conversion. The R, G, B, and A components of each pixel are next scaled by the four 2D $(D_INLINECODE GL_CONVOLUTION_FILTER_SCALE) parameters and biased by the four 2D $(D_INLINECODE GL_CONVOLUTION_FILTER_BIAS) parameters. (The scale and bias parameters are set by $(D_INLINECODE glConvolutionParameter) using the $(D_INLINECODE GL_CONVOLUTION_2D) target and the names $(D_INLINECODE GL_CONVOLUTION_FILTER_SCALE) and $(D_INLINECODE GL_CONVOLUTION_FILTER_BIAS). The parameters themselves are vectors of four values that are applied to red, green, blue, and alpha, in that order.) The R, G, B, and A values are not clamped to [0,1] at any time during this process. Each pixel is then converted to the internal format specified by $(D_INLINECODE internalformat). This conversion simply maps the component values of the pixel (R, G, B, and A) to the values included in the internal format (red, green, blue, alpha, luminance, and intensity).  The mapping is as follows: $(B Internal Format) $(B Red) $(B Green) $(B Blue) $(B Alpha) $(B Luminance) $(B Intensity) $(D_INLINECODE GL_ALPHA) A $(D_INLINECODE GL_LUMINANCE) R $(D_INLINECODE GL_LUMINANCE_ALPHA) A R $(D_INLINECODE GL_INTENSITY) R $(D_INLINECODE GL_RGB) R G B $(D_INLINECODE GL_RGBA) R G B A The red, green, blue, alpha, luminance, and/or intensity components of the resulting pixels are stored in floating-point rather than integer format. Pixel ordering is such that lower x screen coordinates correspond to lower filter image coordinates, and lower y screen coordinates correspond to lower filter image coordinates. Note that after a convolution is performed, the resulting color components are also scaled by their corresponding $(D_INLINECODE GL_POST_CONVOLUTION_c_SCALE) parameters and biased by their corresponding $(D_INLINECODE GL_POST_CONVOLUTION_c_BIAS) parameters (where takes on the values $(B RED), $(B GREEN), $(B BLUE), and $(B ALPHA) ). These parameters are set by $(D_INLINECODE glPixelTransfer).
     + 
     + $(D_INLINECODE glCopyConvolutionFilter2D) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glConvolutionFilter2D), $(D_INLINECODE glConvolutionParameter), $(D_INLINECODE glPixelTransfer)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    fn_glCopyConvolutionFilter2D glCopyConvolutionFilter2D;
    alias fn_glCopyPixels = extern(System) void function(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type) @system @nogc nothrow;

    /++
     + glCopyPixels: man2/glCopyPixels.xml
     + 
     + $(D_INLINECODE glCopyPixels) copies a screen-aligned rectangle of pixels from the specified frame buffer location to a region relative to the current raster position. Its operation is well defined only if the entire pixel source region is within the exposed portion of the window. Results of copies from outside the window, or from regions of the window that are not exposed, are hardware dependent and undefined. $(D_INLINECODE x) and $(D_INLINECODE y) specify the window coordinates of the lower left corner of the rectangular region to be copied. $(D_INLINECODE width) and $(D_INLINECODE height) specify the dimensions of the rectangular region to be copied. Both $(D_INLINECODE width) and $(D_INLINECODE height) must not be negative. Several parameters control the processing of the pixel data while it is being copied. These parameters are set with three commands: $(D_INLINECODE glPixelTransfer), $(D_INLINECODE glPixelMap), and $(D_INLINECODE glPixelZoom). This reference page describes the effects on $(D_INLINECODE glCopyPixels) of most, but not all, of the parameters specified by these three commands. $(D_INLINECODE glCopyPixels) copies values from each pixel with the lower left-hand corner at x + i y + j for 0 &lt;= i &lt; width and 0 &lt;= j &lt; height. This pixel is said to be the i th pixel in the j th row. Pixels are copied in row order from the lowest to the highest row, left to right in each row. $(D_INLINECODE type) specifies whether color, depth, or stencil data is to be copied. The details of the transfer for each data type are as follows: The rasterization described thus far assumes pixel zoom factors of 1.0. If $(D_INLINECODE glPixelZoom) is used to change the x and y pixel zoom factors, pixels are converted to fragments as follows. If x r y r is the current raster position, and a given pixel is in the i th location in the j th row of the source pixel rectangle, then fragments are generated for pixels whose centers are in the rectangle with corners at x r + zoom x &it; i y r + zoom y &it; j and x r + zoom x &af; i + 1 y r + zoom y &af; j + 1 where zoom x is the value of $(D_INLINECODE GL_ZOOM_X) and zoom y is the value of $(D_INLINECODE GL_ZOOM_Y).
     + 
     + Modes specified by $(D_INLINECODE glPixelStore) have no effect on the operation of $(D_INLINECODE glCopyPixels).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorTable), $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glConvolutionFilter2D), $(D_INLINECODE glDepthFunc), $(D_INLINECODE glDrawBuffer), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glMatrixMode), $(D_INLINECODE glPixelMap), $(D_INLINECODE glPixelTransfer), $(D_INLINECODE glPixelZoom), $(D_INLINECODE glRasterPos), $(D_INLINECODE glReadBuffer), $(D_INLINECODE glReadPixels), $(D_INLINECODE glSeparableFilter2D), $(D_INLINECODE glStencilFunc), $(D_INLINECODE glWindowPos)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glCopyPixels glCopyPixels;
    alias fn_glDeleteLists = extern(System) void function(GLuint list, GLsizei range) @system @nogc nothrow;

    /++
     + glDeleteLists: man2/glDeleteLists.xml
     + 
     + $(D_INLINECODE glDeleteLists) causes a contiguous group of display lists to be deleted. $(D_INLINECODE list) is the name of the first display list to be deleted, and $(D_INLINECODE range) is the number of display lists to delete. All display lists d with list &lt;= d &lt;= list + range - 1 are deleted. All storage locations allocated to the specified display lists are freed, and the names are available for reuse at a later time. Names within the range that do not have an associated display list are ignored. If $(D_INLINECODE range) is 0, nothing happens.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCallList), $(D_INLINECODE glCallLists), $(D_INLINECODE glGenLists), $(D_INLINECODE glIsList), $(D_INLINECODE glNewList)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glDeleteLists glDeleteLists;
    alias fn_glDrawPixels = extern(System) void function(GLsizei width, GLsizei height, GLenum format, GLenum type, const( GLvoid*) data) @system @nogc nothrow;

    /++
     + glDrawPixels: man2/glDrawPixels.xml
     + 
     + $(D_INLINECODE glDrawPixels) reads pixel data from memory and writes it into the frame buffer relative to the current raster position, provided that the raster position is valid.  Use $(D_INLINECODE glRasterPos) or $(D_INLINECODE glWindowPos) to set the current raster position; use $(D_INLINECODE glGet) with argument $(D_INLINECODE GL_CURRENT_RASTER_POSITION_VALID) to determine if the specified raster position is valid, and $(D_INLINECODE glGet) with argument $(D_INLINECODE GL_CURRENT_RASTER_POSITION) to query the raster position. Several parameters define the encoding of pixel data in memory and control the processing of the pixel data before it is placed in the frame buffer. These parameters are set with four commands: $(D_INLINECODE glPixelStore), $(D_INLINECODE glPixelTransfer), $(D_INLINECODE glPixelMap), and $(D_INLINECODE glPixelZoom). This reference page describes the effects on $(D_INLINECODE glDrawPixels) of many, but not all, of the parameters specified by these four commands. Data is read from $(D_INLINECODE data) as a sequence of signed or unsigned bytes, signed or unsigned shorts, signed or unsigned integers, or single-precision floating-point values, depending on $(D_INLINECODE type). When $(D_INLINECODE type) is one of $(D_INLINECODE GL_UNSIGNED_BYTE), $(D_INLINECODE GL_BYTE), $(D_INLINECODE GL_UNSIGNED_SHORT), $(D_INLINECODE GL_SHORT), $(D_INLINECODE GL_UNSIGNED_INT), $(D_INLINECODE GL_INT), or $(D_INLINECODE GL_FLOAT) each of these bytes, shorts, integers, or floating-point values is interpreted as one color or depth component, or one index, depending on $(D_INLINECODE format). When $(D_INLINECODE type) is one of $(D_INLINECODE GL_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GL_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8), or $(D_INLINECODE GL_UNSIGNED_INT_10_10_10_2), each unsigned value is interpreted as containing all the components for a single pixel, with the color components arranged according to $(D_INLINECODE format). When $(D_INLINECODE type) is one of $(D_INLINECODE GL_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8_REV), or $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV), each unsigned value is interpreted as containing all color components, specified by $(D_INLINECODE format), for a single pixel in a reversed order. Indices are always treated individually. Color components are treated as groups of one, two, three, or four values, again based on $(D_INLINECODE format). Both individual indices and groups of components are referred to as pixels. If $(D_INLINECODE type) is $(D_INLINECODE GL_BITMAP), the data must be unsigned bytes, and $(D_INLINECODE format) must be either $(D_INLINECODE GL_COLOR_INDEX) or $(D_INLINECODE GL_STENCIL_INDEX). Each unsigned byte is treated as eight 1-bit pixels, with bit ordering determined by $(D_INLINECODE GL_UNPACK_LSB_FIRST) (see $(D_INLINECODE glPixelStore) ). width &times; height pixels are read from memory, starting at location $(D_INLINECODE data). By default, these pixels are taken from adjacent memory locations, except that after all $(D_INLINECODE width) pixels are read, the read pointer is advanced to the next four-byte boundary. The four-byte row alignment is specified by $(D_INLINECODE glPixelStore) with argument $(D_INLINECODE GL_UNPACK_ALIGNMENT), and it can be set to one, two, four, or eight bytes. Other pixel store parameters specify different read pointer advancements, both before the first pixel is read and after all $(D_INLINECODE width) pixels are read. See the $(D_INLINECODE glPixelStore) reference page for details on these options. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a block of pixels is specified, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store. The width &times; height pixels that are read from memory are each operated on in the same way, based on the values of several parameters specified by $(D_INLINECODE glPixelTransfer) and $(D_INLINECODE glPixelMap). The details of these operations, as well as the target buffer into which the pixels are drawn, are specific to the format of the pixels, as specified by $(D_INLINECODE format). $(D_INLINECODE format) can assume one of 13 symbolic values: The following table summarizes the meaning of the valid constants for the parameter: $(B Type) $(B Corresponding Type) $(D_INLINECODE GL_UNSIGNED_BYTE) unsigned 8-bit integer $(D_INLINECODE GL_BYTE) signed 8-bit integer $(D_INLINECODE GL_BITMAP) single bits in unsigned 8-bit integers $(D_INLINECODE GL_UNSIGNED_SHORT) unsigned 16-bit integer $(D_INLINECODE GL_SHORT) signed 16-bit integer $(D_INLINECODE GL_UNSIGNED_INT) unsigned 32-bit integer $(D_INLINECODE GL_INT) 32-bit integer $(D_INLINECODE GL_FLOAT) single-precision floating-point $(D_INLINECODE GL_UNSIGNED_BYTE_3_3_2) unsigned 8-bit integer $(D_INLINECODE GL_UNSIGNED_BYTE_2_3_3_REV) unsigned 8-bit integer with reversed component ordering $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5) unsigned 16-bit integer $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5_REV) unsigned 16-bit integer with reversed component ordering $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4) unsigned 16-bit integer $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4_REV) unsigned 16-bit integer with reversed component ordering $(D_INLINECODE GL_UNSIGNED_SHORT_5_5_5_1) unsigned 16-bit integer $(D_INLINECODE GL_UNSIGNED_SHORT_1_5_5_5_REV) unsigned 16-bit integer with reversed component ordering $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8) unsigned 32-bit integer $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8_REV) unsigned 32-bit integer with reversed component ordering $(D_INLINECODE GL_UNSIGNED_INT_10_10_10_2) unsigned 32-bit integer $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV) unsigned 32-bit integer with reversed component ordering The rasterization described so far assumes pixel zoom factors of 1. If $(D_INLINECODE glPixelZoom) is used to change the x and y pixel zoom factors, pixels are converted to fragments as follows. If x r y r is the current raster position, and a given pixel is in the n th column and m th row of the pixel rectangle, then fragments are generated for pixels whose centers are in the rectangle with corners at x r + zoom x &it; n y r + zoom y &it; m x r + zoom x &af; n + 1 y r + zoom y &af; m + 1 where zoom x is the value of $(D_INLINECODE GL_ZOOM_X) and zoom y is the value of $(D_INLINECODE GL_ZOOM_Y).
     + 
     + $(D_INLINECODE GL_BGR) and $(D_INLINECODE GL_BGRA) are only valid for $(D_INLINECODE format) if the GL version is 1.2 or greater. $(D_INLINECODE GL_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GL_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GL_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GL_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GL_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GL_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GL_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GL_UNSIGNED_INT_10_10_10_2), and $(D_INLINECODE GL_UNSIGNED_INT_2_10_10_10_REV) are only valid for $(D_INLINECODE type) if the GL version is 1.2 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAlphaFunc), $(D_INLINECODE glBlendFunc), $(D_INLINECODE glCopyPixels), $(D_INLINECODE glDepthFunc), $(D_INLINECODE glLogicOp), $(D_INLINECODE glPixelMap), $(D_INLINECODE glPixelStore), $(D_INLINECODE glPixelTransfer), $(D_INLINECODE glPixelZoom), $(D_INLINECODE glRasterPos), $(D_INLINECODE glReadPixels), $(D_INLINECODE glScissor), $(D_INLINECODE glStencilFunc), $(D_INLINECODE glWindowPos)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glDrawPixels glDrawPixels;
    alias fn_glEdgeFlag = extern(System) void function(GLboolean flag) @system @nogc nothrow;

    /++
     + glEdgeFlag: man2/glEdgeFlag.xml
     + 
     + Each vertex of a polygon, separate triangle, or separate quadrilateral specified between a $(D_INLINECODE glBegin) / $(D_INLINECODE glEnd) pair is marked as the start of either a boundary or nonboundary edge. If the current edge flag is true when the vertex is specified, the vertex is marked as the start of a boundary edge. Otherwise, the vertex is marked as the start of a nonboundary edge. $(D_INLINECODE glEdgeFlag) sets the edge flag bit to $(D_INLINECODE GL_TRUE) if $(D_INLINECODE flag) is $(D_INLINECODE GL_TRUE) and to $(D_INLINECODE GL_FALSE) otherwise. The vertices of connected triangles and connected quadrilaterals are always marked as boundary, regardless of the value of the edge flag. Boundary and nonboundary edge flags on vertices are significant only if $(D_INLINECODE GL_POLYGON_MODE) is set to $(D_INLINECODE GL_POINT) or $(D_INLINECODE GL_LINE). See $(D_INLINECODE glPolygonMode).
     + 
     + The current edge flag can be updated at any time. In particular, $(D_INLINECODE glEdgeFlag) can be called between a call to $(D_INLINECODE glBegin) and the corresponding call to $(D_INLINECODE glEnd).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBegin), $(D_INLINECODE glEdgeFlagPointer), $(D_INLINECODE glPolygonMode)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glEdgeFlag glEdgeFlag;
    alias fn_glEdgeFlagv = extern(System) void function(const( GLboolean*) flag) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glEdgeFlagv glEdgeFlagv;
    alias fn_glEdgeFlagPointer = extern(System) void function(GLsizei stride, const( GLvoid*) pointer) @system @nogc nothrow;

    /++
     + glEdgeFlagPointer: man2/glEdgeFlagPointer.xml
     + 
     + $(D_INLINECODE glEdgeFlagPointer) specifies the location and data format of an array of boolean edge flags to use when rendering. $(D_INLINECODE stride) specifies the byte stride from one edge flag to the next, allowing vertices and attributes to be packed into a single array or stored in separate arrays. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_ARRAY_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while an edge flag array is specified, $(D_INLINECODE pointer) is treated as a byte offset into the buffer object's data store. Also, the buffer object binding ( $(D_INLINECODE GL_ARRAY_BUFFER_BINDING) ) is saved as edge flag vertex array client-side state ( $(D_INLINECODE GL_EDGE_FLAG_ARRAY_BUFFER_BINDING) ). When an edge flag array is specified, $(D_INLINECODE stride) and $(D_INLINECODE pointer) are saved as client-side state, in addition to the current vertex array buffer object binding. To enable and disable the edge flag array, call $(D_INLINECODE glEnableClientState) and $(D_INLINECODE glDisableClientState) with the argument $(D_INLINECODE GL_EDGE_FLAG_ARRAY). If enabled, the edge flag array is used when $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glMultiDrawElements), $(D_INLINECODE glDrawRangeElements), or $(D_INLINECODE glArrayElement) is called.
     + 
     + $(D_INLINECODE glEdgeFlagPointer) is available only if the GL version is 1.1 or greater. Edge flags are not supported for interleaved vertex array formats (see $(D_INLINECODE glInterleavedArrays) ). The edge flag array is initially disabled and isn't accessed when $(D_INLINECODE glArrayElement), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), or $(D_INLINECODE glMultiDrawElements) is called. Execution of $(D_INLINECODE glEdgeFlagPointer) is not allowed between the execution of $(D_INLINECODE glBegin) and the corresponding execution of $(D_INLINECODE glEnd), but an error may or may not be generated. If no error is generated, the operation is undefined. $(D_INLINECODE glEdgeFlagPointer) is typically implemented on the client side. Edge flag array parameters are client-side state and are therefore not saved or restored by $(D_INLINECODE glPushAttrib) and $(D_INLINECODE glPopAttrib). Use $(D_INLINECODE glPushClientAttrib) and $(D_INLINECODE glPopClientAttrib) instead.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glArrayElement), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glColorPointer), $(D_INLINECODE glDisableClientState), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glEdgeFlag), $(D_INLINECODE glEnableClientState), $(D_INLINECODE glFogCoordPointer), $(D_INLINECODE glIndexPointer), $(D_INLINECODE glInterleavedArrays), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glMultiDrawElements), $(D_INLINECODE glNormalPointer), $(D_INLINECODE glPopClientAttrib), $(D_INLINECODE glPushClientAttrib), $(D_INLINECODE glSecondaryColorPointer), $(D_INLINECODE glTexCoordPointer), $(D_INLINECODE glVertexAttribPointer), $(D_INLINECODE glVertexPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    fn_glEdgeFlagPointer glEdgeFlagPointer;
    alias fn_glEnableClientState = extern(System) void function(GLenum cap) @system @nogc nothrow;

    /++
     + glEnableClientState: man2/glEnableClientState.xml
     + 
     + $(D_INLINECODE glEnableClientState) and $(D_INLINECODE glDisableClientState) enable or disable individual client-side capabilities. By default, all client-side capabilities are disabled. Both $(D_INLINECODE glEnableClientState) and $(D_INLINECODE glDisableClientState) take a single argument, $(D_INLINECODE cap), which can assume one of the following values:
     + 
     + $(D_INLINECODE glEnableClientState) is available only if the GL version is 1.1 or greater. $(D_INLINECODE GL_FOG_COORD_ARRAY) and $(D_INLINECODE GL_SECONDARY_COLOR_ARRAY) are available only if the GL version is 1.4 or greater. For OpenGL versions 1.3 and greater, or when $(D_INLINECODE ARB_multitexture) is supported, enabling and disabling $(D_INLINECODE GL_TEXTURE_COORD_ARRAY) affects the active client texture unit. The active client texture unit is controlled with $(D_INLINECODE glClientActiveTexture).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glArrayElement), $(D_INLINECODE glClientActiveTexture), $(D_INLINECODE glColorPointer), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glEdgeFlagPointer), $(D_INLINECODE glFogCoordPointer), $(D_INLINECODE glEnable), $(D_INLINECODE glGetPointerv), $(D_INLINECODE glIndexPointer), $(D_INLINECODE glInterleavedArrays), $(D_INLINECODE glNormalPointer), $(D_INLINECODE glSecondaryColorPointer), $(D_INLINECODE glTexCoordPointer), $(D_INLINECODE glVertexPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    fn_glEnableClientState glEnableClientState;
    alias fn_glDisableClientState = extern(System) void function(GLenum cap) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    fn_glDisableClientState glDisableClientState;
    alias fn_glEvalCoord1f = extern(System) void function(GLfloat u) @system @nogc nothrow;

    /++
     + glEvalCoord: man2/glEvalCoord.xml
     + 
     + $(D_INLINECODE glEvalCoord1) evaluates enabled one-dimensional maps at argument $(D_INLINECODE u). $(D_INLINECODE glEvalCoord2) does the same for two-dimensional maps using two domain values, $(D_INLINECODE u) and $(D_INLINECODE v). To define a map, call $(D_INLINECODE glMap1) and $(D_INLINECODE glMap2); to enable and disable it, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable). When one of the $(D_INLINECODE glEvalCoord) commands is issued, all currently enabled maps of the indicated dimension are evaluated. Then, for each enabled map, it is as if the corresponding GL command had been issued with the computed value. That is, if $(D_INLINECODE GL_MAP1_INDEX) or $(D_INLINECODE GL_MAP2_INDEX) is enabled, a $(D_INLINECODE glIndex) command is simulated. If $(D_INLINECODE GL_MAP1_COLOR_4) or $(D_INLINECODE GL_MAP2_COLOR_4) is enabled, a $(D_INLINECODE glColor) command is simulated. If $(D_INLINECODE GL_MAP1_NORMAL) or $(D_INLINECODE GL_MAP2_NORMAL) is enabled, a normal vector is produced, and if any of $(D_INLINECODE GL_MAP1_TEXTURE_COORD_1), $(D_INLINECODE GL_MAP1_TEXTURE_COORD_2), $(D_INLINECODE GL_MAP1_TEXTURE_COORD_3), $(D_INLINECODE GL_MAP1_TEXTURE_COORD_4), $(D_INLINECODE GL_MAP2_TEXTURE_COORD_1), $(D_INLINECODE GL_MAP2_TEXTURE_COORD_2), $(D_INLINECODE GL_MAP2_TEXTURE_COORD_3), or $(D_INLINECODE GL_MAP2_TEXTURE_COORD_4) is enabled, then an appropriate $(D_INLINECODE glTexCoord) command is simulated. For color, color index, normal, and texture coordinates the GL uses evaluated values instead of current values for those evaluations that are enabled, and current values otherwise, However, the evaluated values do not update the current values. Thus, if $(D_INLINECODE glVertex) commands are interspersed with $(D_INLINECODE glEvalCoord) commands, the color, normal, and texture coordinates associated with the $(D_INLINECODE glVertex) commands are not affected by the values generated by the $(D_INLINECODE glEvalCoord) commands, but only by the most recent $(D_INLINECODE glColor), $(D_INLINECODE glIndex), $(D_INLINECODE glNormal), and $(D_INLINECODE glTexCoord) commands. No commands are issued for maps that are not enabled. If more than one texture evaluation is enabled for a particular dimension (for example, $(D_INLINECODE GL_MAP2_TEXTURE_COORD_1) and $(D_INLINECODE GL_MAP2_TEXTURE_COORD_2) ), then only the evaluation of the map that produces the larger number of coordinates (in this case, $(D_INLINECODE GL_MAP2_TEXTURE_COORD_2) ) is carried out. $(D_INLINECODE GL_MAP1_VERTEX_4) overrides $(D_INLINECODE GL_MAP1_VERTEX_3), and $(D_INLINECODE GL_MAP2_VERTEX_4) overrides $(D_INLINECODE GL_MAP2_VERTEX_3), in the same manner. If neither a three- nor a four-component vertex map is enabled for the specified dimension, the $(D_INLINECODE glEvalCoord) command is ignored. If you have enabled automatic normal generation, by calling $(D_INLINECODE glEnable) with argument $(D_INLINECODE GL_AUTO_NORMAL), $(D_INLINECODE glEvalCoord2) generates surface normals analytically, regardless of the contents or enabling of the $(D_INLINECODE GL_MAP2_NORMAL) map. Let m = &PartialD; p &PartialD; u &times; &PartialD; p &PartialD; v Then the generated normal n is n = m m If automatic normal generation is disabled, the corresponding normal map $(D_INLINECODE GL_MAP2_NORMAL), if enabled, is used to produce a normal. If neither automatic normal generation nor a normal map is enabled, no normal is generated for $(D_INLINECODE glEvalCoord2) commands.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBegin), $(D_INLINECODE glColor), $(D_INLINECODE glEnable), $(D_INLINECODE glEvalMesh), $(D_INLINECODE glEvalPoint), $(D_INLINECODE glIndex), $(D_INLINECODE glMap1), $(D_INLINECODE glMap2), $(D_INLINECODE glMapGrid), $(D_INLINECODE glNormal), $(D_INLINECODE glTexCoord), $(D_INLINECODE glVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glEvalCoord1f glEvalCoord1f;
    alias fn_glEvalCoord1d = extern(System) void function(GLdouble u) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glEvalCoord1d glEvalCoord1d;
    alias fn_glEvalCoord2f = extern(System) void function(GLfloat u, GLfloat v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glEvalCoord2f glEvalCoord2f;
    alias fn_glEvalCoord2d = extern(System) void function(GLdouble u, GLdouble v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glEvalCoord2d glEvalCoord2d;
    alias fn_glEvalCoord1fv = extern(System) void function(const( GLfloat*) u) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glEvalCoord1fv glEvalCoord1fv;
    alias fn_glEvalCoord1dv = extern(System) void function(const( GLdouble*) u) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glEvalCoord1dv glEvalCoord1dv;
    alias fn_glEvalCoord2fv = extern(System) void function(const( GLfloat*) u) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glEvalCoord2fv glEvalCoord2fv;
    alias fn_glEvalCoord2dv = extern(System) void function(const( GLdouble*) u) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glEvalCoord2dv glEvalCoord2dv;
    alias fn_glEvalMesh1 = extern(System) void function(GLenum mode, GLint i1, GLint i2) @system @nogc nothrow;

    /++
     + glEvalMesh: man2/glEvalMesh.xml
     + 
     + $(D_INLINECODE glMapGrid) and $(D_INLINECODE glEvalMesh) are used in tandem to efficiently generate and evaluate a series of evenly-spaced map domain values. $(D_INLINECODE glEvalMesh) steps through the integer domain of a one- or two-dimensional grid, whose range is the domain of the evaluation maps specified by $(D_INLINECODE glMap1) and $(D_INLINECODE glMap2). $(D_INLINECODE mode) determines whether the resulting vertices are connected as points, lines, or filled polygons. In the one-dimensional case, $(D_INLINECODE glEvalMesh1), the mesh is generated as if the following code fragment were executed:
     + 
     + ---
     + glBegin(  $(D_INLINECODE type));
     + for ( i =  $(D_INLINECODE i1); i &lt;=  $(D_INLINECODE i2); i += 1 )
     +    glEvalCoord1(  i &CenterDot; &Delta; u + u 1);
     + glEnd();
     +         
     + ---
     +  where &Delta; u = u 2 - u 1 n and n, u 1, and u 2 are the arguments to the most recent $(D_INLINECODE glMapGrid1) command. is $(D_INLINECODE GL_POINTS) if $(D_INLINECODE mode) is $(D_INLINECODE GL_POINT), or $(D_INLINECODE GL_LINES) if $(D_INLINECODE mode) is $(D_INLINECODE GL_LINE). The one absolute numeric requirement is that if i = n, then the value computed from i &CenterDot; &Delta; u + u 1 is exactly u 2. In the two-dimensional case, $(D_INLINECODE glEvalMesh2), let .cp &Delta; u = u 2 - u 1 n &Delta; v = v 2 - v 1 m where n, u 1, u 2, m, v 1, and v 2 are the arguments to the most recent $(D_INLINECODE glMapGrid2) command.  Then, if $(D_INLINECODE mode) is $(D_INLINECODE GL_FILL), the $(D_INLINECODE glEvalMesh2) command is equivalent to:
     + 
     + ---
     + for ( j =  $(D_INLINECODE j1); j &lt;  $(D_INLINECODE j2); j += 1 ) {
     +    glBegin( GL_QUAD_STRIP );
     +    for ( i =  $(D_INLINECODE i1); i &lt;=  $(D_INLINECODE i2); i += 1 ) {
     +   glEvalCoord2(  i &CenterDot; &Delta; u + u 1, j &CenterDot; &Delta; v + v 1);
     +   glEvalCoord2(  i &CenterDot; &Delta; u + u 1, j + 1 &CenterDot; &Delta; v + v 1);
     +    }
     +    glEnd();
     + }
     +         
     + ---
     +  If $(D_INLINECODE mode) is $(D_INLINECODE GL_LINE), then a call to $(D_INLINECODE glEvalMesh2) is equivalent to:
     + 
     + ---
     + for ( j =  $(D_INLINECODE j1); j &lt;=  $(D_INLINECODE j2); j += 1 ) {
     +    glBegin( GL_LINE_STRIP );
     +    for ( i =  $(D_INLINECODE i1); i &lt;=  $(D_INLINECODE i2); i += 1 )
     +   glEvalCoord2(  i &CenterDot; &Delta; u + u 1, j &CenterDot; &Delta; v + v 1);
     +    glEnd();
     + }
     + 
     + for ( i =  $(D_INLINECODE i1);  i &lt;=  $(D_INLINECODE i2); i += 1 ) {
     +    glBegin( GL_LINE_STRIP );
     +    for ( j =  $(D_INLINECODE j1); j &lt;=  $(D_INLINECODE j1); j += 1 )
     +   glEvalCoord2(  i &CenterDot; &Delta; u + u 1, j &CenterDot; &Delta; v + v 1);
     +    glEnd();
     + }
     +         
     + ---
     +  And finally, if $(D_INLINECODE mode) is $(D_INLINECODE GL_POINT), then a call to $(D_INLINECODE glEvalMesh2) is equivalent to:
     + 
     + ---
     + glBegin( GL_POINTS );
     + for ( j =  $(D_INLINECODE j1); j &lt;=  $(D_INLINECODE j2); j += 1 )
     +    for ( i =  $(D_INLINECODE i1); i &lt;=  $(D_INLINECODE i2); i += 1 )
     +   glEvalCoord2(  i &CenterDot; &Delta; u + u 1, j &CenterDot; &Delta; v + v 1);
     + glEnd();
     +         
     + ---
     +  In all three cases, the only absolute numeric requirements are that if i = n, then the value computed from i &CenterDot; &Delta; u + u 1 is exactly u 2, and if j = m, then the value computed from j &CenterDot; &Delta; v + v 1 is exactly v 2.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBegin), $(D_INLINECODE glEvalCoord), $(D_INLINECODE glEvalPoint), $(D_INLINECODE glMap1), $(D_INLINECODE glMap2), $(D_INLINECODE glMapGrid)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glEvalMesh1 glEvalMesh1;
    alias fn_glEvalMesh2 = extern(System) void function(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glEvalMesh2 glEvalMesh2;
    alias fn_glEvalPoint1 = extern(System) void function(GLint i) @system @nogc nothrow;

    /++
     + glEvalPoint: man2/glEvalPoint.xml
     + 
     + $(D_INLINECODE glMapGrid) and $(D_INLINECODE glEvalMesh) are used in tandem to efficiently generate and evaluate a series of evenly spaced map domain values. $(D_INLINECODE glEvalPoint) can be used to evaluate a single grid point in the same gridspace that is traversed by $(D_INLINECODE glEvalMesh). Calling $(D_INLINECODE glEvalPoint1) is equivalent to calling
     + 
     + ---
     + glEvalCoord1(  i &CenterDot; &Delta; u + u 1);
     +      
     + ---
     +  where &Delta; u = u 2 - u 1 n and n, u 1, and u 2 are the arguments to the most recent $(D_INLINECODE glMapGrid1) command. The one absolute numeric requirement is that if i = n, then the value computed from i &CenterDot; &Delta; u + u 1 is exactly u 2. In the two-dimensional case, $(D_INLINECODE glEvalPoint2), let &Delta; u = u 2 - u 1 n &Delta; v = v 2 - v 1 m where n, u 1, u 2, m, v 1, and v 2 are the arguments to the most recent $(D_INLINECODE glMapGrid2) command. Then the $(D_INLINECODE glEvalPoint2) command is equivalent to calling
     + 
     + ---
     + glEvalCoord2(  i &CenterDot; &Delta; u + u 1, j &CenterDot; &Delta; v + v 1);
     +         
     + ---
     +  The only absolute numeric requirements are that if i = n, then the value computed from i &CenterDot; &Delta; u + u 1 is exactly u 2, and if j = m, then the value computed from j &CenterDot; &Delta; v + v 1 is exactly v 2.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glEvalCoord), $(D_INLINECODE glEvalMesh), $(D_INLINECODE glMap1), $(D_INLINECODE glMap2), $(D_INLINECODE glMapGrid)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glEvalPoint1 glEvalPoint1;
    alias fn_glEvalPoint2 = extern(System) void function(GLint i, GLint j) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glEvalPoint2 glEvalPoint2;
    alias fn_glFeedbackBuffer = extern(System) void function(GLsizei size, GLenum type, GLfloat* buffer) @system @nogc nothrow;

    /++
     + glFeedbackBuffer: man2/glFeedbackBuffer.xml
     + 
     + The $(D_INLINECODE glFeedbackBuffer) function controls feedback. Feedback, like selection, is a GL mode. The mode is selected by calling $(D_INLINECODE glRenderMode) with $(D_INLINECODE GL_FEEDBACK). When the GL is in feedback mode, no pixels are produced by rasterization. Instead, information about primitives that would have been rasterized is fed back to the application using the GL. $(D_INLINECODE glFeedbackBuffer) has three arguments: $(D_INLINECODE buffer) is a pointer to an array of floating-point values into which feedback information is placed. $(D_INLINECODE size) indicates the size of the array. $(D_INLINECODE type) is a symbolic constant describing the information that is fed back for each vertex. $(D_INLINECODE glFeedbackBuffer) must be issued before feedback mode is enabled (by calling $(D_INLINECODE glRenderMode) with argument $(D_INLINECODE GL_FEEDBACK) ). Setting $(D_INLINECODE GL_FEEDBACK) without establishing the feedback buffer, or calling $(D_INLINECODE glFeedbackBuffer) while the GL is in feedback mode, is an error. When $(D_INLINECODE glRenderMode) is called while in feedback mode, it returns the number of entries placed in the feedback array and resets the feedback array pointer to the base of the feedback buffer. The returned value never exceeds $(D_INLINECODE size). If the feedback data required more room than was available in $(D_INLINECODE buffer), $(D_INLINECODE glRenderMode) returns a negative value. To take the GL out of feedback mode, call $(D_INLINECODE glRenderMode) with a parameter value other than $(D_INLINECODE GL_FEEDBACK). While in feedback mode, each primitive, bitmap, or pixel rectangle that would be rasterized generates a block of values that are copied into the feedback array. If doing so would cause the number of entries to exceed the maximum, the block is partially written so as to fill the array (if there is any room left at all), and an overflow flag is set. Each block begins with a code indicating the primitive type, followed by values that describe the primitive's vertices and associated data. Entries are also written for bitmaps and pixel rectangles. Feedback occurs after polygon culling and $(D_INLINECODE glPolygonMode) interpretation of polygons has taken place, so polygons that are culled are not returned in the feedback buffer. It can also occur after polygons with more than three edges are broken up into triangles, if the GL implementation renders polygons by performing this decomposition. The $(D_INLINECODE glPassThrough) command can be used to insert a marker into the feedback buffer. See $(D_INLINECODE glPassThrough). Following is the grammar for the blocks of values written into the feedback buffer. Each primitive is indicated with a unique identifying value followed by some number of vertices. Polygon entries include an integer value indicating how many vertices follow. A vertex is fed back as some number of floating-point values, as determined by $(D_INLINECODE type). Colors are fed back as four values in RGBA mode and one value in color index mode. feedbackList &#x2190; feedbackItem feedbackList | feedbackItem feedbackItem &#x2190; point | lineSegment | polygon | bitmap | pixelRectangle | passThru point &#x2190; $(D_INLINECODE GL_POINT_TOKEN) vertex lineSegment &#x2190; $(D_INLINECODE GL_LINE_TOKEN) vertex vertex | $(D_INLINECODE GL_LINE_RESET_TOKEN) vertex vertex polygon &#x2190; $(D_INLINECODE GL_POLYGON_TOKEN) n polySpec polySpec &#x2190; polySpec vertex | vertex vertex vertex bitmap &#x2190; $(D_INLINECODE GL_BITMAP_TOKEN) vertex pixelRectangle &#x2190; $(D_INLINECODE GL_DRAW_PIXEL_TOKEN) vertex | $(D_INLINECODE GL_COPY_PIXEL_TOKEN) vertex passThru &#x2190; $(D_INLINECODE GL_PASS_THROUGH_TOKEN) value vertex &#x2190; 2d | 3d | 3dColor | 3dColorTexture | 4dColorTexture 2d &#x2190; value value 3d &#x2190; value value value 3dColor &#x2190; value value value color 3dColorTexture &#x2190; value value value color tex 4dColorTexture &#x2190; value value value value color tex color &#x2190; rgba | index rgba &#x2190; value value value value index &#x2190; value tex &#x2190; value value value value is a floating-point number, and is a floating-point integer giving the number of vertices in the polygon. $(D_INLINECODE GL_POINT_TOKEN), $(D_INLINECODE GL_LINE_TOKEN), $(D_INLINECODE GL_LINE_RESET_TOKEN), $(D_INLINECODE GL_POLYGON_TOKEN), $(D_INLINECODE GL_BITMAP_TOKEN), $(D_INLINECODE GL_DRAW_PIXEL_TOKEN), $(D_INLINECODE GL_COPY_PIXEL_TOKEN) and $(D_INLINECODE GL_PASS_THROUGH_TOKEN) are symbolic floating-point constants. $(D_INLINECODE GL_LINE_RESET_TOKEN) is returned whenever the line stipple pattern is reset. The data returned as a vertex depends on the feedback $(D_INLINECODE type). The following table gives the correspondence between $(D_INLINECODE type) and the number of values per vertex. is 1 in color index mode and 4 in RGBA mode. $(B Type) $(B Coordinates) $(B Color) $(B Texture) $(B Total Number of Values) $(D_INLINECODE GL_2D), 2 $(D_INLINECODE GL_3D),, 3 $(D_INLINECODE GL_3D_COLOR),, k 3 + k $(D_INLINECODE GL_3D_COLOR_TEXTURE),, k 4 7 + k $(D_INLINECODE GL_4D_COLOR_TEXTURE),,, k 4 8 + k Feedback vertex coordinates are in window coordinates, except, which is in clip coordinates. Feedback colors are lighted, if lighting is enabled. Feedback texture coordinates are generated, if texture coordinate generation is enabled. They are always transformed by the texture matrix.
     + 
     + $(D_INLINECODE glFeedbackBuffer), when used in a display list, is not compiled into the display list but is executed immediately. $(D_INLINECODE glFeedbackBuffer) returns only the texture coordinate of texture unit $(D_INLINECODE GL_TEXTURE0).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBegin), $(D_INLINECODE glLineStipple), $(D_INLINECODE glPassThrough), $(D_INLINECODE glPolygonMode), $(D_INLINECODE glRenderMode), $(D_INLINECODE glSelectBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glFeedbackBuffer glFeedbackBuffer;
    alias fn_glFogf = extern(System) void function(GLenum pname, GLfloat param) @system @nogc nothrow;

    /++
     + glFog: man2/glFog.xml
     + 
     + Fog is initially disabled. While enabled, fog affects rasterized geometry, bitmaps, and pixel blocks, but not buffer clear operations. To enable and disable fog, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_FOG). $(D_INLINECODE glFog) assigns the value or values in $(D_INLINECODE params) to the fog parameter specified by $(D_INLINECODE pname). The following values are accepted for $(D_INLINECODE pname) : Fog blends a fog color with each rasterized pixel fragment's post-texturing color using a blending factor f. Factor f is computed in one of three ways, depending on the fog mode. Let c be either the distance in eye coordinate from the origin (in the case that the $(D_INLINECODE GL_FOG_COORD_SRC) is $(D_INLINECODE GL_FRAGMENT_DEPTH) ) or the current fog coordinate (in the case that $(D_INLINECODE GL_FOG_COORD_SRC) is $(D_INLINECODE GL_FOG_COORD) ). The equation for $(D_INLINECODE GL_LINEAR) fog is f = end - c end - start The equation for $(D_INLINECODE GL_EXP) fog is f = e - density &CenterDot; c The equation for $(D_INLINECODE GL_EXP2) fog is f = e - density &CenterDot; c 2 Regardless of the fog mode, f is clamped to the range 0 1 after it is computed. Then, if the GL is in RGBA color mode, the fragment's red, green, and blue colors, represented by C r, are replaced by C r &Prime; = f &times; C r + 1 - f &times; C f Fog does not affect a fragment's alpha component. In color index mode, the fragment's color index i r is replaced by i r &Prime; = i r + 1 - f &times; i f
     + 
     + $(D_INLINECODE GL_FOG_COORD_SRC) is available only if the GL version is 1.4 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glEnable)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glFogf glFogf;
    alias fn_glFogi = extern(System) void function(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glFogi glFogi;
    alias fn_glFogfv = extern(System) void function(GLenum pname, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glFogfv glFogfv;
    alias fn_glFogiv = extern(System) void function(GLenum pname, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glFogiv glFogiv;
    alias fn_glFogCoordd = extern(System) void function(GLdouble coord) @system @nogc nothrow;

    /++
     + glFogCoord: man2/glFogCoord.xml
     + 
     + $(D_INLINECODE glFogCoord) specifies the fog coordinate that is associated with each vertex and the current raster position.  The value specified is interpolated and used in computing the fog color (see $(D_INLINECODE glFog) ).
     + 
     + $(D_INLINECODE glFogCoord) is available only if the GL version is 1.4 or greater. The current fog coordinate can be updated at any time.  In particular, $(D_INLINECODE glFogCoord) can be called between a call to $(D_INLINECODE glBegin) and the corresponding call to $(D_INLINECODE glEnd).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glFog), $(D_INLINECODE glFogCoordPointer), $(D_INLINECODE glVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glFogCoordd glFogCoordd;
    alias fn_glFogCoordf = extern(System) void function(GLfloat coord) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glFogCoordf glFogCoordf;
    alias fn_glFogCoorddv = extern(System) void function(GLdouble* coord) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glFogCoorddv glFogCoorddv;
    alias fn_glFogCoordfv = extern(System) void function(GLfloat* coord) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glFogCoordfv glFogCoordfv;
    alias fn_glFogCoordPointer = extern(System) void function(GLenum type, GLsizei stride, GLvoid* pointer) @system @nogc nothrow;

    /++
     + glFogCoordPointer: man2/glFogCoordPointer.xml
     + 
     + $(D_INLINECODE glFogCoordPointer) specifies the location and data format of an array of fog coordinates to use when rendering. $(D_INLINECODE type) specifies the data type of each fog coordinate, and $(D_INLINECODE stride) specifies the byte stride from one fog coordinate to the next, allowing vertices and attributes to be packed into a single array or stored in separate arrays. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_ARRAY_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a fog coordinate array is specified, $(D_INLINECODE pointer) is treated as a byte offset into the buffer object's data store. Also, the buffer object binding ( $(D_INLINECODE GL_ARRAY_BUFFER_BINDING) ) is saved as fog coordinate vertex array client-side state ( $(D_INLINECODE GL_FOG_COORD_ARRAY_BUFFER_BINDING) ). When a fog coordinate array is specified, $(D_INLINECODE type), $(D_INLINECODE stride), and $(D_INLINECODE pointer) are saved as client-side state, in addition to the current vertex array buffer object binding. To enable and disable the fog coordinate array, call $(D_INLINECODE glEnableClientState) and $(D_INLINECODE glDisableClientState) with the argument $(D_INLINECODE GL_FOG_COORD_ARRAY). If enabled, the fog coordinate array is used when $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glMultiDrawElements), $(D_INLINECODE glDrawRangeElements), or $(D_INLINECODE glArrayElement) is called.
     + 
     + $(D_INLINECODE glFogCoordPointer) is available only if the GL version is 1.4 or greater. Fog coordinates are not supported for interleaved vertex array formats (see $(D_INLINECODE glInterleavedArrays) ). The fog coordinate array is initially disabled and isn't accessed when $(D_INLINECODE glArrayElement), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), or $(D_INLINECODE glMultiDrawElements) is called. Execution of $(D_INLINECODE glFogCoordPointer) is not allowed between the execution of $(D_INLINECODE glBegin) and the corresponding execution of $(D_INLINECODE glEnd), but an error may or may not be generated. If no error is generated, the operation is undefined. $(D_INLINECODE glFogCoordPointer) is typically implemented on the client side with no protocol. Fog coordinate array parameters are client-side state and are therefore not saved or restored by $(D_INLINECODE glPushAttrib) and $(D_INLINECODE glPopAttrib). Use $(D_INLINECODE glPushClientAttrib) and $(D_INLINECODE glPopClientAttrib) instead.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glArrayElement), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glColorPointer), $(D_INLINECODE glDisableClientState), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glEdgeFlagPointer), $(D_INLINECODE glEnableClientState), $(D_INLINECODE glFogCoord), $(D_INLINECODE glIndexPointer), $(D_INLINECODE glInterleavedArrays), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glMultiDrawElements), $(D_INLINECODE glNormalPointer), $(D_INLINECODE glPopClientAttrib), $(D_INLINECODE glPushClientAttrib), $(D_INLINECODE glSecondaryColorPointer), $(D_INLINECODE glTexCoordPointer), $(D_INLINECODE glVertexAttribPointer), $(D_INLINECODE glVertexPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glFogCoordPointer glFogCoordPointer;
    alias fn_glFrustum = extern(System) void function(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble nearVal, GLdouble farVal) @system @nogc nothrow;

    /++
     + glFrustum: man2/glFrustum.xml
     + 
     + $(D_INLINECODE glFrustum) describes a perspective matrix that produces a perspective projection. The current matrix (see $(D_INLINECODE glMatrixMode) ) is multiplied by this matrix and the result replaces the current matrix, as if $(D_INLINECODE glMultMatrix) were called with the following matrix as its argument: 2 &it; nearVal right - left 0 A 0 0 2 &it; nearVal top - bottom B 0 0 0 C D 0 0 -1 0 A = right + left right - left B = top + bottom top - bottom C = - farVal + nearVal farVal - nearVal D = - 2 &it; farVal &it; nearVal farVal - nearVal Typically, the matrix mode is $(D_INLINECODE GL_PROJECTION), and left bottom - nearVal and right top - nearVal specify the points on the near clipping plane that are mapped to the lower left and upper right corners of the window, assuming that the eye is located at (0, 0, 0). - farVal specifies the location of the far clipping plane. Both $(D_INLINECODE nearVal) and $(D_INLINECODE farVal) must be positive. Use $(D_INLINECODE glPushMatrix) and $(D_INLINECODE glPopMatrix) to save and restore the current matrix stack.
     + 
     + Depth buffer precision is affected by the values specified for $(D_INLINECODE nearVal) and $(D_INLINECODE farVal). The greater the ratio of $(D_INLINECODE farVal) to $(D_INLINECODE nearVal) is, the less effective the depth buffer will be at distinguishing between surfaces that are near each other. If r = farVal nearVal roughly log 2 &af; r bits of depth buffer precision are lost. Because r approaches infinity as $(D_INLINECODE nearVal) approaches 0, $(D_INLINECODE nearVal) must never be set to 0.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glOrtho), $(D_INLINECODE glMatrixMode), $(D_INLINECODE glMultMatrix), $(D_INLINECODE glPushMatrix), $(D_INLINECODE glViewport)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glFrustum glFrustum;
    alias fn_glGenLists = extern(System) GLuint function(GLsizei range) @system @nogc nothrow;

    /++
     + glGenLists: man2/glGenLists.xml
     + 
     + $(D_INLINECODE glGenLists) has one argument, $(D_INLINECODE range). It returns an integer such that $(D_INLINECODE range) contiguous empty display lists, named n, n + 1,..., n + range - 1, are created. If $(D_INLINECODE range) is 0, if there is no group of $(D_INLINECODE range) contiguous names available, or if any error is generated, no display lists are generated, and 0 is returned.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCallList), $(D_INLINECODE glCallLists), $(D_INLINECODE glDeleteLists), $(D_INLINECODE glNewList)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glGenLists glGenLists;
    alias fn_glGetClipPlane = extern(System) void function(GLenum plane, GLdouble* equation) @system @nogc nothrow;

    /++
     + glGetClipPlane: man2/glGetClipPlane.xml
     + 
     + $(D_INLINECODE glGetClipPlane) returns in $(D_INLINECODE equation) the four coefficients of the plane equation for $(D_INLINECODE plane).
     + 
     + It is always the case that $(D_INLINECODE GL_CLIP_PLANE) i = $(D_INLINECODE GL_CLIP_PLANE0) + i. If an error is generated, no change is made to the contents of $(D_INLINECODE equation).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glClipPlane)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glGetClipPlane glGetClipPlane;
    alias fn_glGetColorTable = extern(System) void function(GLenum target, GLenum format, GLenum type, GLvoid* table) @system @nogc nothrow;

    /++
     + glGetColorTable: man2/glGetColorTable.xml
     + 
     + $(D_INLINECODE glGetColorTable) returns in $(D_INLINECODE table) the contents of the color table specified by $(D_INLINECODE target). No pixel transfer operations are performed, but pixel storage modes that are applicable to $(D_INLINECODE glReadPixels) are performed. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_PACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a histogram table is requested, $(D_INLINECODE table) is treated as a byte offset into the buffer object's data store. Color components that are requested in the specified $(D_INLINECODE format), but which are not included in the internal format of the color lookup table, are returned as zero.  The assignments of internal color components to the components requested by $(D_INLINECODE format) are $(B Internal Component) $(B Resulting Component) Red Red Green Green Blue Blue Alpha Alpha Luminance Red Intensity Red
     + 
     + $(D_INLINECODE glGetColorTable) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorTable), $(D_INLINECODE glColorTableParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    fn_glGetColorTable glGetColorTable;
    alias fn_glGetColorTableParameterfv = extern(System) void function(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;

    /++
     + glGetColorTableParameter: man2/glGetColorTableParameter.xml
     + 
     + Returns parameters specific to color table $(D_INLINECODE target). When $(D_INLINECODE pname) is set to $(D_INLINECODE GL_COLOR_TABLE_SCALE) or $(D_INLINECODE GL_COLOR_TABLE_BIAS), $(D_INLINECODE glGetColorTableParameter) returns the color table scale or bias parameters for the table specified by $(D_INLINECODE target). For these queries, $(D_INLINECODE target) must be set to $(D_INLINECODE GL_COLOR_TABLE), $(D_INLINECODE GL_POST_CONVOLUTION_COLOR_TABLE), or $(D_INLINECODE GL_POST_COLOR_MATRIX_COLOR_TABLE) and $(D_INLINECODE params) points to an array of four elements, which receive the scale or bias factors for red, green, blue, and alpha, in that order. $(D_INLINECODE glGetColorTableParameter) can also be used to retrieve the format and size parameters for a color table. For these queries, set $(D_INLINECODE target) to either the color table target or the proxy color table target. The format and size parameters are set by $(D_INLINECODE glColorTable). The following table lists the format and size parameters that may be queried. For each symbolic constant listed below for $(D_INLINECODE pname), $(D_INLINECODE params) must point to an array of the given length and receive the values indicated. $(B Parameter) $(B N) $(B Meaning) $(D_INLINECODE GL_COLOR_TABLE_FORMAT) 1 Internal format (e.g., $(D_INLINECODE GL_RGBA) ) $(D_INLINECODE GL_COLOR_TABLE_WIDTH) 1 Number of elements in table $(D_INLINECODE GL_COLOR_TABLE_RED_SIZE) 1 Size of red component, in bits $(D_INLINECODE GL_COLOR_TABLE_GREEN_SIZE) 1 Size of green component $(D_INLINECODE GL_COLOR_TABLE_BLUE_SIZE) 1 Size of blue component $(D_INLINECODE GL_COLOR_TABLE_ALPHA_SIZE) 1 Size of alpha component $(D_INLINECODE GL_COLOR_TABLE_LUMINANCE_SIZE) 1 Size of luminance component $(D_INLINECODE GL_COLOR_TABLE_INTENSITY_SIZE) 1 Size of intensity component
     + 
     + $(D_INLINECODE glGetColorTableParameter) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorTable), $(D_INLINECODE glTexParameter), $(D_INLINECODE glColorTableParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    fn_glGetColorTableParameterfv glGetColorTableParameterfv;
    alias fn_glGetColorTableParameteriv = extern(System) void function(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    fn_glGetColorTableParameteriv glGetColorTableParameteriv;
    alias fn_glGetConvolutionFilter = extern(System) void function(GLenum target, GLenum format, GLenum type, GLvoid* image) @system @nogc nothrow;

    /++
     + glGetConvolutionFilter: man2/glGetConvolutionFilter.xml
     + 
     + $(D_INLINECODE glGetConvolutionFilter) returns the current 1D or 2D convolution filter kernel as an image. The one- or two-dimensional image is placed in $(D_INLINECODE image) according to the specifications in $(D_INLINECODE format) and $(D_INLINECODE type). No pixel transfer operations are performed on this image, but the relevant pixel storage modes are applied. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_PACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a convolution filter is requested, $(D_INLINECODE image) is treated as a byte offset into the buffer object's data store. Color components that are present in $(D_INLINECODE format) but not included in the internal format of the filter are returned as zero. The assignments of internal color components to the components of $(D_INLINECODE format) are as follows. $(B Internal Component) $(B Resulting Component) Red Red Green Green Blue Blue Alpha Alpha Luminance Red Intensity Red
     + 
     + $(D_INLINECODE glGetConvolutionFilter) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS). The current separable 2D filter must be retrieved with $(D_INLINECODE glGetSeparableFilter) rather than $(D_INLINECODE glGetConvolutionFilter).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetSeparableFilter), $(D_INLINECODE glConvolutionParameter), $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glConvolutionFilter2D)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    fn_glGetConvolutionFilter glGetConvolutionFilter;
    alias fn_glGetConvolutionParameterfv = extern(System) void function(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;

    /++
     + glGetConvolutionParameter: man2/glGetConvolutionParameter.xml
     + 
     + $(D_INLINECODE glGetConvolutionParameter) retrieves convolution parameters. $(D_INLINECODE target) determines which convolution filter is queried. $(D_INLINECODE pname) determines which parameter is returned:
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetConvolutionFilter), $(D_INLINECODE glGetSeparableFilter), $(D_INLINECODE glConvolutionParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    fn_glGetConvolutionParameterfv glGetConvolutionParameterfv;
    alias fn_glGetConvolutionParameteriv = extern(System) void function(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    fn_glGetConvolutionParameteriv glGetConvolutionParameteriv;
    alias fn_glGetHistogram = extern(System) void function(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid* values) @system @nogc nothrow;

    /++
     + glGetHistogram: man2/glGetHistogram.xml
     + 
     + $(D_INLINECODE glGetHistogram) returns the current histogram table as a one-dimensional image with the same width as the histogram. No pixel transfer operations are performed on this image, but pixel storage modes that are applicable to 1D images are honored. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_PACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a histogram table is requested, $(D_INLINECODE values) is treated as a byte offset into the buffer object's data store. Color components that are requested in the specified $(D_INLINECODE format), but which are not included in the internal format of the histogram, are returned as zero. The assignments of internal color components to the components requested by $(D_INLINECODE format) are: $(B Internal Component) $(B Resulting Component) Red Red Green Green Blue Blue Alpha Alpha Luminance Red
     + 
     + $(D_INLINECODE glGetHistogram) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glHistogram), $(D_INLINECODE glResetHistogram),
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    fn_glGetHistogram glGetHistogram;
    alias fn_glGetHistogramParameterfv = extern(System) void function(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;

    /++
     + glGetHistogramParameter: man2/glGetHistogramParameter.xml
     + 
     + $(D_INLINECODE glGetHistogramParameter) is used to query parameter values for the current histogram or for a proxy.  The histogram state information may be queried by calling $(D_INLINECODE glGetHistogramParameter) with a $(D_INLINECODE target) of $(D_INLINECODE GL_HISTOGRAM) (to obtain information for the current histogram table) or $(D_INLINECODE GL_PROXY_HISTOGRAM) (to obtain information from the most recent proxy request) and one of the following values for the $(D_INLINECODE pname) argument: $(B Parameter) $(B Description) $(D_INLINECODE GL_HISTOGRAM_WIDTH) Histogram table width $(D_INLINECODE GL_HISTOGRAM_FORMAT) Internal format $(D_INLINECODE GL_HISTOGRAM_RED_SIZE) Red component counter size, in bits $(D_INLINECODE GL_HISTOGRAM_GREEN_SIZE) Green component counter size, in bits $(D_INLINECODE GL_HISTOGRAM_BLUE_SIZE) Blue component counter size, in bits $(D_INLINECODE GL_HISTOGRAM_ALPHA_SIZE) Alpha component counter size, in bits $(D_INLINECODE GL_HISTOGRAM_LUMINANCE_SIZE) Luminance component counter size, in bits $(D_INLINECODE GL_HISTOGRAM_SINK) Value of the parameter
     + 
     + $(D_INLINECODE glGetHistogramParameter) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetHistogram), $(D_INLINECODE glHistogram)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    fn_glGetHistogramParameterfv glGetHistogramParameterfv;
    alias fn_glGetHistogramParameteriv = extern(System) void function(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    fn_glGetHistogramParameteriv glGetHistogramParameteriv;
    alias fn_glGetLightfv = extern(System) void function(GLenum light, GLenum pname, GLfloat* params) @system @nogc nothrow;

    /++
     + glGetLight: man2/glGetLight.xml
     + 
     + $(D_INLINECODE glGetLight) returns in $(D_INLINECODE params) the value or values of a light source parameter. $(D_INLINECODE light) names the light and is a symbolic name of the form $(D_INLINECODE GL_LIGHT) i where i ranges from 0 to the value of $(D_INLINECODE GL_MAX_LIGHTS) - 1. $(D_INLINECODE GL_MAX_LIGHTS) is an implementation dependent constant that is greater than or equal to eight. $(D_INLINECODE pname) specifies one of ten light source parameters, again by symbolic name. The following parameters are defined:
     + 
     + It is always the case that $(D_INLINECODE GL_LIGHT) i = $(D_INLINECODE GL_LIGHT0) + i. If an error is generated, no change is made to the contents of $(D_INLINECODE params).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glLight)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glGetLightfv glGetLightfv;
    alias fn_glGetLightiv = extern(System) void function(GLenum light, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glGetLightiv glGetLightiv;
    alias fn_glGetMapdv = extern(System) void function(GLenum target, GLenum query, GLdouble* v) @system @nogc nothrow;

    /++
     + glGetMap: man2/glGetMap.xml
     + 
     + $(D_INLINECODE glMap1) and $(D_INLINECODE glMap2) define evaluators. $(D_INLINECODE glGetMap) returns evaluator parameters. $(D_INLINECODE target) chooses a map, $(D_INLINECODE query) selects a specific parameter, and $(D_INLINECODE v) points to storage where the values will be returned. The acceptable values for the $(D_INLINECODE target) parameter are described in the $(D_INLINECODE glMap1) and $(D_INLINECODE glMap2) reference pages. $(D_INLINECODE query) can assume the following values:
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE v).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glEvalCoord), $(D_INLINECODE glMap1), $(D_INLINECODE glMap2)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glGetMapdv glGetMapdv;
    alias fn_glGetMapfv = extern(System) void function(GLenum target, GLenum query, GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glGetMapfv glGetMapfv;
    alias fn_glGetMapiv = extern(System) void function(GLenum target, GLenum query, GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glGetMapiv glGetMapiv;
    alias fn_glGetMaterialfv = extern(System) void function(GLenum face, GLenum pname, GLfloat* params) @system @nogc nothrow;

    /++
     + glGetMaterial: man2/glGetMaterial.xml
     + 
     + $(D_INLINECODE glGetMaterial) returns in $(D_INLINECODE params) the value or values of parameter $(D_INLINECODE pname) of material $(D_INLINECODE face). Six parameters are defined:
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE params).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glMaterial)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glGetMaterialfv glGetMaterialfv;
    alias fn_glGetMaterialiv = extern(System) void function(GLenum face, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glGetMaterialiv glGetMaterialiv;
    alias fn_glGetMinmax = extern(System) void function(GLenum target, GLboolean reset, GLenum format, GLenum types, GLvoid* values) @system @nogc nothrow;

    /++
     + glGetMinmax: man2/glGetMinmax.xml
     + 
     + $(D_INLINECODE glGetMinmax) returns the accumulated minimum and maximum pixel values (computed on a per-component basis) in a one-dimensional image of width 2.  The first set of return values are the minima, and the second set of return values are the maxima. The format of the return values is determined by $(D_INLINECODE format), and their type is determined by $(D_INLINECODE types). If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_PACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while minimum and maximum pixel values are requested, $(D_INLINECODE values) is treated as a byte offset into the buffer object's data store. No pixel transfer operations are performed on the return values, but pixel storage modes that are applicable to one-dimensional images are performed. Color components that are requested in the specified $(D_INLINECODE format), but that are not included in the internal format of the minmax table, are returned as zero.  The assignment of internal color components to the components requested by $(D_INLINECODE format) are as follows: $(B Internal Component) $(B Resulting Component) Red Red Green Green Blue Blue Alpha Alpha Luminance Red If $(D_INLINECODE reset) is $(D_INLINECODE GL_TRUE), the minmax table entries corresponding to the return values are reset to their initial values.  Minimum and maximum values that are not returned are not modified, even if $(D_INLINECODE reset) is $(D_INLINECODE GL_TRUE).
     + 
     + $(D_INLINECODE glGetMinmax) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glMinmax), $(D_INLINECODE glResetMinmax),
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    fn_glGetMinmax glGetMinmax;
    alias fn_glGetMinmaxParameterfv = extern(System) void function(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;

    /++
     + glGetMinmaxParameter: man2/glGetMinmaxParameter.xml
     + 
     + $(D_INLINECODE glGetMinmaxParameter) retrieves parameters for the current minmax table by setting $(D_INLINECODE pname) to one of the following values: $(B Parameter) $(B Description) $(D_INLINECODE GL_MINMAX_FORMAT) Internal format of minmax table $(D_INLINECODE GL_MINMAX_SINK) Value of the parameter
     + 
     + $(D_INLINECODE glGetMinmaxParameter) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glMinmax), $(D_INLINECODE glGetMinmax)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    fn_glGetMinmaxParameterfv glGetMinmaxParameterfv;
    alias fn_glGetMinmaxParameteriv = extern(System) void function(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    fn_glGetMinmaxParameteriv glGetMinmaxParameteriv;
    alias fn_glGetPixelMapfv = extern(System) void function(GLenum map, GLfloat* data) @system @nogc nothrow;

    /++
     + glGetPixelMap: man2/glGetPixelMap.xml
     + 
     + See the $(D_INLINECODE glPixelMap) reference page for a description of the acceptable values for the $(D_INLINECODE map) parameter. $(D_INLINECODE glGetPixelMap) returns in $(D_INLINECODE data) the contents of the pixel map specified in $(D_INLINECODE map). Pixel maps are used during the execution of $(D_INLINECODE glReadPixels), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glCopyPixels), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), and $(D_INLINECODE glCopyTexSubImage3D). to map color indices, stencil indices, color components, and depth components to other values. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_PACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a pixel map is requested, $(D_INLINECODE data) is treated as a byte offset into the buffer object's data store. Unsigned integer values, if requested, are linearly mapped from the internal fixed or floating-point representation such that 1.0 maps to the largest representable integer value, and 0.0 maps to 0. Return unsigned integer values are undefined if the map value was not in the range [0,1]. To determine the required size of $(D_INLINECODE map), call $(D_INLINECODE glGet) with the appropriate symbolic constant.
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE data).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorSubTable), $(D_INLINECODE glColorTable), $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glConvolutionFilter2D), $(D_INLINECODE glCopyColorSubTable), $(D_INLINECODE glCopyColorTable), $(D_INLINECODE glCopyPixels), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glGetHistogram), $(D_INLINECODE glGetMinmax), $(D_INLINECODE glGetTexImage), $(D_INLINECODE glPixelMap), $(D_INLINECODE glPixelTransfer), $(D_INLINECODE glReadPixels), $(D_INLINECODE glSeparableFilter2D), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D) $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glGetPixelMapfv glGetPixelMapfv;
    alias fn_glGetPixelMapuiv = extern(System) void function(GLenum map, GLuint* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glGetPixelMapuiv glGetPixelMapuiv;
    alias fn_glGetPixelMapusv = extern(System) void function(GLenum map, GLushort* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glGetPixelMapusv glGetPixelMapusv;
    alias fn_glGetPolygonStipple = extern(System) void function(GLubyte* pattern) @system @nogc nothrow;

    /++
     + glGetPolygonStipple: man2/glGetPolygonStipple.xml
     + 
     + $(D_INLINECODE glGetPolygonStipple) returns to $(D_INLINECODE pattern) a 32 &times; 32 polygon stipple pattern. The pattern is packed into memory as if $(D_INLINECODE glReadPixels) with both and of 32, of $(D_INLINECODE GL_BITMAP), and of $(D_INLINECODE GL_COLOR_INDEX) were called, and the stipple pattern were stored in an internal 32 &times; 32 color index buffer. Unlike $(D_INLINECODE glReadPixels), however, pixel transfer operations (shift, offset, pixel map) are not applied to the returned stipple image. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_PACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a polygon stipple pattern is requested, $(D_INLINECODE pattern) is treated as a byte offset into the buffer object's data store.
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE pattern).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glPixelStore), $(D_INLINECODE glPixelTransfer), $(D_INLINECODE glPolygonStipple), $(D_INLINECODE glReadPixels)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glGetPolygonStipple glGetPolygonStipple;
    alias fn_glGetSeparableFilter = extern(System) void function(GLenum target, GLenum format, GLenum type, GLvoid* row, GLvoid* column, GLvoid* span) @system @nogc nothrow;

    /++
     + glGetSeparableFilter: man2/glGetSeparableFilter.xml
     + 
     + $(D_INLINECODE glGetSeparableFilter) returns the two one-dimensional filter kernel images for the current separable 2D convolution filter. The row image is placed in $(D_INLINECODE row) and the column image is placed in $(D_INLINECODE column) according to the specifications in $(D_INLINECODE format) and $(D_INLINECODE type). (In the current implementation, $(D_INLINECODE span) is not affected in any way.) No pixel transfer operations are performed on the images, but the relevant pixel storage modes are applied. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_PACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a separable convolution filter is requested, $(D_INLINECODE row), $(D_INLINECODE column), and $(D_INLINECODE span) are treated as a byte offset into the buffer object's data store. Color components that are present in $(D_INLINECODE format) but not included in the internal format of the filters are returned as zero. The assignments of internal color components to the components of $(D_INLINECODE format) are as follows: $(B Internal Component) $(B Resulting Component) Red Red Green Green Blue Blue Alpha Alpha Luminance Red Intensity Red
     + 
     + $(D_INLINECODE glGetSeparableFilter) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS). Non-separable 2D filters must be retrieved with $(D_INLINECODE glGetConvolutionFilter).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetConvolutionFilter), $(D_INLINECODE glConvolutionParameter), $(D_INLINECODE glSeparableFilter2D)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    fn_glGetSeparableFilter glGetSeparableFilter;
    alias fn_glGetTexEnvfv = extern(System) void function(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;

    /++
     + glGetTexEnv: man2/glGetTexEnv.xml
     + 
     + $(D_INLINECODE glGetTexEnv) returns in $(D_INLINECODE params) selected values of a texture environment that was specified with $(D_INLINECODE glTexEnv). $(D_INLINECODE target) specifies a texture environment. When $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_FILTER_CONTROL), $(D_INLINECODE pname) must be $(D_INLINECODE GL_TEXTURE_LOD_BIAS). When $(D_INLINECODE target) is $(D_INLINECODE GL_POINT_SPRITE), $(D_INLINECODE pname) must be $(D_INLINECODE GL_COORD_REPLACE). When $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_ENV), $(D_INLINECODE pname) can be $(D_INLINECODE GL_TEXTURE_ENV_MODE), $(D_INLINECODE GL_TEXTURE_ENV_COLOR), $(D_INLINECODE GL_COMBINE_RGB), $(D_INLINECODE GL_COMBINE_ALPHA), $(D_INLINECODE GL_RGB_SCALE), $(D_INLINECODE GL_ALPHA_SCALE), $(D_INLINECODE GL_SRC0_RGB), $(D_INLINECODE GL_SRC1_RGB), $(D_INLINECODE GL_SRC2_RGB), $(D_INLINECODE GL_SRC0_ALPHA), $(D_INLINECODE GL_SRC1_ALPHA), or $(D_INLINECODE GL_SRC2_ALPHA). $(D_INLINECODE pname) names a specific texture environment parameter, as follows:
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE params). For OpenGL versions 1.3 and greater, or when the $(D_INLINECODE ARB_multitexture) extension is supported, $(D_INLINECODE glGetTexEnv) returns the texture environment parameters for the active texture unit. $(D_INLINECODE GL_COMBINE_RGB), $(D_INLINECODE GL_COMBINE_ALPHA), $(D_INLINECODE GL_SRC0_RGB), $(D_INLINECODE GL_SRC1_RGB), $(D_INLINECODE GL_SRC2_RGB), $(D_INLINECODE GL_SRC0_ALPHA), $(D_INLINECODE GL_SRC1_ALPHA), $(D_INLINECODE GL_SRC2_ALPHA), $(D_INLINECODE GL_OPERAND0_RGB), $(D_INLINECODE GL_OPERAND1_RGB), $(D_INLINECODE GL_OPERAND2_RGB), $(D_INLINECODE GL_OPERAND0_ALPHA), $(D_INLINECODE GL_OPERAND1_ALPHA), $(D_INLINECODE GL_OPERAND2_ALPHA), $(D_INLINECODE GL_RGB_SCALE), and $(D_INLINECODE GL_ALPHA_SCALE) are available only if the GL version is 1.3 or greater. $(D_INLINECODE GL_TEXTURE_FILTER_CONTROL) and $(D_INLINECODE GL_TEXTURE_LOD_BIAS) are available only if the GL version is 1.4 or greater. $(D_INLINECODE GL_POINT_SPRITE) and $(D_INLINECODE GL_COORD_REPLACE) are available only if the GL version is 2.0 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glTexEnv)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glGetTexEnvfv glGetTexEnvfv;
    alias fn_glGetTexEnviv = extern(System) void function(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glGetTexEnviv glGetTexEnviv;
    alias fn_glGetTexGendv = extern(System) void function(GLenum coord, GLenum pname, GLdouble* params) @system @nogc nothrow;

    /++
     + glGetTexGen: man2/glGetTexGen.xml
     + 
     + $(D_INLINECODE glGetTexGen) returns in $(D_INLINECODE params) selected parameters of a texture coordinate generation function that was specified using $(D_INLINECODE glTexGen). $(D_INLINECODE coord) names one of the (,,, ) texture coordinates, using the symbolic constant $(D_INLINECODE GL_S), $(D_INLINECODE GL_T), $(D_INLINECODE GL_R), or $(D_INLINECODE GL_Q). $(D_INLINECODE pname) specifies one of three symbolic names:
     + 
     + If an error is generated, no change is made to the contents of $(D_INLINECODE params). For OpenGL versions 1.3 and greater, or when the $(D_INLINECODE ARB_multitexture) extension is supported, $(D_INLINECODE glGetTexGen) returns the texture coordinate generation parameters for the active texture unit.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glTexGen)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glGetTexGendv glGetTexGendv;
    alias fn_glGetTexGenfv = extern(System) void function(GLenum coord, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glGetTexGenfv glGetTexGenfv;
    alias fn_glGetTexGeniv = extern(System) void function(GLenum coord, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glGetTexGeniv glGetTexGeniv;
    alias fn_glHistogram = extern(System) void function(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink) @system @nogc nothrow;

    /++
     + glHistogram: man2/glHistogram.xml
     + 
     + When $(D_INLINECODE GL_HISTOGRAM) is enabled, RGBA color components are converted to histogram table indices by clamping to the range [0,1], multiplying by the width of the histogram table, and rounding to the nearest integer. The table entries selected by the RGBA indices are then incremented. (If the internal format of the histogram table includes luminance, then the index derived from the R color component determines the luminance table entry to be incremented.)  If a histogram table entry is incremented beyond its maximum value, then its value becomes undefined.  (This is not an error.) Histogramming is performed only for RGBA pixels (though these may be specified originally as color indices and converted to RGBA by index table lookup). Histogramming is enabled with $(D_INLINECODE glEnable) and disabled with $(D_INLINECODE glDisable). When $(D_INLINECODE target) is $(D_INLINECODE GL_HISTOGRAM), $(D_INLINECODE glHistogram) redefines the current histogram table to have $(D_INLINECODE width) entries of the format specified by $(D_INLINECODE internalformat). The entries are indexed 0 through width - 1, and all entries are initialized to zero. The values in the previous histogram table, if any, are lost. If $(D_INLINECODE sink) is $(D_INLINECODE GL_TRUE), then pixels are discarded after histogramming; no further processing of the pixels takes place, and no drawing, texture loading, or pixel readback will result. When $(D_INLINECODE target) is $(D_INLINECODE GL_PROXY_HISTOGRAM), $(D_INLINECODE glHistogram) computes all state information as if the histogram table were to be redefined, but does not actually define the new table. If the requested histogram table is too large to be supported, then the state information will be set to zero. This provides a way to determine if a histogram table with the given parameters can be supported.
     + 
     + $(D_INLINECODE glHistogram) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetHistogram), $(D_INLINECODE glResetHistogram)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    fn_glHistogram glHistogram;
    alias fn_glIndexs = extern(System) void function(GLshort c) @system @nogc nothrow;

    /++
     + glIndex: man2/glIndex.xml
     + 
     + $(D_INLINECODE glIndex) updates the current (single-valued) color index. It takes one argument, the new value for the current color index. The current index is stored as a floating-point value. Integer values are converted directly to floating-point values, with no special mapping. The initial value is 1. Index values outside the representable range of the color index buffer are not clamped. However, before an index is dithered (if enabled) and written to the frame buffer, it is converted to fixed-point format. Any bits in the integer portion of the resulting fixed-point value that do not correspond to bits in the frame buffer are masked out.
     + 
     + $(D_INLINECODE glIndexub) and $(D_INLINECODE glIndexubv) are available only if the GL version is 1.1 or greater. The current index can be updated at any time. In particular, $(D_INLINECODE glIndex) can be called between a call to $(D_INLINECODE glBegin) and the corresponding call to $(D_INLINECODE glEnd).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColor), $(D_INLINECODE glIndexPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glIndexs glIndexs;
    alias fn_glIndexi = extern(System) void function(GLint c) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glIndexi glIndexi;
    alias fn_glIndexf = extern(System) void function(GLfloat c) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glIndexf glIndexf;
    alias fn_glIndexd = extern(System) void function(GLdouble c) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glIndexd glIndexd;
    alias fn_glIndexub = extern(System) void function(GLubyte c) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    fn_glIndexub glIndexub;
    alias fn_glIndexsv = extern(System) void function(const( GLshort*) c) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glIndexsv glIndexsv;
    alias fn_glIndexiv = extern(System) void function(const( GLint*) c) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glIndexiv glIndexiv;
    alias fn_glIndexfv = extern(System) void function(const( GLfloat*) c) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glIndexfv glIndexfv;
    alias fn_glIndexdv = extern(System) void function(const( GLdouble*) c) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glIndexdv glIndexdv;
    alias fn_glIndexubv = extern(System) void function(const(GLubyte)* c) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    fn_glIndexubv glIndexubv;
    alias fn_glIndexMask = extern(System) void function(GLuint mask) @system @nogc nothrow;

    /++
     + glIndexMask: man2/glIndexMask.xml
     + 
     + $(D_INLINECODE glIndexMask) controls the writing of individual bits in the color index buffers. The least significant n bits of $(D_INLINECODE mask), where n is the number of bits in a color index buffer, specify a mask. Where a 1 (one) appears in the mask, it's possible to write to the corresponding bit in the color index buffer (or buffers). Where a 0 (zero) appears, the corresponding bit is write-protected. This mask is used only in color index mode, and it affects only the buffers currently selected for writing (see $(D_INLINECODE glDrawBuffer) ). Initially, all bits are enabled for writing.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorMask), $(D_INLINECODE glDepthMask), $(D_INLINECODE glDrawBuffer), $(D_INLINECODE glIndex), $(D_INLINECODE glIndexPointer), $(D_INLINECODE glStencilMask)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glIndexMask glIndexMask;
    alias fn_glIndexPointer = extern(System) void function(GLenum type, GLsizei stride, const( GLvoid*) pointer) @system @nogc nothrow;

    /++
     + glIndexPointer: man2/glIndexPointer.xml
     + 
     + $(D_INLINECODE glIndexPointer) specifies the location and data format of an array of color indexes to use when rendering. $(D_INLINECODE type) specifies the data type of each color index and $(D_INLINECODE stride) specifies the byte stride from one color index to the next, allowing vertices and attributes to be packed into a single array or stored in separate arrays. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_ARRAY_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a color index array is specified, $(D_INLINECODE pointer) is treated as a byte offset into the buffer object's data store. Also, the buffer object binding ( $(D_INLINECODE GL_ARRAY_BUFFER_BINDING) ) is saved as color index vertex array client-side state ( $(D_INLINECODE GL_INDEX_ARRAY_BUFFER_BINDING) ). When a color index array is specified, $(D_INLINECODE type), $(D_INLINECODE stride), and $(D_INLINECODE pointer) are saved as client-side state, in addition to the current vertex array buffer object binding. To enable and disable the color index array, call $(D_INLINECODE glEnableClientState) and $(D_INLINECODE glDisableClientState) with the argument $(D_INLINECODE GL_INDEX_ARRAY). If enabled, the color index array is used when $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glMultiDrawElements), $(D_INLINECODE glDrawRangeElements), or $(D_INLINECODE glArrayElement) is called.
     + 
     + $(D_INLINECODE glIndexPointer) is available only if the GL version is 1.1 or greater. Color indexes are not supported for interleaved vertex array formats (see $(D_INLINECODE glInterleavedArrays) ). The color index array is initially disabled and isn't accessed when $(D_INLINECODE glArrayElement), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), or $(D_INLINECODE glMultiDrawElements) is called. Execution of $(D_INLINECODE glIndexPointer) is not allowed between $(D_INLINECODE glBegin) and the corresponding $(D_INLINECODE glEnd), but an error may or may not be generated. If an error is not generated, the operation is undefined. $(D_INLINECODE glIndexPointer) is typically implemented on the client side. Color index array parameters are client-side state and are therefore not saved or restored by $(D_INLINECODE glPushAttrib) and $(D_INLINECODE glPopAttrib). Use $(D_INLINECODE glPushClientAttrib) and $(D_INLINECODE glPopClientAttrib) instead.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glArrayElement), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glColorPointer), $(D_INLINECODE glDisableClientState), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glEdgeFlagPointer), $(D_INLINECODE glEnableClientState), $(D_INLINECODE glFogCoordPointer), $(D_INLINECODE glIndex), $(D_INLINECODE glInterleavedArrays), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glMultiDrawElements), $(D_INLINECODE glNormalPointer), $(D_INLINECODE glPopClientAttrib), $(D_INLINECODE glPushClientAttrib), $(D_INLINECODE glSecondaryColorPointer), $(D_INLINECODE glTexCoordPointer), $(D_INLINECODE glVertexAttribPointer), $(D_INLINECODE glVertexPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    fn_glIndexPointer glIndexPointer;
    alias fn_glInitNames = extern(System) void function() @system @nogc nothrow;

    /++
     + glInitNames: man2/glInitNames.xml
     + 
     + The name stack is used during selection mode to allow sets of rendering commands to be uniquely identified. It consists of an ordered set of unsigned integers. $(D_INLINECODE glInitNames) causes the name stack to be initialized to its default empty state. The name stack is always empty while the render mode is not $(D_INLINECODE GL_SELECT). Calls to $(D_INLINECODE glInitNames) while the render mode is not $(D_INLINECODE GL_SELECT) are ignored.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glLoadName), $(D_INLINECODE glPushName), $(D_INLINECODE glRenderMode), $(D_INLINECODE glSelectBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glInitNames glInitNames;
    alias fn_glInterleavedArrays = extern(System) void function(GLenum format, GLsizei stride, const( GLvoid*) pointer) @system @nogc nothrow;

    /++
     + glInterleavedArrays: man2/glInterleavedArrays.xml
     + 
     + $(D_INLINECODE glInterleavedArrays) lets you specify and enable individual color, normal, texture and vertex arrays whose elements are part of a larger aggregate array element. For some implementations, this is more efficient than specifying the arrays separately. If $(D_INLINECODE stride) is 0, the aggregate elements are stored consecutively. Otherwise, $(D_INLINECODE stride) bytes occur between the beginning of one aggregate array element and the beginning of the next aggregate array element. $(D_INLINECODE format) serves as a ``key'' describing the extraction of individual arrays from the aggregate array. If $(D_INLINECODE format) contains a T, then texture coordinates are extracted from the interleaved array.  If C is present, color values are extracted. If N is present, normal coordinates are extracted. Vertex coordinates are always extracted. The digits 2, 3, and 4 denote how many values are extracted. F indicates that values are extracted as floating-point values. Colors may also be extracted as 4 unsigned bytes if 4UB follows the C.  If a color is extracted as 4 unsigned bytes, the vertex array element which follows is located at the first possible floating-point aligned address.
     + 
     + $(D_INLINECODE glInterleavedArrays) is available only if the GL version is 1.1 or greater. If $(D_INLINECODE glInterleavedArrays) is called while compiling a display list, it is not compiled into the list, and it is executed immediately. Execution of $(D_INLINECODE glInterleavedArrays) is not allowed between the execution of $(D_INLINECODE glBegin) and the corresponding execution of $(D_INLINECODE glEnd), but an error may or may not be generated. If no error is generated, the operation is undefined. $(D_INLINECODE glInterleavedArrays) is typically implemented on the client side. Vertex array parameters are client-side state and are therefore not saved or restored by $(D_INLINECODE glPushAttrib) and $(D_INLINECODE glPopAttrib). Use $(D_INLINECODE glPushClientAttrib) and $(D_INLINECODE glPopClientAttrib) instead. For OpenGL versions 1.3 and greater, or when the $(D_INLINECODE ARB_multitexture) extension is supported, $(D_INLINECODE glInterleavedArrays) only updates the texture coordinate array for the client active texture unit. The texture coordinate state for other client texture units is not updated, regardless of whether the client texture unit is enabled or not. Secondary color values are not supported in interleaved vertex array formats.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glArrayElement), $(D_INLINECODE glClientActiveTexture), $(D_INLINECODE glColorPointer), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glEdgeFlagPointer), $(D_INLINECODE glEnableClientState), $(D_INLINECODE glGetPointerv), $(D_INLINECODE glIndexPointer), $(D_INLINECODE glNormalPointer), $(D_INLINECODE glSecondaryColorPointer), $(D_INLINECODE glTexCoordPointer), $(D_INLINECODE glVertexPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    fn_glInterleavedArrays glInterleavedArrays;
    alias fn_glIsList = extern(System) GLboolean function(GLuint list) @system @nogc nothrow;

    /++
     + glIsList: man2/glIsList.xml
     + 
     + $(D_INLINECODE glIsList) returns $(D_INLINECODE GL_TRUE) if $(D_INLINECODE list) is the name of a display list and returns $(D_INLINECODE GL_FALSE) if it is not, or if an error occurs. A name returned by $(D_INLINECODE glGenLists), but not yet associated with a display list by calling $(D_INLINECODE glNewList), is not the name of a display list.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCallList), $(D_INLINECODE glCallLists), $(D_INLINECODE glDeleteLists), $(D_INLINECODE glGenLists), $(D_INLINECODE glNewList)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glIsList glIsList;
    alias fn_glLightf = extern(System) void function(GLenum light, GLenum pname, GLfloat param) @system @nogc nothrow;

    /++
     + glLight: man2/glLight.xml
     + 
     + $(D_INLINECODE glLight) sets the values of individual light source parameters. $(D_INLINECODE light) names the light and is a symbolic name of the form $(D_INLINECODE GL_LIGHT) i, where i ranges from 0 to the value of $(D_INLINECODE GL_MAX_LIGHTS) - 1. $(D_INLINECODE pname) specifies one of ten light source parameters, again by symbolic name. $(D_INLINECODE params) is either a single value or a pointer to an array that contains the new values. To enable and disable lighting calculation, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_LIGHTING). Lighting is initially disabled. When it is enabled, light sources that are enabled contribute to the lighting calculation. Light source i is enabled and disabled using $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_LIGHT) i. The ten light parameters are as follows:
     + 
     + It is always the case that $(D_INLINECODE GL_LIGHT) i = $(D_INLINECODE GL_LIGHT0) + i.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorMaterial), $(D_INLINECODE glLightModel), $(D_INLINECODE glMaterial)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glLightf glLightf;
    alias fn_glLighti = extern(System) void function(GLenum light, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glLighti glLighti;
    alias fn_glLightfv = extern(System) void function(GLenum light, GLenum pname, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glLightfv glLightfv;
    alias fn_glLightiv = extern(System) void function(GLenum light, GLenum pname, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glLightiv glLightiv;
    alias fn_glLightModelf = extern(System) void function(GLenum pname, GLfloat param) @system @nogc nothrow;

    /++
     + glLightModel: man2/glLightModel.xml
     + 
     + $(D_INLINECODE glLightModel) sets the lighting model parameter. $(D_INLINECODE pname) names a parameter and $(D_INLINECODE params) gives the new value. There are three lighting model parameters: In RGBA mode, the lighted color of a vertex is the sum of the material emission intensity, the product of the material ambient reflectance and the lighting model full-scene ambient intensity, and the contribution of each enabled light source. Each light source contributes the sum of three terms: ambient, diffuse, and specular. The ambient light source contribution is the product of the material ambient reflectance and the light's ambient intensity. The diffuse light source contribution is the product of the material diffuse reflectance, the light's diffuse intensity, and the dot product of the vertex's normal with the normalized vector from the vertex to the light source. The specular light source contribution is the product of the material specular reflectance, the light's specular intensity, and the dot product of the normalized vertex-to-eye and vertex-to-light vectors, raised to the power of the shininess of the material. All three light source contributions are attenuated equally based on the distance from the vertex to the light source and on light source direction, spread exponent, and spread cutoff angle. All dot products are replaced with 0 if they evaluate to a negative value. The alpha component of the resulting lighted color is set to the alpha value of the material diffuse reflectance. In color index mode, the value of the lighted index of a vertex ranges from the ambient to the specular values passed to $(D_INLINECODE glMaterial) using $(D_INLINECODE GL_COLOR_INDEXES). Diffuse and specular coefficients, computed with a (.30, .59, .11) weighting of the lights' colors, the shininess of the material, and the same reflection and attenuation equations as in the RGBA case, determine how much above ambient the resulting index is.
     + 
     + $(D_INLINECODE GL_LIGHT_MODEL_COLOR_CONTROL) is available only if the GL version is 1.2 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glLight), $(D_INLINECODE glMaterial)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glLightModelf glLightModelf;
    alias fn_glLightModeli = extern(System) void function(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glLightModeli glLightModeli;
    alias fn_glLightModelfv = extern(System) void function(GLenum pname, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glLightModelfv glLightModelfv;
    alias fn_glLightModeliv = extern(System) void function(GLenum pname, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glLightModeliv glLightModeliv;
    alias fn_glLineStipple = extern(System) void function(GLint factor, GLushort pattern) @system @nogc nothrow;

    /++
     + glLineStipple: man2/glLineStipple.xml
     + 
     + Line stippling masks out certain fragments produced by rasterization; those fragments will not be drawn. The masking is achieved by using three parameters: the 16-bit line stipple pattern $(D_INLINECODE pattern), the repeat count $(D_INLINECODE factor), and an integer stipple counter s. Counter s is reset to 0 whenever $(D_INLINECODE glBegin) is called and before each line segment of a $(D_INLINECODE glBegin) ( $(D_INLINECODE GL_LINES) )/ $(D_INLINECODE glEnd) sequence is generated. It is incremented after each fragment of a unit width aliased line segment is generated or after each i fragments of an i width line segment are generated. The i fragments associated with count s are masked out if $(D_INLINECODE pattern) bit s factor % 16 is 0, otherwise these fragments are sent to the frame buffer. Bit zero of $(D_INLINECODE pattern) is the least significant bit. Antialiased lines are treated as a sequence of 1 &times; width rectangles for purposes of stippling. Whether rectangle s is rasterized or not depends on the fragment rule described for aliased lines, counting rectangles rather than groups of fragments. To enable and disable line stippling, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_LINE_STIPPLE). When enabled, the line stipple pattern is applied as described above. When disabled, it is as if the pattern were all 1's. Initially, line stippling is disabled.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glLineWidth), $(D_INLINECODE glPolygonStipple)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glLineStipple glLineStipple;
    alias fn_glListBase = extern(System) void function(GLuint base) @system @nogc nothrow;

    /++
     + glListBase: man2/glListBase.xml
     + 
     + $(D_INLINECODE glCallLists) specifies an array of offsets. Display-list names are generated by adding $(D_INLINECODE base) to each offset. Names that reference valid display lists are executed; the others are ignored.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCallLists)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glListBase glListBase;
    alias fn_glLoadIdentity = extern(System) void function() @system @nogc nothrow;

    /++
     + glLoadIdentity: man2/glLoadIdentity.xml
     + 
     + $(D_INLINECODE glLoadIdentity) replaces the current matrix with the identity matrix. It is semantically equivalent to calling $(D_INLINECODE glLoadMatrix) with the identity matrix 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 but in some cases it is more efficient.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glLoadMatrix), $(D_INLINECODE glLoadTransposeMatrix), $(D_INLINECODE glMatrixMode), $(D_INLINECODE glMultMatrix), $(D_INLINECODE glMultTransposeMatrix), $(D_INLINECODE glPushMatrix)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glLoadIdentity glLoadIdentity;
    alias fn_glLoadMatrixd = extern(System) void function(const( GLdouble*) m) @system @nogc nothrow;

    /++
     + glLoadMatrix: man2/glLoadMatrix.xml
     + 
     + $(D_INLINECODE glLoadMatrix) replaces the current matrix with the one whose elements are specified by $(D_INLINECODE m). The current matrix is the projection matrix, modelview matrix, or texture matrix, depending on the current matrix mode (see $(D_INLINECODE glMatrixMode) ). The current matrix, M, defines a transformation of coordinates. For instance, assume M refers to the modelview matrix. If v = v &af; 0 v &af; 1 v &af; 2 v &af; 3 is the set of object coordinates of a vertex, and $(D_INLINECODE m) points to an array of 16 single- or double-precision floating-point values m = m &af; 0 m &af; 1... m &af; 15, then the modelview transformation M &af; v does the following: M &af; v = m &af; 0 m &af; 4 m &af; 8 m &af; 12 m &af; 1 m &af; 5 m &af; 9 m &af; 13 m &af; 2 m &af; 6 m &af; 10 m &af; 14 m &af; 3 m &af; 7 m &af; 11 m &af; 15 &times; v &af; 0 v &af; 1 v &af; 2 v &af; 3 Projection and texture transformations are similarly defined.
     + 
     + While the elements of the matrix may be specified with single or double precision, the GL implementation may store or operate on these values in less than single precision.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glLoadIdentity), $(D_INLINECODE glMatrixMode), $(D_INLINECODE glMultMatrix), $(D_INLINECODE glMultTransposeMatrix), $(D_INLINECODE glPushMatrix)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glLoadMatrixd glLoadMatrixd;
    alias fn_glLoadMatrixf = extern(System) void function(const( GLfloat*) m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glLoadMatrixf glLoadMatrixf;
    alias fn_glLoadName = extern(System) void function(GLuint name) @system @nogc nothrow;

    /++
     + glLoadName: man2/glLoadName.xml
     + 
     + The name stack is used during selection mode to allow sets of rendering commands to be uniquely identified. It consists of an ordered set of unsigned integers and is initially empty. $(D_INLINECODE glLoadName) causes $(D_INLINECODE name) to replace the value on the top of the name stack. The name stack is always empty while the render mode is not $(D_INLINECODE GL_SELECT). Calls to $(D_INLINECODE glLoadName) while the render mode is not $(D_INLINECODE GL_SELECT) are ignored.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glInitNames), $(D_INLINECODE glPushName), $(D_INLINECODE glRenderMode), $(D_INLINECODE glSelectBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glLoadName glLoadName;
    alias fn_glLoadTransposeMatrixd = extern(System) void function(const( GLdouble*) m) @system @nogc nothrow;

    /++
     + glLoadTransposeMatrix: man2/glLoadTransposeMatrix.xml
     + 
     + $(D_INLINECODE glLoadTransposeMatrix) replaces the current matrix with the one whose elements are specified by $(D_INLINECODE m). The current matrix is the projection matrix, modelview matrix, or texture matrix, depending on the current matrix mode (see $(D_INLINECODE glMatrixMode) ). The current matrix, M, defines a transformation of coordinates. For instance, assume M refers to the modelview matrix. If v = v &af; 0 v &af; 1 v &af; 2 v &af; 3 is the set of object coordinates of a vertex, and $(D_INLINECODE m) points to an array of 16 single- or double-precision floating-point values m = m &af; 0 m &af; 1... m &af; 15, then the modelview transformation M &af; v does the following: M &af; v = m &af; 0 m &af; 1 m &af; 2 m &af; 3 m &af; 4 m &af; 5 m &af; 6 m &af; 7 m &af; 8 m &af; 9 m &af; 10 m &af; 11 m &af; 12 m &af; 13 m &af; 14 m &af; 15 &times; v &af; 0 v &af; 1 v &af; 2 v &af; 3 Projection and texture transformations are similarly defined. Calling $(D_INLINECODE glLoadTransposeMatrix) with matrix M is identical in operation to $(D_INLINECODE glLoadMatrix) with M T, where T represents the transpose.
     + 
     + $(D_INLINECODE glLoadTransposeMatrix) is available only if the GL version is 1.3 or greater. While the elements of the matrix may be specified with single or double precision, the GL implementation may store or operate on these values in less than single precision.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glLoadIdentity), $(D_INLINECODE glLoadMatrix), $(D_INLINECODE glMatrixMode), $(D_INLINECODE glMultMatrix), $(D_INLINECODE glMultTransposeMatrix), $(D_INLINECODE glPushMatrix)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glLoadTransposeMatrixd glLoadTransposeMatrixd;
    alias fn_glLoadTransposeMatrixf = extern(System) void function(const( GLfloat*) m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glLoadTransposeMatrixf glLoadTransposeMatrixf;
    alias fn_glMap1f = extern(System) void function(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const( GLfloat*) points) @system @nogc nothrow;

    /++
     + glMap1: man2/glMap1.xml
     + 
     + Evaluators provide a way to use polynomial or rational polynomial mapping to produce vertices, normals, texture coordinates, and colors. The values produced by an evaluator are sent to further stages of GL processing just as if they had been presented using $(D_INLINECODE glVertex), $(D_INLINECODE glNormal), $(D_INLINECODE glTexCoord), and $(D_INLINECODE glColor) commands, except that the generated values do not update the current normal, texture coordinates, or color. All polynomial or rational polynomial splines of any degree (up to the maximum degree supported by the GL implementation) can be described using evaluators. These include almost all splines used in computer graphics: B-splines, Bezier curves, Hermite splines, and so on. Evaluators define curves based on Bernstein polynomials. Define p &af; u &Hat; as p &af; u &Hat; = &Sigma; i = 0 n B i n &af; u &Hat; &it; R i where R i is a control point and B i n &af; u &Hat; is the i th Bernstein polynomial of degree n ( $(D_INLINECODE order) = n + 1 ): B i n &af; u &Hat; = n i &it; u &Hat; i &it; 1 - u &Hat; n - i Recall that 0 0 == 1 and n 0 == 1 $(D_INLINECODE glMap1) is used to define the basis and to specify what kind of values are produced. Once defined, a map can be enabled and disabled by calling $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with the map name, one of the nine predefined values for $(D_INLINECODE target) described below. $(D_INLINECODE glEvalCoord1) evaluates the one-dimensional maps that are enabled. When $(D_INLINECODE glEvalCoord1) presents a value u, the Bernstein functions are evaluated using u &Hat;, where u &Hat; = u - u1 u2 - u1 $(D_INLINECODE target) is a symbolic constant that indicates what kind of control points are provided in $(D_INLINECODE points), and what output is generated when the map is evaluated. It can assume one of nine predefined values: $(D_INLINECODE stride), $(D_INLINECODE order), and $(D_INLINECODE points) define the array addressing for accessing the control points. $(D_INLINECODE points) is the location of the first control point, which occupies one, two, three, or four contiguous memory locations, depending on which map is being defined. $(D_INLINECODE order) is the number of control points in the array. $(D_INLINECODE stride) specifies how many float or double locations to advance the internal memory pointer to reach the next control point.
     + 
     + As is the case with all GL commands that accept pointers to data, it is as if the contents of $(D_INLINECODE points) were copied by $(D_INLINECODE glMap1) before $(D_INLINECODE glMap1) returns. Changes to the contents of $(D_INLINECODE points) have no effect after $(D_INLINECODE glMap1) is called.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBegin), $(D_INLINECODE glColor), $(D_INLINECODE glEnable), $(D_INLINECODE glEvalCoord), $(D_INLINECODE glEvalMesh), $(D_INLINECODE glEvalPoint), $(D_INLINECODE glMap2), $(D_INLINECODE glMapGrid), $(D_INLINECODE glNormal), $(D_INLINECODE glTexCoord), $(D_INLINECODE glVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glMap1f glMap1f;
    alias fn_glMap1d = extern(System) void function(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const( GLdouble*) points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glMap1d glMap1d;
    alias fn_glMap2f = extern(System) void function(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const( GLfloat*) points) @system @nogc nothrow;

    /++
     + glMap2: man2/glMap2.xml
     + 
     + Evaluators provide a way to use polynomial or rational polynomial mapping to produce vertices, normals, texture coordinates, and colors. The values produced by an evaluator are sent on to further stages of GL processing just as if they had been presented using $(D_INLINECODE glVertex), $(D_INLINECODE glNormal), $(D_INLINECODE glTexCoord), and $(D_INLINECODE glColor) commands, except that the generated values do not update the current normal, texture coordinates, or color. All polynomial or rational polynomial splines of any degree (up to the maximum degree supported by the GL implementation) can be described using evaluators. These include almost all surfaces used in computer graphics, including B-spline surfaces, NURBS surfaces, Bezier surfaces, and so on. Evaluators define surfaces based on bivariate Bernstein polynomials. Define p &af; u &Hat; v &Hat; as p &af; u &Hat; v &Hat; = &Sigma; i = 0 n &Sigma; j = 0 m B i n &af; u &Hat; &it; B j m &af; v &Hat; &it; R ij where R ij is a control point, B i n &af; u &Hat; is the i th Bernstein polynomial of degree n ( $(D_INLINECODE uorder) = n + 1 ) B i n &af; u &Hat; = n i &it; u &Hat; i &it; 1 - u &Hat; n - i and B j m &af; v &Hat; is the j th Bernstein polynomial of degree m ( $(D_INLINECODE vorder) = m + 1 ) B j m &af; v &Hat; = m j &it; v &Hat; j &it; 1 - v &Hat; m - j Recall that 0 0 == 1 and n 0 == 1 $(D_INLINECODE glMap2) is used to define the basis and to specify what kind of values are produced. Once defined, a map can be enabled and disabled by calling $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with the map name, one of the nine predefined values for $(D_INLINECODE target), described below. When $(D_INLINECODE glEvalCoord2) presents values u and v, the bivariate Bernstein polynomials are evaluated using u &Hat; and v &Hat;, where u &Hat; = u - u1 u2 - u1 v &Hat; = v - v1 v2 - v1 $(D_INLINECODE target) is a symbolic constant that indicates what kind of control points are provided in $(D_INLINECODE points), and what output is generated when the map is evaluated. It can assume one of nine predefined values: $(D_INLINECODE ustride), $(D_INLINECODE uorder), $(D_INLINECODE vstride), $(D_INLINECODE vorder), and $(D_INLINECODE points) define the array addressing for accessing the control points. $(D_INLINECODE points) is the location of the first control point, which occupies one, two, three, or four contiguous memory locations, depending on which map is being defined. There are uorder &times; vorder control points in the array. $(D_INLINECODE ustride) specifies how many float or double locations are skipped to advance the internal memory pointer from control point R i &it; j to control point R i + 1 &it; j. $(D_INLINECODE vstride) specifies how many float or double locations are skipped to advance the internal memory pointer from control point R i &it; j to control point R i &af; j + 1.
     + 
     + As is the case with all GL commands that accept pointers to data, it is as if the contents of $(D_INLINECODE points) were copied by $(D_INLINECODE glMap2) before $(D_INLINECODE glMap2) returns. Changes to the contents of $(D_INLINECODE points) have no effect after $(D_INLINECODE glMap2) is called. Initially, $(D_INLINECODE GL_AUTO_NORMAL) is enabled. If $(D_INLINECODE GL_AUTO_NORMAL) is enabled, normal vectors are generated when either $(D_INLINECODE GL_MAP2_VERTEX_3) or $(D_INLINECODE GL_MAP2_VERTEX_4) is used to generate vertices.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBegin), $(D_INLINECODE glColor), $(D_INLINECODE glEnable), $(D_INLINECODE glEvalCoord), $(D_INLINECODE glEvalMesh), $(D_INLINECODE glEvalPoint), $(D_INLINECODE glMap1), $(D_INLINECODE glMapGrid), $(D_INLINECODE glNormal), $(D_INLINECODE glTexCoord), $(D_INLINECODE glVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glMap2f glMap2f;
    alias fn_glMap2d = extern(System) void function(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const( GLdouble*) points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glMap2d glMap2d;
    alias fn_glMapGrid1d = extern(System) void function(GLint un, GLdouble u1, GLdouble u2) @system @nogc nothrow;

    /++
     + glMapGrid: man2/glMapGrid.xml
     + 
     + $(D_INLINECODE glMapGrid) and $(D_INLINECODE glEvalMesh) are used together to efficiently generate and evaluate a series of evenly-spaced map domain values. $(D_INLINECODE glEvalMesh) steps through the integer domain of a one- or two-dimensional grid, whose range is the domain of the evaluation maps specified by $(D_INLINECODE glMap1) and $(D_INLINECODE glMap2). $(D_INLINECODE glMapGrid1) and $(D_INLINECODE glMapGrid2) specify the linear grid mappings between the i (or i and j ) integer grid coordinates, to the u (or u and v ) floating-point evaluation map coordinates. See $(D_INLINECODE glMap1) and $(D_INLINECODE glMap2) for details of how u and v coordinates are evaluated. $(D_INLINECODE glMapGrid1) specifies a single linear mapping such that integer grid coordinate 0 maps exactly to $(D_INLINECODE u1), and integer grid coordinate $(D_INLINECODE un) maps exactly to $(D_INLINECODE u2). All other integer grid coordinates i are mapped so that u = i &af; u2 - u1 un + u1 $(D_INLINECODE glMapGrid2) specifies two such linear mappings. One maps integer grid coordinate i = 0 exactly to $(D_INLINECODE u1), and integer grid coordinate i = un exactly to $(D_INLINECODE u2). The other maps integer grid coordinate j = 0 exactly to $(D_INLINECODE v1), and integer grid coordinate j = vn exactly to $(D_INLINECODE v2). Other integer grid coordinates i and j are mapped such that u = i &af; u2 - u1 un + u1 v = j &af; v2 - v1 vn + v1 The mappings specified by $(D_INLINECODE glMapGrid) are used identically by $(D_INLINECODE glEvalMesh) and $(D_INLINECODE glEvalPoint).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glEvalCoord), $(D_INLINECODE glEvalMesh), $(D_INLINECODE glEvalPoint), $(D_INLINECODE glMap1), $(D_INLINECODE glMap2)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glMapGrid1d glMapGrid1d;
    alias fn_glMapGrid1f = extern(System) void function(GLint un, GLfloat u1, GLfloat u2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glMapGrid1f glMapGrid1f;
    alias fn_glMapGrid2d = extern(System) void function(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glMapGrid2d glMapGrid2d;
    alias fn_glMapGrid2f = extern(System) void function(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glMapGrid2f glMapGrid2f;
    alias fn_glMaterialf = extern(System) void function(GLenum face, GLenum pname, GLfloat param) @system @nogc nothrow;

    /++
     + glMaterial: man2/glMaterial.xml
     + 
     + $(D_INLINECODE glMaterial) assigns values to material parameters. There are two matched sets of material parameters. One, the set, is used to shade points, lines, bitmaps, and all polygons (when two-sided lighting is disabled), or just front-facing polygons (when two-sided lighting is enabled). The other set,, is used to shade back-facing polygons only when two-sided lighting is enabled. Refer to the $(D_INLINECODE glLightModel) reference page for details concerning one- and two-sided lighting calculations. $(D_INLINECODE glMaterial) takes three arguments. The first, $(D_INLINECODE face), specifies whether the $(D_INLINECODE GL_FRONT) materials, the $(D_INLINECODE GL_BACK) materials, or both $(D_INLINECODE GL_FRONT_AND_BACK) materials will be modified. The second, $(D_INLINECODE pname), specifies which of several parameters in one or both sets will be modified. The third, $(D_INLINECODE params), specifies what value or values will be assigned to the specified parameter. Material parameters are used in the lighting equation that is optionally applied to each vertex. The equation is discussed in the $(D_INLINECODE glLightModel) reference page. The parameters that can be specified using $(D_INLINECODE glMaterial), and their interpretations by the lighting equation, are as follows:
     + 
     + The material parameters can be updated at any time. In particular, $(D_INLINECODE glMaterial) can be called between a call to $(D_INLINECODE glBegin) and the corresponding call to $(D_INLINECODE glEnd). If only a single material parameter is to be changed per vertex, however, $(D_INLINECODE glColorMaterial) is preferred over $(D_INLINECODE glMaterial) (see $(D_INLINECODE glColorMaterial) ). While the ambient, diffuse, specular and emission material parameters all have alpha components, only the diffuse alpha component is used in the lighting computation.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorMaterial), $(D_INLINECODE glLight), $(D_INLINECODE glLightModel)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glMaterialf glMaterialf;
    alias fn_glMateriali = extern(System) void function(GLenum face, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glMateriali glMateriali;
    alias fn_glMaterialfv = extern(System) void function(GLenum face, GLenum pname, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glMaterialfv glMaterialfv;
    alias fn_glMaterialiv = extern(System) void function(GLenum face, GLenum pname, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glMaterialiv glMaterialiv;
    alias fn_glMatrixMode = extern(System) void function(GLenum mode) @system @nogc nothrow;

    /++
     + glMatrixMode: man2/glMatrixMode.xml
     + 
     + $(D_INLINECODE glMatrixMode) sets the current matrix mode. $(D_INLINECODE mode) can assume one of four values: To find out which matrix stack is currently the target of all matrix operations, call $(D_INLINECODE glGet) with argument $(D_INLINECODE GL_MATRIX_MODE). The initial value is $(D_INLINECODE GL_MODELVIEW).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glLoadMatrix), $(D_INLINECODE glLoadTransposeMatrix), $(D_INLINECODE glMultMatrix), $(D_INLINECODE glMultTransposeMatrix), $(D_INLINECODE glPopMatrix), $(D_INLINECODE glPushMatrix)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glMatrixMode glMatrixMode;
    alias fn_glMinmax = extern(System) void function(GLenum target, GLenum internalformat, GLboolean sink) @system @nogc nothrow;

    /++
     + glMinmax: man2/glMinmax.xml
     + 
     + When $(D_INLINECODE GL_MINMAX) is enabled, the RGBA components of incoming pixels are compared to the minimum and maximum values for each component, which are stored in the two-element minmax table. (The first element stores the minima, and the second element stores the maxima.) If a pixel component is greater than the corresponding component in the maximum element, then the maximum element is updated with the pixel component value. If a pixel component is less than the corresponding component in the minimum element, then the minimum element is updated with the pixel component value. (In both cases, if the internal format of the minmax table includes luminance, then the R color component of incoming pixels is used for comparison.) The contents of the minmax table may be retrieved at a later time by calling $(D_INLINECODE glGetMinmax). The minmax operation is enabled or disabled by calling $(D_INLINECODE glEnable) or $(D_INLINECODE glDisable), respectively, with an argument of $(D_INLINECODE GL_MINMAX). $(D_INLINECODE glMinmax) redefines the current minmax table to have entries of the format specified by $(D_INLINECODE internalformat). The maximum element is initialized with the smallest possible component values, and the minimum element is initialized with the largest possible component values. The values in the previous minmax table, if any, are lost. If $(D_INLINECODE sink) is $(D_INLINECODE GL_TRUE), then pixels are discarded after minmax; no further processing of the pixels takes place, and no drawing, texture loading, or pixel readback will result.
     + 
     + $(D_INLINECODE glMinmax) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetMinmax), $(D_INLINECODE glResetMinmax)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    fn_glMinmax glMinmax;
    alias fn_glMultMatrixd = extern(System) void function(const( GLdouble*) m) @system @nogc nothrow;

    /++
     + glMultMatrix: man2/glMultMatrix.xml
     + 
     + $(D_INLINECODE glMultMatrix) multiplies the current matrix with the one specified using $(D_INLINECODE m), and replaces the current matrix with the product. The current matrix is determined by the current matrix mode (see $(D_INLINECODE glMatrixMode) ). It is either the projection matrix, modelview matrix, or the texture matrix.
     + 
     + While the elements of the matrix may be specified with single or double precision, the GL may store or operate on these values in less-than-single precision. In many computer languages, 4 &times; 4 arrays are represented in row-major order. The transformations just described represent these matrices in column-major order. The order of the multiplication is important. For example, if the current transformation is a rotation, and $(D_INLINECODE glMultMatrix) is called with a translation matrix, the translation is done directly on the coordinates to be transformed, while the rotation is done on the results of that translation.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glLoadIdentity), $(D_INLINECODE glLoadMatrix), $(D_INLINECODE glLoadTransposeMatrix), $(D_INLINECODE glMatrixMode), $(D_INLINECODE glMultTransposeMatrix), $(D_INLINECODE glPushMatrix)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glMultMatrixd glMultMatrixd;
    alias fn_glMultMatrixf = extern(System) void function(const( GLfloat*) m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glMultMatrixf glMultMatrixf;
    alias fn_glMultTransposeMatrixd = extern(System) void function(const( GLdouble*) m) @system @nogc nothrow;

    /++
     + glMultTransposeMatrix: man2/glMultTransposeMatrix.xml
     + 
     + $(D_INLINECODE glMultTransposeMatrix) multiplies the current matrix with the one specified using $(D_INLINECODE m), and replaces the current matrix with the product. The current matrix is determined by the current matrix mode (see $(D_INLINECODE glMatrixMode) ). It is either the projection matrix, modelview matrix, or the texture matrix.
     + 
     + $(D_INLINECODE glMultTransposeMatrix) is available only if the GL version is 1.3 or greater. While the elements of the matrix may be specified with single or double precision, the GL may store or operate on these values in less-than-single precision. The order of the multiplication is important. For example, if the current transformation is a rotation, and $(D_INLINECODE glMultTransposeMatrix) is called with a translation matrix, the translation is done directly on the coordinates to be transformed, while the rotation is done on the results of that translation.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glLoadIdentity), $(D_INLINECODE glLoadMatrix), $(D_INLINECODE glLoadTransposeMatrix), $(D_INLINECODE glMatrixMode), $(D_INLINECODE glPushMatrix)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glMultTransposeMatrixd glMultTransposeMatrixd;
    alias fn_glMultTransposeMatrixf = extern(System) void function(const( GLfloat*) m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P3)
    fn_glMultTransposeMatrixf glMultTransposeMatrixf;
    alias fn_glNewList = extern(System) void function(GLuint list, GLenum mode) @system @nogc nothrow;

    /++
     + glNewList: man2/glNewList.xml
     + 
     + Display lists are groups of GL commands that have been stored for subsequent execution. Display lists are created with $(D_INLINECODE glNewList). All subsequent commands are placed in the display list, in the order issued, until $(D_INLINECODE glEndList) is called. $(D_INLINECODE glNewList) has two arguments. The first argument, $(D_INLINECODE list), is a positive integer that becomes the unique name for the display list. Names can be created and reserved with $(D_INLINECODE glGenLists) and tested for uniqueness with $(D_INLINECODE glIsList). The second argument, $(D_INLINECODE mode), is a symbolic constant that can assume one of two values: Certain commands are not compiled into the display list but are executed immediately, regardless of the display-list mode. These commands are $(D_INLINECODE glAreTexturesResident), $(D_INLINECODE glColorPointer), $(D_INLINECODE glDeleteLists), $(D_INLINECODE glDeleteTextures), $(D_INLINECODE glDisableClientState), $(D_INLINECODE glEdgeFlagPointer), $(D_INLINECODE glEnableClientState), $(D_INLINECODE glFeedbackBuffer), $(D_INLINECODE glFinish), $(D_INLINECODE glFlush), $(D_INLINECODE glGenLists), $(D_INLINECODE glGenTextures), $(D_INLINECODE glIndexPointer), $(D_INLINECODE glInterleavedArrays), $(D_INLINECODE glIsEnabled), $(D_INLINECODE glIsList), $(D_INLINECODE glIsTexture), $(D_INLINECODE glNormalPointer), $(D_INLINECODE glPopClientAttrib), $(D_INLINECODE glPixelStore), $(D_INLINECODE glPushClientAttrib), $(D_INLINECODE glReadPixels), $(D_INLINECODE glRenderMode), $(D_INLINECODE glSelectBuffer), $(D_INLINECODE glTexCoordPointer), $(D_INLINECODE glVertexPointer), and all of the $(D_INLINECODE glGet) commands. Similarly, $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), and $(D_INLINECODE glTexImage3D) are executed immediately and not compiled into the display list when their first argument is $(D_INLINECODE GL_PROXY_TEXTURE_1D), $(D_INLINECODE GL_PROXY_TEXTURE_1D), or $(D_INLINECODE GL_PROXY_TEXTURE_3D), respectively. When the $(D_INLINECODE ARB_imaging) extension is supported, $(D_INLINECODE glHistogram) executes immediately when its argument is $(D_INLINECODE GL_PROXY_HISTOGRAM).  Similarly, $(D_INLINECODE glColorTable) executes immediately when its first argument is $(D_INLINECODE GL_PROXY_COLOR_TABLE), $(D_INLINECODE GL_PROXY_POST_CONVOLUTION_COLOR_TABLE), or $(D_INLINECODE GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE). For OpenGL versions 1.3 and greater, or when the $(D_INLINECODE ARB_multitexture) extension is supported, $(D_INLINECODE glClientActiveTexture) is not compiled into display lists, but executed immediately. When $(D_INLINECODE glEndList) is encountered, the display-list definition is completed by associating the list with the unique name $(D_INLINECODE list) (specified in the $(D_INLINECODE glNewList) command). If a display list with name $(D_INLINECODE list) already exists, it is replaced only when $(D_INLINECODE glEndList) is called.
     + 
     + $(D_INLINECODE glCallList) and $(D_INLINECODE glCallLists) can be entered into display lists. Commands in the display list or lists executed by $(D_INLINECODE glCallList) or $(D_INLINECODE glCallLists) are not included in the display list being created, even if the list creation mode is $(D_INLINECODE GL_COMPILE_AND_EXECUTE). A display list is just a group of commands and arguments, so errors generated by commands in a display list must be generated when the list is executed. If the list is created in $(D_INLINECODE GL_COMPILE) mode, errors are not generated until the list is executed.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCallList), $(D_INLINECODE glCallLists), $(D_INLINECODE glDeleteLists), $(D_INLINECODE glGenLists)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glNewList glNewList;
    alias fn_glEndList = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glEndList glEndList;
    alias fn_glNormal3b = extern(System) void function(GLbyte nx, GLbyte ny, GLbyte nz) @system @nogc nothrow;

    /++
     + glNormal: man2/glNormal.xml
     + 
     + The current normal is set to the given coordinates whenever $(D_INLINECODE glNormal) is issued. Byte, short, or integer arguments are converted to floating-point format with a linear mapping that maps the most positive representable integer value to 1.0 and the most negative representable integer value to -1.0. Normals specified with $(D_INLINECODE glNormal) need not have unit length. If $(D_INLINECODE GL_NORMALIZE) is enabled, then normals of any length specified with $(D_INLINECODE glNormal) are normalized after transformation. If $(D_INLINECODE GL_RESCALE_NORMAL) is enabled, normals are scaled by a scaling factor derived from the modelview matrix. $(D_INLINECODE GL_RESCALE_NORMAL) requires that the originally specified normals were of unit length, and that the modelview matrix contain only uniform scales for proper results. To enable and disable normalization, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with either $(D_INLINECODE GL_NORMALIZE) or $(D_INLINECODE GL_RESCALE_NORMAL). Normalization is initially disabled.
     + 
     + The current normal can be updated at any time. In particular, $(D_INLINECODE glNormal) can be called between a call to $(D_INLINECODE glBegin) and the corresponding call to $(D_INLINECODE glEnd).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBegin), $(D_INLINECODE glColor), $(D_INLINECODE glIndex), $(D_INLINECODE glMultiTexCoord), $(D_INLINECODE glNormalPointer), $(D_INLINECODE glTexCoord), $(D_INLINECODE glVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glNormal3b glNormal3b;
    alias fn_glNormal3d = extern(System) void function(GLdouble nx, GLdouble ny, GLdouble nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glNormal3d glNormal3d;
    alias fn_glNormal3f = extern(System) void function(GLfloat nx, GLfloat ny, GLfloat nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glNormal3f glNormal3f;
    alias fn_glNormal3i = extern(System) void function(GLint nx, GLint ny, GLint nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glNormal3i glNormal3i;
    alias fn_glNormal3s = extern(System) void function(GLshort nx, GLshort ny, GLshort nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glNormal3s glNormal3s;
    alias fn_glNormal3bv = extern(System) void function(const( GLbyte*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glNormal3bv glNormal3bv;
    alias fn_glNormal3dv = extern(System) void function(const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glNormal3dv glNormal3dv;
    alias fn_glNormal3fv = extern(System) void function(const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glNormal3fv glNormal3fv;
    alias fn_glNormal3iv = extern(System) void function(const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glNormal3iv glNormal3iv;
    alias fn_glNormal3sv = extern(System) void function(const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glNormal3sv glNormal3sv;
    alias fn_glNormalPointer = extern(System) void function(GLenum type, GLsizei stride, const( GLvoid*) pointer) @system @nogc nothrow;

    /++
     + glNormalPointer: man2/glNormalPointer.xml
     + 
     + $(D_INLINECODE glNormalPointer) specifies the location and data format of an array of normals to use when rendering. $(D_INLINECODE type) specifies the data type of each normal coordinate, and $(D_INLINECODE stride) specifies the byte stride from one normal to the next, allowing vertices and attributes to be packed into a single array or stored in separate arrays. (Single-array storage may be more efficient on some implementations; see $(D_INLINECODE glInterleavedArrays).) If a non-zero named buffer object is bound to the $(D_INLINECODE GL_ARRAY_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a normal array is specified, $(D_INLINECODE pointer) is treated as a byte offset into the buffer object's data store. Also, the buffer object binding ( $(D_INLINECODE GL_ARRAY_BUFFER_BINDING) ) is saved as normal vertex array client-side state ( $(D_INLINECODE GL_NORMAL_ARRAY_BUFFER_BINDING) ). When a normal array is specified, $(D_INLINECODE type), $(D_INLINECODE stride), and $(D_INLINECODE pointer) are saved as client-side state, in addition to the current vertex array buffer object binding. To enable and disable the normal array, call $(D_INLINECODE glEnableClientState) and $(D_INLINECODE glDisableClientState) with the argument $(D_INLINECODE GL_NORMAL_ARRAY). If enabled, the normal array is used when $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glMultiDrawElements), $(D_INLINECODE glDrawRangeElements), or $(D_INLINECODE glArrayElement) is called.
     + 
     + $(D_INLINECODE glNormalPointer) is available only if the GL version is 1.1 or greater. The normal array is initially disabled and isn't accessed when $(D_INLINECODE glArrayElement), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), or $(D_INLINECODE glMultiDrawElements) is called. Execution of $(D_INLINECODE glNormalPointer) is not allowed between $(D_INLINECODE glBegin) and the corresponding $(D_INLINECODE glEnd), but an error may or may not be generated. If an error is not generated, the operation is undefined. $(D_INLINECODE glNormalPointer) is typically implemented on the client side. Normal array parameters are client-side state and are therefore not saved or restored by $(D_INLINECODE glPushAttrib) and $(D_INLINECODE glPopAttrib). Use $(D_INLINECODE glPushClientAttrib) and $(D_INLINECODE glPopClientAttrib) instead.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glArrayElement), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glColorPointer), $(D_INLINECODE glDisableClientState), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glEdgeFlagPointer), $(D_INLINECODE glEnableClientState), $(D_INLINECODE glFogCoordPointer), $(D_INLINECODE glIndexPointer), $(D_INLINECODE glInterleavedArrays), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glMultiDrawElements), $(D_INLINECODE glNormal), $(D_INLINECODE glPopClientAttrib), $(D_INLINECODE glPushClientAttrib), $(D_INLINECODE glSecondaryColorPointer), $(D_INLINECODE glTexCoordPointer), $(D_INLINECODE glVertexAttribPointer), $(D_INLINECODE glVertexPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    fn_glNormalPointer glNormalPointer;
    alias fn_glOrtho = extern(System) void function(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble nearVal, GLdouble farVal) @system @nogc nothrow;

    /++
     + glOrtho: man2/glOrtho.xml
     + 
     + $(D_INLINECODE glOrtho) describes a transformation that produces a parallel projection. The current matrix (see $(D_INLINECODE glMatrixMode) ) is multiplied by this matrix and the result replaces the current matrix, as if $(D_INLINECODE glMultMatrix) were called with the following matrix as its argument: 2 right - left 0 0 t x 0 2 top - bottom 0 t y 0 0 -2 farVal - nearVal t z 0 0 0 1 where t x = - right + left right - left t y = - top + bottom top - bottom t z = - farVal + nearVal farVal - nearVal Typically, the matrix mode is $(D_INLINECODE GL_PROJECTION), and left bottom - nearVal and right top - nearVal specify the points on the near clipping plane that are mapped to the lower left and upper right corners of the window, respectively, assuming that the eye is located at (0, 0, 0). - farVal specifies the location of the far clipping plane. Both $(D_INLINECODE nearVal) and $(D_INLINECODE farVal) can be either positive or negative. Use $(D_INLINECODE glPushMatrix) and $(D_INLINECODE glPopMatrix) to save and restore the current matrix stack.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glFrustum), $(D_INLINECODE glMatrixMode), $(D_INLINECODE glMultMatrix), $(D_INLINECODE glPushMatrix), $(D_INLINECODE glViewport)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glOrtho glOrtho;
    alias fn_glPassThrough = extern(System) void function(GLfloat token) @system @nogc nothrow;

    /++
     + glPassThrough: man2/glPassThrough.xml
     + 
     + Feedback is a GL render mode. The mode is selected by calling $(D_INLINECODE glRenderMode) with $(D_INLINECODE GL_FEEDBACK). When the GL is in feedback mode, no pixels are produced by rasterization. Instead, information about primitives that would have been rasterized is fed back to the application using the GL. See the $(D_INLINECODE glFeedbackBuffer) reference page for a description of the feedback buffer and the values in it. $(D_INLINECODE glPassThrough) inserts a user-defined marker in the feedback buffer when it is executed in feedback mode. $(D_INLINECODE token) is returned as if it were a primitive; it is indicated with its own unique identifying value: $(D_INLINECODE GL_PASS_THROUGH_TOKEN). The order of $(D_INLINECODE glPassThrough) commands with respect to the specification of graphics primitives is maintained.
     + 
     + $(D_INLINECODE glPassThrough) is ignored if the GL is not in feedback mode.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glFeedbackBuffer), $(D_INLINECODE glRenderMode)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glPassThrough glPassThrough;
    alias fn_glPixelMapfv = extern(System) void function(GLenum map, GLsizei mapsize, const( GLfloat*) values) @system @nogc nothrow;

    /++
     + glPixelMap: man2/glPixelMap.xml
     + 
     + $(D_INLINECODE glPixelMap) sets up translation tables, or, used by $(D_INLINECODE glCopyPixels), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glReadPixels), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), and $(D_INLINECODE glTexSubImage3D). Additionally, if the $(D_INLINECODE ARB_imaging) subset is supported, the routines $(D_INLINECODE glColorTable), $(D_INLINECODE glColorSubTable), $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glConvolutionFilter2D), $(D_INLINECODE glHistogram), $(D_INLINECODE glMinmax), and $(D_INLINECODE glSeparableFilter2D). Use of these maps is described completely in the $(D_INLINECODE glPixelTransfer) reference page, and partly in the reference pages for the pixel and texture image commands. Only the specification of the maps is described in this reference page. $(D_INLINECODE map) is a symbolic map name, indicating one of ten maps to set. $(D_INLINECODE mapsize) specifies the number of entries in the map, and $(D_INLINECODE values) is a pointer to an array of $(D_INLINECODE mapsize) map values. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a pixel transfer map is specified, $(D_INLINECODE values) is treated as a byte offset into the buffer object's data store. The ten maps are as follows: The entries in a map can be specified as single-precision floating-point numbers, unsigned short integers, or unsigned int integers. Maps that store color component values (all but $(D_INLINECODE GL_PIXEL_MAP_I_TO_I) and $(D_INLINECODE GL_PIXEL_MAP_S_TO_S) ) retain their values in floating-point format, with unspecified mantissa and exponent sizes. Floating-point values specified by $(D_INLINECODE glPixelMapfv) are converted directly to the internal floating-point format of these maps, then clamped to the range [0,1]. Unsigned integer values specified by $(D_INLINECODE glPixelMapusv) and $(D_INLINECODE glPixelMapuiv) are converted linearly such that the largest representable integer maps to 1.0, and 0 maps to 0.0. Maps that store indices, $(D_INLINECODE GL_PIXEL_MAP_I_TO_I) and $(D_INLINECODE GL_PIXEL_MAP_S_TO_S), retain their values in fixed-point format, with an unspecified number of bits to the right of the binary point. Floating-point values specified by $(D_INLINECODE glPixelMapfv) are converted directly to the internal fixed-point format of these maps. Unsigned integer values specified by $(D_INLINECODE glPixelMapusv) and $(D_INLINECODE glPixelMapuiv) specify integer values, with all 0's to the right of the binary point. The following table shows the initial sizes and values for each of the maps. Maps that are indexed by either color or stencil indices must have $(D_INLINECODE mapsize) = 2 n for some n or the results are undefined. The maximum allowable size for each map depends on the implementation and can be determined by calling $(D_INLINECODE glGet) with argument $(D_INLINECODE GL_MAX_PIXEL_MAP_TABLE). The single maximum applies to all maps; it is at least 32. $(B $(D_INLINECODE map)) $(B Lookup Index) $(B Lookup Value) $(B Initial Size) $(B Initial Value) $(D_INLINECODE GL_PIXEL_MAP_I_TO_I) color index color index 1 0 $(D_INLINECODE GL_PIXEL_MAP_S_TO_S) stencil index stencil index 1 0 $(D_INLINECODE GL_PIXEL_MAP_I_TO_R) color index R 1 0 $(D_INLINECODE GL_PIXEL_MAP_I_TO_G) color index G 1 0 $(D_INLINECODE GL_PIXEL_MAP_I_TO_B) color index B 1 0 $(D_INLINECODE GL_PIXEL_MAP_I_TO_A) color index A 1 0 $(D_INLINECODE GL_PIXEL_MAP_R_TO_R) R R 1 0 $(D_INLINECODE GL_PIXEL_MAP_G_TO_G) G G 1 0 $(D_INLINECODE GL_PIXEL_MAP_B_TO_B) B B 1 0 $(D_INLINECODE GL_PIXEL_MAP_A_TO_A) A A 1 0
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorTable), $(D_INLINECODE glColorSubTable), $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glConvolutionFilter2D), $(D_INLINECODE glCopyPixels), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glHistogram), $(D_INLINECODE glMinmax), $(D_INLINECODE glPixelStore), $(D_INLINECODE glPixelTransfer), $(D_INLINECODE glReadPixels), $(D_INLINECODE glSeparableFilter2D), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glPixelMapfv glPixelMapfv;
    alias fn_glPixelMapuiv = extern(System) void function(GLenum map, GLsizei mapsize, const( GLuint*) values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glPixelMapuiv glPixelMapuiv;
    alias fn_glPixelMapusv = extern(System) void function(GLenum map, GLsizei mapsize, const( GLushort*) values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glPixelMapusv glPixelMapusv;
    alias fn_glPixelTransferf = extern(System) void function(GLenum pname, GLfloat param) @system @nogc nothrow;

    /++
     + glPixelTransfer: man2/glPixelTransfer.xml
     + 
     + $(D_INLINECODE glPixelTransfer) sets pixel transfer modes that affect the operation of subsequent $(D_INLINECODE glCopyPixels), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glReadPixels), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), and $(D_INLINECODE glTexSubImage3D) commands. Additionally, if the $(D_INLINECODE ARB_imaging) subset is supported, the routines $(D_INLINECODE glColorTable), $(D_INLINECODE glColorSubTable), $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glConvolutionFilter2D), $(D_INLINECODE glHistogram), $(D_INLINECODE glMinmax), and $(D_INLINECODE glSeparableFilter2D) are also affected. The algorithms that are specified by pixel transfer modes operate on pixels after they are read from the frame buffer ( $(D_INLINECODE glCopyPixels) $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), and $(D_INLINECODE glReadPixels) ), or unpacked from client memory ( $(D_INLINECODE glDrawPixels), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), and $(D_INLINECODE glTexSubImage3D) ). Pixel transfer operations happen in the same order, and in the same manner, regardless of the command that resulted in the pixel operation. Pixel storage modes (see $(D_INLINECODE glPixelStore) ) control the unpacking of pixels being read from client memory and the packing of pixels being written back into client memory. Pixel transfer operations handle four fundamental pixel types:,,, and. pixels consist of four floating-point values with unspecified mantissa and exponent sizes, scaled such that 0 represents zero intensity and 1 represents full intensity. comprise a single fixed-point value, with unspecified precision to the right of the binary point. pixels comprise a single floating-point value, with unspecified mantissa and exponent sizes, scaled such that 0.0 represents the minimum depth buffer value, and 1.0 represents the maximum depth buffer value. Finally, pixels comprise a single fixed-point value, with unspecified precision to the right of the binary point. The pixel transfer operations performed on the four basic pixel types are as follows: The following table gives the type, initial value, and range of valid values for each of the pixel transfer parameters that are set with $(D_INLINECODE glPixelTransfer). $(B $(D_INLINECODE pname)) $(B Type) $(B Initial Value) $(B Valid Range) $(D_INLINECODE GL_MAP_COLOR) boolean false true/false $(D_INLINECODE GL_MAP_STENCIL) boolean false true/false $(D_INLINECODE GL_INDEX_SHIFT) integer 0 -&#8734;&#8734; $(D_INLINECODE GL_INDEX_OFFSET) integer 0 -&#8734;&#8734; $(D_INLINECODE GL_RED_SCALE) float 1 -&#8734;&#8734; $(D_INLINECODE GL_GREEN_SCALE) float 1 -&#8734;&#8734; $(D_INLINECODE GL_BLUE_SCALE) float 1 -&#8734;&#8734; $(D_INLINECODE GL_ALPHA_SCALE) float 1 -&#8734;&#8734; $(D_INLINECODE GL_DEPTH_SCALE) float 1 -&#8734;&#8734; $(D_INLINECODE GL_RED_BIAS) float 0 -&#8734;&#8734; $(D_INLINECODE GL_GREEN_BIAS) float 0 -&#8734;&#8734; $(D_INLINECODE GL_BLUE_BIAS) float 0 -&#8734;&#8734; $(D_INLINECODE GL_ALPHA_BIAS) float 0 -&#8734;&#8734; $(D_INLINECODE GL_DEPTH_BIAS) float 0 -&#8734;&#8734; $(D_INLINECODE GL_POST_COLOR_MATRIX_RED_SCALE) float 1 -&#8734;&#8734; $(D_INLINECODE GL_POST_COLOR_MATRIX_GREEN_SCALE) float 1 -&#8734;&#8734; $(D_INLINECODE GL_POST_COLOR_MATRIX_BLUE_SCALE) float 1 -&#8734;&#8734; $(D_INLINECODE GL_POST_COLOR_MATRIX_ALPHA_SCALE) float 1 -&#8734;&#8734; $(D_INLINECODE GL_POST_COLOR_MATRIX_RED_BIAS) float 0 -&#8734;&#8734; $(D_INLINECODE GL_POST_COLOR_MATRIX_GREEN_BIAS) float 0 -&#8734;&#8734; $(D_INLINECODE GL_POST_COLOR_MATRIX_BLUE_BIAS) float 0 -&#8734;&#8734; $(D_INLINECODE GL_POST_COLOR_MATRIX_ALPHA_BIAS) float 0 -&#8734;&#8734; $(D_INLINECODE GL_POST_CONVOLUTION_RED_SCALE) float 1 -&#8734;&#8734; $(D_INLINECODE GL_POST_CONVOLUTION_GREEN_SCALE) float 1 -&#8734;&#8734; $(D_INLINECODE GL_POST_CONVOLUTION_BLUE_SCALE) float 1 -&#8734;&#8734; $(D_INLINECODE GL_POST_CONVOLUTION_ALPHA_SCALE) float 1 -&#8734;&#8734; $(D_INLINECODE GL_POST_CONVOLUTION_RED_BIAS) float 0 -&#8734;&#8734; $(D_INLINECODE GL_POST_CONVOLUTION_GREEN_BIAS) float 0 -&#8734;&#8734; $(D_INLINECODE GL_POST_CONVOLUTION_BLUE_BIAS) float 0 -&#8734;&#8734; $(D_INLINECODE GL_POST_CONVOLUTION_ALPHA_BIAS) float 0 -&#8734;&#8734; $(D_INLINECODE glPixelTransferf) can be used to set any pixel transfer parameter. If the parameter type is boolean, 0 implies false and any other value implies true. If $(D_INLINECODE pname) is an integer parameter, $(D_INLINECODE param) is rounded to the nearest integer. Likewise, $(D_INLINECODE glPixelTransferi) can be used to set any of the pixel transfer parameters. Boolean parameters are set to false if $(D_INLINECODE param) is 0 and to true otherwise. $(D_INLINECODE param) is converted to floating point before being assigned to real-valued parameters.
     + 
     + If a $(D_INLINECODE glColorTable), $(D_INLINECODE glColorSubTable), $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glConvolutionFilter2D), $(D_INLINECODE glCopyPixels), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glReadPixels), $(D_INLINECODE glSeparableFilter2D), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), or $(D_INLINECODE glTexSubImage3D) command is placed in a display list (see $(D_INLINECODE glNewList) and $(D_INLINECODE glCallList) ), the pixel transfer mode settings in effect when the display list is are the ones that are used. They may be different from the settings when the command was compiled into the display list.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCallList), $(D_INLINECODE glColorTable), $(D_INLINECODE glColorSubTable), $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glConvolutionFilter2D), $(D_INLINECODE glCopyPixels), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glNewList), $(D_INLINECODE glPixelMap), $(D_INLINECODE glPixelStore), $(D_INLINECODE glPixelZoom), $(D_INLINECODE glReadPixels), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glPixelTransferf glPixelTransferf;
    alias fn_glPixelTransferi = extern(System) void function(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glPixelTransferi glPixelTransferi;
    alias fn_glPixelZoom = extern(System) void function(GLfloat xfactor, GLfloat yfactor) @system @nogc nothrow;

    /++
     + glPixelZoom: man2/glPixelZoom.xml
     + 
     + $(D_INLINECODE glPixelZoom) specifies values for the x and y zoom factors. During the execution of $(D_INLINECODE glDrawPixels) or $(D_INLINECODE glCopyPixels), if ( xr, yr ) is the current raster position, and a given element is in the m th row and n th column of the pixel rectangle, then pixels whose centers are in the rectangle with corners at ( xr + n &CenterDot; xfactor, yr + m &CenterDot; yfactor ) ( xr + n + 1 &CenterDot; xfactor, yr + m + 1 &CenterDot; yfactor ) are candidates for replacement. Any pixel whose center lies on the bottom or left edge of this rectangular region is also modified. Pixel zoom factors are not limited to positive values. Negative zoom factors reflect the resulting image about the current raster position.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glCopyPixels), $(D_INLINECODE glDrawPixels)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glPixelZoom glPixelZoom;
    alias fn_glPolygonStipple = extern(System) void function(const(GLubyte)* pattern) @system @nogc nothrow;

    /++
     + glPolygonStipple: man2/glPolygonStipple.xml
     + 
     + Polygon stippling, like line stippling (see $(D_INLINECODE glLineStipple) ), masks out certain fragments produced by rasterization, creating a pattern. Stippling is independent of polygon antialiasing. $(D_INLINECODE pattern) is a pointer to a 32 &times; 32 stipple pattern that is stored in memory just like the pixel data supplied to a $(D_INLINECODE glDrawPixels) call with height and both equal to 32, a pixel format of $(D_INLINECODE GL_COLOR_INDEX), and data type of $(D_INLINECODE GL_BITMAP). That is, the stipple pattern is represented as a 32 &times; 32 array of 1-bit color indices packed in unsigned bytes. $(D_INLINECODE glPixelStore) parameters like $(D_INLINECODE GL_UNPACK_SWAP_BYTES) and $(D_INLINECODE GL_UNPACK_LSB_FIRST) affect the assembling of the bits into a stipple pattern. Pixel transfer operations (shift, offset, pixel map) are not applied to the stipple image, however. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a stipple pattern is specified, $(D_INLINECODE pattern) is treated as a byte offset into the buffer object's data store. To enable and disable polygon stippling, call $(D_INLINECODE glEnable) and $(D_INLINECODE glDisable) with argument $(D_INLINECODE GL_POLYGON_STIPPLE). Polygon stippling is initially disabled. If it's enabled, a rasterized polygon fragment with window coordinates x w and y w is sent to the next stage of the GL if and only if the ( x w % 32 )th bit in the ( y w % 32 )th row of the stipple pattern is 1 (one). When polygon stippling is disabled, it is as if the stipple pattern consists of all 1's.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glDrawPixels), $(D_INLINECODE glLineStipple), $(D_INLINECODE glPixelStore), $(D_INLINECODE glPixelTransfer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glPolygonStipple glPolygonStipple;
    alias fn_glPrioritizeTextures = extern(System) void function(GLsizei n, const( GLuint*) textures, const( GLclampf*) priorities) @system @nogc nothrow;

    /++
     + glPrioritizeTextures: man2/glPrioritizeTextures.xml
     + 
     + $(D_INLINECODE glPrioritizeTextures) assigns the $(D_INLINECODE n) texture priorities given in $(D_INLINECODE priorities) to the $(D_INLINECODE n) textures named in $(D_INLINECODE textures). The GL establishes a ``working set'' of textures that are resident in texture memory. These textures may be bound to a texture target much more efficiently than textures that are not resident. By specifying a priority for each texture, $(D_INLINECODE glPrioritizeTextures) allows applications to guide the GL implementation in determining which textures should be resident. The priorities given in $(D_INLINECODE priorities) are clamped to the range 0 1 before they are assigned. 0 indicates the lowest priority; textures with priority 0 are least likely to be resident. 1 indicates the highest priority; textures with priority 1 are most likely to be resident. However, textures are not guaranteed to be resident until they are used. $(D_INLINECODE glPrioritizeTextures) silently ignores attempts to prioritize texture 0 or any texture name that does not correspond to an existing texture. $(D_INLINECODE glPrioritizeTextures) does not require that any of the textures named by $(D_INLINECODE textures) be bound to a texture target. $(D_INLINECODE glTexParameter) may also be used to set a texture's priority, but only if the texture is currently bound. This is the only way to set the priority of a default texture.
     + 
     + $(D_INLINECODE glPrioritizeTextures) is available only if the GL version is 1.1 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glAreTexturesResident), $(D_INLINECODE glBindTexture), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexParameter)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    fn_glPrioritizeTextures glPrioritizeTextures;
    alias fn_glPushAttrib = extern(System) void function(GLbitfield mask) @system @nogc nothrow;

    /++
     + glPushAttrib: man2/glPushAttrib.xml
     + 
     + $(D_INLINECODE glPushAttrib) takes one argument, a mask that indicates which groups of state variables to save on the attribute stack. Symbolic constants are used to set bits in the mask. $(D_INLINECODE mask) is typically constructed by specifying the bitwise-or of several of these constants together. The special mask $(D_INLINECODE GL_ALL_ATTRIB_BITS) can be used to save all stackable states. The symbolic mask constants and their associated GL state are as follows (the second column lists which attributes are saved): $(D_INLINECODE GL_ACCUM_BUFFER_BIT) Accumulation buffer clear value $(D_INLINECODE GL_COLOR_BUFFER_BIT) $(D_INLINECODE GL_ALPHA_TEST) enable bit Alpha test function and reference value $(D_INLINECODE GL_BLEND) enable bit Blending source and destination functions Constant blend color Blending equation $(D_INLINECODE GL_DITHER) enable bit $(D_INLINECODE GL_DRAW_BUFFER) setting $(D_INLINECODE GL_COLOR_LOGIC_OP) enable bit $(D_INLINECODE GL_INDEX_LOGIC_OP) enable bit Logic op function Color mode and index mode clear values Color mode and index mode writemasks $(D_INLINECODE GL_CURRENT_BIT) Current RGBA color Current color index Current normal vector Current texture coordinates Current raster position $(D_INLINECODE GL_CURRENT_RASTER_POSITION_VALID) flag RGBA color associated with current raster position Color index associated with current raster position Texture coordinates associated with current raster position $(D_INLINECODE GL_EDGE_FLAG) flag $(D_INLINECODE GL_DEPTH_BUFFER_BIT) $(D_INLINECODE GL_DEPTH_TEST) enable bit Depth buffer test function Depth buffer clear value $(D_INLINECODE GL_DEPTH_WRITEMASK) enable bit $(D_INLINECODE GL_ENABLE_BIT) $(D_INLINECODE GL_ALPHA_TEST) flag $(D_INLINECODE GL_AUTO_NORMAL) flag $(D_INLINECODE GL_BLEND) flag Enable bits for the user-definable clipping planes $(D_INLINECODE GL_COLOR_MATERIAL) $(D_INLINECODE GL_CULL_FACE) flag $(D_INLINECODE GL_DEPTH_TEST) flag $(D_INLINECODE GL_DITHER) flag $(D_INLINECODE GL_FOG) flag $(D_INLINECODE GL_LIGHT) where $(D_INLINECODE 0) &lt;&#61; &lt; $(D_INLINECODE GL_MAX_LIGHTS) $(D_INLINECODE GL_LIGHTING) flag $(D_INLINECODE GL_LINE_SMOOTH) flag $(D_INLINECODE GL_LINE_STIPPLE) flag $(D_INLINECODE GL_COLOR_LOGIC_OP) flag $(D_INLINECODE GL_INDEX_LOGIC_OP) flag $(D_INLINECODE GL_MAP1_) where is a map type $(D_INLINECODE GL_MAP2_) where is a map type $(D_INLINECODE GL_MULTISAMPLE) flag $(D_INLINECODE GL_NORMALIZE) flag $(D_INLINECODE GL_POINT_SMOOTH) flag $(D_INLINECODE GL_POLYGON_OFFSET_LINE) flag $(D_INLINECODE GL_POLYGON_OFFSET_FILL) flag $(D_INLINECODE GL_POLYGON_OFFSET_POINT) flag $(D_INLINECODE GL_POLYGON_SMOOTH) flag $(D_INLINECODE GL_POLYGON_STIPPLE) flag $(D_INLINECODE GL_SAMPLE_ALPHA_TO_COVERAGE) flag $(D_INLINECODE GL_SAMPLE_ALPHA_TO_ONE) flag $(D_INLINECODE GL_SAMPLE_COVERAGE) flag $(D_INLINECODE GL_SCISSOR_TEST) flag $(D_INLINECODE GL_STENCIL_TEST) flag $(D_INLINECODE GL_TEXTURE_1D) flag $(D_INLINECODE GL_TEXTURE_2D) flag $(D_INLINECODE GL_TEXTURE_3D) flag Flags $(D_INLINECODE GL_TEXTURE_GEN_) where is S, T, R, or Q $(D_INLINECODE GL_EVAL_BIT) $(D_INLINECODE GL_MAP1_) enable bits, where is a map type $(D_INLINECODE GL_MAP2_) enable bits, where is a map type 1D grid endpoints and divisions 2D grid endpoints and divisions $(D_INLINECODE GL_AUTO_NORMAL) enable bit $(D_INLINECODE GL_FOG_BIT) $(D_INLINECODE GL_FOG) enable bit Fog color Fog density Linear fog start Linear fog end Fog index $(D_INLINECODE GL_FOG_MODE) value $(D_INLINECODE GL_HINT_BIT) $(D_INLINECODE GL_PERSPECTIVE_CORRECTION_HINT) setting $(D_INLINECODE GL_POINT_SMOOTH_HINT) setting $(D_INLINECODE GL_LINE_SMOOTH_HINT) setting $(D_INLINECODE GL_POLYGON_SMOOTH_HINT) setting $(D_INLINECODE GL_FOG_HINT) setting $(D_INLINECODE GL_GENERATE_MIPMAP_HINT) setting $(D_INLINECODE GL_TEXTURE_COMPRESSION_HINT) setting $(D_INLINECODE GL_LIGHTING_BIT) $(D_INLINECODE GL_COLOR_MATERIAL) enable bit $(D_INLINECODE GL_COLOR_MATERIAL_FACE) value Color material parameters that are tracking the current color Ambient scene color $(D_INLINECODE GL_LIGHT_MODEL_LOCAL_VIEWER) value $(D_INLINECODE GL_LIGHT_MODEL_TWO_SIDE) setting $(D_INLINECODE GL_LIGHTING) enable bit Enable bit for each light Ambient, diffuse, and specular intensity for each light Direction, position, exponent, and cutoff angle for each light Constant, linear, and quadratic attenuation factors for each light Ambient, diffuse, specular, and emissive color for each material Ambient, diffuse, and specular color indices for each material Specular exponent for each material $(D_INLINECODE GL_SHADE_MODEL) setting $(D_INLINECODE GL_LINE_BIT) $(D_INLINECODE GL_LINE_SMOOTH) flag $(D_INLINECODE GL_LINE_STIPPLE) enable bit Line stipple pattern and repeat counter Line width $(D_INLINECODE GL_LIST_BIT) $(D_INLINECODE GL_LIST_BASE) setting $(D_INLINECODE GL_MULTISAMPLE_BIT) $(D_INLINECODE GL_MULTISAMPLE) flag $(D_INLINECODE GL_SAMPLE_ALPHA_TO_COVERAGE) flag $(D_INLINECODE GL_SAMPLE_ALPHA_TO_ONE) flag $(D_INLINECODE GL_SAMPLE_COVERAGE) flag $(D_INLINECODE GL_SAMPLE_COVERAGE_VALUE) value $(D_INLINECODE GL_SAMPLE_COVERAGE_INVERT) value $(D_INLINECODE GL_PIXEL_MODE_BIT) $(D_INLINECODE GL_RED_BIAS) and $(D_INLINECODE GL_RED_SCALE) settings $(D_INLINECODE GL_GREEN_BIAS) and $(D_INLINECODE GL_GREEN_SCALE) values $(D_INLINECODE GL_BLUE_BIAS) and $(D_INLINECODE GL_BLUE_SCALE) $(D_INLINECODE GL_ALPHA_BIAS) and $(D_INLINECODE GL_ALPHA_SCALE) $(D_INLINECODE GL_DEPTH_BIAS) and $(D_INLINECODE GL_DEPTH_SCALE) $(D_INLINECODE GL_INDEX_OFFSET) and $(D_INLINECODE GL_INDEX_SHIFT) values $(D_INLINECODE GL_MAP_COLOR) and $(D_INLINECODE GL_MAP_STENCIL) flags $(D_INLINECODE GL_ZOOM_X) and $(D_INLINECODE GL_ZOOM_Y) factors $(D_INLINECODE GL_READ_BUFFER) setting $(D_INLINECODE GL_POINT_BIT) $(D_INLINECODE GL_POINT_SMOOTH) flag Point size $(D_INLINECODE GL_POLYGON_BIT) $(D_INLINECODE GL_CULL_FACE) enable bit $(D_INLINECODE GL_CULL_FACE_MODE) value $(D_INLINECODE GL_FRONT_FACE) indicator $(D_INLINECODE GL_POLYGON_MODE) setting $(D_INLINECODE GL_POLYGON_SMOOTH) flag $(D_INLINECODE GL_POLYGON_STIPPLE) enable bit $(D_INLINECODE GL_POLYGON_OFFSET_FILL) flag $(D_INLINECODE GL_POLYGON_OFFSET_LINE) flag $(D_INLINECODE GL_POLYGON_OFFSET_POINT) flag $(D_INLINECODE GL_POLYGON_OFFSET_FACTOR) $(D_INLINECODE GL_POLYGON_OFFSET_UNITS) $(D_INLINECODE GL_POLYGON_STIPPLE_BIT) Polygon stipple image $(D_INLINECODE GL_SCISSOR_BIT) $(D_INLINECODE GL_SCISSOR_TEST) flag Scissor box $(D_INLINECODE GL_STENCIL_BUFFER_BIT) $(D_INLINECODE GL_STENCIL_TEST) enable bit Stencil function and reference value Stencil value mask Stencil fail, pass, and depth buffer pass actions Stencil buffer clear value Stencil buffer writemask $(D_INLINECODE GL_TEXTURE_BIT) Enable bits for the four texture coordinates Border color for each texture image Minification function for each texture image Magnification function for each texture image Texture coordinates and wrap mode for each texture image Color and mode for each texture environment Enable bits $(D_INLINECODE GL_TEXTURE_GEN_), is S, T, R, and Q $(D_INLINECODE GL_TEXTURE_GEN_MODE) setting for S, T, R, and Q $(D_INLINECODE glTexGen) plane equations for S, T, R, and Q Current texture bindings (for example, $(D_INLINECODE GL_TEXTURE_BINDING_2D) ) $(D_INLINECODE GL_TRANSFORM_BIT) Coefficients of the six clipping planes Enable bits for the user-definable clipping planes $(D_INLINECODE GL_MATRIX_MODE) value $(D_INLINECODE GL_NORMALIZE) flag $(D_INLINECODE GL_RESCALE_NORMAL) flag $(D_INLINECODE GL_VIEWPORT_BIT) Depth range (near and far) Viewport origin and extent $(D_INLINECODE glPopAttrib) restores the values of the state variables saved with the last $(D_INLINECODE glPushAttrib) command. Those not saved are left unchanged. It is an error to push attributes onto a full stack or to pop attributes off an empty stack. In either case, the error flag is set and no other change is made to GL state. Initially, the attribute stack is empty.
     + 
     + Not all values for GL state can be saved on the attribute stack. For example, render mode state, and select and feedback state cannot be saved. Client state must be saved with $(D_INLINECODE glPushClientAttrib). The depth of the attribute stack depends on the implementation, but it must be at least 16. For OpenGL versions 1.3 and greater, or when the $(D_INLINECODE ARB_multitexture) extension is supported, pushing and popping texture state applies to all supported texture units.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGet), $(D_INLINECODE glGetClipPlane), $(D_INLINECODE glGetError), $(D_INLINECODE glGetLight), $(D_INLINECODE glGetMap), $(D_INLINECODE glGetMaterial), $(D_INLINECODE glGetPixelMap), $(D_INLINECODE glGetPolygonStipple), $(D_INLINECODE glGetString), $(D_INLINECODE glGetTexEnv), $(D_INLINECODE glGetTexGen), $(D_INLINECODE glGetTexImage), $(D_INLINECODE glGetTexLevelParameter), $(D_INLINECODE glGetTexParameter), $(D_INLINECODE glIsEnabled), $(D_INLINECODE glPushClientAttrib)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glPushAttrib glPushAttrib;
    alias fn_glPopAttrib = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glPopAttrib glPopAttrib;
    alias fn_glPushClientAttrib = extern(System) void function(GLbitfield mask) @system @nogc nothrow;

    /++
     + glPushClientAttrib: man2/glPushClientAttrib.xml
     + 
     + $(D_INLINECODE glPushClientAttrib) takes one argument, a mask that indicates which groups of client-state variables to save on the client attribute stack. Symbolic constants are used to set bits in the mask. $(D_INLINECODE mask) is typically constructed by specifying the bitwise-or of several of these constants together. The special mask $(D_INLINECODE GL_CLIENT_ALL_ATTRIB_BITS) can be used to save all stackable client state. The symbolic mask constants and their associated GL client state are as follows (the second column lists which attributes are saved): $(D_INLINECODE GL_CLIENT_PIXEL_STORE_BIT) Pixel storage modes $(D_INLINECODE GL_CLIENT_VERTEX_ARRAY_BIT) Vertex arrays (and enables) $(D_INLINECODE glPopClientAttrib) restores the values of the client-state variables saved with the last $(D_INLINECODE glPushClientAttrib). Those not saved are left unchanged. It is an error to push attributes onto a full client attribute stack or to pop attributes off an empty stack. In either case, the error flag is set, and no other change is made to GL state. Initially, the client attribute stack is empty.
     + 
     + $(D_INLINECODE glPushClientAttrib) is available only if the GL version is 1.1 or greater. Not all values for GL client state can be saved on the attribute stack. For example, select and feedback state cannot be saved. The depth of the attribute stack depends on the implementation, but it must be at least 16. Use $(D_INLINECODE glPushAttrib) and $(D_INLINECODE glPopAttrib) to push and restore state that is kept on the server. Only pixel storage modes and vertex array state may be pushed and popped with $(D_INLINECODE glPushClientAttrib) and $(D_INLINECODE glPopClientAttrib). For OpenGL versions 1.3 and greater, or when the $(D_INLINECODE ARB_multitexture) extension is supported, pushing and popping client vertex array state applies to all supported texture units, and the active client texture state.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColorPointer), $(D_INLINECODE glDisableClientState), $(D_INLINECODE glEdgeFlagPointer), $(D_INLINECODE glEnableClientState), $(D_INLINECODE glFogCoordPointer), $(D_INLINECODE glGet), $(D_INLINECODE glGetError), $(D_INLINECODE glIndexPointer), $(D_INLINECODE glNormalPointer), $(D_INLINECODE glNewList), $(D_INLINECODE glPixelStore), $(D_INLINECODE glPushAttrib), $(D_INLINECODE glTexCoordPointer), $(D_INLINECODE glVertexPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    fn_glPushClientAttrib glPushClientAttrib;
    alias fn_glPopClientAttrib = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    fn_glPopClientAttrib glPopClientAttrib;
    alias fn_glPushMatrix = extern(System) void function() @system @nogc nothrow;

    /++
     + glPushMatrix: man2/glPushMatrix.xml
     + 
     + There is a stack of matrices for each of the matrix modes. In $(D_INLINECODE GL_MODELVIEW) mode, the stack depth is at least 32. In the other modes, $(D_INLINECODE GL_COLOR), $(D_INLINECODE GL_PROJECTION), and $(D_INLINECODE GL_TEXTURE), the depth is at least 2. The current matrix in any mode is the matrix on the top of the stack for that mode. $(D_INLINECODE glPushMatrix) pushes the current matrix stack down by one, duplicating the current matrix. That is, after a $(D_INLINECODE glPushMatrix) call, the matrix on top of the stack is identical to the one below it. $(D_INLINECODE glPopMatrix) pops the current matrix stack, replacing the current matrix with the one below it on the stack. Initially, each of the stacks contains one matrix, an identity matrix. It is an error to push a full matrix stack or to pop a matrix stack that contains only a single matrix. In either case, the error flag is set and no other change is made to GL state.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glFrustum), $(D_INLINECODE glLoadIdentity), $(D_INLINECODE glLoadMatrix), $(D_INLINECODE glLoadTransposeMatrix), $(D_INLINECODE glMatrixMode), $(D_INLINECODE glMultMatrix), $(D_INLINECODE glMultTransposeMatrix), $(D_INLINECODE glOrtho), $(D_INLINECODE glRotate), $(D_INLINECODE glScale), $(D_INLINECODE glTranslate), $(D_INLINECODE glViewport)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glPushMatrix glPushMatrix;
    alias fn_glPopMatrix = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glPopMatrix glPopMatrix;
    alias fn_glPushName = extern(System) void function(GLuint name) @system @nogc nothrow;

    /++
     + glPushName: man2/glPushName.xml
     + 
     + The name stack is used during selection mode to allow sets of rendering commands to be uniquely identified. It consists of an ordered set of unsigned integers and is initially empty. $(D_INLINECODE glPushName) causes $(D_INLINECODE name) to be pushed onto the name stack. $(D_INLINECODE glPopName) pops one name off the top of the stack. The maximum name stack depth is implementation-dependent; call $(D_INLINECODE GL_MAX_NAME_STACK_DEPTH) to find out the value for a particular implementation. It is an error to push a name onto a full stack or to pop a name off an empty stack. It is also an error to manipulate the name stack between the execution of $(D_INLINECODE glBegin) and the corresponding execution of $(D_INLINECODE glEnd). In any of these cases, the error flag is set and no other change is made to GL state. The name stack is always empty while the render mode is not $(D_INLINECODE GL_SELECT). Calls to $(D_INLINECODE glPushName) or $(D_INLINECODE glPopName) while the render mode is not $(D_INLINECODE GL_SELECT) are ignored.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glInitNames), $(D_INLINECODE glLoadName), $(D_INLINECODE glRenderMode), $(D_INLINECODE glSelectBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glPushName glPushName;
    alias fn_glPopName = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glPopName glPopName;
    alias fn_glRasterPos2s = extern(System) void function(GLshort x, GLshort y) @system @nogc nothrow;

    /++
     + glRasterPos: man2/glRasterPos.xml
     + 
     + The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See $(D_INLINECODE glBitmap), $(D_INLINECODE glDrawPixels), and $(D_INLINECODE glCopyPixels). The current raster position consists of three window coordinates ( x, y, z ), a clip coordinate value ( w ), an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The w coordinate is a clip coordinate, because w is not projected to window coordinates. $(D_INLINECODE glRasterPos4) specifies object coordinates x, y, z, and w explicitly. $(D_INLINECODE glRasterPos3) specifies object coordinate x, y, and z explicitly, while w is implicitly set to 1. $(D_INLINECODE glRasterPos2) uses the argument values for x and y while implicitly setting z and w to 0 and 1. The object coordinates presented by $(D_INLINECODE glRasterPos) are treated just like those of a $(D_INLINECODE glVertex) command: They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the $(D_INLINECODE GL_CURRENT_RASTER_POSITION_VALID) flag is set. If the vertex culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined. The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then $(D_INLINECODE GL_CURRENT_RASTER_COLOR) (in RGBA mode) or $(D_INLINECODE GL_CURRENT_RASTER_INDEX) (in color index mode) is set to the color produced by the lighting calculation (see $(D_INLINECODE glLight), $(D_INLINECODE glLightModel), and $(D_INLINECODE glShadeModel) ). If lighting is disabled, current color (in RGBA mode, state variable $(D_INLINECODE GL_CURRENT_COLOR) ) or color index (in color index mode, state variable $(D_INLINECODE GL_CURRENT_INDEX) ) is used to update the current raster color. $(D_INLINECODE GL_CURRENT_RASTER_SECONDARY_COLOR) (in RGBA mode) is likewise updated. Likewise, $(D_INLINECODE GL_CURRENT_RASTER_TEXTURE_COORDS) is updated as a function of $(D_INLINECODE GL_CURRENT_TEXTURE_COORDS), based on the texture matrix and the texture generation functions (see $(D_INLINECODE glTexGen) ). Finally, the distance from the origin of the eye coordinate system to the vertex as transformed by only the modelview matrix replaces $(D_INLINECODE GL_CURRENT_RASTER_DISTANCE). Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, $(D_INLINECODE GL_CURRENT_RASTER_INDEX) is always 1; in color index mode, the current raster RGBA color always maintains its initial value.
     + 
     + The raster position is modified by $(D_INLINECODE glRasterPos), $(D_INLINECODE glBitmap), and $(D_INLINECODE glWindowPos). When the raster position coordinates are invalid, drawing commands that are based on the raster position are ignored (that is, they do not result in changes to GL state). Calling $(D_INLINECODE glDrawElements) or $(D_INLINECODE glDrawRangeElements) may leave the current color or index indeterminate. If $(D_INLINECODE glRasterPos) is executed while the current color or index is indeterminate, the current raster color or current raster index remains indeterminate. To set a valid raster position outside the viewport, first set a valid raster position, then call $(D_INLINECODE glBitmap) with null as the
     +  parameter. When the $(D_INLINECODE ARB_imaging) extension is supported, there are distinct raster texture coordinates for each texture unit. Each texture unit's current raster texture coordinates are updated by $(D_INLINECODE glRasterPos).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBitmap), $(D_INLINECODE glCopyPixels), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glMultiTexCoord), $(D_INLINECODE glTexCoord), $(D_INLINECODE glTexGen), $(D_INLINECODE glVertex), $(D_INLINECODE glWindowPos)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glRasterPos2s glRasterPos2s;
    alias fn_glRasterPos2i = extern(System) void function(GLint x, GLint y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glRasterPos2i glRasterPos2i;
    alias fn_glRasterPos2f = extern(System) void function(GLfloat x, GLfloat y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glRasterPos2f glRasterPos2f;
    alias fn_glRasterPos2d = extern(System) void function(GLdouble x, GLdouble y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glRasterPos2d glRasterPos2d;
    alias fn_glRasterPos3s = extern(System) void function(GLshort x, GLshort y, GLshort z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glRasterPos3s glRasterPos3s;
    alias fn_glRasterPos3i = extern(System) void function(GLint x, GLint y, GLint z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glRasterPos3i glRasterPos3i;
    alias fn_glRasterPos3f = extern(System) void function(GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glRasterPos3f glRasterPos3f;
    alias fn_glRasterPos3d = extern(System) void function(GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glRasterPos3d glRasterPos3d;
    alias fn_glRasterPos4s = extern(System) void function(GLshort x, GLshort y, GLshort z, GLshort w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glRasterPos4s glRasterPos4s;
    alias fn_glRasterPos4i = extern(System) void function(GLint x, GLint y, GLint z, GLint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glRasterPos4i glRasterPos4i;
    alias fn_glRasterPos4f = extern(System) void function(GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glRasterPos4f glRasterPos4f;
    alias fn_glRasterPos4d = extern(System) void function(GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glRasterPos4d glRasterPos4d;
    alias fn_glRasterPos2sv = extern(System) void function(const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glRasterPos2sv glRasterPos2sv;
    alias fn_glRasterPos2iv = extern(System) void function(const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glRasterPos2iv glRasterPos2iv;
    alias fn_glRasterPos2fv = extern(System) void function(const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glRasterPos2fv glRasterPos2fv;
    alias fn_glRasterPos2dv = extern(System) void function(const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glRasterPos2dv glRasterPos2dv;
    alias fn_glRasterPos3sv = extern(System) void function(const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glRasterPos3sv glRasterPos3sv;
    alias fn_glRasterPos3iv = extern(System) void function(const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glRasterPos3iv glRasterPos3iv;
    alias fn_glRasterPos3fv = extern(System) void function(const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glRasterPos3fv glRasterPos3fv;
    alias fn_glRasterPos3dv = extern(System) void function(const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glRasterPos3dv glRasterPos3dv;
    alias fn_glRasterPos4sv = extern(System) void function(const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glRasterPos4sv glRasterPos4sv;
    alias fn_glRasterPos4iv = extern(System) void function(const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glRasterPos4iv glRasterPos4iv;
    alias fn_glRasterPos4fv = extern(System) void function(const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glRasterPos4fv glRasterPos4fv;
    alias fn_glRasterPos4dv = extern(System) void function(const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glRasterPos4dv glRasterPos4dv;
    alias fn_glRectd = extern(System) void function(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2) @system @nogc nothrow;

    /++
     + glRect: man2/glRect.xml
     + 
     + $(D_INLINECODE glRect) supports efficient specification of rectangles as two corner points. Each rectangle command takes four arguments, organized either as two consecutive pairs of x y coordinates or as two pointers to arrays, each containing an x y pair. The resulting rectangle is defined in the z = 0 plane. $(D_INLINECODE glRect) ( $(D_INLINECODE x1), $(D_INLINECODE y1), $(D_INLINECODE x2), $(D_INLINECODE y2) ) is exactly equivalent to the following sequence:
     + 
     + ---
     + glBegin( $(D_INLINECODE GL_POLYGON));
     + glVertex2( $(D_INLINECODE x1),  $(D_INLINECODE y1));
     + glVertex2( $(D_INLINECODE x2),  $(D_INLINECODE y1));
     + glVertex2( $(D_INLINECODE x2),  $(D_INLINECODE y2));
     + glVertex2( $(D_INLINECODE x1),  $(D_INLINECODE y2));
     + glEnd();
     +         
     + ---
     +  Note that if the second vertex is above and to the right of the first vertex, the rectangle is constructed with a counterclockwise winding.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBegin), $(D_INLINECODE glVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glRectd glRectd;
    alias fn_glRectf = extern(System) void function(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glRectf glRectf;
    alias fn_glRecti = extern(System) void function(GLint x1, GLint y1, GLint x2, GLint y2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glRecti glRecti;
    alias fn_glRects = extern(System) void function(GLshort x1, GLshort y1, GLshort x2, GLshort y2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glRects glRects;
    alias fn_glRectdv = extern(System) void function(const( GLdouble*) v1, const( GLdouble*) v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glRectdv glRectdv;
    alias fn_glRectfv = extern(System) void function(const( GLfloat*) v1, const( GLfloat*) v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glRectfv glRectfv;
    alias fn_glRectiv = extern(System) void function(const( GLint*) v1, const( GLint*) v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glRectiv glRectiv;
    alias fn_glRectsv = extern(System) void function(const( GLshort*) v1, const( GLshort*) v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glRectsv glRectsv;
    alias fn_glRenderMode = extern(System) GLint function(GLenum mode) @system @nogc nothrow;

    /++
     + glRenderMode: man2/glRenderMode.xml
     + 
     + $(D_INLINECODE glRenderMode) sets the rasterization mode. It takes one argument, $(D_INLINECODE mode), which can assume one of three predefined values: The return value of $(D_INLINECODE glRenderMode) is determined by the render mode at the time $(D_INLINECODE glRenderMode) is called, rather than by $(D_INLINECODE mode). The values returned for the three render modes are as follows: See the $(D_INLINECODE glSelectBuffer) and $(D_INLINECODE glFeedbackBuffer) reference pages for more details concerning selection and feedback operation.
     + 
     + If an error is generated, $(D_INLINECODE glRenderMode) returns 0 regardless of the current render mode.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glFeedbackBuffer), $(D_INLINECODE glInitNames), $(D_INLINECODE glLoadName), $(D_INLINECODE glPassThrough), $(D_INLINECODE glPushName), $(D_INLINECODE glSelectBuffer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glRenderMode glRenderMode;
    alias fn_glResetHistogram = extern(System) void function(GLenum target) @system @nogc nothrow;

    /++
     + glResetHistogram: man2/glResetHistogram.xml
     + 
     + $(D_INLINECODE glResetHistogram) resets all the elements of the current histogram table to zero.
     + 
     + $(D_INLINECODE glResetHistogram) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glHistogram)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    fn_glResetHistogram glResetHistogram;
    alias fn_glResetMinmax = extern(System) void function(GLenum target) @system @nogc nothrow;

    /++
     + glResetMinmax: man2/glResetMinmax.xml
     + 
     + $(D_INLINECODE glResetMinmax) resets the elements of the current minmax table to their initial values: the ``maximum'' element receives the minimum possible component values, and the ``minimum'' element receives the maximum possible component values.
     + 
     + $(D_INLINECODE glResetMinmax) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glMinmax)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    fn_glResetMinmax glResetMinmax;
    alias fn_glRotated = extern(System) void function(GLdouble angle, GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;

    /++
     + glRotate: man2/glRotate.xml
     + 
     + $(D_INLINECODE glRotate) produces a rotation of $(D_INLINECODE angle) degrees around the vector x y z. The current matrix (see $(D_INLINECODE glMatrixMode) ) is multiplied by a rotation matrix with the product replacing the current matrix, as if $(D_INLINECODE glMultMatrix) were called with the following matrix as its argument: x 2 &af; 1 - c + c x &it; y &af; 1 - c - z &it; s x &it; z &af; 1 - c + y &it; s 0 y &it; x &af; 1 - c + z &it; s y 2 &af; 1 - c + c y &it; z &af; 1 - c - x &it; s 0 x &it; z &af; 1 - c - y &it; s y &it; z &af; 1 - c + x &it; s z 2 &af; 1 - c + c 0 0 0 0 1 Where c = cos &af; angle, s = sin &af; angle, and x y z = 1 (if not, the GL will normalize this vector). If the matrix mode is either $(D_INLINECODE GL_MODELVIEW) or $(D_INLINECODE GL_PROJECTION), all objects drawn after $(D_INLINECODE glRotate) is called are rotated. Use $(D_INLINECODE glPushMatrix) and $(D_INLINECODE glPopMatrix) to save and restore the unrotated coordinate system.
     + 
     + This rotation follows the right-hand rule, so if the vector x y z points toward the user, the rotation will be counterclockwise.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glMatrixMode), $(D_INLINECODE glMultMatrix), $(D_INLINECODE glPushMatrix), $(D_INLINECODE glScale), $(D_INLINECODE glTranslate)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glRotated glRotated;
    alias fn_glRotatef = extern(System) void function(GLfloat angle, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glRotatef glRotatef;
    alias fn_glScaled = extern(System) void function(GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;

    /++
     + glScale: man2/glScale.xml
     + 
     + $(D_INLINECODE glScale) produces a nonuniform scaling along the,, and axes. The three parameters indicate the desired scale factor along each of the three axes. The current matrix (see $(D_INLINECODE glMatrixMode) ) is multiplied by this scale matrix, and the product replaces the current matrix as if $(D_INLINECODE glMultMatrix) were called with the following matrix as its argument: x 0 0 0 0 y 0 0 0 0 z 0 0 0 0 1 If the matrix mode is either $(D_INLINECODE GL_MODELVIEW) or $(D_INLINECODE GL_PROJECTION), all objects drawn after $(D_INLINECODE glScale) is called are scaled. Use $(D_INLINECODE glPushMatrix) and $(D_INLINECODE glPopMatrix) to save and restore the unscaled coordinate system.
     + 
     + If scale factors other than 1 are applied to the modelview matrix and lighting is enabled, lighting often appears wrong. In that case, enable automatic normalization of normals by calling $(D_INLINECODE glEnable) with the argument $(D_INLINECODE GL_NORMALIZE).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glMatrixMode), $(D_INLINECODE glMultMatrix), $(D_INLINECODE glPushMatrix), $(D_INLINECODE glRotate), $(D_INLINECODE glTranslate)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glScaled glScaled;
    alias fn_glScalef = extern(System) void function(GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glScalef glScalef;
    alias fn_glSecondaryColor3b = extern(System) void function(GLbyte red, GLbyte green, GLbyte blue) @system @nogc nothrow;

    /++
     + glSecondaryColor: man2/glSecondaryColor.xml
     + 
     + The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where alpha is always set to 0.0) that is associated with every vertex. The secondary color is interpolated and applied to each fragment during rasterization when $(D_INLINECODE GL_COLOR_SUM) is enabled.  When lighting is enabled, and $(D_INLINECODE GL_SEPARATE_SPECULAR_COLOR) is specified, the value of the secondary color is assigned the value computed from the specular term of the lighting computation. Both the primary and secondary current colors are applied to each fragment, regardless of the state of $(D_INLINECODE GL_COLOR_SUM), under such conditions.  When $(D_INLINECODE GL_SEPARATE_SPECULAR_COLOR) is specified, the value returned from querying the current secondary color is undefined. $(D_INLINECODE glSecondaryColor3b), $(D_INLINECODE glSecondaryColor3s), and $(D_INLINECODE glSecondaryColor3i) take three signed byte, short, or long integers as arguments.  When $(B v) is appended to the name, the color commands can take a pointer to an array of such values. Color values are stored in floating-point format, with unspecified mantissa and exponent sizes.  Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity).  Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to -1.0. (Note that this mapping does not convert 0 precisely to 0.0).  Floating-point values are mapped directly. Neither floating-point nor signed integer values are clamped to the range 0 1 before the current color is updated.  However, color components are clamped to this range before they are interpolated or written into a color buffer.
     + 
     + $(D_INLINECODE glSecondaryColor) is available only if the GL version is 1.4 or greater. The initial value for the secondary color is (0, 0, 0, 0). The secondary color can be updated at any time.  In particular, $(D_INLINECODE glSecondaryColor) can be called between a call to $(D_INLINECODE glBegin) and the corresponding call to $(D_INLINECODE glEnd).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glColor), $(D_INLINECODE glIndex), $(D_INLINECODE glIsEnabled), $(D_INLINECODE glLightModel), $(D_INLINECODE glSecondaryColorPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glSecondaryColor3b glSecondaryColor3b;
    alias fn_glSecondaryColor3s = extern(System) void function(GLshort red, GLshort green, GLshort blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glSecondaryColor3s glSecondaryColor3s;
    alias fn_glSecondaryColor3i = extern(System) void function(GLint red, GLint green, GLint blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glSecondaryColor3i glSecondaryColor3i;
    alias fn_glSecondaryColor3f = extern(System) void function(GLfloat red, GLfloat green, GLfloat blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glSecondaryColor3f glSecondaryColor3f;
    alias fn_glSecondaryColor3d = extern(System) void function(GLdouble red, GLdouble green, GLdouble blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glSecondaryColor3d glSecondaryColor3d;
    alias fn_glSecondaryColor3ub = extern(System) void function(GLubyte red, GLubyte green, GLubyte blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glSecondaryColor3ub glSecondaryColor3ub;
    alias fn_glSecondaryColor3us = extern(System) void function(GLushort red, GLushort green, GLushort blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glSecondaryColor3us glSecondaryColor3us;
    alias fn_glSecondaryColor3ui = extern(System) void function(GLuint red, GLuint green, GLuint blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glSecondaryColor3ui glSecondaryColor3ui;
    alias fn_glSecondaryColor3bv = extern(System) void function(const( GLbyte*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glSecondaryColor3bv glSecondaryColor3bv;
    alias fn_glSecondaryColor3sv = extern(System) void function(const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glSecondaryColor3sv glSecondaryColor3sv;
    alias fn_glSecondaryColor3iv = extern(System) void function(const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glSecondaryColor3iv glSecondaryColor3iv;
    alias fn_glSecondaryColor3fv = extern(System) void function(const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glSecondaryColor3fv glSecondaryColor3fv;
    alias fn_glSecondaryColor3dv = extern(System) void function(const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glSecondaryColor3dv glSecondaryColor3dv;
    alias fn_glSecondaryColor3ubv = extern(System) void function(const(GLubyte)* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glSecondaryColor3ubv glSecondaryColor3ubv;
    alias fn_glSecondaryColor3usv = extern(System) void function(const( GLushort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glSecondaryColor3usv glSecondaryColor3usv;
    alias fn_glSecondaryColor3uiv = extern(System) void function(const( GLuint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glSecondaryColor3uiv glSecondaryColor3uiv;
    alias fn_glSecondaryColorPointer = extern(System) void function(GLint size, GLenum type, GLsizei stride, const( GLvoid*) pointer) @system @nogc nothrow;

    /++
     + glSecondaryColorPointer: man2/glSecondaryColorPointer.xml
     + 
     + $(D_INLINECODE glSecondaryColorPointer) specifies the location and data format of an array of color components to use when rendering. $(D_INLINECODE size) specifies the number of components per color, and must be 3. $(D_INLINECODE type) specifies the data type of each color component, and $(D_INLINECODE stride) specifies the byte stride from one color to the next, allowing vertices and attributes to be packed into a single array or stored in separate arrays. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_ARRAY_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a secondary color array is specified, $(D_INLINECODE pointer) is treated as a byte offset into the buffer object's data store. Also, the buffer object binding ( $(D_INLINECODE GL_ARRAY_BUFFER_BINDING) ) is saved as secondary color vertex array client-side state ( $(D_INLINECODE GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING) ). When a secondary color array is specified, $(D_INLINECODE size), $(D_INLINECODE type), $(D_INLINECODE stride), and $(D_INLINECODE pointer) are saved as client-side state, in addition to the current vertex array buffer object binding. To enable and disable the secondary color array, call $(D_INLINECODE glEnableClientState) and $(D_INLINECODE glDisableClientState) with the argument $(D_INLINECODE GL_SECONDARY_COLOR_ARRAY). If enabled, the secondary color array is used when $(D_INLINECODE glArrayElement), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glMultiDrawElements), or $(D_INLINECODE glDrawRangeElements) is called.
     + 
     + $(D_INLINECODE glSecondaryColorPointer) is available only if the GL version is 1.4 or greater. Secondary colors are not supported for interleaved vertex array formats (see $(D_INLINECODE glInterleavedArrays) ). The secondary color array is initially disabled and isn't accessed when $(D_INLINECODE glArrayElement), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), or $(D_INLINECODE glMultiDrawElements) is called. Execution of $(D_INLINECODE glSecondaryColorPointer) is not allowed between the execution of $(D_INLINECODE glBegin) and the corresponding execution of $(D_INLINECODE glEnd), but an error may or may not be generated. If no error is generated, the operation is undefined. $(D_INLINECODE glSecondaryColorPointer) is typically implemented on the client side. Secondary color array parameters are client-side state and are therefore not saved or restored by $(D_INLINECODE glPushAttrib) and $(D_INLINECODE glPopAttrib).  Use $(D_INLINECODE glPushClientAttrib) and $(D_INLINECODE glPopClientAttrib) instead.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glArrayElement), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glColorPointer), $(D_INLINECODE glDisableClientState), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glEdgeFlagPointer), $(D_INLINECODE glEnableClientState), $(D_INLINECODE glFogCoordPointer), $(D_INLINECODE glIndexPointer), $(D_INLINECODE glInterleavedArrays), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glMultiDrawElements), $(D_INLINECODE glNormalPointer), $(D_INLINECODE glPopClientAttrib), $(D_INLINECODE glPushClientAttrib), $(D_INLINECODE glSecondaryColor), $(D_INLINECODE glTexCoordPointer), $(D_INLINECODE glVertexAttribPointer), $(D_INLINECODE glVertexPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glSecondaryColorPointer glSecondaryColorPointer;
    alias fn_glSelectBuffer = extern(System) void function(GLsizei size, GLuint* buffer) @system @nogc nothrow;

    /++
     + glSelectBuffer: man2/glSelectBuffer.xml
     + 
     + $(D_INLINECODE glSelectBuffer) has two arguments: $(D_INLINECODE buffer) is a pointer to an array of unsigned integers, and $(D_INLINECODE size) indicates the size of the array. $(D_INLINECODE buffer) returns values from the name stack (see $(D_INLINECODE glInitNames), $(D_INLINECODE glLoadName), $(D_INLINECODE glPushName) ) when the rendering mode is $(D_INLINECODE GL_SELECT) (see $(D_INLINECODE glRenderMode) ). $(D_INLINECODE glSelectBuffer) must be issued before selection mode is enabled, and it must not be issued while the rendering mode is $(D_INLINECODE GL_SELECT). A programmer can use selection to determine which primitives are drawn into some region of a window. The region is defined by the current modelview and perspective matrices. In selection mode, no pixel fragments are produced from rasterization. Instead, if a primitive or a raster position intersects the clipping volume defined by the viewing frustum and the user-defined clipping planes, this primitive causes a selection hit. (With polygons, no hit occurs if the polygon is culled.) When a change is made to the name stack, or when $(D_INLINECODE glRenderMode) is called, a hit record is copied to $(D_INLINECODE buffer) if any hits have occurred since the last such event (name stack change or $(D_INLINECODE glRenderMode) call). The hit record consists of the number of names in the name stack at the time of the event, followed by the minimum and maximum depth values of all vertices that hit since the previous event, followed by the name stack contents, bottom name first. Depth values (which are in the range [0,1]) are multiplied by 2 32 - 1, before being placed in the hit record. An internal index into $(D_INLINECODE buffer) is reset to 0 whenever selection mode is entered. Each time a hit record is copied into $(D_INLINECODE buffer), the index is incremented to point to the cell just past the end of the block of names\(emthat is, to the next available cell If the hit record is larger than the number of remaining locations in $(D_INLINECODE buffer), as much data as can fit is copied, and the overflow flag is set. If the name stack is empty when a hit record is copied, that record consists of 0 followed by the minimum and maximum depth values. To exit selection mode, call $(D_INLINECODE glRenderMode) with an argument other than $(D_INLINECODE GL_SELECT). Whenever $(D_INLINECODE glRenderMode) is called while the render mode is $(D_INLINECODE GL_SELECT), it returns the number of hit records copied to $(D_INLINECODE buffer), resets the overflow flag and the selection buffer pointer, and initializes the name stack to be empty. If the overflow bit was set when $(D_INLINECODE glRenderMode) was called, a negative hit record count is returned.
     + 
     + The contents of $(D_INLINECODE buffer) is undefined until $(D_INLINECODE glRenderMode) is called with an argument other than $(D_INLINECODE GL_SELECT). $(D_INLINECODE glBegin) / $(D_INLINECODE glEnd) primitives and calls to $(D_INLINECODE glRasterPos) can result in hits. $(D_INLINECODE glWindowPos) will always generate a selection hit.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glFeedbackBuffer), $(D_INLINECODE glInitNames), $(D_INLINECODE glLoadName), $(D_INLINECODE glPushName), $(D_INLINECODE glRenderMode)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glSelectBuffer glSelectBuffer;
    alias fn_glSeparableFilter2D = extern(System) void function(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const( GLvoid*) row, const( GLvoid*) column) @system @nogc nothrow;

    /++
     + glSeparableFilter2D: man2/glSeparableFilter2D.xml
     + 
     + $(D_INLINECODE glSeparableFilter2D) builds a two-dimensional separable convolution filter kernel from two arrays of pixels. The pixel arrays specified by ( $(D_INLINECODE width), $(D_INLINECODE format), $(D_INLINECODE type), $(D_INLINECODE row) ) and ( $(D_INLINECODE height), $(D_INLINECODE format), $(D_INLINECODE type), $(D_INLINECODE column) ) are processed just as if they had been passed to $(D_INLINECODE glDrawPixels), but processing stops after the final expansion to RGBA is completed. If a non-zero named buffer object is bound to the $(D_INLINECODE GL_PIXEL_UNPACK_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a convolution filter is specified, $(D_INLINECODE row) and $(D_INLINECODE column) are treated as byte offsets into the buffer object's data store. Next, the R, G, B, and A components of all pixels in both arrays are scaled by the four separable 2D $(D_INLINECODE GL_CONVOLUTION_FILTER_SCALE) parameters and biased by the four separable 2D $(D_INLINECODE GL_CONVOLUTION_FILTER_BIAS) parameters. (The scale and bias parameters are set by $(D_INLINECODE glConvolutionParameter) using the $(D_INLINECODE GL_SEPARABLE_2D) target and the names $(D_INLINECODE GL_CONVOLUTION_FILTER_SCALE) and $(D_INLINECODE GL_CONVOLUTION_FILTER_BIAS). The parameters themselves are vectors of four values that are applied to red, green, blue, and alpha, in that order.) The R, G, B, and A values are not clamped to [0,1] at any time during this process. Each pixel is then converted to the internal format specified by $(D_INLINECODE internalformat). This conversion simply maps the component values of the pixel (R, G, B, and A) to the values included in the internal format (red, green, blue, alpha, luminance, and intensity).  The mapping is as follows: $(B Internal Format) $(B Red) $(B Green) $(B Blue) $(B Alpha) $(B Luminance) $(B Intensity) $(D_INLINECODE GL_LUMINANCE) R $(D_INLINECODE GL_LUMINANCE_ALPHA) A R $(D_INLINECODE GL_INTENSITY) R $(D_INLINECODE GL_RGB) R G B $(D_INLINECODE GL_RGBA) R G B A The red, green, blue, alpha, luminance, and/or intensity components of the resulting pixels are stored in floating-point rather than integer format. They form two one-dimensional filter kernel images. The row image is indexed by coordinate starting at zero and increasing from left to right. Each location in the row image is derived from element of $(D_INLINECODE row). The column image is indexed by coordinate starting at zero and increasing from bottom to top. Each location in the column image is derived from element of $(D_INLINECODE column). Note that after a convolution is performed, the resulting color components are also scaled by their corresponding $(D_INLINECODE GL_POST_CONVOLUTION_c_SCALE) parameters and biased by their corresponding $(D_INLINECODE GL_POST_CONVOLUTION_c_BIAS) parameters (where takes on the values $(B RED), $(B GREEN), $(B BLUE), and $(B ALPHA) ). These parameters are set by $(D_INLINECODE glPixelTransfer).
     + 
     + $(D_INLINECODE glSeparableFilter2D) is present only if $(D_INLINECODE ARB_imaging) is returned when $(D_INLINECODE glGetString) is called with an argument of $(D_INLINECODE GL_EXTENSIONS).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glConvolutionFilter1D), $(D_INLINECODE glConvolutionFilter2D), $(D_INLINECODE glConvolutionParameter), $(D_INLINECODE glPixelTransfer)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_imaging")
    fn_glSeparableFilter2D glSeparableFilter2D;
    alias fn_glShadeModel = extern(System) void function(GLenum mode) @system @nogc nothrow;

    /++
     + glShadeModel: man2/glShadeModel.xml
     + 
     + GL primitives can have either flat or smooth shading. Smooth shading, the default, causes the computed colors of vertices to be interpolated as the primitive is rasterized, typically assigning different colors to each resulting pixel fragment. Flat shading selects the computed color of just one vertex and assigns it to all the pixel fragments generated by rasterizing a single primitive. In either case, the computed color of a vertex is the result of lighting if lighting is enabled, or it is the current color at the time the vertex was specified if lighting is disabled. Flat and smooth shading are indistinguishable for points. Starting when $(D_INLINECODE glBegin) is issued and counting vertices and primitives from 1, the GL gives each flat-shaded line segment i the computed color of vertex i + 1, its second vertex. Counting similarly from 1, the GL gives each flat-shaded polygon the computed color of the vertex listed in the following table. This is the last vertex to specify the polygon in all cases except single polygons, where the first vertex specifies the flat-shaded color. $(B Primitive Type of Polygon i) $(B Vertex) Single polygon ( i == 1 ) 1 Triangle strip i + 2 Triangle fan i + 2 Independent triangle 3 &it; i Quad strip 2 &it; i + 2 Independent quad 4 &it; i Flat and smooth shading are specified by $(D_INLINECODE glShadeModel) with $(D_INLINECODE mode) set to $(D_INLINECODE GL_FLAT) and $(D_INLINECODE GL_SMOOTH), respectively.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBegin), $(D_INLINECODE glColor), $(D_INLINECODE glLight), $(D_INLINECODE glLightModel)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glShadeModel glShadeModel;
    alias fn_glTexCoord1s = extern(System) void function(GLshort s) @system @nogc nothrow;

    /++
     + glTexCoord: man2/glTexCoord.xml
     + 
     + $(D_INLINECODE glTexCoord) specifies texture coordinates in one, two, three, or four dimensions. $(D_INLINECODE glTexCoord1) sets the current texture coordinates to s 0 0 1; a call to $(D_INLINECODE glTexCoord2) sets them to s t 0 1. Similarly, $(D_INLINECODE glTexCoord3) specifies the texture coordinates as s t r 1, and $(D_INLINECODE glTexCoord4) defines all four components explicitly as s t r q. The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for,,, and are (0, 0, 0, 1).
     + 
     + The current texture coordinates can be updated at any time. In particular, $(D_INLINECODE glTexCoord) can be called between a call to $(D_INLINECODE glBegin) and the corresponding call to $(D_INLINECODE glEnd). When the $(D_INLINECODE ARB_imaging) extension is supported, $(D_INLINECODE glTexCoord) always updates texture unit $(D_INLINECODE GL_TEXTURE0).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glMultiTexCoord), $(D_INLINECODE glTexCoordPointer), $(D_INLINECODE glVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexCoord1s glTexCoord1s;
    alias fn_glTexCoord1i = extern(System) void function(GLint s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexCoord1i glTexCoord1i;
    alias fn_glTexCoord1f = extern(System) void function(GLfloat s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexCoord1f glTexCoord1f;
    alias fn_glTexCoord1d = extern(System) void function(GLdouble s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexCoord1d glTexCoord1d;
    alias fn_glTexCoord2s = extern(System) void function(GLshort s, GLshort t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexCoord2s glTexCoord2s;
    alias fn_glTexCoord2i = extern(System) void function(GLint s, GLint t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexCoord2i glTexCoord2i;
    alias fn_glTexCoord2f = extern(System) void function(GLfloat s, GLfloat t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexCoord2f glTexCoord2f;
    alias fn_glTexCoord2d = extern(System) void function(GLdouble s, GLdouble t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexCoord2d glTexCoord2d;
    alias fn_glTexCoord3s = extern(System) void function(GLshort s, GLshort t, GLshort r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexCoord3s glTexCoord3s;
    alias fn_glTexCoord3i = extern(System) void function(GLint s, GLint t, GLint r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexCoord3i glTexCoord3i;
    alias fn_glTexCoord3f = extern(System) void function(GLfloat s, GLfloat t, GLfloat r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexCoord3f glTexCoord3f;
    alias fn_glTexCoord3d = extern(System) void function(GLdouble s, GLdouble t, GLdouble r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexCoord3d glTexCoord3d;
    alias fn_glTexCoord4s = extern(System) void function(GLshort s, GLshort t, GLshort r, GLshort q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexCoord4s glTexCoord4s;
    alias fn_glTexCoord4i = extern(System) void function(GLint s, GLint t, GLint r, GLint q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexCoord4i glTexCoord4i;
    alias fn_glTexCoord4f = extern(System) void function(GLfloat s, GLfloat t, GLfloat r, GLfloat q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexCoord4f glTexCoord4f;
    alias fn_glTexCoord4d = extern(System) void function(GLdouble s, GLdouble t, GLdouble r, GLdouble q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexCoord4d glTexCoord4d;
    alias fn_glTexCoord1sv = extern(System) void function(const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexCoord1sv glTexCoord1sv;
    alias fn_glTexCoord1iv = extern(System) void function(const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexCoord1iv glTexCoord1iv;
    alias fn_glTexCoord1fv = extern(System) void function(const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexCoord1fv glTexCoord1fv;
    alias fn_glTexCoord1dv = extern(System) void function(const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexCoord1dv glTexCoord1dv;
    alias fn_glTexCoord2sv = extern(System) void function(const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexCoord2sv glTexCoord2sv;
    alias fn_glTexCoord2iv = extern(System) void function(const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexCoord2iv glTexCoord2iv;
    alias fn_glTexCoord2fv = extern(System) void function(const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexCoord2fv glTexCoord2fv;
    alias fn_glTexCoord2dv = extern(System) void function(const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexCoord2dv glTexCoord2dv;
    alias fn_glTexCoord3sv = extern(System) void function(const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexCoord3sv glTexCoord3sv;
    alias fn_glTexCoord3iv = extern(System) void function(const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexCoord3iv glTexCoord3iv;
    alias fn_glTexCoord3fv = extern(System) void function(const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexCoord3fv glTexCoord3fv;
    alias fn_glTexCoord3dv = extern(System) void function(const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexCoord3dv glTexCoord3dv;
    alias fn_glTexCoord4sv = extern(System) void function(const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexCoord4sv glTexCoord4sv;
    alias fn_glTexCoord4iv = extern(System) void function(const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexCoord4iv glTexCoord4iv;
    alias fn_glTexCoord4fv = extern(System) void function(const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexCoord4fv glTexCoord4fv;
    alias fn_glTexCoord4dv = extern(System) void function(const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexCoord4dv glTexCoord4dv;
    alias fn_glTexCoordPointer = extern(System) void function(GLint size, GLenum type, GLsizei stride, const( GLvoid*) pointer) @system @nogc nothrow;

    /++
     + glTexCoordPointer: man2/glTexCoordPointer.xml
     + 
     + $(D_INLINECODE glTexCoordPointer) specifies the location and data format of an array of texture coordinates to use when rendering. $(D_INLINECODE size) specifies the number of coordinates per texture coordinate set, and must be 1, 2, 3, or 4. $(D_INLINECODE type) specifies the data type of each texture coordinate, and $(D_INLINECODE stride) specifies the byte stride from one texture coordinate set to the next, allowing vertices and attributes to be packed into a single array or stored in separate arrays. (Single-array storage may be more efficient on some implementations; see $(D_INLINECODE glInterleavedArrays).) If a non-zero named buffer object is bound to the $(D_INLINECODE GL_ARRAY_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a texture coordinate array is specified, $(D_INLINECODE pointer) is treated as a byte offset into the buffer object's data store. Also, the buffer object binding ( $(D_INLINECODE GL_ARRAY_BUFFER_BINDING) ) is saved as texture coordinate vertex array client-side state ( $(D_INLINECODE GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING) ). When a texture coordinate array is specified, $(D_INLINECODE size), $(D_INLINECODE type), $(D_INLINECODE stride), and $(D_INLINECODE pointer) are saved as client-side state, in addition to the current vertex array buffer object binding. To enable and disable a texture coordinate array, call $(D_INLINECODE glEnableClientState) and $(D_INLINECODE glDisableClientState) with the argument $(D_INLINECODE GL_TEXTURE_COORD_ARRAY). If enabled, the texture coordinate array is used when $(D_INLINECODE glArrayElement), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glMultiDrawElements), or $(D_INLINECODE glDrawRangeElements) is called.
     + 
     + $(D_INLINECODE glTexCoordPointer) is available only if the GL version is 1.1 or greater. For OpenGL versions 1.3 and greater, or when the $(D_INLINECODE ARB_multitexture) extension is supported, $(D_INLINECODE glTexCoordPointer) updates the texture coordinate array state of the active client texture unit, specified with $(D_INLINECODE glClientActiveTexture). Each texture coordinate array is initially disabled and isn't accessed when $(D_INLINECODE glArrayElement), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), or $(D_INLINECODE glMultiDrawElements) is called. Execution of $(D_INLINECODE glTexCoordPointer) is not allowed between the execution of $(D_INLINECODE glBegin) and the corresponding execution of $(D_INLINECODE glEnd), but an error may or may not be generated. If no error is generated, the operation is undefined. $(D_INLINECODE glTexCoordPointer) is typically implemented on the client side. Texture coordinate array parameters are client-side state and are therefore not saved or restored by $(D_INLINECODE glPushAttrib) and $(D_INLINECODE glPopAttrib). Use $(D_INLINECODE glPushClientAttrib) and $(D_INLINECODE glPopClientAttrib) instead.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glArrayElement), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glClientActiveTexture), $(D_INLINECODE glColorPointer), $(D_INLINECODE glDisableClientState), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glEdgeFlagPointer), $(D_INLINECODE glEnableClientState), $(D_INLINECODE glFogCoordPointer), $(D_INLINECODE glIndexPointer), $(D_INLINECODE glInterleavedArrays), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glMultiDrawElements), $(D_INLINECODE glMultiTexCoord), $(D_INLINECODE glNormalPointer), $(D_INLINECODE glPopClientAttrib), $(D_INLINECODE glPushClientAttrib), $(D_INLINECODE glSecondaryColorPointer), $(D_INLINECODE glTexCoord), $(D_INLINECODE glVertexAttribPointer), $(D_INLINECODE glVertexPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    fn_glTexCoordPointer glTexCoordPointer;
    alias fn_glTexEnvf = extern(System) void function(GLenum target, GLenum pname, GLfloat param) @system @nogc nothrow;

    /++
     + glTexEnv: man2/glTexEnv.xml
     + 
     + A texture environment specifies how texture values are interpreted when a fragment is textured.  When $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_FILTER_CONTROL), $(D_INLINECODE pname) must be $(D_INLINECODE GL_TEXTURE_LOD_BIAS).  When $(D_INLINECODE target) is $(D_INLINECODE GL_TEXTURE_ENV), $(D_INLINECODE pname) can be $(D_INLINECODE GL_TEXTURE_ENV_MODE), $(D_INLINECODE GL_TEXTURE_ENV_COLOR), $(D_INLINECODE GL_COMBINE_RGB), $(D_INLINECODE GL_COMBINE_ALPHA), $(D_INLINECODE GL_RGB_SCALE), $(D_INLINECODE GL_ALPHA_SCALE), $(D_INLINECODE GL_SRC0_RGB), $(D_INLINECODE GL_SRC1_RGB), $(D_INLINECODE GL_SRC2_RGB), $(D_INLINECODE GL_SRC0_ALPHA), $(D_INLINECODE GL_SRC1_ALPHA), or $(D_INLINECODE GL_SRC2_ALPHA). If $(D_INLINECODE pname) is $(D_INLINECODE GL_TEXTURE_ENV_MODE), then $(D_INLINECODE params) is (or points to) the symbolic name of a texture function. Six texture functions may be specified: $(D_INLINECODE GL_ADD), $(D_INLINECODE GL_MODULATE), $(D_INLINECODE GL_DECAL), $(D_INLINECODE GL_BLEND), $(D_INLINECODE GL_REPLACE), or $(D_INLINECODE GL_COMBINE). The following table shows the correspondence of filtered texture values R t, G t, B t, A t, L t, I t to texture source components. C s and A s are used by the texture functions described below. Texture Base Internal Format C s A s $(D_INLINECODE GL_ALPHA) (0, 0, 0) A t $(D_INLINECODE GL_LUMINANCE) ( L t, L t, L t ) 1 $(D_INLINECODE GL_LUMINANCE_ALPHA) ( L t, L t, L t ) A t $(D_INLINECODE GL_INTENSITY) ( I t, I t, I t ) I t $(D_INLINECODE GL_RGB) ( R t, G t, B t ) 1 $(D_INLINECODE GL_RGBA) ( R t, G t, B t ) A t A texture function acts on the fragment to be textured using the texture image value that applies to the fragment (see $(D_INLINECODE glTexParameter) ) and produces an RGBA color for that fragment. The following table shows how the RGBA color is produced for each of the first five texture functions that can be chosen. C is a triple of color values (RGB) and A is the associated alpha value. RGBA values extracted from a texture image are in the range [0,1]. The subscript p refers to the color computed from the previous texture stage (or the incoming fragment if processing texture stage 0), the subscript s to the texture source color, the subscript c to the texture environment color, and the subscript v indicates a value produced by the texture function. Texture Base Internal Format $(D_INLINECODE Value) $(D_INLINECODE GL_REPLACE) Function $(D_INLINECODE GL_MODULATE) Function $(D_INLINECODE GL_DECAL) Function $(D_INLINECODE GL_BLEND) Function $(D_INLINECODE GL_ADD) Function $(D_INLINECODE GL_ALPHA) C v = C p C p undefined C p C p A v = A s A p &it; A s A v = A p &it; A s A p &it; A s $(D_INLINECODE GL_LUMINANCE) C v = C s C p &it; C s undefined C p &it; 1 - C s + C c &it; C s C p + C s (or 1) A v = A p A p A p A p $(D_INLINECODE GL_LUMINANCE_ALPHA) C v = C s C p &it; C s undefined C p &it; 1 - C s + C c &it; C s C p + C s (or 2) A v = A s A p &it; A s A p &it; A s A p &it; A s $(D_INLINECODE GL_INTENSITY) C v = C s C p &it; C s undefined C p &it; 1 - C s + C c &it; C s C p + C s A v = A s A p &it; A s A p &it; 1 - A s + A c &it; A s A p + A s $(D_INLINECODE GL_RGB) C v = C s C p &it; C s C s C p &it; 1 - C s + C c &it; C s C p + C s (or 3) A v = A p A p A p A p A p $(D_INLINECODE GL_RGBA) C v = C s C p &it; C s C p &it; 1 - A s + C s &it; A s C p &it; 1 - C s + C c &it; C s C p + C s (or 4) A v = A s A p &it; A s A p A p &it; A s A p &it; A s If $(D_INLINECODE pname) is $(D_INLINECODE GL_TEXTURE_ENV_MODE), and $(D_INLINECODE params) is $(D_INLINECODE GL_COMBINE), the form of the texture function depends on the values of $(D_INLINECODE GL_COMBINE_RGB) and $(D_INLINECODE GL_COMBINE_ALPHA). The following describes how the texture sources, as specified by $(D_INLINECODE GL_SRC0_RGB), $(D_INLINECODE GL_SRC1_RGB), $(D_INLINECODE GL_SRC2_RGB), $(D_INLINECODE GL_SRC0_ALPHA), $(D_INLINECODE GL_SRC1_ALPHA), and $(D_INLINECODE GL_SRC2_ALPHA), are combined to produce a final texture color. In the following tables, $(D_INLINECODE GL_SRC0_c) is represented by Arg0, $(D_INLINECODE GL_SRC1_c) is represented by Arg1, and $(D_INLINECODE GL_SRC2_c) is represented by Arg2. $(D_INLINECODE GL_COMBINE_RGB) accepts any of $(D_INLINECODE GL_REPLACE), $(D_INLINECODE GL_MODULATE), $(D_INLINECODE GL_ADD), $(D_INLINECODE GL_ADD_SIGNED), $(D_INLINECODE GL_INTERPOLATE), $(D_INLINECODE GL_SUBTRACT), $(D_INLINECODE GL_DOT3_RGB), or $(D_INLINECODE GL_DOT3_RGBA). $(B $(D_INLINECODE GL_COMBINE_RGB)) $(B Texture Function) $(D_INLINECODE GL_REPLACE) Arg0 $(D_INLINECODE GL_MODULATE) Arg0 &times; Arg1 $(D_INLINECODE GL_ADD) Arg0 + Arg1 $(D_INLINECODE GL_ADD_SIGNED) Arg0 + Arg1 - 0.5 $(D_INLINECODE GL_INTERPOLATE) Arg0 &times; Arg2 + Arg1 &times; 1 - Arg2 $(D_INLINECODE GL_SUBTRACT) Arg0 - Arg1 $(D_INLINECODE GL_DOT3_RGB) or $(D_INLINECODE GL_DOT3_RGBA) 4 &times; Arg0 r - 0.5 &times; Arg1 r - 0.5 + Arg0 g - 0.5 &times; Arg1 g - 0.5 + Arg0 b - 0.5 &times; Arg1 b - 0.5 The scalar results for $(D_INLINECODE GL_DOT3_RGB) and $(D_INLINECODE GL_DOT3_RGBA) are placed into each of the 3 (RGB) or 4 (RGBA) components on output. Likewise, $(D_INLINECODE GL_COMBINE_ALPHA) accepts any of $(D_INLINECODE GL_REPLACE), $(D_INLINECODE GL_MODULATE), $(D_INLINECODE GL_ADD), $(D_INLINECODE GL_ADD_SIGNED), $(D_INLINECODE GL_INTERPOLATE), or $(D_INLINECODE GL_SUBTRACT).  The following table describes how alpha values are combined: $(B $(D_INLINECODE GL_COMBINE_ALPHA)) $(B Texture Function) $(D_INLINECODE GL_REPLACE) Arg0 $(D_INLINECODE GL_MODULATE) Arg0 &times; Arg1 $(D_INLINECODE GL_ADD) Arg0 + Arg1 $(D_INLINECODE GL_ADD_SIGNED) Arg0 + Arg1 - 0.5 $(D_INLINECODE GL_INTERPOLATE) Arg0 &times; Arg2 + Arg1 &times; 1 - Arg2 $(D_INLINECODE GL_SUBTRACT) Arg0 - Arg1 In the following tables, the value C s represents the color sampled from the currently bound texture, C c represents the constant texture-environment color, C f represents the primary color of the incoming fragment, and C p represents the color computed from the previous texture stage or C f if processing texture stage 0.  Likewise, A s, A c, A f, and A p represent the respective alpha values. The following table describes the values assigned to Arg0, Arg1, and Arg2 based upon the RGB sources and operands: $(B $(D_INLINECODE GL_SRCn_RGB)) $(B $(D_INLINECODE GL_OPERANDn_RGB)) $(B Argument Value) $(D_INLINECODE GL_TEXTURE) $(D_INLINECODE GL_SRC_COLOR) C s $(D_INLINECODE GL_ONE_MINUS_SRC_COLOR) 1 - C s $(D_INLINECODE GL_SRC_ALPHA) A s $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA) 1 - A s $(D_INLINECODE GL_TEXTUREn) $(D_INLINECODE GL_SRC_COLOR) C s $(D_INLINECODE GL_ONE_MINUS_SRC_COLOR) 1 - C s $(D_INLINECODE GL_SRC_ALPHA) A s $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA) 1 - A s $(D_INLINECODE GL_CONSTANT) $(D_INLINECODE GL_SRC_COLOR) C c $(D_INLINECODE GL_ONE_MINUS_SRC_COLOR) 1 - C c $(D_INLINECODE GL_SRC_ALPHA) A c $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA) 1 - A c $(D_INLINECODE GL_PRIMARY_COLOR) $(D_INLINECODE GL_SRC_COLOR) C f $(D_INLINECODE GL_ONE_MINUS_SRC_COLOR) 1 - C f $(D_INLINECODE GL_SRC_ALPHA) A f $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA) 1 - A f $(D_INLINECODE GL_PREVIOUS) $(D_INLINECODE GL_SRC_COLOR) C p $(D_INLINECODE GL_ONE_MINUS_SRC_COLOR) 1 - C p $(D_INLINECODE GL_SRC_ALPHA) A p $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA) 1 - A p For $(D_INLINECODE GL_TEXTUREn) sources, C s and A s represent the color and alpha, respectively, produced from texture stage n. The follow table describes the values assigned to Arg0, Arg1, and Arg2 based upon the alpha sources and operands: $(B $(D_INLINECODE GL_SRCn_ALPHA)) $(B $(D_INLINECODE GL_OPERANDn_ALPHA)) $(B Argument Value) $(D_INLINECODE GL_TEXTURE) $(D_INLINECODE GL_SRC_ALPHA) A s $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA) 1 - A s $(D_INLINECODE GL_TEXTUREn) $(D_INLINECODE GL_SRC_ALPHA) A s $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA) 1 - A s $(D_INLINECODE GL_CONSTANT) $(D_INLINECODE GL_SRC_ALPHA) A c $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA) 1 - A c $(D_INLINECODE GL_PRIMARY_COLOR) $(D_INLINECODE GL_SRC_ALPHA) A f $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA) 1 - A f $(D_INLINECODE GL_PREVIOUS) $(D_INLINECODE GL_SRC_ALPHA) A p $(D_INLINECODE GL_ONE_MINUS_SRC_ALPHA) 1 - A p The RGB and alpha results of the texture function are multipled by the values of $(D_INLINECODE GL_RGB_SCALE) and $(D_INLINECODE GL_ALPHA_SCALE), respectively, and clamped to the range 0 1. If $(D_INLINECODE pname) is $(D_INLINECODE GL_TEXTURE_ENV_COLOR), $(D_INLINECODE params) is a pointer to an array that holds an RGBA color consisting of four values. Integer color components are interpreted linearly such that the most positive integer maps to 1.0, and the most negative integer maps to -1.0. The values are clamped to the range [0,1] when they are specified. C c takes these four values. If $(D_INLINECODE pname) is $(D_INLINECODE GL_TEXTURE_LOD_BIAS), the value specified is added to the texture level-of-detail parameter, that selects which mipmap, or mipmaps depending upon the selected $(D_INLINECODE GL_TEXTURE_MIN_FILTER), will be sampled. $(D_INLINECODE GL_TEXTURE_ENV_MODE) defaults to $(D_INLINECODE GL_MODULATE) and $(D_INLINECODE GL_TEXTURE_ENV_COLOR) defaults to (0, 0, 0, 0). If $(D_INLINECODE target) is $(D_INLINECODE GL_POINT_SPRITE) and $(D_INLINECODE pname) is $(D_INLINECODE GL_COORD_REPLACE), the boolean value specified is used to either enable or disable point sprite texture coordinate replacement. The default value is $(D_INLINECODE GL_FALSE).
     + 
     + $(D_INLINECODE GL_REPLACE) may only be used if the GL version is 1.1 or greater. $(D_INLINECODE GL_TEXTURE_FILTER_CONTROL) and $(D_INLINECODE GL_TEXTURE_LOD_BIAS) may only be used if the GL version is 1.4 or greater. $(D_INLINECODE GL_COMBINE) mode and its associated constants may only be used if the GL version is 1.3 or greater. $(D_INLINECODE GL_TEXTUREn) may only be used if the GL version is 1.4 or greater. Internal formats other than 1, 2, 3, or 4 may only be used if the GL version is 1.1 or greater. For OpenGL versions 1.3 and greater, or when the $(D_INLINECODE ARB_multitexture) extension is supported, $(D_INLINECODE glTexEnv) controls the texture environment for the current active texture unit, selected by $(D_INLINECODE glActiveTexture). $(D_INLINECODE GL_POINT_SPRITE) and $(D_INLINECODE GL_COORD_REPLACE) are available only if the GL version is 2.0 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glCopyPixels), $(D_INLINECODE glCopyTexImage1D), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexParameter), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexEnvf glTexEnvf;
    alias fn_glTexEnvi = extern(System) void function(GLenum target, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexEnvi glTexEnvi;
    alias fn_glTexEnvfv = extern(System) void function(GLenum target, GLenum pname, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexEnvfv glTexEnvfv;
    alias fn_glTexEnviv = extern(System) void function(GLenum target, GLenum pname, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexEnviv glTexEnviv;
    alias fn_glTexGeni = extern(System) void function(GLenum coord, GLenum pname, GLint param) @system @nogc nothrow;

    /++
     + glTexGen: man2/glTexGen.xml
     + 
     + $(D_INLINECODE glTexGen) selects a texture-coordinate generation function or supplies coefficients for one of the functions. $(D_INLINECODE coord) names one of the (,,, ) texture coordinates; it must be one of the symbols $(D_INLINECODE GL_S), $(D_INLINECODE GL_T), $(D_INLINECODE GL_R), or $(D_INLINECODE GL_Q). $(D_INLINECODE pname) must be one of three symbolic constants: $(D_INLINECODE GL_TEXTURE_GEN_MODE), $(D_INLINECODE GL_OBJECT_PLANE), or $(D_INLINECODE GL_EYE_PLANE). If $(D_INLINECODE pname) is $(D_INLINECODE GL_TEXTURE_GEN_MODE), then $(D_INLINECODE params) chooses a mode, one of $(D_INLINECODE GL_OBJECT_LINEAR), $(D_INLINECODE GL_EYE_LINEAR), $(D_INLINECODE GL_SPHERE_MAP), $(D_INLINECODE GL_NORMAL_MAP), or $(D_INLINECODE GL_REFLECTION_MAP). If $(D_INLINECODE pname) is either $(D_INLINECODE GL_OBJECT_PLANE) or $(D_INLINECODE GL_EYE_PLANE), $(D_INLINECODE params) contains coefficients for the corresponding texture generation function. If the texture generation function is $(D_INLINECODE GL_OBJECT_LINEAR), the function g = p 1 &times; x o + p 2 &times; y o + p 3 &times; z o + p 4 &times; w o is used, where g is the value computed for the coordinate named in $(D_INLINECODE coord), p 1, p 2, p 3, and p 4 are the four values supplied in $(D_INLINECODE params), and x o, y o, z o, and w o are the object coordinates of the vertex. This function can be used, for example, to texture-map terrain using sea level as a reference plane (defined by p 1, p 2, p 3, and p 4 ). The altitude of a terrain vertex is computed by the $(D_INLINECODE GL_OBJECT_LINEAR) coordinate generation function as its distance from sea level; that altitude can then be used to index the texture image to map white snow onto peaks and green grass onto foothills. If the texture generation function is $(D_INLINECODE GL_EYE_LINEAR), the function g = p 1 &Prime; &times; x e + p 2 &Prime; &times; y e + p 3 &Prime; &times; z e + p 4 &Prime; &times; w e is used, where p 1 &Prime; &it; p 2 &Prime; &it; p 3 &Prime; &it; p 4 &Prime; = p 1 &it; p 2 &it; p 3 &it; p 4 &it; M -1 and x e, y e, z e, and w e are the eye coordinates of the vertex, p 1, p 2, p 3, and p 4 are the values supplied in $(D_INLINECODE params), and M is the modelview matrix when $(D_INLINECODE glTexGen) is invoked. If M is poorly conditioned or singular, texture coordinates generated by the resulting function may be inaccurate or undefined. Note that the values in $(D_INLINECODE params) define a reference plane in eye coordinates. The modelview matrix that is applied to them may not be the same one in effect when the polygon vertices are transformed. This function establishes a field of texture coordinates that can produce dynamic contour lines on moving objects. If the texture generation function is $(D_INLINECODE GL_SPHERE_MAP) and $(D_INLINECODE coord) is either $(D_INLINECODE GL_S) or $(D_INLINECODE GL_T), s and t texture coordinates are generated as follows. Let be the unit vector pointing from the origin to the polygon vertex (in eye coordinates). Let sup prime be the current normal, after transformation to eye coordinates. Let f = f x &it; f y &it; f z T be the reflection vector such that f = u - 2 &it; n &Prime; &it; n &Prime; T &it; u Finally, let m = 2 &it; f x 2 + f y 2 + f z + 1 2. Then the values assigned to the s and t texture coordinates are s = f x m + 1 2 t = f y m + 1 2 To enable or disable a texture-coordinate generation function, call $(D_INLINECODE glEnable) or $(D_INLINECODE glDisable) with one of the symbolic texture-coordinate names ( $(D_INLINECODE GL_TEXTURE_GEN_S), $(D_INLINECODE GL_TEXTURE_GEN_T), $(D_INLINECODE GL_TEXTURE_GEN_R), or $(D_INLINECODE GL_TEXTURE_GEN_Q) ) as the argument. When enabled, the specified texture coordinate is computed according to the generating function associated with that coordinate. When disabled, subsequent vertices take the specified texture coordinate from the current set of texture coordinates. Initially, all texture generation functions are set to $(D_INLINECODE GL_EYE_LINEAR) and are disabled. Both s plane equations are (1, 0, 0, 0), both t plane equations are (0, 1, 0, 0), and all r and q plane equations are (0, 0, 0, 0). When the $(D_INLINECODE ARB_multitexture) extension is supported, $(D_INLINECODE glTexGen) sets the texture generation parameters for the currently active texture unit, selected with $(D_INLINECODE glActiveTexture).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glActiveTexture), $(D_INLINECODE glCopyPixels), $(D_INLINECODE glCopyTexImage2D), $(D_INLINECODE glCopyTexSubImage1D), $(D_INLINECODE glCopyTexSubImage2D), $(D_INLINECODE glCopyTexSubImage3D), $(D_INLINECODE glTexEnv), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D), $(D_INLINECODE glTexParameter), $(D_INLINECODE glTexSubImage1D), $(D_INLINECODE glTexSubImage2D), $(D_INLINECODE glTexSubImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexGeni glTexGeni;
    alias fn_glTexGenf = extern(System) void function(GLenum coord, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexGenf glTexGenf;
    alias fn_glTexGend = extern(System) void function(GLenum coord, GLenum pname, GLdouble param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexGend glTexGend;
    alias fn_glTexGeniv = extern(System) void function(GLenum coord, GLenum pname, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexGeniv glTexGeniv;
    alias fn_glTexGenfv = extern(System) void function(GLenum coord, GLenum pname, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexGenfv glTexGenfv;
    alias fn_glTexGendv = extern(System) void function(GLenum coord, GLenum pname, const( GLdouble*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexGendv glTexGendv;
    alias fn_glTranslated = extern(System) void function(GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;

    /++
     + glTranslate: man2/glTranslate.xml
     + 
     + $(D_INLINECODE glTranslate) produces a translation by x y z. The current matrix (see $(D_INLINECODE glMatrixMode) ) is multiplied by this translation matrix, with the product replacing the current matrix, as if $(D_INLINECODE glMultMatrix) were called with the following matrix for its argument: 1 0 0 x 0 1 0 y 0 0 1 z 0 0 0 1 If the matrix mode is either $(D_INLINECODE GL_MODELVIEW) or $(D_INLINECODE GL_PROJECTION), all objects drawn after a call to $(D_INLINECODE glTranslate) are translated. Use $(D_INLINECODE glPushMatrix) and $(D_INLINECODE glPopMatrix) to save and restore the untranslated coordinate system.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glMatrixMode), $(D_INLINECODE glMultMatrix), $(D_INLINECODE glPushMatrix), $(D_INLINECODE glRotate), $(D_INLINECODE glScale)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTranslated glTranslated;
    alias fn_glTranslatef = extern(System) void function(GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTranslatef glTranslatef;
    alias fn_gluBeginCurve = extern(System) void function(GLUnurbs* nurb) @system @nogc nothrow;

    /++
     + gluBeginCurve: man2/gluBeginCurve.xml
     + 
     + Use $(D_INLINECODE gluBeginCurve) to mark the beginning of a NURBS curve definition. After calling $(D_INLINECODE gluBeginCurve), make one or more calls to $(D_INLINECODE gluNurbsCurve) to define the attributes of the curve. Exactly one of the calls to $(D_INLINECODE gluNurbsCurve) must have a curve type of $(D_INLINECODE GLU_MAP1_VERTEX_3) or $(D_INLINECODE GLU_MAP1_VERTEX_4). To mark the end of the NURBS curve definition, call $(D_INLINECODE gluEndCurve). GL evaluators are used to render the NURBS curve as a series of line segments. Evaluator state is preserved during rendering with $(D_INLINECODE glPushAttrib) ( $(D_INLINECODE GLU_EVAL_BIT) ) and $(D_INLINECODE glPopAttrib) (). See the $(D_INLINECODE glPushAttrib) reference page for details on exactly what state these calls preserve.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluBeginSurface), $(D_INLINECODE gluBeginTrim), $(D_INLINECODE gluNewNurbsRenderer), $(D_INLINECODE gluNurbsCurve), $(D_INLINECODE glPopAttrib), $(D_INLINECODE glPushAttrib)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluBeginCurve gluBeginCurve;
    alias fn_gluEndCurve = extern(System) void function(GLUnurbs* nurb) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluEndCurve gluEndCurve;
    alias fn_gluBeginPolygon = extern(System) void function(GLUtesselator* tess) @system @nogc nothrow;

    /++
     + gluBeginPolygon: man2/gluBeginPolygon.xml
     + 
     + $(D_INLINECODE gluBeginPolygon) and $(D_INLINECODE gluEndPolygon) delimit the definition of a nonconvex polygon. To define such a polygon, first call $(D_INLINECODE gluBeginPolygon). Then define the contours of the polygon by calling $(D_INLINECODE gluTessVertex) for each vertex and $(D_INLINECODE gluNextContour) to start each new contour. Finally, call $(D_INLINECODE gluEndPolygon) to signal the end of the definition. See the $(D_INLINECODE gluTessVertex) and $(D_INLINECODE gluNextContour) reference pages for more details. Once $(D_INLINECODE gluEndPolygon) is called, the polygon is tessellated, and the resulting triangles are described through callbacks. See $(D_INLINECODE gluTessCallback) for descriptions of the callback functions.
     + 
     + This command is obsolete and is provided for backward compatibility only. Calls to $(D_INLINECODE gluBeginPolygon) are mapped to $(D_INLINECODE gluTessBeginPolygon) followed by $(D_INLINECODE gluTessBeginContour). Calls to $(D_INLINECODE gluEndPolygon) are mapped to $(D_INLINECODE gluTessEndContour) followed by $(D_INLINECODE gluTessEndPolygon).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluNewTess), $(D_INLINECODE gluNextContour), $(D_INLINECODE gluTessBeginContour), $(D_INLINECODE gluTessBeginPolygon), $(D_INLINECODE gluTessCallback), $(D_INLINECODE gluTessVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluBeginPolygon gluBeginPolygon;
    alias fn_gluEndPolygon = extern(System) void function(GLUtesselator* tess) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluEndPolygon gluEndPolygon;
    alias fn_gluBeginSurface = extern(System) void function(GLUnurbs* nurb) @system @nogc nothrow;

    /++
     + gluBeginSurface: man2/gluBeginSurface.xml
     + 
     + Use $(D_INLINECODE gluBeginSurface) to mark the beginning of a NURBS surface definition. After calling $(D_INLINECODE gluBeginSurface), make one or more calls to $(D_INLINECODE gluNurbsSurface) to define the attributes of the surface. Exactly one of these calls to $(D_INLINECODE gluNurbsSurface) must have a surface type of $(D_INLINECODE GLU_MAP2_VERTEX_3) or $(D_INLINECODE GLU_MAP2_VERTEX_4). To mark the end of the NURBS surface definition, call $(D_INLINECODE gluEndSurface). Trimming of NURBS surfaces is supported with $(D_INLINECODE gluBeginTrim), $(D_INLINECODE gluPwlCurve), $(D_INLINECODE gluNurbsCurve), and $(D_INLINECODE gluEndTrim). See the $(D_INLINECODE gluBeginTrim) reference page for details. GL evaluators are used to render the NURBS surface as a set of polygons. Evaluator state is preserved during rendering with $(D_INLINECODE glPushAttrib) ( $(D_INLINECODE GLU_EVAL_BIT) ) and $(D_INLINECODE glPopAttrib). See the $(D_INLINECODE glPushAttrib) reference page for details on exactly what state these calls preserve.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluBeginCurve), $(D_INLINECODE gluBeginTrim), $(D_INLINECODE gluNewNurbsRenderer), $(D_INLINECODE gluNurbsCurve), $(D_INLINECODE gluNurbsSurface), $(D_INLINECODE gluPwlCurve), $(D_INLINECODE glPushAttrib)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluBeginSurface gluBeginSurface;
    alias fn_gluEndSurface = extern(System) void function(GLUnurbs* nurb) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluEndSurface gluEndSurface;
    alias fn_gluBeginTrim = extern(System) void function(GLUnurbs* nurb) @system @nogc nothrow;

    /++
     + gluBeginTrim: man2/gluBeginTrim.xml
     + 
     + Use $(D_INLINECODE gluBeginTrim) to mark the beginning of a trimming loop and $(D_INLINECODE gluEndTrim) to mark the end of a trimming loop. A trimming loop is a set of oriented curve segments (forming a closed curve) that define boundaries of a NURBS surface. You include these trimming loops in the definition of a NURBS surface, between calls to $(D_INLINECODE gluBeginSurface) and $(D_INLINECODE gluEndSurface). The definition for a NURBS surface can contain many trimming loops. For example, if you wrote a definition for a NURBS surface that resembled a rectangle with a hole punched out, the definition would contain two trimming loops. One loop would define the outer edge of the rectangle; the other would define the hole punched out of the rectangle. The definitions of each of these trimming loops would be bracketed by a $(D_INLINECODE gluBeginTrim) / $(D_INLINECODE gluEndTrim) pair. The definition of a single closed trimming loop can consist of multiple curve segments, each described as a piecewise linear curve (see $(D_INLINECODE gluPwlCurve) ) or as a single NURBS curve (see $(D_INLINECODE gluNurbsCurve) ), or as a combination of both in any order. The only library calls that can appear in a trimming loop definition (between the calls to $(D_INLINECODE gluBeginTrim) and $(D_INLINECODE gluEndTrim) ) are $(D_INLINECODE gluPwlCurve) and $(D_INLINECODE gluNurbsCurve). The area of the NURBS surface that is displayed is the region in the domain to the left of the trimming curve as the curve parameter increases. Thus, the retained region of the NURBS surface is inside a counterclockwise trimming loop and outside a clockwise trimming loop. For the rectangle mentioned earlier, the trimming loop for the outer edge of the rectangle runs counterclockwise, while the trimming loop for the punched-out hole runs clockwise. If you use more than one curve to define a single trimming loop, the curve segments must form a closed loop (that is, the endpoint of each curve must be the starting point of the next curve, and the endpoint of the final curve must be the starting point of the first curve). If the endpoints of the curve are sufficiently close together but not exactly coincident, they will be coerced to match. If the endpoints are not sufficiently close, an error results (see $(D_INLINECODE gluNurbsCallback) ). If a trimming loop definition contains multiple curves, the direction of the curves must be consistent (that is, the inside must be to the left of all of the curves). Nested trimming loops are legal as long as the curve orientations alternate correctly. If trimming curves are self-intersecting, or intersect one another, an error results. If no trimming information is given for a NURBS surface, the entire surface is drawn.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluBeginSurface), $(D_INLINECODE gluNewNurbsRenderer), $(D_INLINECODE gluNurbsCallback), $(D_INLINECODE gluNurbsCurve), $(D_INLINECODE gluPwlCurve)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluBeginTrim gluBeginTrim;
    alias fn_gluEndTrim = extern(System) void function(GLUnurbs* nurb) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluEndTrim gluEndTrim;
    alias fn_gluBuild1DMipmapLevels = extern(System) GLint function(GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const( void*) data) @system @nogc nothrow;

    /++
     + gluBuild1DMipmapLevels: man2/gluBuild1DMipmapLevels.xml
     + 
     + $(D_INLINECODE gluBuild1DMipmapLevels) builds a subset of prefiltered one-dimensional texture maps of decreasing resolutions called a mipmap. This is used for the antialiasing of texture mapped primitives. A return value of zero indicates success, otherwise a GLU error code is returned (see $(D_INLINECODE gluErrorString) ). A series of mipmap levels from $(D_INLINECODE base) to $(D_INLINECODE max) is built by decimating $(D_INLINECODE data) in half until size 1 &times; 1 is reached. At each level, each texel in the halved mipmap level is an average of the corresponding two texels in the larger mipmap level. $(D_INLINECODE glTexImage1D) is called to load these mipmap levels from $(D_INLINECODE base) to $(D_INLINECODE max). If $(D_INLINECODE max) is larger than the highest mipmap level for the texture of the specified size, then a GLU error code is returned (see $(D_INLINECODE gluErrorString) ) and nothing is loaded. For example, if $(D_INLINECODE level) is 2 and $(D_INLINECODE width) is 16, the following levels are possible: 16 &times; 1, 8 &times; 1, 4 &times; 1, 2 &times; 1, 1 &times; 1. These correspond to levels 2 through 6 respectively. If $(D_INLINECODE base) is 3 and $(D_INLINECODE max) is 5, then only mipmap levels 8 &times; 1, 4 &times; 1 and 2 &times; 1 are loaded. However, if $(D_INLINECODE max) is 7, then an error is returned and nothing is loaded since $(D_INLINECODE max) is larger than the highest mipmap level which is, in this case, 6. The highest mipmap level can be derived from the formula log 2 &af; width &times; 2 level. See the $(D_INLINECODE glTexImage1D) reference page for a description of the acceptable values for $(D_INLINECODE type) parameter. See the $(D_INLINECODE glDrawPixels) reference page for a description of the acceptable values for $(D_INLINECODE level) parameter.
     + 
     + $(D_INLINECODE gluBuild1DMipmapLevels) is only available if the GLU version is 1.3 or greater. Formats $(D_INLINECODE GLU_BGR), and $(D_INLINECODE GLU_BGRA), and types $(D_INLINECODE GLU_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GLU_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GLU_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GLU_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GLU_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GLU_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GLU_UNSIGNED_INT_10_10_10_2), and $(D_INLINECODE GLU_UNSIGNED_INT_2_10_10_10_REV) are only available if the GL version is 1.2 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluBuild1DMipmaps), $(D_INLINECODE gluBuild2DMipmapLevels), $(D_INLINECODE gluBuild2DMipmaps), $(D_INLINECODE gluBuild3DMipmapLevels), $(D_INLINECODE gluBuild3DMipmaps), $(D_INLINECODE gluErrorString), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glGetTexImage), $(D_INLINECODE glGetTexLevelParameter), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluBuild1DMipmapLevels gluBuild1DMipmapLevels;
    alias fn_gluBuild1DMipmaps = extern(System) GLint function(GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const( void*) data) @system @nogc nothrow;

    /++
     + gluBuild1DMipmaps: man2/gluBuild1DMipmaps.xml
     + 
     + $(D_INLINECODE gluBuild1DMipmaps) builds a series of prefiltered one-dimensional texture maps of decreasing resolutions called a mipmap. This is used for the antialiasing of texture mapped primitives. A return value of zero indicates success, otherwise a GLU error code is returned (see $(D_INLINECODE gluErrorString) ). Initially, the $(D_INLINECODE width) of $(D_INLINECODE data) is checked to see if it is a power of 2. If not, a copy of $(D_INLINECODE data) is scaled up or down to the nearest power of 2. (If $(D_INLINECODE width) is exactly between powers of 2, then the copy of $(D_INLINECODE data) will scale upwards.)  This copy will be used for subsequent mipmapping operations described below. For example, if $(D_INLINECODE width) is 57, then a copy of $(D_INLINECODE data) will scale up to 64 before mipmapping takes place. Then, proxy textures (see $(D_INLINECODE glTexImage1D) ) are used to determine if the implementation can fit the requested texture. If not, $(D_INLINECODE width) is continually halved until it fits. Next, a series of mipmap levels is built by decimating a copy of $(D_INLINECODE data) in half until size 1 &times; 1 is reached. At each level, each texel in the halved mipmap level is an average of the corresponding two texels in the larger mipmap level. $(D_INLINECODE glTexImage1D) is called to load each of these mipmap levels. Level 0 is a copy of $(D_INLINECODE data). The highest level is log 2 &af; width. For example, if $(D_INLINECODE width) is 64 and the implementation can store a texture of this size, the following mipmap levels are built: 64 &times; 1, 32 &times; 1, 16 &times; 1, 8 &times; 1, 4 &times; 1, 2 &times; 1, and 1 &times; 1. These correspond to levels 0 through 6, respectively. See the $(D_INLINECODE glTexImage1D) reference page for a description of the acceptable values for the $(D_INLINECODE type) parameter. See the $(D_INLINECODE glDrawPixels) reference page for a description of the acceptable values for the $(D_INLINECODE data) parameter.
     + 
     + Note that there is no direct way of querying the maximum level. This can be derived indirectly via $(D_INLINECODE glGetTexLevelParameter). First, query for the width actually used at level 0. (The width may not be equal to $(D_INLINECODE width) since proxy textures might have scaled it to fit the implementation.) Then the maximum level can be derived from the formula log 2 &af; width. Formats $(D_INLINECODE GLU_BGR), and $(D_INLINECODE GLU_BGRA), and types $(D_INLINECODE GLU_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GLU_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GLU_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GLU_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GLU_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GLU_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GLU_UNSIGNED_INT_10_10_10_2), and $(D_INLINECODE GLU_UNSIGNED_INT_2_10_10_10_REV) are only available if the GL version is 1.2 or greater, and if the GLU version is 1.3 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluBuild1DMipmapLevels), $(D_INLINECODE gluBuild2DMipmapLevels), $(D_INLINECODE gluBuild2DMipmaps), $(D_INLINECODE gluBuild3DMipmapLevels), $(D_INLINECODE gluBuild3DMipmaps), $(D_INLINECODE gluErrorString), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glGetTexImage), $(D_INLINECODE glGetTexLevelParameter), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluBuild1DMipmaps gluBuild1DMipmaps;
    alias fn_gluBuild2DMipmapLevels = extern(System) GLint function(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const( void*) data) @system @nogc nothrow;

    /++
     + gluBuild2DMipmapLevels: man2/gluBuild2DMipmapLevels.xml
     + 
     + $(D_INLINECODE gluBuild2DMipmapLevels) builds a subset of prefiltered two-dimensional texture maps of decreasing resolutions called a mipmap. This is used for the antialiasing of texture mapped primitives. A return value of zero indicates success, otherwise a GLU error code is returned (see $(D_INLINECODE gluErrorString) ). A series of mipmap levels from $(D_INLINECODE base) to $(D_INLINECODE max) is built by decimating $(D_INLINECODE data) in half along both dimensions until size 1 &times; 1 is reached. At each level, each texel in the halved mipmap level is an average of the corresponding four texels in the larger mipmap level. (In the case of rectangular images, the decimation will ultimately reach an N &times; 1 or 1 &times; N configuration. Here, two texels are averaged instead.) $(D_INLINECODE glTexImage2D) is called to load these mipmap levels from $(D_INLINECODE base) to $(D_INLINECODE max). If $(D_INLINECODE max) is larger than the highest mipmap level for the texture of the specified size, then a GLU error code is returned (see $(D_INLINECODE gluErrorString) ) and nothing is loaded. For example, if $(D_INLINECODE level) is 2 and $(D_INLINECODE width) is 16 and $(D_INLINECODE height) is 8, the following levels are possible: 16 &times; 8, 8 &times; 4, 4 &times; 2, 2 &times; 1, 1 &times; 1. These correspond to levels 2 through 6 respectively.  If $(D_INLINECODE base) is 3 and $(D_INLINECODE max) is 5, then only mipmap levels 8 &times; 4, 4 &times; 2, and 2 &times; 1 are loaded. However, if $(D_INLINECODE max) is 7, then an error is returned and nothing is loaded since $(D_INLINECODE max) is larger than the highest mipmap level which is, in this case, 6. The highest mipmap level can be derived from the formula log 2 &af; max &af; width height &times; 2 level. See the $(D_INLINECODE glTexImage1D) reference page for a description of the acceptable values for $(D_INLINECODE format) parameter. See the $(D_INLINECODE glDrawPixels) reference page for a description of the acceptable values for $(D_INLINECODE type) parameter.
     + 
     + $(D_INLINECODE gluBuild2DMipmapLevels) is only available if the GLU version is 1.3 or greater. Formats $(D_INLINECODE GLU_BGR), and $(D_INLINECODE GLU_BGRA), and types $(D_INLINECODE GLU_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GLU_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GLU_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GLU_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GLU_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GLU_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GLU_UNSIGNED_INT_10_10_10_2), and $(D_INLINECODE GLU_UNSIGNED_INT_2_10_10_10_REV) are only available if the GL version is 1.2 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluBuild1DMipmapLevels), $(D_INLINECODE gluBuild1DMipmaps), $(D_INLINECODE gluBuild2DMipmaps), $(D_INLINECODE gluBuild3DMipmapLevels), $(D_INLINECODE gluBuild3DMipmaps), $(D_INLINECODE gluErrorString), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glGetTexImage), $(D_INLINECODE glGetTexLevelParameter), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluBuild2DMipmapLevels gluBuild2DMipmapLevels;
    alias fn_gluBuild2DMipmaps = extern(System) GLint function(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const( void*) data) @system @nogc nothrow;

    /++
     + gluBuild2DMipmaps: man2/gluBuild2DMipmaps.xml
     + 
     + $(D_INLINECODE gluBuild2DMipmaps) builds a series of prefiltered two-dimensional texture maps of decreasing resolutions called a mipmap. This is used for the antialiasing of texture-mapped primitives. A return value of zero indicates success, otherwise a GLU error code is returned (see $(D_INLINECODE gluErrorString) ). Initially, the $(D_INLINECODE width) and $(D_INLINECODE height) of $(D_INLINECODE data) are checked to see if they are a power of 2. If not, a copy of $(D_INLINECODE data) (not $(D_INLINECODE data) ), is scaled up or down to the nearest power of 2. This copy will be used for subsequent mipmapping operations described below. (If $(D_INLINECODE width) or $(D_INLINECODE height) is exactly between powers of 2, then the copy of $(D_INLINECODE data) will scale upwards.)  For example, if $(D_INLINECODE width) is 57 and $(D_INLINECODE height) is 23, then a copy of $(D_INLINECODE data) will scale up to 64 in $(D_INLINECODE width) and down to 16 in depth, before mipmapping takes place. Then, proxy textures (see $(D_INLINECODE glTexImage2D) ) are used to determine if the implementation can fit the requested texture. If not, both dimensions are continually halved until it fits. (If the OpenGL version is \(&lt;= 1.0, both maximum texture dimensions are clamped to the value returned by $(D_INLINECODE glGetIntegerv) with the argument $(D_INLINECODE GLU_MAX_TEXTURE_SIZE).) Next, a series of mipmap levels is built by decimating a copy of $(D_INLINECODE data) in half along both dimensions until size 1 &times; 1 is reached. At each level, each texel in the halved mipmap level is an average of the corresponding four texels in the larger mipmap level. (In the case of rectangular images, the decimation will ultimately reach an N &times; 1 or 1 &times; N configuration. Here, two texels are averaged instead.) $(D_INLINECODE glTexImage2D) is called to load each of these mipmap levels. Level 0 is a copy of $(D_INLINECODE data).  The highest level is log 2 &af; max &af; width height. For example, if $(D_INLINECODE width) is 64 and $(D_INLINECODE height) is 16 and the implementation can store a texture of this size, the following mipmap levels are built: 64 &times; 16, 32 &times; 8, 16 &times; 4, 8 &times; 2, 4 &times; 1, 2 &times; 1, and 1 &times; 1 These correspond to levels 0 through 6, respectively. See the $(D_INLINECODE glTexImage1D) reference page for a description of the acceptable values for $(D_INLINECODE format) parameter. See the $(D_INLINECODE glDrawPixels) reference page for a description of the acceptable values for $(D_INLINECODE type) parameter.
     + 
     + Note that there is no direct way of querying the maximum level. This can be derived indirectly via $(D_INLINECODE glGetTexLevelParameter). First, query for the width and height actually used at level 0.  (The width and height may not be equal to $(D_INLINECODE width) and $(D_INLINECODE height) respectively since proxy textures might have scaled them to fit the implementation.)  Then the maximum level can be derived from the formula log 2 &af; max &af; width height. Formats $(D_INLINECODE GLU_BGR), and $(D_INLINECODE GLU_BGRA), and types $(D_INLINECODE GLU_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GLU_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GLU_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GLU_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GLU_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GLU_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GLU_UNSIGNED_INT_10_10_10_2), and $(D_INLINECODE GLU_UNSIGNED_INT_2_10_10_10_REV) are only available if the GL version is 1.2 or greater and if the GLU version is 1.3 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluBuild1DMipmapLevels), $(D_INLINECODE gluBuild1DMipmaps), $(D_INLINECODE gluBuild2DMipmapLevels), $(D_INLINECODE gluBuild3DMipmapLevels), $(D_INLINECODE gluBuild3DMipmaps), $(D_INLINECODE gluErrorString), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glGetTexImage), $(D_INLINECODE glGetTexLevelParameter), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluBuild2DMipmaps gluBuild2DMipmaps;
    alias fn_gluBuild3DMipmapLevels = extern(System) GLint function(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const( void*) data) @system @nogc nothrow;

    /++
     + gluBuild3DMipmapLevels: man2/gluBuild3DMipmapLevels.xml
     + 
     + $(D_INLINECODE gluBuild3DMipmapLevels) builds a subset of prefiltered three-dimensional texture maps of decreasing resolutions called a mipmap. This is used for the antialiasing of texture mapped primitives. A return value of zero indicates success, otherwise a GLU error code is returned (see $(D_INLINECODE gluErrorString) ). A series of mipmap levels from $(D_INLINECODE base) to $(D_INLINECODE max) is built by decimating $(D_INLINECODE data) in half along both dimensions until size 1 &times; 1 &times; 1 is reached. At each level, each texel in the halved mipmap level is an average of the corresponding eight texels in the larger mipmap level. (If exactly one of the dimensions is 1, four texels are averaged.  If exactly two of the dimensions are 1, two texels are averaged.) $(D_INLINECODE glTexImage3D) is called to load these mipmap levels from $(D_INLINECODE base) to $(D_INLINECODE max). If $(D_INLINECODE max) is larger than the highest mipmap level for the texture of the specified size, then a GLU error code is returned (see $(D_INLINECODE gluErrorString) ) and nothing is loaded. For example, if $(D_INLINECODE level) is 2 and $(D_INLINECODE width) is 16, $(D_INLINECODE height) is 8 and $(D_INLINECODE depth) is 4, the following levels are possible: 16 &times; 8 &times; 4, 8 &times; 4 &times; 2, 4 &times; 2 &times; 1, 2 &times; 1 &times; 1, 1 &times; 1 &times; 1. These correspond to levels 2 through 6 respectively.  If $(D_INLINECODE base) is 3 and $(D_INLINECODE max) is 5, then only mipmap levels 8 &times; 4 &times; 2, 4 &times; 2 &times; 1, and 2 &times; 1 &times; 1 are loaded. However, if $(D_INLINECODE max) is 7, then an error is returned and nothing is loaded, since $(D_INLINECODE max) is larger than the highest mipmap level which is, in this case, 6. The highest mipmap level can be derived from the formula log 2 &af; max &af; width height depth &times; 2 level. See the $(D_INLINECODE glTexImage1D) reference page for a description of the acceptable values for $(D_INLINECODE format) parameter. See the $(D_INLINECODE glDrawPixels) reference page for a description of the acceptable values for $(D_INLINECODE type) parameter.
     + 
     + $(D_INLINECODE gluBuild3DMipmapLevels) is only available if the GLU version is 1.3 or greater. Formats $(D_INLINECODE GLU_BGR), and $(D_INLINECODE GLU_BGRA), and types $(D_INLINECODE GLU_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GLU_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GLU_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GLU_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GLU_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GLU_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GLU_UNSIGNED_INT_10_10_10_2), and $(D_INLINECODE GLU_UNSIGNED_INT_2_10_10_10_REV) are only available if the GL version is 1.2 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluBuild1DMipmapLevels), $(D_INLINECODE gluBuild1DMipmaps), $(D_INLINECODE gluBuild2DMipmapLevels), $(D_INLINECODE gluBuild2DMipmaps), $(D_INLINECODE gluBuild3DMipmaps), $(D_INLINECODE gluErrorString), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glGetTexImage), $(D_INLINECODE glGetTexLevelParameter), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluBuild3DMipmapLevels gluBuild3DMipmapLevels;
    alias fn_gluBuild3DMipmaps = extern(System) GLint function(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const( void*) data) @system @nogc nothrow;

    /++
     + gluBuild3DMipmaps: man2/gluBuild3DMipmaps.xml
     + 
     + $(D_INLINECODE gluBuild3DMipmaps) builds a series of prefiltered three-dimensional texture maps of decreasing resolutions called a mipmap. This is used for the antialiasing of texture-mapped primitives. A return value of zero indicates success, otherwise a GLU error code is returned (see $(D_INLINECODE gluErrorString) ). Initially, the $(D_INLINECODE width), $(D_INLINECODE height) and $(D_INLINECODE depth) of $(D_INLINECODE data) are checked to see if they are a power of 2. If not, a copy of $(D_INLINECODE data) is made and scaled up or down to the nearest power of 2. (If $(D_INLINECODE width), $(D_INLINECODE height), or $(D_INLINECODE depth) is exactly between powers of 2, then the copy of $(D_INLINECODE data) will scale upwards.) This copy will be used for subsequent mipmapping operations described below.  For example, if $(D_INLINECODE width) is 57, $(D_INLINECODE height) is 23, and $(D_INLINECODE depth) is 24, then a copy of $(D_INLINECODE data) will scale up to 64 in width, down to 16 in height, and up to 32 in depth before mipmapping takes place. Then, proxy textures (see $(D_INLINECODE glTexImage3D) ) are used to determine if the implementation can fit the requested texture. If not, all three dimensions are continually halved until it fits. Next, a series of mipmap levels is built by decimating a copy of $(D_INLINECODE data) in half along all three dimensions until size 1 &times; 1 &times; 1 is reached. At each level, each texel in the halved mipmap level is an average of the corresponding eight texels in the larger mipmap level. (If exactly one of the dimensions is 1, four texels are averaged. If exactly two of the dimensions are 1, two texels are averaged.) $(D_INLINECODE glTexImage3D) is called to load each of these mipmap levels. Level 0 is a copy of $(D_INLINECODE data).  The highest level is log 2 &af; max &af; width height depth. For example, if $(D_INLINECODE width) is 64, $(D_INLINECODE height) is 16, and $(D_INLINECODE depth) is 32, and the implementation can store a texture of this size, the following mipmap levels are built: 64 &times; 16 &times; 32, 32 &times; 8 &times; 16, 16 &times; 4 &times; 8, 8 &times; 2 &times; 4, 4 &times; 1 &times; 2, 2 &times; 1 &times; 1, and 1 &times; 1 &times; 1. These correspond to levels 0 through 6, respectively. See the $(D_INLINECODE glTexImage1D) reference page for a description of the acceptable values for $(D_INLINECODE format) parameter. See the $(D_INLINECODE glDrawPixels) reference page for a description of the acceptable values for $(D_INLINECODE type) parameter.
     + 
     + Note that there is no direct way of querying the maximum level. This can be derived indirectly via $(D_INLINECODE glGetTexLevelParameter). First, query the width, height, and depth actually used at level 0.  (The width, height, and depth may not be equal to $(D_INLINECODE width), $(D_INLINECODE height), and $(D_INLINECODE depth) respectively since proxy textures might have scaled them to fit the implementation.)  Then the maximum level can be derived from the formula log 2 &af; max &af; width height depth. $(D_INLINECODE gluBuild3DMipmaps) is only available if the GLU version is 1.3 or greater. Formats $(D_INLINECODE GLU_BGR), and $(D_INLINECODE GLU_BGRA), and types $(D_INLINECODE GLU_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GLU_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GLU_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GLU_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GLU_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GLU_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GLU_UNSIGNED_INT_10_10_10_2), and $(D_INLINECODE GLU_UNSIGNED_INT_2_10_10_10_REV) are only available if the GL version is 1.2 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluBuild1DMipmapLevels), $(D_INLINECODE gluBuild1DMipmaps), $(D_INLINECODE gluBuild2DMipmapLevels), $(D_INLINECODE gluBuild3DMipmapLevels), $(D_INLINECODE gluBuild3DMipmaps), $(D_INLINECODE gluErrorString), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glGetTexImage), $(D_INLINECODE glGetTexLevelParameter), $(D_INLINECODE glTexImage1D), $(D_INLINECODE glTexImage2D), $(D_INLINECODE glTexImage3D)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluBuild3DMipmaps gluBuild3DMipmaps;
    alias fn_gluCheckExtension = extern(System) GLboolean function(const(GLubyte)* extName, const(GLubyte)* extString) @system @nogc nothrow;

    /++
     + gluCheckExtension: man2/gluCheckExtension.xml
     + 
     + $(D_INLINECODE gluCheckExtension) returns $(D_INLINECODE GLU_TRUE) if $(D_INLINECODE extName) is supported otherwise $(D_INLINECODE GLU_FALSE) is returned. This is used to check for the presence for OpenGL, GLU, or GLX extension names by passing the extension strings returned by $(D_INLINECODE glGetString), $(D_INLINECODE gluGetString), $(D_INLINECODE glXGetClientString), $(D_INLINECODE glXQueryExtensionsString), or $(D_INLINECODE glXQueryServerString), respectively, as $(D_INLINECODE extString).
     + 
     + Cases where one extension name is a substring of another are correctly handled. There may or may not be leading or trailing blanks in $(D_INLINECODE extString). Extension names should not contain embedded spaces. All strings are null-terminated.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluGetString), $(D_INLINECODE glGetString), $(D_INLINECODE glXGetClientString), $(D_INLINECODE glXQueryExtensionsString), $(D_INLINECODE glXQueryServerString)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluCheckExtension gluCheckExtension;
    alias fn_gluCylinder = extern(System) void function(GLUquadric* quad, GLdouble base, GLdouble top, GLdouble height, GLint slices, GLint stacks) @system @nogc nothrow;

    /++
     + gluCylinder: man2/gluCylinder.xml
     + 
     + $(D_INLINECODE gluCylinder) draws a cylinder oriented along the axis. The base of the cylinder is placed at = 0 and the top at z = height. Like a sphere, a cylinder is subdivided around the axis into slices and along the axis into stacks. Note that if $(D_INLINECODE top) is set to 0.0, this routine generates a cone. If the orientation is set to $(D_INLINECODE GLU_OUTSIDE) (with $(D_INLINECODE gluQuadricOrientation) ), then any generated normals point away from the axis. Otherwise, they point toward the axis. If texturing is turned on (with $(D_INLINECODE gluQuadricTexture) ), then texture coordinates are generated so that ranges linearly from 0.0 at = 0 to 1.0 at = $(D_INLINECODE height), and ranges from 0.0 at the + axis, to 0.25 at the + axis, to 0.5 at the - axis, to 0.75 at the \- axis, and back to 1.0 at the + axis.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluDisk), $(D_INLINECODE gluNewQuadric), $(D_INLINECODE gluPartialDisk), $(D_INLINECODE gluQuadricTexture), $(D_INLINECODE gluSphere)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluCylinder gluCylinder;
    alias fn_gluDeleteNurbsRenderer = extern(System) void function(GLUnurbs* nurb) @system @nogc nothrow;

    /++
     + gluDeleteNurbsRenderer: man2/gluDeleteNurbsRenderer.xml
     + 
     + $(D_INLINECODE gluDeleteNurbsRenderer) destroys the NURBS object (which was created with $(D_INLINECODE gluNewNurbsRenderer) ) and frees any memory it uses. Once $(D_INLINECODE gluDeleteNurbsRenderer) has been called, $(D_INLINECODE nurb) cannot be used again.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluNewNurbsRenderer)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluDeleteNurbsRenderer gluDeleteNurbsRenderer;
    alias fn_gluDeleteQuadric = extern(System) void function(GLUquadric* quad) @system @nogc nothrow;

    /++
     + gluDeleteQuadric: man2/gluDeleteQuadric.xml
     + 
     + $(D_INLINECODE gluDeleteQuadric) destroys the quadrics object (created with $(D_INLINECODE gluNewQuadric) ) and frees any memory it uses. Once $(D_INLINECODE gluDeleteQuadric) has been called, $(D_INLINECODE quad) cannot be used again.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluNewQuadric)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluDeleteQuadric gluDeleteQuadric;
    alias fn_gluDeleteTess = extern(System) void function(GLUtesselator* tess) @system @nogc nothrow;

    /++
     + gluDeleteTess: man2/gluDeleteTess.xml
     + 
     + $(D_INLINECODE gluDeleteTess) destroys the indicated tessellation object (which was created with $(D_INLINECODE gluNewTess) ) and frees any memory that it used.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluBeginPolygon), $(D_INLINECODE gluNewTess), $(D_INLINECODE gluTessCallback)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluDeleteTess gluDeleteTess;
    alias fn_gluDisk = extern(System) void function(GLUquadric* quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops) @system @nogc nothrow;

    /++
     + gluDisk: man2/gluDisk.xml
     + 
     + $(D_INLINECODE gluDisk) renders a disk on the = 0 plane. The disk has a radius of $(D_INLINECODE outer) and contains a concentric circular hole with a radius of $(D_INLINECODE inner). If $(D_INLINECODE inner) is 0, then no hole is generated. The disk is subdivided around the axis into slices (like pizza slices) and also about the axis into rings (as specified by $(D_INLINECODE slices) and $(D_INLINECODE loops), respectively). With respect to orientation, the + side of the disk is considered to be ``outside'' (see $(D_INLINECODE gluQuadricOrientation) ). This means that if the orientation is set to $(D_INLINECODE GLU_OUTSIDE), then any normals generated point along the + axis. Otherwise, they point along the \- axis. If texturing has been turned on (with $(D_INLINECODE gluQuadricTexture) ), texture coordinates are generated linearly such that where r = outer, the value at (, 0, 0) is (1, 0.5), at (0,, 0) it is (0.5, 1), at (\-, 0, 0) it is (0, 0.5), and at (0, \-, 0) it is (0.5, 0).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluCylinder), $(D_INLINECODE gluNewQuadric), $(D_INLINECODE gluPartialDisk), $(D_INLINECODE gluQuadricOrientation), $(D_INLINECODE gluQuadricTexture), $(D_INLINECODE gluSphere)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluDisk gluDisk;
    alias fn_gluErrorString = extern(System) const(GLubyte)* function(GLenum error) @system @nogc nothrow;

    /++
     + gluErrorString: man2/gluErrorString.xml
     + 
     + $(D_INLINECODE gluErrorString) produces an error string from a GL or GLU error code. The string is in ISO Latin 1 format. For example, $(D_INLINECODE gluErrorString) ( $(D_INLINECODE GLU_OUT_OF_MEMORY) ) returns the string. The standard GLU error codes are $(D_INLINECODE GLU_INVALID_ENUM), $(D_INLINECODE GLU_INVALID_VALUE), and $(D_INLINECODE GLU_OUT_OF_MEMORY). Certain other GLU functions can return specialized error codes through callbacks. See the $(D_INLINECODE glGetError) reference page for the list of GL error codes.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluNurbsCallback), $(D_INLINECODE gluQuadricCallback), $(D_INLINECODE gluTessCallback), $(D_INLINECODE glGetError)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluErrorString gluErrorString;
    alias fn_gluGetNurbsProperty = extern(System) void function(GLUnurbs* nurb, GLenum property, GLfloat* data) @system @nogc nothrow;

    /++
     + gluGetNurbsProperty: man2/gluGetNurbsProperty.xml
     + 
     + $(D_INLINECODE gluGetNurbsProperty) retrieves properties stored in a NURBS object. These properties affect the way that NURBS curves and surfaces are rendered. See the $(D_INLINECODE gluNurbsProperty) reference page for information about what the properties are and what they do.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluNewNurbsRenderer), $(D_INLINECODE gluNurbsProperty)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluGetNurbsProperty gluGetNurbsProperty;
    alias fn_gluGetString = extern(System) const(GLubyte)* function(GLenum name) @system @nogc nothrow;

    /++
     + gluGetString: man2/gluGetString.xml
     + 
     + $(D_INLINECODE gluGetString) returns a pointer to a static string describing the GLU version or the GLU extensions that are supported. The version number is one of the following forms:. The version string is of the following form: Vendor-specific information is optional. Its format and contents depend on the implementation. The standard GLU contains a basic set of features and capabilities. If a company or group of companies wish to support other features, these may be included as extensions to the GLU. If $(D_INLINECODE name) is $(D_INLINECODE GLU_EXTENSIONS), then $(D_INLINECODE gluGetString) returns a space-separated list of names of supported GLU extensions. (Extension names never contain spaces.) All strings are null-terminated.
     + 
     + $(D_INLINECODE gluGetString) only returns information about GLU extensions. Call $(D_INLINECODE glGetString) to get a list of GL extensions. $(D_INLINECODE gluGetString) is an initialization routine. Calling it after a $(D_INLINECODE glNewList) results in undefined behavior.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glGetString)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluGetString gluGetString;
    alias fn_gluGetTessProperty = extern(System) void function(GLUtesselator* tess, GLenum which, GLdouble* data) @system @nogc nothrow;

    /++
     + gluGetTessProperty: man2/gluGetTessProperty.xml
     + 
     + $(D_INLINECODE gluGetTessProperty) retrieves properties stored in a tessellation object. These properties affect the way that tessellation objects are interpreted and rendered. See the $(D_INLINECODE gluTessProperty) reference page for information about the properties and what they do.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluNewTess), $(D_INLINECODE gluTessProperty)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluGetTessProperty gluGetTessProperty;
    alias fn_gluLoadSamplingMatrices = extern(System) void function(GLUnurbs* nurb, const( GLfloat*) model, const( GLfloat*) perspective, const( GLint*) view) @system @nogc nothrow;

    /++
     + gluLoadSamplingMatrices: man2/gluLoadSamplingMatrices.xml
     + 
     + $(D_INLINECODE gluLoadSamplingMatrices) uses $(D_INLINECODE model), $(D_INLINECODE perspective), and $(D_INLINECODE view) to recompute the sampling and culling matrices stored in $(D_INLINECODE nurb). The sampling matrix determines how finely a NURBS curve or surface must be tessellated to satisfy the sampling tolerance (as determined by the $(D_INLINECODE GLU_SAMPLING_TOLERANCE) property). The culling matrix is used in deciding if a NURBS curve or surface should be culled before rendering (when the $(D_INLINECODE GLU_CULLING) property is turned on). $(D_INLINECODE gluLoadSamplingMatrices) is necessary only if the $(D_INLINECODE GLU_AUTO_LOAD_MATRIX) property is turned off (see $(D_INLINECODE gluNurbsProperty) ). Although it can be convenient to leave the $(D_INLINECODE GLU_AUTO_LOAD_MATRIX) property turned on, there can be a performance penalty for doing so. (A round trip to the GL server is needed to fetch the current values of the modelview matrix, projection matrix, and viewport.)
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluGetNurbsProperty), $(D_INLINECODE gluNewNurbsRenderer), $(D_INLINECODE gluNurbsProperty)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluLoadSamplingMatrices gluLoadSamplingMatrices;
    alias fn_gluLookAt = extern(System) void function(GLdouble eyeX, GLdouble eyeY, GLdouble eyeZ, GLdouble centerX, GLdouble centerY, GLdouble centerZ, GLdouble upX, GLdouble upY, GLdouble upZ) @system @nogc nothrow;

    /++
     + gluLookAt: man2/gluLookAt.xml
     + 
     + $(D_INLINECODE gluLookAt) creates a viewing matrix derived from an eye point, a reference point indicating the center of the scene, and an vector. The matrix maps the reference point to the negative axis and the eye point to the origin. When a typical projection matrix is used, the center of the scene therefore maps to the center of the viewport. Similarly, the direction described by the vector projected onto the viewing plane is mapped to the positive axis so that it points upward in the viewport. The vector must not be parallel to the line of sight from the eye point to the reference point. Let F = centerX - eyeX centerY - eyeY centerZ - eyeZ Let be the vector upX upY upZ. Then normalize as follows: f = F F UP &Prime; = UP UP Finally, let s = f &times; UP &Prime;, and u = s s &times; f. M is then constructed as follows: M = s &af; 0 s &af; 1 s &af; 2 0 u &af; 0 u &af; 1 u &af; 2 0 - f &af; 0 - f &af; 1 - f &af; 2 0 0 0 0 1 and $(D_INLINECODE gluLookAt) is equivalent to
     + 
     + ---
     + glMultMatrixf(M);
     + glTranslated(-eyex, -eyey, -eyez);
     +         
     + ---
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluPerspective), $(D_INLINECODE glFrustum)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluLookAt gluLookAt;
    alias fn_gluNewNurbsRenderer = extern(System) GLUnurbs* function() @system @nogc nothrow;

    /++
     + gluNewNurbsRenderer: man2/gluNewNurbsRenderer.xml
     + 
     + $(D_INLINECODE gluNewNurbsRenderer) creates and returns a pointer to a new NURBS object. This object must be referred to when calling NURBS rendering and control functions. A return value of 0 means that there is not enough memory to allocate the object.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluBeginCurve), $(D_INLINECODE gluBeginSurface), $(D_INLINECODE gluBeginTrim), $(D_INLINECODE gluDeleteNurbsRenderer), $(D_INLINECODE gluNurbsCallback), $(D_INLINECODE gluNurbsProperty)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluNewNurbsRenderer gluNewNurbsRenderer;
    alias fn_gluNewQuadric = extern(System) GLUquadric* function() @system @nogc nothrow;

    /++
     + gluNewQuadric: man2/gluNewQuadric.xml
     + 
     + $(D_INLINECODE gluNewQuadric) creates and returns a pointer to a new quadrics object. This object must be referred to when calling quadrics rendering and control functions. A return value of 0 means that there is not enough memory to allocate the object.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluCylinder), $(D_INLINECODE gluDeleteQuadric), $(D_INLINECODE gluDisk), $(D_INLINECODE gluPartialDisk), $(D_INLINECODE gluQuadricCallback), $(D_INLINECODE gluQuadricDrawStyle), $(D_INLINECODE gluQuadricNormals), $(D_INLINECODE gluQuadricOrientation), $(D_INLINECODE gluQuadricTexture), $(D_INLINECODE gluSphere)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluNewQuadric gluNewQuadric;
    alias fn_gluNewTess = extern(System) GLUtesselator* function() @system @nogc nothrow;

    /++
     + gluNewTess: man2/gluNewTess.xml
     + 
     + $(D_INLINECODE gluNewTess) creates and returns a pointer to a new tessellation object. This object must be referred to when calling tessellation functions.  A return value of 0 means that there is not enough memory to allocate the object.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluTessBeginPolygon), $(D_INLINECODE gluDeleteTess), $(D_INLINECODE gluTessCallback)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluNewTess gluNewTess;
    alias fn_gluNextContour = extern(System) void function(GLUtesselator* tess, GLenum type) @system @nogc nothrow;

    /++
     + gluNextContour: man2/gluNextContour.xml
     + 
     + $(D_INLINECODE gluNextContour) is used in describing polygons with multiple contours. After the first contour has been described through a series of $(D_INLINECODE gluTessVertex) calls, a $(D_INLINECODE gluNextContour) call indicates that the previous contour is complete and that the next contour is about to begin. Another series of $(D_INLINECODE gluTessVertex) calls is then used to describe the new contour. This process can be repeated until all contours have been described. $(D_INLINECODE type) defines what type of contour follows. The legal contour types are as follows: If one contour is of type $(D_INLINECODE GLU_CCW) or $(D_INLINECODE GLU_CW), then all contours must be of the same type (if they are not, then all $(D_INLINECODE GLU_CCW) and $(D_INLINECODE GLU_CW) contours will be changed to $(D_INLINECODE GLU_UNKNOWN) ). Note that there is no real difference between the $(D_INLINECODE GLU_CCW) and $(D_INLINECODE GLU_CW) contour types. Before the first contour is described, $(D_INLINECODE gluNextContour) can be called to define the type of the first contour. If $(D_INLINECODE gluNextContour) is not called before the first contour, then the first contour is marked $(D_INLINECODE GLU_EXTERIOR). This command is obsolete and is provided for backward compatibility only. Calls to $(D_INLINECODE gluNextContour) are mapped to $(D_INLINECODE gluTessEndContour) followed by $(D_INLINECODE gluTessBeginContour).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluBeginPolygon), $(D_INLINECODE gluNewTess), $(D_INLINECODE gluTessBeginContour), $(D_INLINECODE gluTessCallback), $(D_INLINECODE gluTessVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluNextContour gluNextContour;
    alias fn_gluNurbsCallback = extern(System) void function(GLUnurbs* nurb, GLenum which, _GLUfuncptr CallBackFunc) @system @nogc nothrow;

    /++
     + gluNurbsCallback: man2/gluNurbsCallback.xml
     + 
     + $(D_INLINECODE gluNurbsCallback) is used to define a callback to be used by a NURBS object. If the specified callback is already defined, then it is replaced.  If $(D_INLINECODE CallBackFunc) is null, then this callback will not get
     +  invoked and the related data, if any, will be lost.
     +  Except the error callback, these callbacks are used by NURBS tessellator (when $(D_INLINECODE GLU_NURBS_MODE) is set to be $(D_INLINECODE GLU_NURBS_TESSELLATOR) ) to return back the OpenGL polygon primitives resulting from the tessellation. Note that there are two versions of each callback: one with a user data pointer and one without. If both versions for a particular callback are specified then the callback with the user data pointer will be used. Note that ``userData'' is a copy of the pointer that was specified at the last call to $(D_INLINECODE gluNurbsCallbackData). The error callback function is effective no matter which value that $(D_INLINECODE GLU_NURBS_MODE) is set to. All other callback functions are effective only when $(D_INLINECODE GLU_NURBS_MODE) is set to $(D_INLINECODE GLU_NURBS_TESSELLATOR). The legal callbacks are as follows:
     + 
     + $(D_INLINECODE gluNurbsCallback) is available only if the GLU version is 1.2 or greater. GLU version 1.2 supports only the $(D_INLINECODE GLU_ERROR) parameter for $(D_INLINECODE which). The $(D_INLINECODE GLU_ERROR) value is deprecated in GLU version 1.3 in favor of $(D_INLINECODE GLU_NURBS_ERROR).  All other accepted values for $(D_INLINECODE CallBackFunc) are available only if the GLU version is 1.3 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluErrorString), $(D_INLINECODE gluNewNurbsRenderer), $(D_INLINECODE gluNurbsCallbackData), $(D_INLINECODE gluNurbsProperty)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluNurbsCallback gluNurbsCallback;
    alias fn_gluNurbsCallbackData = extern(System) void function(GLUnurbs* nurb, GLvoid* userData) @system @nogc nothrow;

    /++
     + gluNurbsCallbackData: man2/gluNurbsCallbackData.xml
     + 
     + $(D_INLINECODE gluNurbsCallbackData) is used to pass a pointer to the application's data to NURBS tessellator. A copy of this pointer will be passed by the tessellator in the NURBS callback functions (set by $(D_INLINECODE gluNurbsCallback) ).
     + 
     + $(D_INLINECODE gluNurbsCallbackData) is available only if the GLU version is 1.3 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluNewNurbsRenderer), $(D_INLINECODE gluNurbsCallback)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluNurbsCallbackData gluNurbsCallbackData;
    alias fn_gluNurbsCallbackDataEXT = extern(System) void function(GLUnurbs* nurb, GLvoid* userData) @system @nogc nothrow;

    /++
     + gluNurbsCallbackDataEXT: man2/gluNurbsCallbackDataEXT.xml
     + 
     + $(D_INLINECODE gluNurbsCallbackDataEXT) is used to pass a pointer to the application's data to NURBS tessellator. A copy of this pointer will be passed by the tessellator in the NURBS callback functions (set by $(D_INLINECODE gluNurbsCallback) ).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluNurbsCallback)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluNurbsCallbackDataEXT gluNurbsCallbackDataEXT;
    alias fn_gluNurbsCurve = extern(System) void function(GLUnurbs* nurb, GLint knotCount, GLfloat* knots, GLint stride, GLfloat* control, GLint order, GLenum type) @system @nogc nothrow;

    /++
     + gluNurbsCurve: man2/gluNurbsCurve.xml
     + 
     + Use $(D_INLINECODE gluNurbsCurve) to describe a NURBS curve. When $(D_INLINECODE gluNurbsCurve) appears between a $(D_INLINECODE gluBeginCurve) / $(D_INLINECODE gluEndCurve) pair, it is used to describe a curve to be rendered. Positional, texture, and color coordinates are associated by presenting each as a separate $(D_INLINECODE gluNurbsCurve) between a $(D_INLINECODE gluBeginCurve) / $(D_INLINECODE gluEndCurve) pair. No more than one call to $(D_INLINECODE gluNurbsCurve) for each of color, position, and texture data can be made within a single $(D_INLINECODE gluBeginCurve) / $(D_INLINECODE gluEndCurve) pair. Exactly one call must be made to describe the position of the curve (a $(D_INLINECODE type) of $(D_INLINECODE GLU_MAP1_VERTEX_3) or $(D_INLINECODE GLU_MAP1_VERTEX_4) ). When $(D_INLINECODE gluNurbsCurve) appears between a $(D_INLINECODE gluBeginTrim) / $(D_INLINECODE gluEndTrim) pair, it is used to describe a trimming curve on a NURBS surface. If $(D_INLINECODE type) is $(D_INLINECODE GLU_MAP1_TRIM_2), then it describes a curve in two-dimensional ( and ) parameter space. If it is $(D_INLINECODE GLU_MAP1_TRIM_3), then it describes a curve in two-dimensional homogeneous (,, and ) parameter space. See the $(D_INLINECODE gluBeginTrim) reference page for more discussion about trimming curves.
     + 
     + To define trim curves that stitch well, use $(D_INLINECODE gluPwlCurve).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluBeginCurve), $(D_INLINECODE gluBeginTrim), $(D_INLINECODE gluNewNurbsRenderer), $(D_INLINECODE gluPwlCurve)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluNurbsCurve gluNurbsCurve;
    alias fn_gluNurbsProperty = extern(System) void function(GLUnurbs* nurb, GLenum property, GLfloat value) @system @nogc nothrow;

    /++
     + gluNurbsProperty: man2/gluNurbsProperty.xml
     + 
     + $(D_INLINECODE gluNurbsProperty) is used to control properties stored in a NURBS object. These properties affect the way that a NURBS curve is rendered. The accepted values for $(D_INLINECODE property) are as follows:
     + 
     + If $(D_INLINECODE GLU_AUTO_LOAD_MATRIX) is true, sampling and culling may be executed incorrectly if NURBS routines are compiled into a display list. A $(D_INLINECODE property) of $(D_INLINECODE GLU_PARAMETRIC_TOLERANCE), $(D_INLINECODE GLU_SAMPLING_METHOD), $(D_INLINECODE GLU_U_STEP), or $(D_INLINECODE GLU_V_STEP), or a $(D_INLINECODE value) of $(D_INLINECODE GLU_PATH_LENGTH), $(D_INLINECODE GLU_PARAMETRIC_ERROR), $(D_INLINECODE GLU_DOMAIN_DISTANCE) are only available if the GLU version is 1.1 or greater. They are not valid parameters in GLU 1.0. $(D_INLINECODE gluGetString) can be used to determine the GLU version. $(D_INLINECODE GLU_NURBS_MODE) is only available if the GLU version is 1.3 or greater. The $(D_INLINECODE GLU_OBJECT_PATH_LENGTH) and $(D_INLINECODE GLU_OBJECT_PARAMETRIC_ERROR) values for the $(D_INLINECODE GLU_SAMPLING_METHOD) property are only available if the GLU version is 1.3 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluGetNurbsProperty), $(D_INLINECODE gluGetString), $(D_INLINECODE gluLoadSamplingMatrices), $(D_INLINECODE gluNewNurbsRenderer), $(D_INLINECODE gluNurbsCallback)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluNurbsProperty gluNurbsProperty;
    alias fn_gluNurbsSurface = extern(System) void function(GLUnurbs* nurb, GLint sKnotCount, GLfloat* sKnots, GLint tKnotCount, GLfloat* tKnots, GLint sStride, GLint tStride, GLfloat* control, GLint sOrder, GLint tOrder, GLenum type) @system @nogc nothrow;

    /++
     + gluNurbsSurface: man2/gluNurbsSurface.xml
     + 
     + Use $(D_INLINECODE gluNurbsSurface) within a NURBS (Non-Uniform Rational B-Spline) surface definition to describe the shape of a NURBS surface (before any trimming). To mark the beginning of a NURBS surface definition, use the $(D_INLINECODE gluBeginSurface) command. To mark the end of a NURBS surface definition, use the $(D_INLINECODE gluEndSurface) command. Call $(D_INLINECODE gluNurbsSurface) within a NURBS surface definition only. Positional, texture, and color coordinates are associated with a surface by presenting each as a separate $(D_INLINECODE gluNurbsSurface) between a $(D_INLINECODE gluBeginSurface) / $(D_INLINECODE gluEndSurface) pair. No more than one call to $(D_INLINECODE gluNurbsSurface) for each of color, position, and texture data can be made within a single $(D_INLINECODE gluBeginSurface) / $(D_INLINECODE gluEndSurface) pair. Exactly one call must be made to describe the position of the surface (a $(D_INLINECODE type) of $(D_INLINECODE GLU_MAP2_VERTEX_3) or $(D_INLINECODE GLU_MAP2_VERTEX_4) ). A NURBS surface can be trimmed by using the commands $(D_INLINECODE gluNurbsCurve) and $(D_INLINECODE gluPwlCurve) between calls to $(D_INLINECODE gluBeginTrim) and $(D_INLINECODE gluEndTrim). Note that a $(D_INLINECODE gluNurbsSurface) with $(D_INLINECODE sKnotCount) knots in the direction and $(D_INLINECODE tKnotCount) knots in the direction with orders $(D_INLINECODE sOrder) and $(D_INLINECODE tOrder) must have ( $(D_INLINECODE sKnotCount) - $(D_INLINECODE sOrder) ) times ( $(D_INLINECODE tKnotCount) - $(D_INLINECODE tOrder) ) control points.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluBeginSurface), $(D_INLINECODE gluBeginTrim), $(D_INLINECODE gluNewNurbsRenderer), $(D_INLINECODE gluNurbsCurve), $(D_INLINECODE gluPwlCurve)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluNurbsSurface gluNurbsSurface;
    alias fn_gluOrtho2D = extern(System) void function(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top) @system @nogc nothrow;

    /++
     + gluOrtho2D: man2/gluOrtho2D.xml
     + 
     + $(D_INLINECODE gluOrtho2D) sets up a two-dimensional orthographic viewing region. This is equivalent to calling $(D_INLINECODE glOrtho) with near = -1 and far = 1.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glOrtho), $(D_INLINECODE gluPerspective)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluOrtho2D gluOrtho2D;
    alias fn_gluPartialDisk = extern(System) void function(GLUquadric* quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops, GLdouble start, GLdouble sweep) @system @nogc nothrow;

    /++
     + gluPartialDisk: man2/gluPartialDisk.xml
     + 
     + $(D_INLINECODE gluPartialDisk) renders a partial disk on the z = 0 plane. A partial disk is similar to a full disk, except that only the subset of the disk from $(D_INLINECODE start) through $(D_INLINECODE start) + $(D_INLINECODE sweep) is included (where 0 degrees is along the +\f2y\f axis, 90 degrees along the + axis, 180 degrees along the \- axis, and 270 degrees along the \- axis). The partial disk has a radius of $(D_INLINECODE outer) and contains a concentric circular hole with a radius of $(D_INLINECODE inner). If $(D_INLINECODE inner) is 0, then no hole is generated. The partial disk is subdivided around the axis into slices (like pizza slices) and also about the axis into rings (as specified by $(D_INLINECODE slices) and $(D_INLINECODE loops), respectively). With respect to orientation, the + side of the partial disk is considered to be outside (see $(D_INLINECODE gluQuadricOrientation) ). This means that if the orientation is set to $(D_INLINECODE GLU_OUTSIDE), then any normals generated point along the + axis. Otherwise, they point along the \- axis. If texturing is turned on (with $(D_INLINECODE gluQuadricTexture) ), texture coordinates are generated linearly such that where r = outer, the value at (, 0, 0) is (1.0, 0.5), at (0,, 0) it is (0.5, 1.0), at (\-, 0, 0) it is (0.0, 0.5), and at (0, \-, 0) it is (0.5, 0.0).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluCylinder), $(D_INLINECODE gluDisk), $(D_INLINECODE gluNewQuadric), $(D_INLINECODE gluQuadricOrientation), $(D_INLINECODE gluQuadricTexture), $(D_INLINECODE gluSphere)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluPartialDisk gluPartialDisk;
    alias fn_gluPerspective = extern(System) void function(GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar) @system @nogc nothrow;

    /++
     + gluPerspective: man2/gluPerspective.xml
     + 
     + $(D_INLINECODE gluPerspective) specifies a viewing frustum into the world coordinate system. In general, the aspect ratio in $(D_INLINECODE gluPerspective) should match the aspect ratio of the associated viewport. For example, aspect = 2.0 means the viewer's angle of view is twice as wide in as it is in. If the viewport is twice as wide as it is tall, it displays the image without distortion. The matrix generated by $(D_INLINECODE gluPerspective) is multipled by the current matrix, just as if $(D_INLINECODE glMultMatrix) were called with the generated matrix. To load the perspective matrix onto the current matrix stack instead, precede the call to $(D_INLINECODE gluPerspective) with a call to $(D_INLINECODE glLoadIdentity). Given defined as follows: f = cotangent &af; fovy 2 The generated matrix is f aspect 0 0 0 0 f 0 0 0 0 zFar + zNear zNear - zFar 2 &times; zFar &times; zNear zNear - zFar 0 0 -1 0
     + 
     + Depth buffer precision is affected by the values specified for $(D_INLINECODE zNear) and $(D_INLINECODE zFar). The greater the ratio of $(D_INLINECODE zFar) to $(D_INLINECODE zNear) is, the less effective the depth buffer will be at distinguishing between surfaces that are near each other. If r = zFar zNear roughly log 2 &af; r bits of depth buffer precision are lost. Because r approaches infinity as $(D_INLINECODE zNear) approaches 0, $(D_INLINECODE zNear) must never be set to 0.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluOrtho2D), $(D_INLINECODE glFrustum), $(D_INLINECODE glLoadIdentity), $(D_INLINECODE glMultMatrix)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluPerspective gluPerspective;
    alias fn_gluPickMatrix = extern(System) void function(GLdouble x, GLdouble y, GLdouble delX, GLdouble delY, GLint* viewport) @system @nogc nothrow;

    /++
     + gluPickMatrix: man2/gluPickMatrix.xml
     + 
     + $(D_INLINECODE gluPickMatrix) creates a projection matrix that can be used to restrict drawing to a small region of the viewport. This is typically useful to determine what objects are being drawn near the cursor. Use $(D_INLINECODE gluPickMatrix) to restrict drawing to a small region around the cursor. Then, enter selection mode (with $(D_INLINECODE glRenderMode) ) and rerender the scene. All primitives that would have been drawn near the cursor are identified and stored in the selection buffer. The matrix created by $(D_INLINECODE gluPickMatrix) is multiplied by the current matrix just as if $(D_INLINECODE glMultMatrix) is called with the generated matrix. To effectively use the generated pick matrix for picking, first call $(D_INLINECODE glLoadIdentity) to load an identity matrix onto the perspective matrix stack. Then call $(D_INLINECODE gluPickMatrix), and, finally, call a command (such as $(D_INLINECODE gluPerspective) ) to multiply the perspective matrix by the pick matrix. When using $(D_INLINECODE gluPickMatrix) to pick NURBS, be careful to turn off the NURBS property $(D_INLINECODE GLU_AUTO_LOAD_MATRIX).  If $(D_INLINECODE GLU_AUTO_LOAD_MATRIX) is not turned off, then any NURBS surface rendered is subdivided differently with the pick matrix than the way it was subdivided without the pick matrix.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluPerspective), $(D_INLINECODE glGet), $(D_INLINECODE glLoadIdentity), $(D_INLINECODE glMultMatrix), $(D_INLINECODE glRenderMode)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluPickMatrix gluPickMatrix;
    alias fn_gluProject = extern(System) GLint function(GLdouble objX, GLdouble objY, GLdouble objZ, const( GLdouble*) model, const( GLdouble*) proj, const( GLint*) view, GLdouble* winX, GLdouble* winY, GLdouble* winZ) @system @nogc nothrow;

    /++
     + gluProject: man2/gluProject.xml
     + 
     + $(D_INLINECODE gluProject) transforms the specified object coordinates into window coordinates using $(D_INLINECODE model), $(D_INLINECODE proj), and $(D_INLINECODE view). The result is stored in $(D_INLINECODE winX), $(D_INLINECODE winY), and $(D_INLINECODE winZ). A return value of $(D_INLINECODE GLU_TRUE) indicates success, a return value of $(D_INLINECODE GLU_FALSE) indicates failure. To compute the coordinates, let v = objX objY objZ 1.0 represented as a matrix with 4 rows and 1 column. Then $(D_INLINECODE gluProject) computes v &Prime; as follows: v &Prime; = P &times; M &times; v where P is the current projection matrix $(D_INLINECODE proj) and M is the current modelview matrix $(D_INLINECODE model) (both represented as 4 &times; 4 matrices in column-major order). The window coordinates are then computed as follows: winX = view &af; 0 + view &af; 2 &times; v &Prime; &af; 0 + 1 2 winY = view &af; 1 + view &af; 3 &times; v &Prime; &af; 1 + 1 2 winZ = v &Prime; &af; 2 + 1 2
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluUnProject), $(D_INLINECODE glGet)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluProject gluProject;
    alias fn_gluPwlCurve = extern(System) void function(GLUnurbs* nurb, GLint count, GLfloat* data, GLint stride, GLenum type) @system @nogc nothrow;

    /++
     + gluPwlCurve: man2/gluPwlCurve.xml
     + 
     + $(D_INLINECODE gluPwlCurve) describes a piecewise linear trimming curve for a NURBS surface. A piecewise linear curve consists of a list of coordinates of points in the parameter space for the NURBS surface to be trimmed. These points are connected with line segments to form a curve. If the curve is an approximation to a curve that is not piecewise linear, the points should be close enough in parameter space that the resulting path appears curved at the resolution used in the application. If $(D_INLINECODE type) is $(D_INLINECODE GLU_MAP1_TRIM_2), then it describes a curve in two-dimensional ( and ) parameter space. If it is $(D_INLINECODE GLU_MAP1_TRIM_3), then it describes a curve in two-dimensional homogeneous (,, and ) parameter space. See the $(D_INLINECODE gluBeginTrim) reference page for more information about trimming curves.
     + 
     + To describe a trim curve that closely follows the contours of a NURBS surface, call $(D_INLINECODE gluNurbsCurve).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluBeginCurve), $(D_INLINECODE gluBeginTrim), $(D_INLINECODE gluNewNurbsRenderer), $(D_INLINECODE gluNurbsCurve)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluPwlCurve gluPwlCurve;
    alias fn_gluQuadricCallback = extern(System) void function(GLUquadric* quad, GLenum which, _GLUfuncptr CallBackFunc) @system @nogc nothrow;

    /++
     + gluQuadricCallback: man2/gluQuadricCallback.xml
     + 
     + $(D_INLINECODE gluQuadricCallback) is used to define a new callback to be used by a quadrics object. If the specified callback is already defined, then it is replaced. If $(D_INLINECODE CallBackFunc) is null, then any existing callback is erased.
     +  The one legal callback is $(D_INLINECODE GLU_ERROR) :
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluErrorString), $(D_INLINECODE gluNewQuadric)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluQuadricCallback gluQuadricCallback;
    alias fn_gluQuadricDrawStyle = extern(System) void function(GLUquadric* quad, GLenum draw) @system @nogc nothrow;

    /++
     + gluQuadricDrawStyle: man2/gluQuadricDrawStyle.xml
     + 
     + $(D_INLINECODE gluQuadricDrawStyle) specifies the draw style for quadrics rendered with $(D_INLINECODE quad). The legal values are as follows:
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluNewQuadric), $(D_INLINECODE gluQuadricNormals), $(D_INLINECODE gluQuadricOrientation), $(D_INLINECODE gluQuadricTexture)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluQuadricDrawStyle gluQuadricDrawStyle;
    alias fn_gluQuadricNormals = extern(System) void function(GLUquadric* quad, GLenum normal) @system @nogc nothrow;

    /++
     + gluQuadricNormals: man2/gluQuadricNormals.xml
     + 
     + $(D_INLINECODE gluQuadricNormals) specifies what kind of normals are desired for quadrics rendered with $(D_INLINECODE quad). The legal values are as follows:
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluNewQuadric), $(D_INLINECODE gluQuadricDrawStyle), $(D_INLINECODE gluQuadricOrientation), $(D_INLINECODE gluQuadricTexture)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluQuadricNormals gluQuadricNormals;
    alias fn_gluQuadricOrientation = extern(System) void function(GLUquadric* quad, GLenum orientation) @system @nogc nothrow;

    /++
     + gluQuadricOrientation: man2/gluQuadricOrientation.xml
     + 
     + $(D_INLINECODE gluQuadricOrientation) specifies what kind of orientation is desired for quadrics rendered with $(D_INLINECODE quad). The $(D_INLINECODE orientation) values are as follows: Note that the interpretation of and depends on the quadric being drawn.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluNewQuadric), $(D_INLINECODE gluQuadricDrawStyle), $(D_INLINECODE gluQuadricNormals), $(D_INLINECODE gluQuadricTexture)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluQuadricOrientation gluQuadricOrientation;
    alias fn_gluQuadricTexture = extern(System) void function(GLUquadric* quad, GLboolean texture) @system @nogc nothrow;

    /++
     + gluQuadricTexture: man2/gluQuadricTexture.xml
     + 
     + $(D_INLINECODE gluQuadricTexture) specifies if texture coordinates should be generated for quadrics rendered with $(D_INLINECODE quad). If the value of $(D_INLINECODE texture) is $(D_INLINECODE GLU_TRUE), then texture coordinates are generated, and if $(D_INLINECODE texture) is $(D_INLINECODE GLU_FALSE), they are not.  The initial value is $(D_INLINECODE GLU_FALSE). The manner in which texture coordinates are generated depends upon the specific quadric rendered.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluNewQuadric), $(D_INLINECODE gluQuadricDrawStyle), $(D_INLINECODE gluQuadricNormals), $(D_INLINECODE gluQuadricOrientation)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluQuadricTexture gluQuadricTexture;
    alias fn_gluScaleImage = extern(System) GLint function(GLenum format, GLsizei wIn, GLsizei hIn, GLenum typeIn, const( void*) dataIn, GLsizei wOut, GLsizei hOut, GLenum typeOut, GLvoid* dataOut) @system @nogc nothrow;

    /++
     + gluScaleImage: man2/gluScaleImage.xml
     + 
     + $(D_INLINECODE gluScaleImage) scales a pixel image using the appropriate pixel store modes to unpack data from the source image and pack data into the destination image. When shrinking an image, $(D_INLINECODE gluScaleImage) uses a box filter to sample the source image and create pixels for the destination image.  When magnifying an image, the pixels from the source image are linearly interpolated to create the destination image. A return value of zero indicates success, otherwise a GLU error code is returned (see $(D_INLINECODE gluErrorString) ). See the $(D_INLINECODE glReadPixels) reference page for a description of the acceptable values for the $(D_INLINECODE format), $(D_INLINECODE typeIn), and $(D_INLINECODE typeOut) parameters.
     + 
     + Formats $(D_INLINECODE GLU_BGR), and $(D_INLINECODE GLU_BGRA), and types $(D_INLINECODE GLU_UNSIGNED_BYTE_3_3_2), $(D_INLINECODE GLU_UNSIGNED_BYTE_2_3_3_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_6_5), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_6_5_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_4_4_4_4), $(D_INLINECODE GLU_UNSIGNED_SHORT_4_4_4_4_REV), $(D_INLINECODE GLU_UNSIGNED_SHORT_5_5_5_1), $(D_INLINECODE GLU_UNSIGNED_SHORT_1_5_5_5_REV), $(D_INLINECODE GLU_UNSIGNED_INT_8_8_8_8), $(D_INLINECODE GLU_UNSIGNED_INT_8_8_8_8_REV), $(D_INLINECODE GLU_UNSIGNED_INT_10_10_10_2), and $(D_INLINECODE GLU_UNSIGNED_INT_2_10_10_10_REV) are only available if the GL version is 1.2 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluBuild1DMipmaps), $(D_INLINECODE gluBuild2DMipmaps), $(D_INLINECODE gluBuild3DMipmaps), $(D_INLINECODE gluErrorString), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glReadPixels)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluScaleImage gluScaleImage;
    alias fn_gluSphere = extern(System) void function(GLUquadric* quad, GLdouble radius, GLint slices, GLint stacks) @system @nogc nothrow;

    /++
     + gluSphere: man2/gluSphere.xml
     + 
     + $(D_INLINECODE gluSphere) draws a sphere of the given radius centered around the origin. The sphere is subdivided around the axis into slices and along the axis into stacks (similar to lines of longitude and latitude). If the orientation is set to $(D_INLINECODE GLU_OUTSIDE) (with $(D_INLINECODE gluQuadricOrientation) ), then any normals generated point away from the center of the sphere. Otherwise, they point toward the center of the sphere. If texturing is turned on (with $(D_INLINECODE gluQuadricTexture) ), then texture coordinates are generated so that ranges from 0.0 at z = - radius to 1.0 at z = radius ( increases linearly along longitudinal lines), and ranges from 0.0 at the + axis, to 0.25 at the + axis, to 0.5 at the \- axis, to 0.75 at the \- axis, and back to 1.0 at the + axis.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluCylinder), $(D_INLINECODE gluDisk), $(D_INLINECODE gluNewQuadric), $(D_INLINECODE gluPartialDisk), $(D_INLINECODE gluQuadricOrientation), $(D_INLINECODE gluQuadricTexture)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluSphere gluSphere;
    alias fn_gluTessBeginContour = extern(System) void function(GLUtesselator* tess) @system @nogc nothrow;

    /++
     + gluTessBeginContour: man2/gluTessBeginContour.xml
     + 
     + $(D_INLINECODE gluTessBeginContour) and $(D_INLINECODE gluTessEndContour) delimit the definition of a polygon contour. Within each $(D_INLINECODE gluTessBeginContour) / $(D_INLINECODE gluTessEndContour) pair, there can be zero or more calls to $(D_INLINECODE gluTessVertex). The vertices specify a closed contour (the last vertex of each contour is automatically linked to the first).  See the $(D_INLINECODE gluTessVertex) reference page for more details. $(D_INLINECODE gluTessBeginContour) can only be called between $(D_INLINECODE gluTessBeginPolygon) and $(D_INLINECODE gluTessEndPolygon).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluNewTess), $(D_INLINECODE gluTessBeginPolygon), $(D_INLINECODE gluTessCallback), $(D_INLINECODE gluTessEndPolygon), $(D_INLINECODE gluTessNormal), $(D_INLINECODE gluTessProperty), $(D_INLINECODE gluTessVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluTessBeginContour gluTessBeginContour;
    alias fn_gluTessEndContour = extern(System) void function(GLUtesselator* tess) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluTessEndContour gluTessEndContour;
    alias fn_gluTessBeginPolygon = extern(System) void function(GLUtesselator* tess, GLvoid* data) @system @nogc nothrow;

    /++
     + gluTessBeginPolygon: man2/gluTessBeginPolygon.xml
     + 
     + $(D_INLINECODE gluTessBeginPolygon) and $(D_INLINECODE gluTessEndPolygon) delimit the definition of a convex, concave or self-intersecting polygon. Within each $(D_INLINECODE gluTessBeginPolygon) / $(D_INLINECODE gluTessEndPolygon) pair, there must be one or more calls to $(D_INLINECODE gluTessBeginContour) / $(D_INLINECODE gluTessEndContour). Within each contour, there are zero or more calls to $(D_INLINECODE gluTessVertex). The vertices specify a closed contour (the last vertex of each contour is automatically linked to the first). See the $(D_INLINECODE gluTessVertex), $(D_INLINECODE gluTessBeginContour), and $(D_INLINECODE gluTessEndContour) reference pages for more details. $(D_INLINECODE data) is a pointer to a user-defined data structure. If the appropriate callback(s) are specified (see $(D_INLINECODE gluTessCallback) ), then this pointer is returned to the callback function(s). Thus, it is a convenient way to store per-polygon information. Once $(D_INLINECODE gluTessEndPolygon) is called, the polygon is tessellated, and the resulting triangles are described through callbacks. See $(D_INLINECODE gluTessCallback) for descriptions of the callback functions.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluNewTess), $(D_INLINECODE gluTessBeginContour), $(D_INLINECODE gluTessCallback), $(D_INLINECODE gluTessEndPolygon), $(D_INLINECODE gluTessNormal), $(D_INLINECODE gluTessProperty), $(D_INLINECODE gluTessVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluTessBeginPolygon gluTessBeginPolygon;
    alias fn_gluTessCallback = extern(System) void function(GLUtesselator* tess, GLenum which, _GLUfuncptr CallBackFunc) @system @nogc nothrow;

    /++
     + gluTessCallback: man2/gluTessCallback.xml
     + 
     + $(D_INLINECODE gluTessCallback) is used to indicate a callback to be used by a tessellation object. If the specified callback is already defined, then it is replaced. If $(D_INLINECODE CallBackFunc) is null, then the existing callback becomes undefined.
     +  These callbacks are used by the tessellation object to describe how a polygon specified by the user is broken into triangles. Note that there are two versions of each callback: one with user-specified polygon data and one without. If both versions of a particular callback are specified, then the callback with user-specified polygon data will be used. Note that the parameter used by some of the functions is a copy of the pointer that was specified when $(D_INLINECODE gluTessBeginPolygon) was called. The legal callbacks are as follows:
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluErrorString), $(D_INLINECODE gluNewTess), $(D_INLINECODE gluTessBeginContour), $(D_INLINECODE gluTessBeginPolygon), $(D_INLINECODE gluTessNormal), $(D_INLINECODE gluTessProperty), $(D_INLINECODE gluTessVertex), $(D_INLINECODE glBegin), $(D_INLINECODE glEdgeFlag), $(D_INLINECODE glVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluTessCallback gluTessCallback;
    alias fn_gluTessEndPolygon = extern(System) void function(GLUtesselator* tess) @system @nogc nothrow;

    /++
     + gluTessEndPolygon: man2/gluTessEndPolygon.xml
     + 
     + $(D_INLINECODE gluTessBeginPolygon) and $(D_INLINECODE gluTessEndPolygon) delimit the definition of a convex, concave, or self-intersecting polygon. Within each $(D_INLINECODE gluTessBeginPolygon) / $(D_INLINECODE gluTessEndPolygon) pair, there must be one or more calls to $(D_INLINECODE gluTessBeginContour) / $(D_INLINECODE gluTessEndContour). Within each contour, there are zero or more calls to $(D_INLINECODE gluTessVertex). The vertices specify a closed contour (the last vertex of each contour is automatically linked to the first). See the $(D_INLINECODE gluTessVertex), $(D_INLINECODE gluTessBeginContour), and $(D_INLINECODE gluTessEndContour) reference pages for more details. Once $(D_INLINECODE gluTessEndPolygon) is called, the polygon is tessellated, and the resulting triangles are described through callbacks. See $(D_INLINECODE gluTessCallback) for descriptions of the callback functions.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluNewTess), $(D_INLINECODE gluTessBeginContour), $(D_INLINECODE gluTessBeginPolygon), $(D_INLINECODE gluTessCallback), $(D_INLINECODE gluTessNormal), $(D_INLINECODE gluTessProperty), $(D_INLINECODE gluTessVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluTessEndPolygon gluTessEndPolygon;
    alias fn_gluTessNormal = extern(System) void function(GLUtesselator* tess, GLdouble valueX, GLdouble valueY, GLdouble valueZ) @system @nogc nothrow;

    /++
     + gluTessNormal: man2/gluTessNormal.xml
     + 
     + $(D_INLINECODE gluTessNormal) describes a normal for a polygon that the program is defining. All input data will be projected onto a plane perpendicular to one of the three coordinate axes before tessellation and all output triangles will be oriented CCW with respect to the normal (CW orientation can be obtained by reversing the sign of the supplied normal). For example, if you know that all polygons lie in the x-y plane, call $(D_INLINECODE gluTessNormal) (tess, 0.0, 0.0, 1.0) before rendering any polygons. If the supplied normal is (0.0, 0.0, 0.0) (the initial value), the normal is determined as follows. The direction of the normal, up to its sign, is found by fitting a plane to the vertices, without regard to how the vertices are connected. It is expected that the input data lies approximately in the plane; otherwise, projection perpendicular to one of the three coordinate axes may substantially change the geometry. The sign of the normal is chosen so that the sum of the signed areas of all input contours is nonnegative (where a CCW contour has positive area). The supplied normal persists until it is changed by another call to $(D_INLINECODE gluTessNormal).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluTessBeginPolygon), $(D_INLINECODE gluTessEndPolygon)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluTessNormal gluTessNormal;
    alias fn_gluTessProperty = extern(System) void function(GLUtesselator* tess, GLenum which, GLdouble data) @system @nogc nothrow;

    /++
     + gluTessProperty: man2/gluTessProperty.xml
     + 
     + $(D_INLINECODE gluTessProperty) is used to control properties stored in a tessellation object. These properties affect the way that the polygons are interpreted and rendered. The legal values for $(D_INLINECODE which) are as follows:
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluGetTessProperty), $(D_INLINECODE gluNewTess)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluTessProperty gluTessProperty;
    alias fn_gluTessVertex = extern(System) void function(GLUtesselator* tess, GLdouble* location, GLvoid* data) @system @nogc nothrow;

    /++
     + gluTessVertex: man2/gluTessVertex.xml
     + 
     + $(D_INLINECODE gluTessVertex) describes a vertex on a polygon that the program defines. Successive $(D_INLINECODE gluTessVertex) calls describe a closed contour. For example, to describe a quadrilateral, $(D_INLINECODE gluTessVertex) should be called four times. $(D_INLINECODE gluTessVertex) can only be called between $(D_INLINECODE gluTessBeginContour) and $(D_INLINECODE gluTessEndContour). $(D_INLINECODE data) normally points to a structure containing the vertex location, as well as other per-vertex attributes such as color and normal. This pointer is passed back to the user through the $(D_INLINECODE GLU_TESS_VERTEX) or $(D_INLINECODE GLU_TESS_VERTEX_DATA) callback after tessellation (see the $(D_INLINECODE gluTessCallback) reference page).
     + 
     + It is a common error to use a local variable for $(D_INLINECODE location) or $(D_INLINECODE data) and store values into it as part of a loop. For example:
     + 
     + ---
     + for (i = 0; i &lt; NVERTICES; ++i) {
     +    GLdouble data[3];
     +    data[0] = vertex[i][0];
     +    data[1] = vertex[i][1];
     +    data[2] = vertex[i][2];
     +    gluTessVertex(tobj, data, data);
     + }
     +         
     + ---
     +  This doesn't work. Because the pointers specified by $(D_INLINECODE location) and $(D_INLINECODE data) might not be dereferenced until $(D_INLINECODE gluTessEndPolygon) is executed, all the vertex coordinates but the very last set could be overwritten before tessellation begins. Two common symptoms of this problem are when the data consists of a single point (when a local variable is used for $(D_INLINECODE data) ) and a $(D_INLINECODE GLU_TESS_NEED_COMBINE_CALLBACK) error (when a local variable is used for $(D_INLINECODE location) ).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluNewTess), $(D_INLINECODE gluTessBeginContour), $(D_INLINECODE gluTessBeginPolygon), $(D_INLINECODE gluTessCallback), $(D_INLINECODE gluTessEndPolygon), $(D_INLINECODE gluTessNormal), $(D_INLINECODE gluTessProperty)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluTessVertex gluTessVertex;
    alias fn_gluUnProject = extern(System) GLint function(GLdouble winX, GLdouble winY, GLdouble winZ, const( GLdouble*) model, const( GLdouble*) proj, const( GLint*) view, GLdouble* objX, GLdouble* objY, GLdouble* objZ) @system @nogc nothrow;

    /++
     + gluUnProject: man2/gluUnProject.xml
     + 
     + $(D_INLINECODE gluUnProject) maps the specified window coordinates into object coordinates using $(D_INLINECODE model), $(D_INLINECODE proj), and $(D_INLINECODE view). The result is stored in $(D_INLINECODE objX), $(D_INLINECODE objY), and $(D_INLINECODE objZ). A return value of $(D_INLINECODE GLU_TRUE) indicates success; a return value of $(D_INLINECODE GLU_FALSE) indicates failure. To compute the coordinates objX objY objZ, $(D_INLINECODE gluUnProject) multiplies the normalized device coordinates by the inverse of $(D_INLINECODE model) * $(D_INLINECODE proj) as follows: objX objY objZ W = INV &af; P &it; M &it; 2 &af; winX - view &af; 0 view &af; 2 - 1 2 &af; winY - view &af; 1 view &af; 3 - 1 2 &af; winZ - 1 1 INV denotes matrix inversion. W is an unused variable, included for consistent matrix notation.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluProject), $(D_INLINECODE glGet)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluUnProject gluUnProject;
    alias fn_gluUnProject4 = extern(System) GLint function(GLdouble winX, GLdouble winY, GLdouble winZ, GLdouble clipW, const( GLdouble*) model, const( GLdouble*) proj, const( GLint*) view, GLdouble nearVal, GLdouble farVal, GLdouble* objX, GLdouble* objY, GLdouble* objZ, GLdouble* objW) @system @nogc nothrow;

    /++
     + gluUnProject4: man2/gluUnProject4.xml
     + 
     + $(D_INLINECODE gluUnProject4) maps the specified window coordinatesi: $(D_INLINECODE winX), $(D_INLINECODE winY), and $(D_INLINECODE winZ) and its clip w coordinate $(D_INLINECODE clipW) into object coordinates objX objY objZ objW using $(D_INLINECODE model), $(D_INLINECODE proj), and $(D_INLINECODE view). $(D_INLINECODE clipW) can be other than 1 as for vertices in $(D_INLINECODE glFeedbackBuffer) when data type $(D_INLINECODE GLU_4D_COLOR_TEXTURE) is returned. This also handles the case where the $(D_INLINECODE nearVal) and $(D_INLINECODE farVal) planes are different from the default, 0 and 1, respectively. A return value of $(D_INLINECODE GLU_TRUE) indicates success; a return value of $(D_INLINECODE GLU_FALSE) indicates failure. To compute the coordinates objX objY objZ objW, $(D_INLINECODE gluUnProject4) multiplies the normalized device coordinates by the inverse of $(D_INLINECODE model) * $(D_INLINECODE proj) as follows: objX objY objZ objW = INV &af; P &it; M &it; 2 &af; winX - view &af; 0 view &af; 2 - 1 2 &af; winY - view &af; 1 view &af; 3 - 1 2 &af; winZ - nearVal farVal - nearVal - 1 clipW INV denotes matrix inversion. $(D_INLINECODE gluUnProject4) is equivalent to $(D_INLINECODE gluUnProject) when $(D_INLINECODE clipW) is 1, $(D_INLINECODE nearVal) is 0, and $(D_INLINECODE farVal) is 1.
     + 
     + $(D_INLINECODE gluUnProject4) is available only if the GLU version is 1.3 or greater.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE gluProject), $(D_INLINECODE gluUnProject), $(D_INLINECODE glFeedbackBuffer), $(D_INLINECODE glGet)
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_gluUnProject4 gluUnProject4;
    alias fn_glVertex2s = extern(System) void function(GLshort x, GLshort y) @system @nogc nothrow;

    /++
     + glVertex: man2/glVertex.xml
     + 
     + $(D_INLINECODE glVertex) commands are used within $(D_INLINECODE glBegin) / $(D_INLINECODE glEnd) pairs to specify point, line, and polygon vertices.  The current color, normal, texture coordinates, and fog coordinate are associated with the vertex when $(D_INLINECODE glVertex) is called. When only x and y are specified, z defaults to 0 and w defaults to 1.  When x, y, and z are specified, w defaults to 1.
     + 
     + Invoking $(D_INLINECODE glVertex) outside of a $(D_INLINECODE glBegin) / $(D_INLINECODE glEnd) pair results in undefined behavior.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBegin), $(D_INLINECODE glCallList), $(D_INLINECODE glColor), $(D_INLINECODE glEdgeFlag), $(D_INLINECODE glEvalCoord), $(D_INLINECODE glFogCoord), $(D_INLINECODE glIndex), $(D_INLINECODE glMaterial), $(D_INLINECODE glMultiTexCoord), $(D_INLINECODE glNormal), $(D_INLINECODE glRect), $(D_INLINECODE glTexCoord), $(D_INLINECODE glVertexPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glVertex2s glVertex2s;
    alias fn_glVertex2i = extern(System) void function(GLint x, GLint y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glVertex2i glVertex2i;
    alias fn_glVertex2f = extern(System) void function(GLfloat x, GLfloat y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glVertex2f glVertex2f;
    alias fn_glVertex2d = extern(System) void function(GLdouble x, GLdouble y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glVertex2d glVertex2d;
    alias fn_glVertex3s = extern(System) void function(GLshort x, GLshort y, GLshort z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glVertex3s glVertex3s;
    alias fn_glVertex3i = extern(System) void function(GLint x, GLint y, GLint z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glVertex3i glVertex3i;
    alias fn_glVertex3f = extern(System) void function(GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glVertex3f glVertex3f;
    alias fn_glVertex3d = extern(System) void function(GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glVertex3d glVertex3d;
    alias fn_glVertex4s = extern(System) void function(GLshort x, GLshort y, GLshort z, GLshort w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glVertex4s glVertex4s;
    alias fn_glVertex4i = extern(System) void function(GLint x, GLint y, GLint z, GLint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glVertex4i glVertex4i;
    alias fn_glVertex4f = extern(System) void function(GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glVertex4f glVertex4f;
    alias fn_glVertex4d = extern(System) void function(GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glVertex4d glVertex4d;
    alias fn_glVertex2sv = extern(System) void function(const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glVertex2sv glVertex2sv;
    alias fn_glVertex2iv = extern(System) void function(const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glVertex2iv glVertex2iv;
    alias fn_glVertex2fv = extern(System) void function(const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glVertex2fv glVertex2fv;
    alias fn_glVertex2dv = extern(System) void function(const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glVertex2dv glVertex2dv;
    alias fn_glVertex3sv = extern(System) void function(const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glVertex3sv glVertex3sv;
    alias fn_glVertex3iv = extern(System) void function(const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glVertex3iv glVertex3iv;
    alias fn_glVertex3fv = extern(System) void function(const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glVertex3fv glVertex3fv;
    alias fn_glVertex3dv = extern(System) void function(const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glVertex3dv glVertex3dv;
    alias fn_glVertex4sv = extern(System) void function(const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glVertex4sv glVertex4sv;
    alias fn_glVertex4iv = extern(System) void function(const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glVertex4iv glVertex4iv;
    alias fn_glVertex4fv = extern(System) void function(const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glVertex4fv glVertex4fv;
    alias fn_glVertex4dv = extern(System) void function(const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glVertex4dv glVertex4dv;
    alias fn_glVertexPointer = extern(System) void function(GLint size, GLenum type, GLsizei stride, const( GLvoid*) pointer) @system @nogc nothrow;

    /++
     + glVertexPointer: man2/glVertexPointer.xml
     + 
     + $(D_INLINECODE glVertexPointer) specifies the location and data format of an array of vertex coordinates to use when rendering. $(D_INLINECODE size) specifies the number of coordinates per vertex, and must be 2, 3, or 4. $(D_INLINECODE type) specifies the data type of each coordinate, and $(D_INLINECODE stride) specifies the byte stride from one vertex to the next, allowing vertices and attributes to be packed into a single array or stored in separate arrays. (Single-array storage may be more efficient on some implementations; see $(D_INLINECODE glInterleavedArrays).) If a non-zero named buffer object is bound to the $(D_INLINECODE GL_ARRAY_BUFFER) target (see $(D_INLINECODE glBindBuffer) ) while a vertex array is specified, $(D_INLINECODE pointer) is treated as a byte offset into the buffer object's data store. Also, the buffer object binding ( $(D_INLINECODE GL_ARRAY_BUFFER_BINDING) ) is saved as vertex array client-side state ( $(D_INLINECODE GL_VERTEX_ARRAY_BUFFER_BINDING) ). When a vertex array is specified, $(D_INLINECODE size), $(D_INLINECODE type), $(D_INLINECODE stride), and $(D_INLINECODE pointer) are saved as client-side state, in addition to the current vertex array buffer object binding. To enable and disable the vertex array, call $(D_INLINECODE glEnableClientState) and $(D_INLINECODE glDisableClientState) with the argument $(D_INLINECODE GL_VERTEX_ARRAY). If enabled, the vertex array is used when $(D_INLINECODE glArrayElement), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glMultiDrawElements), or $(D_INLINECODE glDrawRangeElements) is called.
     + 
     + $(D_INLINECODE glVertexPointer) is available only if the GL version is 1.1 or greater. The vertex array is initially disabled and isn't accessed when $(D_INLINECODE glArrayElement), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glMultiDrawArrays), or $(D_INLINECODE glMultiDrawElements) is called. Execution of $(D_INLINECODE glVertexPointer) is not allowed between the execution of $(D_INLINECODE glBegin) and the corresponding execution of $(D_INLINECODE glEnd), but an error may or may not be generated. If no error is generated, the operation is undefined. $(D_INLINECODE glVertexPointer) is typically implemented on the client side. Vertex array parameters are client-side state and are therefore not saved or restored by $(D_INLINECODE glPushAttrib) and $(D_INLINECODE glPopAttrib). Use $(D_INLINECODE glPushClientAttrib) and $(D_INLINECODE glPopClientAttrib) instead.
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glArrayElement), $(D_INLINECODE glBindBuffer), $(D_INLINECODE glColorPointer), $(D_INLINECODE glDisableClientState), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glEdgeFlagPointer), $(D_INLINECODE glEnableClientState), $(D_INLINECODE glFogCoordPointer), $(D_INLINECODE glIndexPointer), $(D_INLINECODE glInterleavedArrays), $(D_INLINECODE glMultiDrawArrays), $(D_INLINECODE glMultiDrawElements), $(D_INLINECODE glNormalPointer), $(D_INLINECODE glPopClientAttrib), $(D_INLINECODE glPushClientAttrib), $(D_INLINECODE glSecondaryColorPointer), $(D_INLINECODE glTexCoordPointer), $(D_INLINECODE glVertex), $(D_INLINECODE glVertexAttribPointer)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P1)
    fn_glVertexPointer glVertexPointer;
    alias fn_glWindowPos2s = extern(System) void function(GLshort x, GLshort y) @system @nogc nothrow;

    /++
     + glWindowPos: man2/glWindowPos.xml
     + 
     + The GL maintains a 3D position in window coordinates.  This position, called the raster position, is used to position pixel and bitmap write operations. It is maintained with subpixel accuracy.  See $(D_INLINECODE glBitmap), $(D_INLINECODE glDrawPixels), and $(D_INLINECODE glCopyPixels). $(D_INLINECODE glWindowPos2) specifies the x and y coordinates, while z is implicitly set to 0. $(D_INLINECODE glWindowPos3) specifies all three coordinates. The w coordinate of the current raster position is always set to 1.0. $(D_INLINECODE glWindowPos) directly updates the x and y coordinates of the current raster position with the values specified.  That is, the values are neither transformed by the current modelview and projection matrices, nor by the viewport-to-window transform.  The z coordinate of the current raster position is updated in the following manner: z = n f n + z &times; f - n &it; if &it; z &lt;= 0 if &it; z &gt;= 1 otherwise where n is $(D_INLINECODE GL_DEPTH_RANGE) 's near value, and f is $(D_INLINECODE GL_DEPTH_RANGE) 's far value.  See $(D_INLINECODE glDepthRange). The specified coordinates are not clip-tested, causing the raster position to always be valid. The current raster position also includes some associated color data and texture coordinates.  If lighting is enabled, then $(D_INLINECODE GL_CURRENT_RASTER_COLOR) (in RGBA mode) or $(D_INLINECODE GL_CURRENT_RASTER_INDEX) (in color index mode) is set to the color produced by the lighting calculation (see $(D_INLINECODE glLight), $(D_INLINECODE glLightModel), and $(D_INLINECODE glShadeModel) ). If lighting is disabled, current color (in RGBA mode, state variable $(D_INLINECODE GL_CURRENT_COLOR) ) or color index (in color index mode, state variable $(D_INLINECODE GL_CURRENT_INDEX) ) is used to update the current raster color. $(D_INLINECODE GL_CURRENT_RASTER_SECONDARY_COLOR) (in RGBA mode) is likewise updated. Likewise, $(D_INLINECODE GL_CURRENT_RASTER_TEXTURE_COORDS) is updated as a function of $(D_INLINECODE GL_CURRENT_TEXTURE_COORDS), based on the texture matrix and the texture generation functions (see $(D_INLINECODE glTexGen) ).  The $(D_INLINECODE GL_CURRENT_RASTER_DISTANCE) is set to the $(D_INLINECODE GL_CURRENT_FOG_COORD).
     + 
     + $(D_INLINECODE glWindowPos) is available only if the GL version is 1.4 or greater. The raster position is modified by $(D_INLINECODE glRasterPos), $(D_INLINECODE glBitmap), and $(D_INLINECODE glWindowPos). Calling $(D_INLINECODE glDrawElements), or $(D_INLINECODE glDrawRangeElements) may leave the current color or index indeterminate. If $(D_INLINECODE glWindowPos) is executed while the current color or index is indeterminate, the current raster color or current raster index remains indeterminate. There are distinct raster texture coordinates for each texture unit. Each texture unit's current raster texture coordinates are updated by $(D_INLINECODE glWindowPos).
     + 
     + Params:
     + 
     + Copyright:
     +     Copyright 1991-2006 Silicon Graphics, Inc. This document is licensed under the SGI Free Software B License. For details, see $(LINK2 http://oss.sgi.com/projects/FreeB/, http://oss.sgi.com/projects/FreeB/).
     + 
     + See_Also:
     +     $(D_INLINECODE glBitmap), $(D_INLINECODE glCopyPixels), $(D_INLINECODE glDrawArrays), $(D_INLINECODE glDrawElements), $(D_INLINECODE glDrawRangeElements), $(D_INLINECODE glDrawPixels), $(D_INLINECODE glMultiTexCoord), $(D_INLINECODE glRasterPos), $(D_INLINECODE glTexCoord), $(D_INLINECODE glTexGen), $(D_INLINECODE glVertex)
     +/
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glWindowPos2s glWindowPos2s;
    alias fn_glWindowPos2i = extern(System) void function(GLint x, GLint y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glWindowPos2i glWindowPos2i;
    alias fn_glWindowPos2f = extern(System) void function(GLfloat x, GLfloat y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glWindowPos2f glWindowPos2f;
    alias fn_glWindowPos2d = extern(System) void function(GLdouble x, GLdouble y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glWindowPos2d glWindowPos2d;
    alias fn_glWindowPos3s = extern(System) void function(GLshort x, GLshort y, GLshort z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glWindowPos3s glWindowPos3s;
    alias fn_glWindowPos3i = extern(System) void function(GLint x, GLint y, GLint z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glWindowPos3i glWindowPos3i;
    alias fn_glWindowPos3f = extern(System) void function(GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glWindowPos3f glWindowPos3f;
    alias fn_glWindowPos3d = extern(System) void function(GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glWindowPos3d glWindowPos3d;
    alias fn_glWindowPos2sv = extern(System) void function(const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glWindowPos2sv glWindowPos2sv;
    alias fn_glWindowPos2iv = extern(System) void function(const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glWindowPos2iv glWindowPos2iv;
    alias fn_glWindowPos2fv = extern(System) void function(const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glWindowPos2fv glWindowPos2fv;
    alias fn_glWindowPos2dv = extern(System) void function(const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glWindowPos2dv glWindowPos2dv;
    alias fn_glWindowPos3sv = extern(System) void function(const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glWindowPos3sv glWindowPos3sv;
    alias fn_glWindowPos3iv = extern(System) void function(const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glWindowPos3iv glWindowPos3iv;
    alias fn_glWindowPos3fv = extern(System) void function(const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glWindowPos3fv glWindowPos3fv;
    alias fn_glWindowPos3dv = extern(System) void function(const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glWindowPos3dv glWindowPos3dv;
    alias fn_glAccumxOES = extern(System) void function(GLenum op, GLfixed value) @system @nogc nothrow;

    /++
     + : 
     + 
     + 
     + Params:
     + 
     + Copyright:
     +     
     + 
     + See_Also:
     +     
     +/
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glAccumxOES glAccumxOES;
    alias fn_glActiveProgramEXT = extern(System) void function(GLuint program) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    fn_glActiveProgramEXT glActiveProgramEXT;
    alias fn_glActiveShaderProgramEXT = extern(System) void function(GLuint pipeline, GLuint program) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    fn_glActiveShaderProgramEXT glActiveShaderProgramEXT;
    alias fn_glActiveStencilFaceEXT = extern(System) void function(GLenum face) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_stencil_two_side")
    fn_glActiveStencilFaceEXT glActiveStencilFaceEXT;
    alias fn_glActiveTextureARB = extern(System) void function(GLenum texture) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    fn_glActiveTextureARB glActiveTextureARB;
    alias fn_glActiveVaryingNV = extern(System) void function(GLuint program, const( GLchar*) name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback")
    fn_glActiveVaryingNV glActiveVaryingNV;
    alias fn_glAlphaFragmentOp1ATI = extern(System) void function(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    fn_glAlphaFragmentOp1ATI glAlphaFragmentOp1ATI;
    alias fn_glAlphaFragmentOp2ATI = extern(System) void function(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    fn_glAlphaFragmentOp2ATI glAlphaFragmentOp2ATI;
    alias fn_glAlphaFragmentOp3ATI = extern(System) void function(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    fn_glAlphaFragmentOp3ATI glAlphaFragmentOp3ATI;
    alias fn_glAlphaFuncQCOM = extern(System) void function(GLenum func, GLclampf ref_) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_alpha_test")
    fn_glAlphaFuncQCOM glAlphaFuncQCOM;
    alias fn_glAlphaFuncx = extern(System) void function(GLenum func, GLfixed ref_) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glAlphaFuncx glAlphaFuncx;
    alias fn_glAlphaFuncxOES = extern(System) void function(GLenum func, GLfixed ref_) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glAlphaFuncxOES glAlphaFuncxOES;
    alias fn_glApplyFramebufferAttachmentCMAAINTEL = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_framebuffer_CMAA")
    fn_glApplyFramebufferAttachmentCMAAINTEL glApplyFramebufferAttachmentCMAAINTEL;
    alias fn_glApplyTextureEXT = extern(System) void function(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_light_texture")
    fn_glApplyTextureEXT glApplyTextureEXT;
    alias fn_glAreProgramsResidentNV = extern(System) GLboolean function(GLsizei n, const( GLuint*) programs, GLboolean* residences) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glAreProgramsResidentNV glAreProgramsResidentNV;
    alias fn_glAreTexturesResidentEXT = extern(System) GLboolean function(GLsizei n, const( GLuint*) textures, GLboolean* residences) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_object")
    fn_glAreTexturesResidentEXT glAreTexturesResidentEXT;
    alias fn_glArrayElementEXT = extern(System) void function(GLint i) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_array")
    fn_glArrayElementEXT glArrayElementEXT;
    alias fn_glArrayObjectATI = extern(System) void function(GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_array_object")
    fn_glArrayObjectATI glArrayObjectATI;
    alias fn_glAsyncMarkerSGIX = extern(System) void function(GLuint marker) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_async")
    fn_glAsyncMarkerSGIX glAsyncMarkerSGIX;
    alias fn_glAttachObjectARB = extern(System) void function(GLhandleARB containerObj, GLhandleARB obj) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glAttachObjectARB glAttachObjectARB;
    alias fn_glBeginConditionalRenderNV = extern(System) void function(GLuint id, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_conditional_render")
    fn_glBeginConditionalRenderNV glBeginConditionalRenderNV;
    alias fn_glBeginConditionalRenderNVX = extern(System) void function(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NVX_conditional_render")
    fn_glBeginConditionalRenderNVX glBeginConditionalRenderNVX;
    alias fn_glBeginFragmentShaderATI = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    fn_glBeginFragmentShaderATI glBeginFragmentShaderATI;
    alias fn_glBeginOcclusionQueryNV = extern(System) void function(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_occlusion_query")
    fn_glBeginOcclusionQueryNV glBeginOcclusionQueryNV;
    alias fn_glBeginPerfMonitorAMD = extern(System) void function(GLuint monitor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_performance_monitor")
    fn_glBeginPerfMonitorAMD glBeginPerfMonitorAMD;
    alias fn_glBeginPerfQueryINTEL = extern(System) void function(GLuint queryHandle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_performance_query")
    fn_glBeginPerfQueryINTEL glBeginPerfQueryINTEL;
    alias fn_glBeginQueryARB = extern(System) void function(GLenum target, GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_occlusion_query")
    fn_glBeginQueryARB glBeginQueryARB;
    alias fn_glBeginQueryEXT = extern(System) void function(GLenum target, GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_disjoint_timer_query")
    fn_glBeginQueryEXT glBeginQueryEXT;
    alias fn_glBeginTransformFeedbackEXT = extern(System) void function(GLenum primitiveMode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_transform_feedback")
    fn_glBeginTransformFeedbackEXT glBeginTransformFeedbackEXT;
    alias fn_glBeginTransformFeedbackNV = extern(System) void function(GLenum primitiveMode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback")
    fn_glBeginTransformFeedbackNV glBeginTransformFeedbackNV;
    alias fn_glBeginVertexShaderEXT = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glBeginVertexShaderEXT glBeginVertexShaderEXT;
    alias fn_glBeginVideoCaptureNV = extern(System) void function(GLuint video_capture_slot) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_video_capture")
    fn_glBeginVideoCaptureNV glBeginVideoCaptureNV;
    alias fn_glBindAttribLocationARB = extern(System) void function(GLhandleARB programObj, GLuint index, const( GLcharARB*) name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_shader")
    fn_glBindAttribLocationARB glBindAttribLocationARB;
    alias fn_glBindBufferARB = extern(System) void function(GLenum target, GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_buffer_object")
    fn_glBindBufferARB glBindBufferARB;
    alias fn_glBindBufferBaseEXT = extern(System) void function(GLenum target, GLuint index, GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_transform_feedback")
    fn_glBindBufferBaseEXT glBindBufferBaseEXT;
    alias fn_glBindBufferBaseNV = extern(System) void function(GLenum target, GLuint index, GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback")
    fn_glBindBufferBaseNV glBindBufferBaseNV;
    alias fn_glBindBufferOffsetEXT = extern(System) void function(GLenum target, GLuint index, GLuint buffer, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_transform_feedback")
    fn_glBindBufferOffsetEXT glBindBufferOffsetEXT;
    alias fn_glBindBufferOffsetNV = extern(System) void function(GLenum target, GLuint index, GLuint buffer, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback")
    fn_glBindBufferOffsetNV glBindBufferOffsetNV;
    alias fn_glBindBufferRangeEXT = extern(System) void function(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_transform_feedback")
    fn_glBindBufferRangeEXT glBindBufferRangeEXT;
    alias fn_glBindBufferRangeNV = extern(System) void function(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback")
    fn_glBindBufferRangeNV glBindBufferRangeNV;
    alias fn_glBindFragDataLocationEXT = extern(System) void function(GLuint program, GLuint color, const( GLchar*) name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_blend_func_extended")
    fn_glBindFragDataLocationEXT glBindFragDataLocationEXT;
    alias fn_glBindFragDataLocationIndexedEXT = extern(System) void function(GLuint program, GLuint colorNumber, GLuint index, const( GLchar*) name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_blend_func_extended")
    fn_glBindFragDataLocationIndexedEXT glBindFragDataLocationIndexedEXT;
    alias fn_glBindFragmentShaderATI = extern(System) void function(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    fn_glBindFragmentShaderATI glBindFragmentShaderATI;
    alias fn_glBindFramebufferEXT = extern(System) void function(GLenum target, GLuint framebuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    fn_glBindFramebufferEXT glBindFramebufferEXT;
    alias fn_glBindFramebufferOES = extern(System) void function(GLenum target, GLuint framebuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    fn_glBindFramebufferOES glBindFramebufferOES;
    alias fn_glBindImageTextureEXT = extern(System) void function(GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_shader_image_load_store")
    fn_glBindImageTextureEXT glBindImageTextureEXT;
    alias fn_glBindLightParameterEXT = extern(System) GLuint function(GLenum light, GLenum value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glBindLightParameterEXT glBindLightParameterEXT;
    alias fn_glBindMaterialParameterEXT = extern(System) GLuint function(GLenum face, GLenum value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glBindMaterialParameterEXT glBindMaterialParameterEXT;
    alias fn_glBindMultiTextureEXT = extern(System) void function(GLenum texunit, GLenum target, GLuint texture) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glBindMultiTextureEXT glBindMultiTextureEXT;
    alias fn_glBindParameterEXT = extern(System) GLuint function(GLenum value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glBindParameterEXT glBindParameterEXT;
    alias fn_glBindProgramARB = extern(System) void function(GLenum target, GLuint program) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    fn_glBindProgramARB glBindProgramARB;
    alias fn_glBindProgramNV = extern(System) void function(GLenum target, GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glBindProgramNV glBindProgramNV;
    alias fn_glBindProgramPipelineEXT = extern(System) void function(GLuint pipeline) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    fn_glBindProgramPipelineEXT glBindProgramPipelineEXT;
    alias fn_glBindRenderbufferEXT = extern(System) void function(GLenum target, GLuint renderbuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    fn_glBindRenderbufferEXT glBindRenderbufferEXT;
    alias fn_glBindRenderbufferOES = extern(System) void function(GLenum target, GLuint renderbuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    fn_glBindRenderbufferOES glBindRenderbufferOES;
    alias fn_glBindTexGenParameterEXT = extern(System) GLuint function(GLenum unit, GLenum coord, GLenum value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glBindTexGenParameterEXT glBindTexGenParameterEXT;
    alias fn_glBindTextureEXT = extern(System) void function(GLenum target, GLuint texture) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_object")
    fn_glBindTextureEXT glBindTextureEXT;
    alias fn_glBindTextureUnitParameterEXT = extern(System) GLuint function(GLenum unit, GLenum value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glBindTextureUnitParameterEXT glBindTextureUnitParameterEXT;
    alias fn_glBindTransformFeedbackNV = extern(System) void function(GLenum target, GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback2")
    fn_glBindTransformFeedbackNV glBindTransformFeedbackNV;
    alias fn_glBindVertexArrayAPPLE = extern(System) void function(GLuint array) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_array_object")
    fn_glBindVertexArrayAPPLE glBindVertexArrayAPPLE;
    alias fn_glBindVertexArrayOES = extern(System) void function(GLuint array) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_vertex_array_object")
    fn_glBindVertexArrayOES glBindVertexArrayOES;
    alias fn_glBindVertexShaderEXT = extern(System) void function(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glBindVertexShaderEXT glBindVertexShaderEXT;
    alias fn_glBindVideoCaptureStreamBufferNV = extern(System) void function(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_video_capture")
    fn_glBindVideoCaptureStreamBufferNV glBindVideoCaptureStreamBufferNV;
    alias fn_glBindVideoCaptureStreamTextureNV = extern(System) void function(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_video_capture")
    fn_glBindVideoCaptureStreamTextureNV glBindVideoCaptureStreamTextureNV;
    alias fn_glBinormal3bEXT = extern(System) void function(GLbyte bx, GLbyte by, GLbyte bz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    fn_glBinormal3bEXT glBinormal3bEXT;
    alias fn_glBinormal3bvEXT = extern(System) void function(const( GLbyte*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    fn_glBinormal3bvEXT glBinormal3bvEXT;
    alias fn_glBinormal3dEXT = extern(System) void function(GLdouble bx, GLdouble by, GLdouble bz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    fn_glBinormal3dEXT glBinormal3dEXT;
    alias fn_glBinormal3dvEXT = extern(System) void function(const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    fn_glBinormal3dvEXT glBinormal3dvEXT;
    alias fn_glBinormal3fEXT = extern(System) void function(GLfloat bx, GLfloat by, GLfloat bz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    fn_glBinormal3fEXT glBinormal3fEXT;
    alias fn_glBinormal3fvEXT = extern(System) void function(const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    fn_glBinormal3fvEXT glBinormal3fvEXT;
    alias fn_glBinormal3iEXT = extern(System) void function(GLint bx, GLint by, GLint bz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    fn_glBinormal3iEXT glBinormal3iEXT;
    alias fn_glBinormal3ivEXT = extern(System) void function(const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    fn_glBinormal3ivEXT glBinormal3ivEXT;
    alias fn_glBinormal3sEXT = extern(System) void function(GLshort bx, GLshort by, GLshort bz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    fn_glBinormal3sEXT glBinormal3sEXT;
    alias fn_glBinormal3svEXT = extern(System) void function(const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    fn_glBinormal3svEXT glBinormal3svEXT;
    alias fn_glBinormalPointerEXT = extern(System) void function(GLenum type, GLsizei stride, const( void*) pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    fn_glBinormalPointerEXT glBinormalPointerEXT;
    alias fn_glBitmapxOES = extern(System) void function(GLsizei width, GLsizei height, GLfixed xorig, GLfixed yorig, GLfixed xmove, GLfixed ymove, const(GLubyte)* bitmap) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glBitmapxOES glBitmapxOES;
    alias fn_glBlendBarrier = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glBlendBarrier glBlendBarrier;
    alias fn_glBlendBarrierKHR = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_blend_equation_advanced")
    fn_glBlendBarrierKHR glBlendBarrierKHR;
    alias fn_glBlendBarrierNV = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_blend_equation_advanced")
    fn_glBlendBarrierNV glBlendBarrierNV;
    alias fn_glBlendColorEXT = extern(System) void function(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_blend_color")
    fn_glBlendColorEXT glBlendColorEXT;
    alias fn_glBlendColorxOES = extern(System) void function(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glBlendColorxOES glBlendColorxOES;
    alias fn_glBlendEquationEXT = extern(System) void function(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_blend_minmax")
    fn_glBlendEquationEXT glBlendEquationEXT;
    alias fn_glBlendEquationIndexedAMD = extern(System) void function(GLuint buf, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_draw_buffers_blend")
    fn_glBlendEquationIndexedAMD glBlendEquationIndexedAMD;
    alias fn_glBlendEquationOES = extern(System) void function(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_blend_subtract")
    fn_glBlendEquationOES glBlendEquationOES;
    alias fn_glBlendEquationSeparateEXT = extern(System) void function(GLenum modeRGB, GLenum modeAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_blend_equation_separate")
    fn_glBlendEquationSeparateEXT glBlendEquationSeparateEXT;
    alias fn_glBlendEquationSeparateIndexedAMD = extern(System) void function(GLuint buf, GLenum modeRGB, GLenum modeAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_draw_buffers_blend")
    fn_glBlendEquationSeparateIndexedAMD glBlendEquationSeparateIndexedAMD;
    alias fn_glBlendEquationSeparateOES = extern(System) void function(GLenum modeRGB, GLenum modeAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_blend_equation_separate")
    fn_glBlendEquationSeparateOES glBlendEquationSeparateOES;
    alias fn_glBlendEquationSeparateiARB = extern(System) void function(GLuint buf, GLenum modeRGB, GLenum modeAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_draw_buffers_blend")
    fn_glBlendEquationSeparateiARB glBlendEquationSeparateiARB;
    alias fn_glBlendEquationSeparateiEXT = extern(System) void function(GLuint buf, GLenum modeRGB, GLenum modeAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_buffers_indexed")
    fn_glBlendEquationSeparateiEXT glBlendEquationSeparateiEXT;
    alias fn_glBlendEquationSeparateiOES = extern(System) void function(GLuint buf, GLenum modeRGB, GLenum modeAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_buffers_indexed")
    fn_glBlendEquationSeparateiOES glBlendEquationSeparateiOES;
    alias fn_glBlendEquationiARB = extern(System) void function(GLuint buf, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_draw_buffers_blend")
    fn_glBlendEquationiARB glBlendEquationiARB;
    alias fn_glBlendEquationiEXT = extern(System) void function(GLuint buf, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_buffers_indexed")
    fn_glBlendEquationiEXT glBlendEquationiEXT;
    alias fn_glBlendEquationiOES = extern(System) void function(GLuint buf, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_buffers_indexed")
    fn_glBlendEquationiOES glBlendEquationiOES;
    alias fn_glBlendFuncIndexedAMD = extern(System) void function(GLuint buf, GLenum src, GLenum dst) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_draw_buffers_blend")
    fn_glBlendFuncIndexedAMD glBlendFuncIndexedAMD;
    alias fn_glBlendFuncSeparateEXT = extern(System) void function(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_blend_func_separate")
    fn_glBlendFuncSeparateEXT glBlendFuncSeparateEXT;
    alias fn_glBlendFuncSeparateINGR = extern(System) void function(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INGR_blend_func_separate")
    fn_glBlendFuncSeparateINGR glBlendFuncSeparateINGR;
    alias fn_glBlendFuncSeparateIndexedAMD = extern(System) void function(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_draw_buffers_blend")
    fn_glBlendFuncSeparateIndexedAMD glBlendFuncSeparateIndexedAMD;
    alias fn_glBlendFuncSeparateOES = extern(System) void function(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_blend_func_separate")
    fn_glBlendFuncSeparateOES glBlendFuncSeparateOES;
    alias fn_glBlendFuncSeparateiARB = extern(System) void function(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_draw_buffers_blend")
    fn_glBlendFuncSeparateiARB glBlendFuncSeparateiARB;
    alias fn_glBlendFuncSeparateiEXT = extern(System) void function(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_buffers_indexed")
    fn_glBlendFuncSeparateiEXT glBlendFuncSeparateiEXT;
    alias fn_glBlendFuncSeparateiOES = extern(System) void function(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_buffers_indexed")
    fn_glBlendFuncSeparateiOES glBlendFuncSeparateiOES;
    alias fn_glBlendFunciARB = extern(System) void function(GLuint buf, GLenum src, GLenum dst) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_draw_buffers_blend")
    fn_glBlendFunciARB glBlendFunciARB;
    alias fn_glBlendFunciEXT = extern(System) void function(GLuint buf, GLenum src, GLenum dst) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_buffers_indexed")
    fn_glBlendFunciEXT glBlendFunciEXT;
    alias fn_glBlendFunciOES = extern(System) void function(GLuint buf, GLenum src, GLenum dst) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_buffers_indexed")
    fn_glBlendFunciOES glBlendFunciOES;
    alias fn_glBlendParameteriNV = extern(System) void function(GLenum pname, GLint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_blend_equation_advanced")
    fn_glBlendParameteriNV glBlendParameteriNV;
    alias fn_glBlitFramebufferANGLE = extern(System) void function(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ANGLE_framebuffer_blit")
    fn_glBlitFramebufferANGLE glBlitFramebufferANGLE;
    alias fn_glBlitFramebufferEXT = extern(System) void function(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_blit")
    fn_glBlitFramebufferEXT glBlitFramebufferEXT;
    alias fn_glBlitFramebufferNV = extern(System) void function(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_framebuffer_blit")
    fn_glBlitFramebufferNV glBlitFramebufferNV;
    alias fn_glBufferAddressRangeNV = extern(System) void function(GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_buffer_unified_memory")
    fn_glBufferAddressRangeNV glBufferAddressRangeNV;
    alias fn_glBufferDataARB = extern(System) void function(GLenum target, GLsizeiptrARB size, const( void*) data, GLenum usage) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_buffer_object")
    fn_glBufferDataARB glBufferDataARB;
    alias fn_glBufferPageCommitmentARB = extern(System) void function(GLenum target, GLintptr offset, GLsizeiptr size, GLboolean commit) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_sparse_buffer")
    fn_glBufferPageCommitmentARB glBufferPageCommitmentARB;
    alias fn_glBufferParameteriAPPLE = extern(System) void function(GLenum target, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_flush_buffer_range")
    fn_glBufferParameteriAPPLE glBufferParameteriAPPLE;
    alias fn_glBufferStorageEXT = extern(System) void function(GLenum target, GLsizeiptr size, const( void*) data, GLbitfield flags) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_buffer_storage")
    fn_glBufferStorageEXT glBufferStorageEXT;
    alias fn_glBufferSubDataARB = extern(System) void function(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const( void*) data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_buffer_object")
    fn_glBufferSubDataARB glBufferSubDataARB;
    alias fn_glCallCommandListNV = extern(System) void function(GLuint list) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    fn_glCallCommandListNV glCallCommandListNV;
    alias fn_glCheckFramebufferStatusEXT = extern(System) GLenum function(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    fn_glCheckFramebufferStatusEXT glCheckFramebufferStatusEXT;
    alias fn_glCheckFramebufferStatusOES = extern(System) GLenum function(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    fn_glCheckFramebufferStatusOES glCheckFramebufferStatusOES;
    alias fn_glCheckNamedFramebufferStatusEXT = extern(System) GLenum function(GLuint framebuffer, GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glCheckNamedFramebufferStatusEXT glCheckNamedFramebufferStatusEXT;
    alias fn_glClampColorARB = extern(System) void function(GLenum target, GLenum clamp) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_color_buffer_float")
    fn_glClampColorARB glClampColorARB;
    alias fn_glClearAccumxOES = extern(System) void function(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glClearAccumxOES glClearAccumxOES;
    alias fn_glClearColorIiEXT = extern(System) void function(GLint red, GLint green, GLint blue, GLint alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_integer")
    fn_glClearColorIiEXT glClearColorIiEXT;
    alias fn_glClearColorIuiEXT = extern(System) void function(GLuint red, GLuint green, GLuint blue, GLuint alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_integer")
    fn_glClearColorIuiEXT glClearColorIuiEXT;
    alias fn_glClearColorx = extern(System) void function(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glClearColorx glClearColorx;
    alias fn_glClearColorxOES = extern(System) void function(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glClearColorxOES glClearColorxOES;
    alias fn_glClearDepthdNV = extern(System) void function(GLdouble depth) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_depth_buffer_float")
    fn_glClearDepthdNV glClearDepthdNV;
    alias fn_glClearDepthfOES = extern(System) void function(GLclampf depth) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_single_precision")
    fn_glClearDepthfOES glClearDepthfOES;
    alias fn_glClearDepthx = extern(System) void function(GLfixed depth) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glClearDepthx glClearDepthx;
    alias fn_glClearDepthxOES = extern(System) void function(GLfixed depth) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glClearDepthxOES glClearDepthxOES;
    alias fn_glClearNamedBufferDataEXT = extern(System) void function(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const( void*) data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glClearNamedBufferDataEXT glClearNamedBufferDataEXT;
    alias fn_glClearNamedBufferSubDataEXT = extern(System) void function(GLuint buffer, GLenum internalformat, GLsizeiptr offset, GLsizeiptr size, GLenum format, GLenum type, const( void*) data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glClearNamedBufferSubDataEXT glClearNamedBufferSubDataEXT;
    alias fn_glClearPixelLocalStorageuiEXT = extern(System) void function(GLsizei offset, GLsizei n, const( GLuint*) values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_shader_pixel_local_storage2")
    fn_glClearPixelLocalStorageuiEXT glClearPixelLocalStorageuiEXT;
    alias fn_glClearTexImageEXT = extern(System) void function(GLuint texture, GLint level, GLenum format, GLenum type, const( void*) data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_clear_texture")
    fn_glClearTexImageEXT glClearTexImageEXT;
    alias fn_glClearTexSubImageEXT = extern(System) void function(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const( void*) data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_clear_texture")
    fn_glClearTexSubImageEXT glClearTexSubImageEXT;
    alias fn_glClientActiveTextureARB = extern(System) void function(GLenum texture) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    fn_glClientActiveTextureARB glClientActiveTextureARB;
    alias fn_glClientActiveVertexStreamATI = extern(System) void function(GLenum stream) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glClientActiveVertexStreamATI glClientActiveVertexStreamATI;
    alias fn_glClientAttribDefaultEXT = extern(System) void function(GLbitfield mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glClientAttribDefaultEXT glClientAttribDefaultEXT;
    alias fn_glClientWaitSyncAPPLE = extern(System) GLenum function(GLsync sync, GLbitfield flags, GLuint64 timeout) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_sync")
    fn_glClientWaitSyncAPPLE glClientWaitSyncAPPLE;
    alias fn_glClipPlanef = extern(System) void function(GLenum p, const( GLfloat*) eqn) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glClipPlanef glClipPlanef;
    alias fn_glClipPlanefIMG = extern(System) void function(GLenum p, const( GLfloat*) eqn) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IMG_user_clip_plane")
    fn_glClipPlanefIMG glClipPlanefIMG;
    alias fn_glClipPlanefOES = extern(System) void function(GLenum plane, const( GLfloat*) equation) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_single_precision")
    fn_glClipPlanefOES glClipPlanefOES;
    alias fn_glClipPlanex = extern(System) void function(GLenum plane, const( GLfixed*) equation) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glClipPlanex glClipPlanex;
    alias fn_glClipPlanexIMG = extern(System) void function(GLenum p, const( GLfixed*) eqn) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IMG_user_clip_plane")
    fn_glClipPlanexIMG glClipPlanexIMG;
    alias fn_glClipPlanexOES = extern(System) void function(GLenum plane, const( GLfixed*) equation) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glClipPlanexOES glClipPlanexOES;
    alias fn_glColor3fVertex3fSUN = extern(System) void function(GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glColor3fVertex3fSUN glColor3fVertex3fSUN;
    alias fn_glColor3fVertex3fvSUN = extern(System) void function(const( GLfloat*) c, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glColor3fVertex3fvSUN glColor3fVertex3fvSUN;
    alias fn_glColor3hNV = extern(System) void function(GLhalfNV red, GLhalfNV green, GLhalfNV blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glColor3hNV glColor3hNV;
    alias fn_glColor3hvNV = extern(System) void function(const( GLhalfNV*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glColor3hvNV glColor3hvNV;
    alias fn_glColor3xOES = extern(System) void function(GLfixed red, GLfixed green, GLfixed blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glColor3xOES glColor3xOES;
    alias fn_glColor3xvOES = extern(System) void function(const( GLfixed*) components) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glColor3xvOES glColor3xvOES;
    alias fn_glColor4fNormal3fVertex3fSUN = extern(System) void function(GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glColor4fNormal3fVertex3fSUN glColor4fNormal3fVertex3fSUN;
    alias fn_glColor4fNormal3fVertex3fvSUN = extern(System) void function(const( GLfloat*) c, const( GLfloat*) n, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glColor4fNormal3fVertex3fvSUN glColor4fNormal3fVertex3fvSUN;
    alias fn_glColor4hNV = extern(System) void function(GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glColor4hNV glColor4hNV;
    alias fn_glColor4hvNV = extern(System) void function(const( GLhalfNV*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glColor4hvNV glColor4hvNV;
    alias fn_glColor4ubVertex2fSUN = extern(System) void function(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glColor4ubVertex2fSUN glColor4ubVertex2fSUN;
    alias fn_glColor4ubVertex2fvSUN = extern(System) void function(const(GLubyte)* c, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glColor4ubVertex2fvSUN glColor4ubVertex2fvSUN;
    alias fn_glColor4ubVertex3fSUN = extern(System) void function(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glColor4ubVertex3fSUN glColor4ubVertex3fSUN;
    alias fn_glColor4ubVertex3fvSUN = extern(System) void function(const(GLubyte)* c, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glColor4ubVertex3fvSUN glColor4ubVertex3fvSUN;
    alias fn_glColor4x = extern(System) void function(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glColor4x glColor4x;
    alias fn_glColor4xOES = extern(System) void function(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glColor4xOES glColor4xOES;
    alias fn_glColor4xvOES = extern(System) void function(const( GLfixed*) components) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glColor4xvOES glColor4xvOES;
    alias fn_glColorFormatNV = extern(System) void function(GLint size, GLenum type, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_buffer_unified_memory")
    fn_glColorFormatNV glColorFormatNV;
    alias fn_glColorFragmentOp1ATI = extern(System) void function(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    fn_glColorFragmentOp1ATI glColorFragmentOp1ATI;
    alias fn_glColorFragmentOp2ATI = extern(System) void function(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    fn_glColorFragmentOp2ATI glColorFragmentOp2ATI;
    alias fn_glColorFragmentOp3ATI = extern(System) void function(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    fn_glColorFragmentOp3ATI glColorFragmentOp3ATI;
    alias fn_glColorMaskIndexedEXT = extern(System) void function(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_buffers2")
    fn_glColorMaskIndexedEXT glColorMaskIndexedEXT;
    alias fn_glColorMaski = extern(System) void function(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glColorMaski glColorMaski;
    alias fn_glColorMaskiEXT = extern(System) void function(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_buffers_indexed")
    fn_glColorMaskiEXT glColorMaskiEXT;
    alias fn_glColorMaskiOES = extern(System) void function(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_buffers_indexed")
    fn_glColorMaskiOES glColorMaskiOES;
    alias fn_glColorP3ui = extern(System) void function(GLenum type, GLuint color) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glColorP3ui glColorP3ui;
    alias fn_glColorP3uiv = extern(System) void function(GLenum type, const( GLuint*) color) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glColorP3uiv glColorP3uiv;
    alias fn_glColorP4ui = extern(System) void function(GLenum type, GLuint color) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glColorP4ui glColorP4ui;
    alias fn_glColorP4uiv = extern(System) void function(GLenum type, const( GLuint*) color) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glColorP4uiv glColorP4uiv;
    alias fn_glColorPointerEXT = extern(System) void function(GLint size, GLenum type, GLsizei stride, GLsizei count, const( void*) pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_array")
    fn_glColorPointerEXT glColorPointerEXT;
    alias fn_glColorPointerListIBM = extern(System) void function(GLint size, GLenum type, GLint stride, const( void**) pointer, GLint ptrstride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IBM_vertex_array_lists")
    fn_glColorPointerListIBM glColorPointerListIBM;
    alias fn_glColorPointervINTEL = extern(System) void function(GLint size, GLenum type, const( void**) pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_parallel_arrays")
    fn_glColorPointervINTEL glColorPointervINTEL;
    alias fn_glColorSubTableEXT = extern(System) void function(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const( void*) data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_color_subtable")
    fn_glColorSubTableEXT glColorSubTableEXT;
    alias fn_glColorTableEXT = extern(System) void function(GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const( void*) table) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_paletted_texture")
    fn_glColorTableEXT glColorTableEXT;
    alias fn_glColorTableParameterfvSGI = extern(System) void function(GLenum target, GLenum pname, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGI_color_table")
    fn_glColorTableParameterfvSGI glColorTableParameterfvSGI;
    alias fn_glColorTableParameterivSGI = extern(System) void function(GLenum target, GLenum pname, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGI_color_table")
    fn_glColorTableParameterivSGI glColorTableParameterivSGI;
    alias fn_glColorTableSGI = extern(System) void function(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const( void*) table) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGI_color_table")
    fn_glColorTableSGI glColorTableSGI;
    alias fn_glCombinerInputNV = extern(System) void function(GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    fn_glCombinerInputNV glCombinerInputNV;
    alias fn_glCombinerOutputNV = extern(System) void function(GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    fn_glCombinerOutputNV glCombinerOutputNV;
    alias fn_glCombinerParameterfNV = extern(System) void function(GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    fn_glCombinerParameterfNV glCombinerParameterfNV;
    alias fn_glCombinerParameterfvNV = extern(System) void function(GLenum pname, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    fn_glCombinerParameterfvNV glCombinerParameterfvNV;
    alias fn_glCombinerParameteriNV = extern(System) void function(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    fn_glCombinerParameteriNV glCombinerParameteriNV;
    alias fn_glCombinerParameterivNV = extern(System) void function(GLenum pname, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    fn_glCombinerParameterivNV glCombinerParameterivNV;
    alias fn_glCombinerStageParameterfvNV = extern(System) void function(GLenum stage, GLenum pname, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners2")
    fn_glCombinerStageParameterfvNV glCombinerStageParameterfvNV;
    alias fn_glCommandListSegmentsNV = extern(System) void function(GLuint list, GLuint segments) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    fn_glCommandListSegmentsNV glCommandListSegmentsNV;
    alias fn_glCompileCommandListNV = extern(System) void function(GLuint list) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    fn_glCompileCommandListNV glCompileCommandListNV;
    alias fn_glCompileShaderARB = extern(System) void function(GLhandleARB shaderObj) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glCompileShaderARB glCompileShaderARB;
    alias fn_glCompileShaderIncludeARB = extern(System) void function(GLuint shader, GLsizei count, const(const(GLvoid*)*) path, const( GLint*) length) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shading_language_include")
    fn_glCompileShaderIncludeARB glCompileShaderIncludeARB;
    alias fn_glCompressedMultiTexImage1DEXT = extern(System) void function(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const( void*) bits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glCompressedMultiTexImage1DEXT glCompressedMultiTexImage1DEXT;
    alias fn_glCompressedMultiTexImage2DEXT = extern(System) void function(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const( void*) bits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glCompressedMultiTexImage2DEXT glCompressedMultiTexImage2DEXT;
    alias fn_glCompressedMultiTexImage3DEXT = extern(System) void function(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const( void*) bits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glCompressedMultiTexImage3DEXT glCompressedMultiTexImage3DEXT;
    alias fn_glCompressedMultiTexSubImage1DEXT = extern(System) void function(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const( void*) bits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glCompressedMultiTexSubImage1DEXT glCompressedMultiTexSubImage1DEXT;
    alias fn_glCompressedMultiTexSubImage2DEXT = extern(System) void function(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const( void*) bits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glCompressedMultiTexSubImage2DEXT glCompressedMultiTexSubImage2DEXT;
    alias fn_glCompressedMultiTexSubImage3DEXT = extern(System) void function(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const( void*) bits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glCompressedMultiTexSubImage3DEXT glCompressedMultiTexSubImage3DEXT;
    alias fn_glCompressedTexImage1DARB = extern(System) void function(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const( void*) data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_texture_compression")
    fn_glCompressedTexImage1DARB glCompressedTexImage1DARB;
    alias fn_glCompressedTexImage2DARB = extern(System) void function(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const( void*) data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_texture_compression")
    fn_glCompressedTexImage2DARB glCompressedTexImage2DARB;
    alias fn_glCompressedTexImage3DARB = extern(System) void function(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const( void*) data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_texture_compression")
    fn_glCompressedTexImage3DARB glCompressedTexImage3DARB;
    alias fn_glCompressedTexImage3DOES = extern(System) void function(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const( void*) data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_3D")
    fn_glCompressedTexImage3DOES glCompressedTexImage3DOES;
    alias fn_glCompressedTexSubImage1DARB = extern(System) void function(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const( void*) data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_texture_compression")
    fn_glCompressedTexSubImage1DARB glCompressedTexSubImage1DARB;
    alias fn_glCompressedTexSubImage2DARB = extern(System) void function(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const( void*) data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_texture_compression")
    fn_glCompressedTexSubImage2DARB glCompressedTexSubImage2DARB;
    alias fn_glCompressedTexSubImage3DARB = extern(System) void function(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const( void*) data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_texture_compression")
    fn_glCompressedTexSubImage3DARB glCompressedTexSubImage3DARB;
    alias fn_glCompressedTexSubImage3DOES = extern(System) void function(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const( void*) data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_3D")
    fn_glCompressedTexSubImage3DOES glCompressedTexSubImage3DOES;
    alias fn_glCompressedTextureImage1DEXT = extern(System) void function(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const( void*) bits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glCompressedTextureImage1DEXT glCompressedTextureImage1DEXT;
    alias fn_glCompressedTextureImage2DEXT = extern(System) void function(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const( void*) bits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glCompressedTextureImage2DEXT glCompressedTextureImage2DEXT;
    alias fn_glCompressedTextureImage3DEXT = extern(System) void function(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const( void*) bits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glCompressedTextureImage3DEXT glCompressedTextureImage3DEXT;
    alias fn_glCompressedTextureSubImage1DEXT = extern(System) void function(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const( void*) bits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glCompressedTextureSubImage1DEXT glCompressedTextureSubImage1DEXT;
    alias fn_glCompressedTextureSubImage2DEXT = extern(System) void function(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const( void*) bits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glCompressedTextureSubImage2DEXT glCompressedTextureSubImage2DEXT;
    alias fn_glCompressedTextureSubImage3DEXT = extern(System) void function(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const( void*) bits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glCompressedTextureSubImage3DEXT glCompressedTextureSubImage3DEXT;
    alias fn_glConservativeRasterParameterfNV = extern(System) void function(GLenum pname, GLfloat value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_conservative_raster_dilate")
    fn_glConservativeRasterParameterfNV glConservativeRasterParameterfNV;
    alias fn_glConservativeRasterParameteriNV = extern(System) void function(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_conservative_raster_pre_snap_triangles")
    fn_glConservativeRasterParameteriNV glConservativeRasterParameteriNV;
    alias fn_glConvolutionFilter1DEXT = extern(System) void function(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const( void*) image) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    fn_glConvolutionFilter1DEXT glConvolutionFilter1DEXT;
    alias fn_glConvolutionFilter2DEXT = extern(System) void function(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const( void*) image) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    fn_glConvolutionFilter2DEXT glConvolutionFilter2DEXT;
    alias fn_glConvolutionParameterfEXT = extern(System) void function(GLenum target, GLenum pname, GLfloat params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    fn_glConvolutionParameterfEXT glConvolutionParameterfEXT;
    alias fn_glConvolutionParameterfvEXT = extern(System) void function(GLenum target, GLenum pname, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    fn_glConvolutionParameterfvEXT glConvolutionParameterfvEXT;
    alias fn_glConvolutionParameteriEXT = extern(System) void function(GLenum target, GLenum pname, GLint params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    fn_glConvolutionParameteriEXT glConvolutionParameteriEXT;
    alias fn_glConvolutionParameterivEXT = extern(System) void function(GLenum target, GLenum pname, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    fn_glConvolutionParameterivEXT glConvolutionParameterivEXT;
    alias fn_glConvolutionParameterxOES = extern(System) void function(GLenum target, GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glConvolutionParameterxOES glConvolutionParameterxOES;
    alias fn_glConvolutionParameterxvOES = extern(System) void function(GLenum target, GLenum pname, const( GLfixed*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glConvolutionParameterxvOES glConvolutionParameterxvOES;
    alias fn_glCopyBufferSubDataNV = extern(System) void function(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_copy_buffer")
    fn_glCopyBufferSubDataNV glCopyBufferSubDataNV;
    alias fn_glCopyColorSubTableEXT = extern(System) void function(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_color_subtable")
    fn_glCopyColorSubTableEXT glCopyColorSubTableEXT;
    alias fn_glCopyColorTableSGI = extern(System) void function(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGI_color_table")
    fn_glCopyColorTableSGI glCopyColorTableSGI;
    alias fn_glCopyConvolutionFilter1DEXT = extern(System) void function(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    fn_glCopyConvolutionFilter1DEXT glCopyConvolutionFilter1DEXT;
    alias fn_glCopyConvolutionFilter2DEXT = extern(System) void function(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    fn_glCopyConvolutionFilter2DEXT glCopyConvolutionFilter2DEXT;
    alias fn_glCopyImageSubDataEXT = extern(System) void function(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_copy_image")
    fn_glCopyImageSubDataEXT glCopyImageSubDataEXT;
    alias fn_glCopyImageSubDataNV = extern(System) void function(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_copy_image")
    fn_glCopyImageSubDataNV glCopyImageSubDataNV;
    alias fn_glCopyImageSubDataOES = extern(System) void function(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_copy_image")
    fn_glCopyImageSubDataOES glCopyImageSubDataOES;
    alias fn_glCopyMultiTexImage1DEXT = extern(System) void function(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glCopyMultiTexImage1DEXT glCopyMultiTexImage1DEXT;
    alias fn_glCopyMultiTexImage2DEXT = extern(System) void function(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glCopyMultiTexImage2DEXT glCopyMultiTexImage2DEXT;
    alias fn_glCopyMultiTexSubImage1DEXT = extern(System) void function(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glCopyMultiTexSubImage1DEXT glCopyMultiTexSubImage1DEXT;
    alias fn_glCopyMultiTexSubImage2DEXT = extern(System) void function(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glCopyMultiTexSubImage2DEXT glCopyMultiTexSubImage2DEXT;
    alias fn_glCopyMultiTexSubImage3DEXT = extern(System) void function(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glCopyMultiTexSubImage3DEXT glCopyMultiTexSubImage3DEXT;
    alias fn_glCopyPathNV = extern(System) void function(GLuint resultPath, GLuint srcPath) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glCopyPathNV glCopyPathNV;
    alias fn_glCopyTexImage1DEXT = extern(System) void function(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_copy_texture")
    fn_glCopyTexImage1DEXT glCopyTexImage1DEXT;
    alias fn_glCopyTexImage2DEXT = extern(System) void function(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_copy_texture")
    fn_glCopyTexImage2DEXT glCopyTexImage2DEXT;
    alias fn_glCopyTexSubImage1DEXT = extern(System) void function(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_copy_texture")
    fn_glCopyTexSubImage1DEXT glCopyTexSubImage1DEXT;
    alias fn_glCopyTexSubImage2DEXT = extern(System) void function(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_copy_texture")
    fn_glCopyTexSubImage2DEXT glCopyTexSubImage2DEXT;
    alias fn_glCopyTexSubImage3DEXT = extern(System) void function(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_copy_texture")
    fn_glCopyTexSubImage3DEXT glCopyTexSubImage3DEXT;
    alias fn_glCopyTexSubImage3DOES = extern(System) void function(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_3D")
    fn_glCopyTexSubImage3DOES glCopyTexSubImage3DOES;
    alias fn_glCopyTextureImage1DEXT = extern(System) void function(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glCopyTextureImage1DEXT glCopyTextureImage1DEXT;
    alias fn_glCopyTextureImage2DEXT = extern(System) void function(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glCopyTextureImage2DEXT glCopyTextureImage2DEXT;
    alias fn_glCopyTextureLevelsAPPLE = extern(System) void function(GLuint destinationTexture, GLuint sourceTexture, GLint sourceBaseLevel, GLsizei sourceLevelCount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_copy_texture_levels")
    fn_glCopyTextureLevelsAPPLE glCopyTextureLevelsAPPLE;
    alias fn_glCopyTextureSubImage1DEXT = extern(System) void function(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glCopyTextureSubImage1DEXT glCopyTextureSubImage1DEXT;
    alias fn_glCopyTextureSubImage2DEXT = extern(System) void function(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glCopyTextureSubImage2DEXT glCopyTextureSubImage2DEXT;
    alias fn_glCopyTextureSubImage3DEXT = extern(System) void function(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glCopyTextureSubImage3DEXT glCopyTextureSubImage3DEXT;
    alias fn_glCoverFillPathInstancedNV = extern(System) void function(GLsizei numPaths, GLenum pathNameType, const( void*) paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const( GLfloat*) transformValues) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glCoverFillPathInstancedNV glCoverFillPathInstancedNV;
    alias fn_glCoverFillPathNV = extern(System) void function(GLuint path, GLenum coverMode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glCoverFillPathNV glCoverFillPathNV;
    alias fn_glCoverStrokePathInstancedNV = extern(System) void function(GLsizei numPaths, GLenum pathNameType, const( void*) paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const( GLfloat*) transformValues) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glCoverStrokePathInstancedNV glCoverStrokePathInstancedNV;
    alias fn_glCoverStrokePathNV = extern(System) void function(GLuint path, GLenum coverMode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glCoverStrokePathNV glCoverStrokePathNV;
    alias fn_glCoverageMaskNV = extern(System) void function(GLboolean mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_coverage_sample")
    fn_glCoverageMaskNV glCoverageMaskNV;
    alias fn_glCoverageModulationNV = extern(System) void function(GLenum components) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_framebuffer_mixed_samples")
    fn_glCoverageModulationNV glCoverageModulationNV;
    alias fn_glCoverageModulationTableNV = extern(System) void function(GLsizei n, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_framebuffer_mixed_samples")
    fn_glCoverageModulationTableNV glCoverageModulationTableNV;
    alias fn_glCoverageOperationNV = extern(System) void function(GLenum operation) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_coverage_sample")
    fn_glCoverageOperationNV glCoverageOperationNV;
    alias fn_glCreateCommandListsNV = extern(System) void function(GLsizei n, GLuint* lists) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    fn_glCreateCommandListsNV glCreateCommandListsNV;
    alias fn_glCreatePerfQueryINTEL = extern(System) void function(GLuint queryId, GLuint* queryHandle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_performance_query")
    fn_glCreatePerfQueryINTEL glCreatePerfQueryINTEL;
    alias fn_glCreateProgramObjectARB = extern(System) GLhandleARB function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glCreateProgramObjectARB glCreateProgramObjectARB;
    alias fn_glCreateShaderObjectARB = extern(System) GLhandleARB function(GLenum shaderType) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glCreateShaderObjectARB glCreateShaderObjectARB;
    alias fn_glCreateShaderProgramEXT = extern(System) GLuint function(GLenum type, const( GLchar*) string) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    fn_glCreateShaderProgramEXT glCreateShaderProgramEXT;
    alias fn_glCreateShaderProgramvEXT = extern(System) GLuint function(GLenum type, GLsizei count, const( GLchar**) strings) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    fn_glCreateShaderProgramvEXT glCreateShaderProgramvEXT;
    alias fn_glCreateStatesNV = extern(System) void function(GLsizei n, GLuint* states) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    fn_glCreateStatesNV glCreateStatesNV;
    alias fn_glCreateSyncFromCLeventARB = extern(System) GLsync function(_cl_context* context, _cl_event* event, GLbitfield flags) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_cl_event")
    fn_glCreateSyncFromCLeventARB glCreateSyncFromCLeventARB;
    alias fn_glCullParameterdvEXT = extern(System) void function(GLenum pname, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_cull_vertex")
    fn_glCullParameterdvEXT glCullParameterdvEXT;
    alias fn_glCullParameterfvEXT = extern(System) void function(GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_cull_vertex")
    fn_glCullParameterfvEXT glCullParameterfvEXT;
    alias fn_glCurrentPaletteMatrixARB = extern(System) void function(GLint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_matrix_palette")
    fn_glCurrentPaletteMatrixARB glCurrentPaletteMatrixARB;
    alias fn_glCurrentPaletteMatrixOES = extern(System) void function(GLuint matrixpaletteindex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_matrix_palette")
    fn_glCurrentPaletteMatrixOES glCurrentPaletteMatrixOES;
    alias fn_glDebugMessageCallbackAMD = extern(System) void function(GLDEBUGPROCAMD callback, void* userParam) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_debug_output")
    fn_glDebugMessageCallbackAMD glDebugMessageCallbackAMD;
    alias fn_glDebugMessageCallbackARB = extern(System) void function(GLDEBUGPROCARB callback, const( void*) userParam) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_debug_output")
    fn_glDebugMessageCallbackARB glDebugMessageCallbackARB;
    alias fn_glDebugMessageCallbackKHR = extern(System) void function(GLDEBUGPROCKHR callback, const( void*) userParam) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_debug")
    fn_glDebugMessageCallbackKHR glDebugMessageCallbackKHR;
    alias fn_glDebugMessageControlARB = extern(System) void function(GLenum source, GLenum type, GLenum severity, GLsizei count, const( GLuint*) ids, GLboolean enabled) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_debug_output")
    fn_glDebugMessageControlARB glDebugMessageControlARB;
    alias fn_glDebugMessageControlKHR = extern(System) void function(GLenum source, GLenum type, GLenum severity, GLsizei count, const( GLuint*) ids, GLboolean enabled) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_debug")
    fn_glDebugMessageControlKHR glDebugMessageControlKHR;
    alias fn_glDebugMessageEnableAMD = extern(System) void function(GLenum category, GLenum severity, GLsizei count, const( GLuint*) ids, GLboolean enabled) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_debug_output")
    fn_glDebugMessageEnableAMD glDebugMessageEnableAMD;
    alias fn_glDebugMessageInsertAMD = extern(System) void function(GLenum category, GLenum severity, GLuint id, GLsizei length, const( GLchar*) buf) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_debug_output")
    fn_glDebugMessageInsertAMD glDebugMessageInsertAMD;
    alias fn_glDebugMessageInsertARB = extern(System) void function(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const( GLchar*) buf) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_debug_output")
    fn_glDebugMessageInsertARB glDebugMessageInsertARB;
    alias fn_glDebugMessageInsertKHR = extern(System) void function(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const( GLchar*) buf) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_debug")
    fn_glDebugMessageInsertKHR glDebugMessageInsertKHR;
    alias fn_glDeformSGIX = extern(System) void function(GLbitfield mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_polynomial_ffd")
    fn_glDeformSGIX glDeformSGIX;
    alias fn_glDeformationMap3dSGIX = extern(System) void function(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble w1, GLdouble w2, GLint wstride, GLint worder, const( GLdouble*) points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_polynomial_ffd")
    fn_glDeformationMap3dSGIX glDeformationMap3dSGIX;
    alias fn_glDeformationMap3fSGIX = extern(System) void function(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat w1, GLfloat w2, GLint wstride, GLint worder, const( GLfloat*) points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_polynomial_ffd")
    fn_glDeformationMap3fSGIX glDeformationMap3fSGIX;
    alias fn_glDeleteAsyncMarkersSGIX = extern(System) void function(GLuint marker, GLsizei range) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_async")
    fn_glDeleteAsyncMarkersSGIX glDeleteAsyncMarkersSGIX;
    alias fn_glDeleteBuffersARB = extern(System) void function(GLsizei n, const( GLuint*) buffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_buffer_object")
    fn_glDeleteBuffersARB glDeleteBuffersARB;
    alias fn_glDeleteCommandListsNV = extern(System) void function(GLsizei n, const( GLuint*) lists) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    fn_glDeleteCommandListsNV glDeleteCommandListsNV;
    alias fn_glDeleteFencesAPPLE = extern(System) void function(GLsizei n, const( GLuint*) fences) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_fence")
    fn_glDeleteFencesAPPLE glDeleteFencesAPPLE;
    alias fn_glDeleteFencesNV = extern(System) void function(GLsizei n, const( GLuint*) fences) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fence")
    fn_glDeleteFencesNV glDeleteFencesNV;
    alias fn_glDeleteFragmentShaderATI = extern(System) void function(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    fn_glDeleteFragmentShaderATI glDeleteFragmentShaderATI;
    alias fn_glDeleteFramebuffersEXT = extern(System) void function(GLsizei n, const( GLuint*) framebuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    fn_glDeleteFramebuffersEXT glDeleteFramebuffersEXT;
    alias fn_glDeleteFramebuffersOES = extern(System) void function(GLsizei n, const( GLuint*) framebuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    fn_glDeleteFramebuffersOES glDeleteFramebuffersOES;
    alias fn_glDeleteNamedStringARB = extern(System) void function(GLint namelen, const( GLchar*) name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shading_language_include")
    fn_glDeleteNamedStringARB glDeleteNamedStringARB;
    alias fn_glDeleteNamesAMD = extern(System) void function(GLenum identifier, GLuint num, const( GLuint*) names) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_name_gen_delete")
    fn_glDeleteNamesAMD glDeleteNamesAMD;
    alias fn_glDeleteObjectARB = extern(System) void function(GLhandleARB obj) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glDeleteObjectARB glDeleteObjectARB;
    alias fn_glDeleteOcclusionQueriesNV = extern(System) void function(GLsizei n, const( GLuint*) ids) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_occlusion_query")
    fn_glDeleteOcclusionQueriesNV glDeleteOcclusionQueriesNV;
    alias fn_glDeletePathsNV = extern(System) void function(GLuint path, GLsizei range) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glDeletePathsNV glDeletePathsNV;
    alias fn_glDeletePerfMonitorsAMD = extern(System) void function(GLsizei n, GLuint* monitors) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_performance_monitor")
    fn_glDeletePerfMonitorsAMD glDeletePerfMonitorsAMD;
    alias fn_glDeletePerfQueryINTEL = extern(System) void function(GLuint queryHandle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_performance_query")
    fn_glDeletePerfQueryINTEL glDeletePerfQueryINTEL;
    alias fn_glDeleteProgramPipelinesEXT = extern(System) void function(GLsizei n, const( GLuint*) pipelines) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    fn_glDeleteProgramPipelinesEXT glDeleteProgramPipelinesEXT;
    alias fn_glDeleteProgramsARB = extern(System) void function(GLsizei n, const( GLuint*) programs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    fn_glDeleteProgramsARB glDeleteProgramsARB;
    alias fn_glDeleteProgramsNV = extern(System) void function(GLsizei n, const( GLuint*) programs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glDeleteProgramsNV glDeleteProgramsNV;
    alias fn_glDeleteQueriesARB = extern(System) void function(GLsizei n, const( GLuint*) ids) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_occlusion_query")
    fn_glDeleteQueriesARB glDeleteQueriesARB;
    alias fn_glDeleteQueriesEXT = extern(System) void function(GLsizei n, const( GLuint*) ids) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_disjoint_timer_query")
    fn_glDeleteQueriesEXT glDeleteQueriesEXT;
    alias fn_glDeleteRenderbuffersEXT = extern(System) void function(GLsizei n, const( GLuint*) renderbuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    fn_glDeleteRenderbuffersEXT glDeleteRenderbuffersEXT;
    alias fn_glDeleteRenderbuffersOES = extern(System) void function(GLsizei n, const( GLuint*) renderbuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    fn_glDeleteRenderbuffersOES glDeleteRenderbuffersOES;
    alias fn_glDeleteStatesNV = extern(System) void function(GLsizei n, const( GLuint*) states) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    fn_glDeleteStatesNV glDeleteStatesNV;
    alias fn_glDeleteSyncAPPLE = extern(System) void function(GLsync sync) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_sync")
    fn_glDeleteSyncAPPLE glDeleteSyncAPPLE;
    alias fn_glDeleteTexturesEXT = extern(System) void function(GLsizei n, const( GLuint*) textures) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_object")
    fn_glDeleteTexturesEXT glDeleteTexturesEXT;
    alias fn_glDeleteTransformFeedbacksNV = extern(System) void function(GLsizei n, const( GLuint*) ids) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback2")
    fn_glDeleteTransformFeedbacksNV glDeleteTransformFeedbacksNV;
    alias fn_glDeleteVertexArraysAPPLE = extern(System) void function(GLsizei n, const( GLuint*) arrays) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_array_object")
    fn_glDeleteVertexArraysAPPLE glDeleteVertexArraysAPPLE;
    alias fn_glDeleteVertexArraysOES = extern(System) void function(GLsizei n, const( GLuint*) arrays) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_vertex_array_object")
    fn_glDeleteVertexArraysOES glDeleteVertexArraysOES;
    alias fn_glDeleteVertexShaderEXT = extern(System) void function(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glDeleteVertexShaderEXT glDeleteVertexShaderEXT;
    alias fn_glDepthBoundsEXT = extern(System) void function(GLclampd zmin, GLclampd zmax) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_depth_bounds_test")
    fn_glDepthBoundsEXT glDepthBoundsEXT;
    alias fn_glDepthBoundsdNV = extern(System) void function(GLdouble zmin, GLdouble zmax) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_depth_buffer_float")
    fn_glDepthBoundsdNV glDepthBoundsdNV;
    alias fn_glDepthRangeArrayfvNV = extern(System) void function(GLuint first, GLsizei count, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_array")
    fn_glDepthRangeArrayfvNV glDepthRangeArrayfvNV;
    alias fn_glDepthRangeArrayfvOES = extern(System) void function(GLuint first, GLsizei count, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_viewport_array")
    fn_glDepthRangeArrayfvOES glDepthRangeArrayfvOES;
    alias fn_glDepthRangeIndexedfNV = extern(System) void function(GLuint index, GLfloat n, GLfloat f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_array")
    fn_glDepthRangeIndexedfNV glDepthRangeIndexedfNV;
    alias fn_glDepthRangeIndexedfOES = extern(System) void function(GLuint index, GLfloat n, GLfloat f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_viewport_array")
    fn_glDepthRangeIndexedfOES glDepthRangeIndexedfOES;
    alias fn_glDepthRangedNV = extern(System) void function(GLdouble zNear, GLdouble zFar) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_depth_buffer_float")
    fn_glDepthRangedNV glDepthRangedNV;
    alias fn_glDepthRangefOES = extern(System) void function(GLclampf n, GLclampf f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_single_precision")
    fn_glDepthRangefOES glDepthRangefOES;
    alias fn_glDepthRangex = extern(System) void function(GLfixed n, GLfixed f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glDepthRangex glDepthRangex;
    alias fn_glDepthRangexOES = extern(System) void function(GLfixed n, GLfixed f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glDepthRangexOES glDepthRangexOES;
    alias fn_glDetachObjectARB = extern(System) void function(GLhandleARB containerObj, GLhandleARB attachedObj) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glDetachObjectARB glDetachObjectARB;
    alias fn_glDetailTexFuncSGIS = extern(System) void function(GLenum target, GLsizei n, const( GLfloat*) points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_detail_texture")
    fn_glDetailTexFuncSGIS glDetailTexFuncSGIS;
    alias fn_glDisableClientStateIndexedEXT = extern(System) void function(GLenum array, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glDisableClientStateIndexedEXT glDisableClientStateIndexedEXT;
    alias fn_glDisableClientStateiEXT = extern(System) void function(GLenum array, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glDisableClientStateiEXT glDisableClientStateiEXT;
    alias fn_glDisableDriverControlQCOM = extern(System) void function(GLuint driverControl) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_driver_control")
    fn_glDisableDriverControlQCOM glDisableDriverControlQCOM;
    alias fn_glDisableIndexedEXT = extern(System) void function(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glDisableIndexedEXT glDisableIndexedEXT;
    alias fn_glDisableVariantClientStateEXT = extern(System) void function(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glDisableVariantClientStateEXT glDisableVariantClientStateEXT;
    alias fn_glDisableVertexArrayAttribEXT = extern(System) void function(GLuint vaobj, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glDisableVertexArrayAttribEXT glDisableVertexArrayAttribEXT;
    alias fn_glDisableVertexArrayEXT = extern(System) void function(GLuint vaobj, GLenum array) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glDisableVertexArrayEXT glDisableVertexArrayEXT;
    alias fn_glDisableVertexAttribAPPLE = extern(System) void function(GLuint index, GLenum pname) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_program_evaluators")
    fn_glDisableVertexAttribAPPLE glDisableVertexAttribAPPLE;
    alias fn_glDisableVertexAttribArrayARB = extern(System) void function(GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glDisableVertexAttribArrayARB glDisableVertexAttribArrayARB;
    alias fn_glDisableiEXT = extern(System) void function(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_buffers_indexed")
    fn_glDisableiEXT glDisableiEXT;
    alias fn_glDisableiNV = extern(System) void function(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_array")
    fn_glDisableiNV glDisableiNV;
    alias fn_glDisableiOES = extern(System) void function(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_buffers_indexed")
    fn_glDisableiOES glDisableiOES;
    alias fn_glDiscardFramebufferEXT = extern(System) void function(GLenum target, GLsizei numAttachments, const( GLenum*) attachments) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_discard_framebuffer")
    fn_glDiscardFramebufferEXT glDiscardFramebufferEXT;
    alias fn_glDispatchComputeGroupSizeARB = extern(System) void function(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, GLuint group_size_x, GLuint group_size_y, GLuint group_size_z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_compute_variable_group_size")
    fn_glDispatchComputeGroupSizeARB glDispatchComputeGroupSizeARB;
    alias fn_glDrawArraysEXT = extern(System) void function(GLenum mode, GLint first, GLsizei count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_array")
    fn_glDrawArraysEXT glDrawArraysEXT;
    alias fn_glDrawArraysInstancedANGLE = extern(System) void function(GLenum mode, GLint first, GLsizei count, GLsizei primcount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ANGLE_instanced_arrays")
    fn_glDrawArraysInstancedANGLE glDrawArraysInstancedANGLE;
    alias fn_glDrawArraysInstancedARB = extern(System) void function(GLenum mode, GLint first, GLsizei count, GLsizei primcount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_draw_instanced")
    fn_glDrawArraysInstancedARB glDrawArraysInstancedARB;
    alias fn_glDrawArraysInstancedBaseInstanceEXT = extern(System) void function(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_base_instance")
    fn_glDrawArraysInstancedBaseInstanceEXT glDrawArraysInstancedBaseInstanceEXT;
    alias fn_glDrawArraysInstancedEXT = extern(System) void function(GLenum mode, GLint start, GLsizei count, GLsizei primcount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_instanced")
    fn_glDrawArraysInstancedEXT glDrawArraysInstancedEXT;
    alias fn_glDrawArraysInstancedNV = extern(System) void function(GLenum mode, GLint first, GLsizei count, GLsizei primcount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_draw_instanced")
    fn_glDrawArraysInstancedNV glDrawArraysInstancedNV;
    alias fn_glDrawBuffersARB = extern(System) void function(GLsizei n, const( GLenum*) bufs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_draw_buffers")
    fn_glDrawBuffersARB glDrawBuffersARB;
    alias fn_glDrawBuffersATI = extern(System) void function(GLsizei n, const( GLenum*) bufs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_draw_buffers")
    fn_glDrawBuffersATI glDrawBuffersATI;
    alias fn_glDrawBuffersEXT = extern(System) void function(GLsizei n, const( GLenum*) bufs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_buffers")
    fn_glDrawBuffersEXT glDrawBuffersEXT;
    alias fn_glDrawBuffersIndexedEXT = extern(System) void function(GLint n, const( GLenum*) location, const( GLint*) indices) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_multiview_draw_buffers")
    fn_glDrawBuffersIndexedEXT glDrawBuffersIndexedEXT;
    alias fn_glDrawBuffersNV = extern(System) void function(GLsizei n, const( GLenum*) bufs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_draw_buffers")
    fn_glDrawBuffersNV glDrawBuffersNV;
    alias fn_glDrawCommandsAddressNV = extern(System) void function(GLenum primitiveMode, const( GLuint64*) indirects, const( GLsizei*) sizes, GLuint count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    fn_glDrawCommandsAddressNV glDrawCommandsAddressNV;
    alias fn_glDrawCommandsNV = extern(System) void function(GLenum primitiveMode, GLuint buffer, const( GLintptr*) indirects, const( GLsizei*) sizes, GLuint count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    fn_glDrawCommandsNV glDrawCommandsNV;
    alias fn_glDrawCommandsStatesAddressNV = extern(System) void function(const( GLuint64*) indirects, const( GLsizei*) sizes, const( GLuint*) states, const( GLuint*) fbos, GLuint count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    fn_glDrawCommandsStatesAddressNV glDrawCommandsStatesAddressNV;
    alias fn_glDrawCommandsStatesNV = extern(System) void function(GLuint buffer, const( GLintptr*) indirects, const( GLsizei*) sizes, const( GLuint*) states, const( GLuint*) fbos, GLuint count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    fn_glDrawCommandsStatesNV glDrawCommandsStatesNV;
    alias fn_glDrawElementArrayAPPLE = extern(System) void function(GLenum mode, GLint first, GLsizei count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_element_array")
    fn_glDrawElementArrayAPPLE glDrawElementArrayAPPLE;
    alias fn_glDrawElementArrayATI = extern(System) void function(GLenum mode, GLsizei count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_element_array")
    fn_glDrawElementArrayATI glDrawElementArrayATI;
    alias fn_glDrawElementsBaseVertexEXT = extern(System) void function(GLenum mode, GLsizei count, GLenum type, const( void*) indices, GLint basevertex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_elements_base_vertex")
    fn_glDrawElementsBaseVertexEXT glDrawElementsBaseVertexEXT;
    alias fn_glDrawElementsBaseVertexOES = extern(System) void function(GLenum mode, GLsizei count, GLenum type, const( void*) indices, GLint basevertex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_elements_base_vertex")
    fn_glDrawElementsBaseVertexOES glDrawElementsBaseVertexOES;
    alias fn_glDrawElementsInstancedANGLE = extern(System) void function(GLenum mode, GLsizei count, GLenum type, const( void*) indices, GLsizei primcount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ANGLE_instanced_arrays")
    fn_glDrawElementsInstancedANGLE glDrawElementsInstancedANGLE;
    alias fn_glDrawElementsInstancedARB = extern(System) void function(GLenum mode, GLsizei count, GLenum type, const( void*) indices, GLsizei primcount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_draw_instanced")
    fn_glDrawElementsInstancedARB glDrawElementsInstancedARB;
    alias fn_glDrawElementsInstancedBaseInstanceEXT = extern(System) void function(GLenum mode, GLsizei count, GLenum type, const( void*) indices, GLsizei instancecount, GLuint baseinstance) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_base_instance")
    fn_glDrawElementsInstancedBaseInstanceEXT glDrawElementsInstancedBaseInstanceEXT;
    alias fn_glDrawElementsInstancedBaseVertexBaseInstanceEXT = extern(System) void function(GLenum mode, GLsizei count, GLenum type, const( void*) indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_base_instance")
    fn_glDrawElementsInstancedBaseVertexBaseInstanceEXT glDrawElementsInstancedBaseVertexBaseInstanceEXT;
    alias fn_glDrawElementsInstancedBaseVertexEXT = extern(System) void function(GLenum mode, GLsizei count, GLenum type, const( void*) indices, GLsizei instancecount, GLint basevertex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_elements_base_vertex")
    fn_glDrawElementsInstancedBaseVertexEXT glDrawElementsInstancedBaseVertexEXT;
    alias fn_glDrawElementsInstancedBaseVertexOES = extern(System) void function(GLenum mode, GLsizei count, GLenum type, const( void*) indices, GLsizei instancecount, GLint basevertex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_elements_base_vertex")
    fn_glDrawElementsInstancedBaseVertexOES glDrawElementsInstancedBaseVertexOES;
    alias fn_glDrawElementsInstancedEXT = extern(System) void function(GLenum mode, GLsizei count, GLenum type, const( void*) indices, GLsizei primcount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_instanced")
    fn_glDrawElementsInstancedEXT glDrawElementsInstancedEXT;
    alias fn_glDrawElementsInstancedNV = extern(System) void function(GLenum mode, GLsizei count, GLenum type, const( void*) indices, GLsizei primcount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_draw_instanced")
    fn_glDrawElementsInstancedNV glDrawElementsInstancedNV;
    alias fn_glDrawMeshArraysSUN = extern(System) void function(GLenum mode, GLint first, GLsizei count, GLsizei width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_mesh_array")
    fn_glDrawMeshArraysSUN glDrawMeshArraysSUN;
    alias fn_glDrawRangeElementArrayAPPLE = extern(System) void function(GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_element_array")
    fn_glDrawRangeElementArrayAPPLE glDrawRangeElementArrayAPPLE;
    alias fn_glDrawRangeElementArrayATI = extern(System) void function(GLenum mode, GLuint start, GLuint end, GLsizei count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_element_array")
    fn_glDrawRangeElementArrayATI glDrawRangeElementArrayATI;
    alias fn_glDrawRangeElementsBaseVertexEXT = extern(System) void function(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const( void*) indices, GLint basevertex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_elements_base_vertex")
    fn_glDrawRangeElementsBaseVertexEXT glDrawRangeElementsBaseVertexEXT;
    alias fn_glDrawRangeElementsBaseVertexOES = extern(System) void function(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const( void*) indices, GLint basevertex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_elements_base_vertex")
    fn_glDrawRangeElementsBaseVertexOES glDrawRangeElementsBaseVertexOES;
    alias fn_glDrawRangeElementsEXT = extern(System) void function(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const( void*) indices) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_range_elements")
    fn_glDrawRangeElementsEXT glDrawRangeElementsEXT;
    alias fn_glDrawTexfOES = extern(System) void function(GLfloat x, GLfloat y, GLfloat z, GLfloat width, GLfloat height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_texture")
    fn_glDrawTexfOES glDrawTexfOES;
    alias fn_glDrawTexfvOES = extern(System) void function(const( GLfloat*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_texture")
    fn_glDrawTexfvOES glDrawTexfvOES;
    alias fn_glDrawTexiOES = extern(System) void function(GLint x, GLint y, GLint z, GLint width, GLint height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_texture")
    fn_glDrawTexiOES glDrawTexiOES;
    alias fn_glDrawTexivOES = extern(System) void function(const( GLint*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_texture")
    fn_glDrawTexivOES glDrawTexivOES;
    alias fn_glDrawTexsOES = extern(System) void function(GLshort x, GLshort y, GLshort z, GLshort width, GLshort height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_texture")
    fn_glDrawTexsOES glDrawTexsOES;
    alias fn_glDrawTexsvOES = extern(System) void function(const( GLshort*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_texture")
    fn_glDrawTexsvOES glDrawTexsvOES;
    alias fn_glDrawTextureNV = extern(System) void function(GLuint texture, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_draw_texture")
    fn_glDrawTextureNV glDrawTextureNV;
    alias fn_glDrawTexxOES = extern(System) void function(GLfixed x, GLfixed y, GLfixed z, GLfixed width, GLfixed height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_texture")
    fn_glDrawTexxOES glDrawTexxOES;
    alias fn_glDrawTexxvOES = extern(System) void function(const( GLfixed*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_texture")
    fn_glDrawTexxvOES glDrawTexxvOES;
    alias fn_glDrawTransformFeedbackEXT = extern(System) void function(GLenum mode, GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_transform_feedback")
    fn_glDrawTransformFeedbackEXT glDrawTransformFeedbackEXT;
    alias fn_glDrawTransformFeedbackInstancedEXT = extern(System) void function(GLenum mode, GLuint id, GLsizei instancecount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_transform_feedback")
    fn_glDrawTransformFeedbackInstancedEXT glDrawTransformFeedbackInstancedEXT;
    alias fn_glDrawTransformFeedbackNV = extern(System) void function(GLenum mode, GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback2")
    fn_glDrawTransformFeedbackNV glDrawTransformFeedbackNV;
    alias fn_glEGLImageTargetRenderbufferStorageOES = extern(System) void function(GLenum target, GLeglImageOES image) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_EGL_image")
    fn_glEGLImageTargetRenderbufferStorageOES glEGLImageTargetRenderbufferStorageOES;
    alias fn_glEGLImageTargetTexture2DOES = extern(System) void function(GLenum target, GLeglImageOES image) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_EGL_image")
    fn_glEGLImageTargetTexture2DOES glEGLImageTargetTexture2DOES;
    alias fn_glEdgeFlagFormatNV = extern(System) void function(GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_buffer_unified_memory")
    fn_glEdgeFlagFormatNV glEdgeFlagFormatNV;
    alias fn_glEdgeFlagPointerEXT = extern(System) void function(GLsizei stride, GLsizei count, const( GLboolean*) pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_array")
    fn_glEdgeFlagPointerEXT glEdgeFlagPointerEXT;
    alias fn_glEdgeFlagPointerListIBM = extern(System) void function(GLint stride, const( GLboolean**) pointer, GLint ptrstride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IBM_vertex_array_lists")
    fn_glEdgeFlagPointerListIBM glEdgeFlagPointerListIBM;
    alias fn_glElementPointerAPPLE = extern(System) void function(GLenum type, const( void*) pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_element_array")
    fn_glElementPointerAPPLE glElementPointerAPPLE;
    alias fn_glElementPointerATI = extern(System) void function(GLenum type, const( void*) pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_element_array")
    fn_glElementPointerATI glElementPointerATI;
    alias fn_glEnableClientStateIndexedEXT = extern(System) void function(GLenum array, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glEnableClientStateIndexedEXT glEnableClientStateIndexedEXT;
    alias fn_glEnableClientStateiEXT = extern(System) void function(GLenum array, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glEnableClientStateiEXT glEnableClientStateiEXT;
    alias fn_glEnableDriverControlQCOM = extern(System) void function(GLuint driverControl) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_driver_control")
    fn_glEnableDriverControlQCOM glEnableDriverControlQCOM;
    alias fn_glEnableIndexedEXT = extern(System) void function(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glEnableIndexedEXT glEnableIndexedEXT;
    alias fn_glEnableVariantClientStateEXT = extern(System) void function(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glEnableVariantClientStateEXT glEnableVariantClientStateEXT;
    alias fn_glEnableVertexArrayAttribEXT = extern(System) void function(GLuint vaobj, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glEnableVertexArrayAttribEXT glEnableVertexArrayAttribEXT;
    alias fn_glEnableVertexArrayEXT = extern(System) void function(GLuint vaobj, GLenum array) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glEnableVertexArrayEXT glEnableVertexArrayEXT;
    alias fn_glEnableVertexAttribAPPLE = extern(System) void function(GLuint index, GLenum pname) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_program_evaluators")
    fn_glEnableVertexAttribAPPLE glEnableVertexAttribAPPLE;
    alias fn_glEnableVertexAttribArrayARB = extern(System) void function(GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glEnableVertexAttribArrayARB glEnableVertexAttribArrayARB;
    alias fn_glEnableiEXT = extern(System) void function(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_buffers_indexed")
    fn_glEnableiEXT glEnableiEXT;
    alias fn_glEnableiNV = extern(System) void function(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_array")
    fn_glEnableiNV glEnableiNV;
    alias fn_glEnableiOES = extern(System) void function(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_buffers_indexed")
    fn_glEnableiOES glEnableiOES;
    alias fn_glEndConditionalRender = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glEndConditionalRender glEndConditionalRender;
    alias fn_glEndConditionalRenderNV = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_conditional_render")
    fn_glEndConditionalRenderNV glEndConditionalRenderNV;
    alias fn_glEndConditionalRenderNVX = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NVX_conditional_render")
    fn_glEndConditionalRenderNVX glEndConditionalRenderNVX;
    alias fn_glEndFragmentShaderATI = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    fn_glEndFragmentShaderATI glEndFragmentShaderATI;
    alias fn_glEndOcclusionQueryNV = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_occlusion_query")
    fn_glEndOcclusionQueryNV glEndOcclusionQueryNV;
    alias fn_glEndPerfMonitorAMD = extern(System) void function(GLuint monitor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_performance_monitor")
    fn_glEndPerfMonitorAMD glEndPerfMonitorAMD;
    alias fn_glEndPerfQueryINTEL = extern(System) void function(GLuint queryHandle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_performance_query")
    fn_glEndPerfQueryINTEL glEndPerfQueryINTEL;
    alias fn_glEndQuery = extern(System) void function(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    fn_glEndQuery glEndQuery;
    alias fn_glEndQueryARB = extern(System) void function(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_occlusion_query")
    fn_glEndQueryARB glEndQueryARB;
    alias fn_glEndQueryEXT = extern(System) void function(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_disjoint_timer_query")
    fn_glEndQueryEXT glEndQueryEXT;
    alias fn_glEndQueryIndexed = extern(System) void function(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_transform_feedback3")
    fn_glEndQueryIndexed glEndQueryIndexed;
    alias fn_glEndTilingQCOM = extern(System) void function(GLbitfield preserveMask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_tiled_rendering")
    fn_glEndTilingQCOM glEndTilingQCOM;
    alias fn_glEndTransformFeedback = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glEndTransformFeedback glEndTransformFeedback;
    alias fn_glEndTransformFeedbackEXT = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_transform_feedback")
    fn_glEndTransformFeedbackEXT glEndTransformFeedbackEXT;
    alias fn_glEndTransformFeedbackNV = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback")
    fn_glEndTransformFeedbackNV glEndTransformFeedbackNV;
    alias fn_glEndVertexShaderEXT = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glEndVertexShaderEXT glEndVertexShaderEXT;
    alias fn_glEndVideoCaptureNV = extern(System) void function(GLuint video_capture_slot) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_video_capture")
    fn_glEndVideoCaptureNV glEndVideoCaptureNV;
    alias fn_glEvalCoord1xOES = extern(System) void function(GLfixed u) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glEvalCoord1xOES glEvalCoord1xOES;
    alias fn_glEvalCoord1xvOES = extern(System) void function(const( GLfixed*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glEvalCoord1xvOES glEvalCoord1xvOES;
    alias fn_glEvalCoord2xOES = extern(System) void function(GLfixed u, GLfixed v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glEvalCoord2xOES glEvalCoord2xOES;
    alias fn_glEvalCoord2xvOES = extern(System) void function(const( GLfixed*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glEvalCoord2xvOES glEvalCoord2xvOES;
    alias fn_glEvalMapsNV = extern(System) void function(GLenum target, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_evaluators")
    fn_glEvalMapsNV glEvalMapsNV;
    alias fn_glEvaluateDepthValuesARB = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_sample_locations")
    fn_glEvaluateDepthValuesARB glEvaluateDepthValuesARB;
    alias fn_glExecuteProgramNV = extern(System) void function(GLenum target, GLuint id, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glExecuteProgramNV glExecuteProgramNV;
    alias fn_glExtGetBufferPointervQCOM = extern(System) void function(GLenum target, void** params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_extended_get")
    fn_glExtGetBufferPointervQCOM glExtGetBufferPointervQCOM;
    alias fn_glExtGetBuffersQCOM = extern(System) void function(GLuint* buffers, GLint maxBuffers, GLint* numBuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_extended_get")
    fn_glExtGetBuffersQCOM glExtGetBuffersQCOM;
    alias fn_glExtGetFramebuffersQCOM = extern(System) void function(GLuint* framebuffers, GLint maxFramebuffers, GLint* numFramebuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_extended_get")
    fn_glExtGetFramebuffersQCOM glExtGetFramebuffersQCOM;
    alias fn_glExtGetProgramBinarySourceQCOM = extern(System) void function(GLuint program, GLenum shadertype, GLchar* source, GLint* length) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_extended_get2")
    fn_glExtGetProgramBinarySourceQCOM glExtGetProgramBinarySourceQCOM;
    alias fn_glExtGetProgramsQCOM = extern(System) void function(GLuint* programs, GLint maxPrograms, GLint* numPrograms) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_extended_get2")
    fn_glExtGetProgramsQCOM glExtGetProgramsQCOM;
    alias fn_glExtGetRenderbuffersQCOM = extern(System) void function(GLuint* renderbuffers, GLint maxRenderbuffers, GLint* numRenderbuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_extended_get")
    fn_glExtGetRenderbuffersQCOM glExtGetRenderbuffersQCOM;
    alias fn_glExtGetShadersQCOM = extern(System) void function(GLuint* shaders, GLint maxShaders, GLint* numShaders) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_extended_get2")
    fn_glExtGetShadersQCOM glExtGetShadersQCOM;
    alias fn_glExtGetTexLevelParameterivQCOM = extern(System) void function(GLuint texture, GLenum face, GLint level, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_extended_get")
    fn_glExtGetTexLevelParameterivQCOM glExtGetTexLevelParameterivQCOM;
    alias fn_glExtGetTexSubImageQCOM = extern(System) void function(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, void* texels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_extended_get")
    fn_glExtGetTexSubImageQCOM glExtGetTexSubImageQCOM;
    alias fn_glExtGetTexturesQCOM = extern(System) void function(GLuint* textures, GLint maxTextures, GLint* numTextures) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_extended_get")
    fn_glExtGetTexturesQCOM glExtGetTexturesQCOM;
    alias fn_glExtIsProgramBinaryQCOM = extern(System) GLboolean function(GLuint program) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_extended_get2")
    fn_glExtIsProgramBinaryQCOM glExtIsProgramBinaryQCOM;
    alias fn_glExtTexObjectStateOverrideiQCOM = extern(System) void function(GLenum target, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_extended_get")
    fn_glExtTexObjectStateOverrideiQCOM glExtTexObjectStateOverrideiQCOM;
    alias fn_glExtractComponentEXT = extern(System) void function(GLuint res, GLuint src, GLuint num) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glExtractComponentEXT glExtractComponentEXT;
    alias fn_glFeedbackBufferxOES = extern(System) void function(GLsizei n, GLenum type, const( GLfixed*) buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glFeedbackBufferxOES glFeedbackBufferxOES;
    alias fn_glFenceSyncAPPLE = extern(System) GLsync function(GLenum condition, GLbitfield flags) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_sync")
    fn_glFenceSyncAPPLE glFenceSyncAPPLE;
    alias fn_glFinalCombinerInputNV = extern(System) void function(GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    fn_glFinalCombinerInputNV glFinalCombinerInputNV;
    alias fn_glFinishAsyncSGIX = extern(System) GLint function(GLuint* markerp) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_async")
    fn_glFinishAsyncSGIX glFinishAsyncSGIX;
    alias fn_glFinishFenceAPPLE = extern(System) void function(GLuint fence) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_fence")
    fn_glFinishFenceAPPLE glFinishFenceAPPLE;
    alias fn_glFinishFenceNV = extern(System) void function(GLuint fence) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fence")
    fn_glFinishFenceNV glFinishFenceNV;
    alias fn_glFinishObjectAPPLE = extern(System) void function(GLenum object, GLint name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_fence")
    fn_glFinishObjectAPPLE glFinishObjectAPPLE;
    alias fn_glFinishTextureSUNX = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUNX_constant_data")
    fn_glFinishTextureSUNX glFinishTextureSUNX;
    alias fn_glFlushMappedBufferRangeAPPLE = extern(System) void function(GLenum target, GLintptr offset, GLsizeiptr size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_flush_buffer_range")
    fn_glFlushMappedBufferRangeAPPLE glFlushMappedBufferRangeAPPLE;
    alias fn_glFlushMappedBufferRangeEXT = extern(System) void function(GLenum target, GLintptr offset, GLsizeiptr length) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_map_buffer_range")
    fn_glFlushMappedBufferRangeEXT glFlushMappedBufferRangeEXT;
    alias fn_glFlushMappedNamedBufferRangeEXT = extern(System) void function(GLuint buffer, GLintptr offset, GLsizeiptr length) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glFlushMappedNamedBufferRangeEXT glFlushMappedNamedBufferRangeEXT;
    alias fn_glFlushPixelDataRangeNV = extern(System) void function(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_pixel_data_range")
    fn_glFlushPixelDataRangeNV glFlushPixelDataRangeNV;
    alias fn_glFlushRasterSGIX = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_flush_raster")
    fn_glFlushRasterSGIX glFlushRasterSGIX;
    alias fn_glFlushStaticDataIBM = extern(System) void function(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IBM_static_data")
    fn_glFlushStaticDataIBM glFlushStaticDataIBM;
    alias fn_glFlushVertexArrayRangeAPPLE = extern(System) void function(GLsizei length, void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_array_range")
    fn_glFlushVertexArrayRangeAPPLE glFlushVertexArrayRangeAPPLE;
    alias fn_glFlushVertexArrayRangeNV = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_array_range")
    fn_glFlushVertexArrayRangeNV glFlushVertexArrayRangeNV;
    alias fn_glFogCoordFormatNV = extern(System) void function(GLenum type, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_buffer_unified_memory")
    fn_glFogCoordFormatNV glFogCoordFormatNV;
    alias fn_glFogCoordPointerEXT = extern(System) void function(GLenum type, GLsizei stride, const( void*) pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_fog_coord")
    fn_glFogCoordPointerEXT glFogCoordPointerEXT;
    alias fn_glFogCoordPointerListIBM = extern(System) void function(GLenum type, GLint stride, const( void**) pointer, GLint ptrstride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IBM_vertex_array_lists")
    fn_glFogCoordPointerListIBM glFogCoordPointerListIBM;
    alias fn_glFogCoorddEXT = extern(System) void function(GLdouble coord) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_fog_coord")
    fn_glFogCoorddEXT glFogCoorddEXT;
    alias fn_glFogCoorddvEXT = extern(System) void function(const( GLdouble*) coord) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_fog_coord")
    fn_glFogCoorddvEXT glFogCoorddvEXT;
    alias fn_glFogCoordfEXT = extern(System) void function(GLfloat coord) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_fog_coord")
    fn_glFogCoordfEXT glFogCoordfEXT;
    alias fn_glFogCoordfvEXT = extern(System) void function(const( GLfloat*) coord) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_fog_coord")
    fn_glFogCoordfvEXT glFogCoordfvEXT;
    alias fn_glFogCoordhNV = extern(System) void function(GLhalfNV fog) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glFogCoordhNV glFogCoordhNV;
    alias fn_glFogCoordhvNV = extern(System) void function(const( GLhalfNV*) fog) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glFogCoordhvNV glFogCoordhvNV;
    alias fn_glFogFuncSGIS = extern(System) void function(GLsizei n, const( GLfloat*) points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_fog_function")
    fn_glFogFuncSGIS glFogFuncSGIS;
    alias fn_glFogx = extern(System) void function(GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glFogx glFogx;
    alias fn_glFogxOES = extern(System) void function(GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glFogxOES glFogxOES;
    alias fn_glFogxv = extern(System) void function(GLenum pname, const( GLfixed*) param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glFogxv glFogxv;
    alias fn_glFogxvOES = extern(System) void function(GLenum pname, const( GLfixed*) param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glFogxvOES glFogxvOES;
    alias fn_glFragmentColorMaterialSGIX = extern(System) void function(GLenum face, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    fn_glFragmentColorMaterialSGIX glFragmentColorMaterialSGIX;
    alias fn_glFragmentCoverageColorNV = extern(System) void function(GLuint color) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fragment_coverage_to_color")
    fn_glFragmentCoverageColorNV glFragmentCoverageColorNV;
    alias fn_glFragmentLightModelfSGIX = extern(System) void function(GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    fn_glFragmentLightModelfSGIX glFragmentLightModelfSGIX;
    alias fn_glFragmentLightModelfvSGIX = extern(System) void function(GLenum pname, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    fn_glFragmentLightModelfvSGIX glFragmentLightModelfvSGIX;
    alias fn_glFragmentLightModeliSGIX = extern(System) void function(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    fn_glFragmentLightModeliSGIX glFragmentLightModeliSGIX;
    alias fn_glFragmentLightModelivSGIX = extern(System) void function(GLenum pname, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    fn_glFragmentLightModelivSGIX glFragmentLightModelivSGIX;
    alias fn_glFragmentLightfSGIX = extern(System) void function(GLenum light, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    fn_glFragmentLightfSGIX glFragmentLightfSGIX;
    alias fn_glFragmentLightfvSGIX = extern(System) void function(GLenum light, GLenum pname, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    fn_glFragmentLightfvSGIX glFragmentLightfvSGIX;
    alias fn_glFragmentLightiSGIX = extern(System) void function(GLenum light, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    fn_glFragmentLightiSGIX glFragmentLightiSGIX;
    alias fn_glFragmentLightivSGIX = extern(System) void function(GLenum light, GLenum pname, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    fn_glFragmentLightivSGIX glFragmentLightivSGIX;
    alias fn_glFragmentMaterialfSGIX = extern(System) void function(GLenum face, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    fn_glFragmentMaterialfSGIX glFragmentMaterialfSGIX;
    alias fn_glFragmentMaterialfvSGIX = extern(System) void function(GLenum face, GLenum pname, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    fn_glFragmentMaterialfvSGIX glFragmentMaterialfvSGIX;
    alias fn_glFragmentMaterialiSGIX = extern(System) void function(GLenum face, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    fn_glFragmentMaterialiSGIX glFragmentMaterialiSGIX;
    alias fn_glFragmentMaterialivSGIX = extern(System) void function(GLenum face, GLenum pname, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    fn_glFragmentMaterialivSGIX glFragmentMaterialivSGIX;
    alias fn_glFrameTerminatorGREMEDY = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_GREMEDY_frame_terminator")
    fn_glFrameTerminatorGREMEDY glFrameTerminatorGREMEDY;
    alias fn_glFrameZoomSGIX = extern(System) void function(GLint factor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_framezoom")
    fn_glFrameZoomSGIX glFrameZoomSGIX;
    alias fn_glFramebufferDrawBufferEXT = extern(System) void function(GLuint framebuffer, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glFramebufferDrawBufferEXT glFramebufferDrawBufferEXT;
    alias fn_glFramebufferDrawBuffersEXT = extern(System) void function(GLuint framebuffer, GLsizei n, const( GLenum*) bufs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glFramebufferDrawBuffersEXT glFramebufferDrawBuffersEXT;
    alias fn_glFramebufferPixelLocalStorageSizeEXT = extern(System) void function(GLuint target, GLsizei size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_shader_pixel_local_storage2")
    fn_glFramebufferPixelLocalStorageSizeEXT glFramebufferPixelLocalStorageSizeEXT;
    alias fn_glFramebufferReadBufferEXT = extern(System) void function(GLuint framebuffer, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glFramebufferReadBufferEXT glFramebufferReadBufferEXT;
    alias fn_glFramebufferRenderbufferEXT = extern(System) void function(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    fn_glFramebufferRenderbufferEXT glFramebufferRenderbufferEXT;
    alias fn_glFramebufferRenderbufferOES = extern(System) void function(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    fn_glFramebufferRenderbufferOES glFramebufferRenderbufferOES;
    alias fn_glFramebufferSampleLocationsfvARB = extern(System) void function(GLenum target, GLuint start, GLsizei count, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_sample_locations")
    fn_glFramebufferSampleLocationsfvARB glFramebufferSampleLocationsfvARB;
    alias fn_glFramebufferSampleLocationsfvNV = extern(System) void function(GLenum target, GLuint start, GLsizei count, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_sample_locations")
    fn_glFramebufferSampleLocationsfvNV glFramebufferSampleLocationsfvNV;
    alias fn_glFramebufferTexture1DEXT = extern(System) void function(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    fn_glFramebufferTexture1DEXT glFramebufferTexture1DEXT;
    alias fn_glFramebufferTexture2DEXT = extern(System) void function(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    fn_glFramebufferTexture2DEXT glFramebufferTexture2DEXT;
    alias fn_glFramebufferTexture2DDownsampleIMG = extern(System) void function(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint xscale, GLint yscale) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IMG_framebuffer_downsample")
    fn_glFramebufferTexture2DDownsampleIMG glFramebufferTexture2DDownsampleIMG;
    alias fn_glFramebufferTexture2DMultisampleEXT = extern(System) void function(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_multisampled_render_to_texture")
    fn_glFramebufferTexture2DMultisampleEXT glFramebufferTexture2DMultisampleEXT;
    alias fn_glFramebufferTexture2DMultisampleIMG = extern(System) void function(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IMG_multisampled_render_to_texture")
    fn_glFramebufferTexture2DMultisampleIMG glFramebufferTexture2DMultisampleIMG;
    alias fn_glFramebufferTexture2DOES = extern(System) void function(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    fn_glFramebufferTexture2DOES glFramebufferTexture2DOES;
    alias fn_glFramebufferTexture3DEXT = extern(System) void function(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    fn_glFramebufferTexture3DEXT glFramebufferTexture3DEXT;
    alias fn_glFramebufferTexture3DOES = extern(System) void function(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_3D")
    fn_glFramebufferTexture3DOES glFramebufferTexture3DOES;
    alias fn_glFramebufferTextureARB = extern(System) void function(GLenum target, GLenum attachment, GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_geometry_shader4")
    fn_glFramebufferTextureARB glFramebufferTextureARB;
    alias fn_glFramebufferTextureEXT = extern(System) void function(GLenum target, GLenum attachment, GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_geometry_shader")
    fn_glFramebufferTextureEXT glFramebufferTextureEXT;
    alias fn_glFramebufferTextureFaceARB = extern(System) void function(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_geometry_shader4")
    fn_glFramebufferTextureFaceARB glFramebufferTextureFaceARB;
    alias fn_glFramebufferTextureFaceEXT = extern(System) void function(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_geometry_program4")
    fn_glFramebufferTextureFaceEXT glFramebufferTextureFaceEXT;
    alias fn_glFramebufferTextureLayerARB = extern(System) void function(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_geometry_shader4")
    fn_glFramebufferTextureLayerARB glFramebufferTextureLayerARB;
    alias fn_glFramebufferTextureLayerEXT = extern(System) void function(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_array")
    fn_glFramebufferTextureLayerEXT glFramebufferTextureLayerEXT;
    alias fn_glFramebufferTextureLayerDownsampleIMG = extern(System) void function(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer, GLint xscale, GLint yscale) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IMG_framebuffer_downsample")
    fn_glFramebufferTextureLayerDownsampleIMG glFramebufferTextureLayerDownsampleIMG;
    alias fn_glFramebufferTextureMultisampleMultiviewOVR = extern(System) void function(GLenum target, GLenum attachment, GLuint texture, GLint level, GLsizei samples, GLint baseViewIndex, GLsizei numViews) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OVR_multiview_multisampled_render_to_texture")
    fn_glFramebufferTextureMultisampleMultiviewOVR glFramebufferTextureMultisampleMultiviewOVR;
    alias fn_glFramebufferTextureMultiviewOVR = extern(System) void function(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OVR_multiview")
    fn_glFramebufferTextureMultiviewOVR glFramebufferTextureMultiviewOVR;
    alias fn_glFramebufferTextureOES = extern(System) void function(GLenum target, GLenum attachment, GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_geometry_shader")
    fn_glFramebufferTextureOES glFramebufferTextureOES;
    alias fn_glFreeObjectBufferATI = extern(System) void function(GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_array_object")
    fn_glFreeObjectBufferATI glFreeObjectBufferATI;
    alias fn_glFrustumf = extern(System) void function(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glFrustumf glFrustumf;
    alias fn_glFrustumfOES = extern(System) void function(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_single_precision")
    fn_glFrustumfOES glFrustumfOES;
    alias fn_glFrustumx = extern(System) void function(GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glFrustumx glFrustumx;
    alias fn_glFrustumxOES = extern(System) void function(GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glFrustumxOES glFrustumxOES;
    alias fn_glGenAsyncMarkersSGIX = extern(System) GLuint function(GLsizei range) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_async")
    fn_glGenAsyncMarkersSGIX glGenAsyncMarkersSGIX;
    alias fn_glGenBuffersARB = extern(System) void function(GLsizei n, GLuint* buffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_buffer_object")
    fn_glGenBuffersARB glGenBuffersARB;
    alias fn_glGenFencesAPPLE = extern(System) void function(GLsizei n, GLuint* fences) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_fence")
    fn_glGenFencesAPPLE glGenFencesAPPLE;
    alias fn_glGenFencesNV = extern(System) void function(GLsizei n, GLuint* fences) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fence")
    fn_glGenFencesNV glGenFencesNV;
    alias fn_glGenFragmentShadersATI = extern(System) GLuint function(GLuint range) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    fn_glGenFragmentShadersATI glGenFragmentShadersATI;
    alias fn_glGenFramebuffersEXT = extern(System) void function(GLsizei n, GLuint* framebuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    fn_glGenFramebuffersEXT glGenFramebuffersEXT;
    alias fn_glGenFramebuffersOES = extern(System) void function(GLsizei n, GLuint* framebuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    fn_glGenFramebuffersOES glGenFramebuffersOES;
    alias fn_glGenNamesAMD = extern(System) void function(GLenum identifier, GLuint num, GLuint* names) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_name_gen_delete")
    fn_glGenNamesAMD glGenNamesAMD;
    alias fn_glGenOcclusionQueriesNV = extern(System) void function(GLsizei n, GLuint* ids) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_occlusion_query")
    fn_glGenOcclusionQueriesNV glGenOcclusionQueriesNV;
    alias fn_glGenPathsNV = extern(System) GLuint function(GLsizei range) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glGenPathsNV glGenPathsNV;
    alias fn_glGenPerfMonitorsAMD = extern(System) void function(GLsizei n, GLuint* monitors) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_performance_monitor")
    fn_glGenPerfMonitorsAMD glGenPerfMonitorsAMD;
    alias fn_glGenProgramPipelinesEXT = extern(System) void function(GLsizei n, GLuint* pipelines) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    fn_glGenProgramPipelinesEXT glGenProgramPipelinesEXT;
    alias fn_glGenProgramsARB = extern(System) void function(GLsizei n, GLuint* programs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    fn_glGenProgramsARB glGenProgramsARB;
    alias fn_glGenProgramsNV = extern(System) void function(GLsizei n, GLuint* programs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glGenProgramsNV glGenProgramsNV;
    alias fn_glGenQueriesARB = extern(System) void function(GLsizei n, GLuint* ids) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_occlusion_query")
    fn_glGenQueriesARB glGenQueriesARB;
    alias fn_glGenQueriesEXT = extern(System) void function(GLsizei n, GLuint* ids) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_disjoint_timer_query")
    fn_glGenQueriesEXT glGenQueriesEXT;
    alias fn_glGenRenderbuffersEXT = extern(System) void function(GLsizei n, GLuint* renderbuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    fn_glGenRenderbuffersEXT glGenRenderbuffersEXT;
    alias fn_glGenRenderbuffersOES = extern(System) void function(GLsizei n, GLuint* renderbuffers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    fn_glGenRenderbuffersOES glGenRenderbuffersOES;
    alias fn_glGenSymbolsEXT = extern(System) GLuint function(GLenum datatype, GLenum storagetype, GLenum range, GLuint components) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glGenSymbolsEXT glGenSymbolsEXT;
    alias fn_glGenTexturesEXT = extern(System) void function(GLsizei n, GLuint* textures) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_object")
    fn_glGenTexturesEXT glGenTexturesEXT;
    alias fn_glGenTransformFeedbacksNV = extern(System) void function(GLsizei n, GLuint* ids) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback2")
    fn_glGenTransformFeedbacksNV glGenTransformFeedbacksNV;
    alias fn_glGenVertexArraysAPPLE = extern(System) void function(GLsizei n, GLuint* arrays) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_array_object")
    fn_glGenVertexArraysAPPLE glGenVertexArraysAPPLE;
    alias fn_glGenVertexArraysOES = extern(System) void function(GLsizei n, GLuint* arrays) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_vertex_array_object")
    fn_glGenVertexArraysOES glGenVertexArraysOES;
    alias fn_glGenVertexShadersEXT = extern(System) GLuint function(GLuint range) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glGenVertexShadersEXT glGenVertexShadersEXT;
    alias fn_glGenerateMipmapEXT = extern(System) void function(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    fn_glGenerateMipmapEXT glGenerateMipmapEXT;
    alias fn_glGenerateMipmapOES = extern(System) void function(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    fn_glGenerateMipmapOES glGenerateMipmapOES;
    alias fn_glGenerateMultiTexMipmapEXT = extern(System) void function(GLenum texunit, GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGenerateMultiTexMipmapEXT glGenerateMultiTexMipmapEXT;
    alias fn_glGenerateTextureMipmapEXT = extern(System) void function(GLuint texture, GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGenerateTextureMipmapEXT glGenerateTextureMipmapEXT;
    alias fn_glGetActiveAttribARB = extern(System) void function(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei* length, GLint* size, GLenum* type, GLcharARB* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_shader")
    fn_glGetActiveAttribARB glGetActiveAttribARB;
    alias fn_glGetActiveUniformARB = extern(System) void function(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei* length, GLint* size, GLenum* type, GLcharARB* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glGetActiveUniformARB glGetActiveUniformARB;
    alias fn_glGetActiveVaryingNV = extern(System) void function(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLsizei* size, GLenum* type, GLchar* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback")
    fn_glGetActiveVaryingNV glGetActiveVaryingNV;
    alias fn_glGetArrayObjectfvATI = extern(System) void function(GLenum array, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_array_object")
    fn_glGetArrayObjectfvATI glGetArrayObjectfvATI;
    alias fn_glGetArrayObjectivATI = extern(System) void function(GLenum array, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_array_object")
    fn_glGetArrayObjectivATI glGetArrayObjectivATI;
    alias fn_glGetAttachedObjectsARB = extern(System) void function(GLhandleARB containerObj, GLsizei maxCount, GLsizei* count, GLhandleARB* obj) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glGetAttachedObjectsARB glGetAttachedObjectsARB;
    alias fn_glGetAttribLocationARB = extern(System) GLint function(GLhandleARB programObj, const( GLcharARB*) name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_shader")
    fn_glGetAttribLocationARB glGetAttribLocationARB;
    alias fn_glGetBooleanIndexedvEXT = extern(System) void function(GLenum target, GLuint index, GLboolean* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetBooleanIndexedvEXT glGetBooleanIndexedvEXT;
    alias fn_glGetBooleani_v = extern(System) void function(GLenum target, GLuint index, GLboolean* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glGetBooleani_v glGetBooleani_v;
    alias fn_glGetBufferParameterivARB = extern(System) void function(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_buffer_object")
    fn_glGetBufferParameterivARB glGetBufferParameterivARB;
    alias fn_glGetBufferParameterui64vNV = extern(System) void function(GLenum target, GLenum pname, GLuint64EXT* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    fn_glGetBufferParameterui64vNV glGetBufferParameterui64vNV;
    alias fn_glGetBufferPointervARB = extern(System) void function(GLenum target, GLenum pname, void** params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_buffer_object")
    fn_glGetBufferPointervARB glGetBufferPointervARB;
    alias fn_glGetBufferPointervOES = extern(System) void function(GLenum target, GLenum pname, void** params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_mapbuffer")
    fn_glGetBufferPointervOES glGetBufferPointervOES;
    alias fn_glGetBufferSubDataARB = extern(System) void function(GLenum target, GLintptrARB offset, GLsizeiptrARB size, void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_buffer_object")
    fn_glGetBufferSubDataARB glGetBufferSubDataARB;
    alias fn_glGetClipPlanef = extern(System) void function(GLenum plane, GLfloat* equation) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glGetClipPlanef glGetClipPlanef;
    alias fn_glGetClipPlanefOES = extern(System) void function(GLenum plane, GLfloat* equation) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_single_precision")
    fn_glGetClipPlanefOES glGetClipPlanefOES;
    alias fn_glGetClipPlanex = extern(System) void function(GLenum plane, GLfixed* equation) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glGetClipPlanex glGetClipPlanex;
    alias fn_glGetClipPlanexOES = extern(System) void function(GLenum plane, GLfixed* equation) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glGetClipPlanexOES glGetClipPlanexOES;
    alias fn_glGetColorTableEXT = extern(System) void function(GLenum target, GLenum format, GLenum type, void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_paletted_texture")
    fn_glGetColorTableEXT glGetColorTableEXT;
    alias fn_glGetColorTableParameterfvEXT = extern(System) void function(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_paletted_texture")
    fn_glGetColorTableParameterfvEXT glGetColorTableParameterfvEXT;
    alias fn_glGetColorTableParameterfvSGI = extern(System) void function(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGI_color_table")
    fn_glGetColorTableParameterfvSGI glGetColorTableParameterfvSGI;
    alias fn_glGetColorTableParameterivEXT = extern(System) void function(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_paletted_texture")
    fn_glGetColorTableParameterivEXT glGetColorTableParameterivEXT;
    alias fn_glGetColorTableParameterivSGI = extern(System) void function(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGI_color_table")
    fn_glGetColorTableParameterivSGI glGetColorTableParameterivSGI;
    alias fn_glGetColorTableSGI = extern(System) void function(GLenum target, GLenum format, GLenum type, void* table) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGI_color_table")
    fn_glGetColorTableSGI glGetColorTableSGI;
    alias fn_glGetCombinerInputParameterfvNV = extern(System) void function(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    fn_glGetCombinerInputParameterfvNV glGetCombinerInputParameterfvNV;
    alias fn_glGetCombinerInputParameterivNV = extern(System) void function(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    fn_glGetCombinerInputParameterivNV glGetCombinerInputParameterivNV;
    alias fn_glGetCombinerOutputParameterfvNV = extern(System) void function(GLenum stage, GLenum portion, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    fn_glGetCombinerOutputParameterfvNV glGetCombinerOutputParameterfvNV;
    alias fn_glGetCombinerOutputParameterivNV = extern(System) void function(GLenum stage, GLenum portion, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    fn_glGetCombinerOutputParameterivNV glGetCombinerOutputParameterivNV;
    alias fn_glGetCombinerStageParameterfvNV = extern(System) void function(GLenum stage, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners2")
    fn_glGetCombinerStageParameterfvNV glGetCombinerStageParameterfvNV;
    alias fn_glGetCommandHeaderNV = extern(System) GLuint function(GLenum tokenID, GLuint size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    fn_glGetCommandHeaderNV glGetCommandHeaderNV;
    alias fn_glGetCompressedMultiTexImageEXT = extern(System) void function(GLenum texunit, GLenum target, GLint lod, void* img) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetCompressedMultiTexImageEXT glGetCompressedMultiTexImageEXT;
    alias fn_glGetCompressedTexImageARB = extern(System) void function(GLenum target, GLint level, void* img) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_texture_compression")
    fn_glGetCompressedTexImageARB glGetCompressedTexImageARB;
    alias fn_glGetCompressedTextureImageEXT = extern(System) void function(GLuint texture, GLenum target, GLint lod, void* img) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetCompressedTextureImageEXT glGetCompressedTextureImageEXT;
    alias fn_glGetConvolutionFilterEXT = extern(System) void function(GLenum target, GLenum format, GLenum type, void* image) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    fn_glGetConvolutionFilterEXT glGetConvolutionFilterEXT;
    alias fn_glGetConvolutionParameterfvEXT = extern(System) void function(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    fn_glGetConvolutionParameterfvEXT glGetConvolutionParameterfvEXT;
    alias fn_glGetConvolutionParameterivEXT = extern(System) void function(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    fn_glGetConvolutionParameterivEXT glGetConvolutionParameterivEXT;
    alias fn_glGetConvolutionParameterxvOES = extern(System) void function(GLenum target, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glGetConvolutionParameterxvOES glGetConvolutionParameterxvOES;
    alias fn_glGetCoverageModulationTableNV = extern(System) void function(GLsizei bufsize, GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_framebuffer_mixed_samples")
    fn_glGetCoverageModulationTableNV glGetCoverageModulationTableNV;
    alias fn_glGetDebugMessageLogAMD = extern(System) GLuint function(GLuint count, GLsizei bufsize, GLenum* categories, GLuint* severities, GLuint* ids, GLsizei* lengths, GLchar* message) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_debug_output")
    fn_glGetDebugMessageLogAMD glGetDebugMessageLogAMD;
    alias fn_glGetDebugMessageLogARB = extern(System) GLuint function(GLuint count, GLsizei bufSize, GLenum* sources, GLenum* types, GLuint* ids, GLenum* severities, GLsizei* lengths, GLchar* messageLog) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_debug_output")
    fn_glGetDebugMessageLogARB glGetDebugMessageLogARB;
    alias fn_glGetDebugMessageLogKHR = extern(System) GLuint function(GLuint count, GLsizei bufSize, GLenum* sources, GLenum* types, GLuint* ids, GLenum* severities, GLsizei* lengths, GLchar* messageLog) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_debug")
    fn_glGetDebugMessageLogKHR glGetDebugMessageLogKHR;
    alias fn_glGetDetailTexFuncSGIS = extern(System) void function(GLenum target, GLfloat* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_detail_texture")
    fn_glGetDetailTexFuncSGIS glGetDetailTexFuncSGIS;
    alias fn_glGetDoubleIndexedvEXT = extern(System) void function(GLenum target, GLuint index, GLdouble* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetDoubleIndexedvEXT glGetDoubleIndexedvEXT;
    alias fn_glGetDoublei_v = extern(System) void function(GLenum target, GLuint index, GLdouble* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_viewport_array")
    fn_glGetDoublei_v glGetDoublei_v;
    alias fn_glGetDoublei_vEXT = extern(System) void function(GLenum pname, GLuint index, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetDoublei_vEXT glGetDoublei_vEXT;
    alias fn_glGetDoublev = extern(System) void function(GLenum pname, GLdouble* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glGetDoublev glGetDoublev;
    alias fn_glGetDriverControlStringQCOM = extern(System) void function(GLuint driverControl, GLsizei bufSize, GLsizei* length, GLchar* driverControlString) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_driver_control")
    fn_glGetDriverControlStringQCOM glGetDriverControlStringQCOM;
    alias fn_glGetDriverControlsQCOM = extern(System) void function(GLint* num, GLsizei size, GLuint* driverControls) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_driver_control")
    fn_glGetDriverControlsQCOM glGetDriverControlsQCOM;
    alias fn_glGetFenceivNV = extern(System) void function(GLuint fence, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fence")
    fn_glGetFenceivNV glGetFenceivNV;
    alias fn_glGetFinalCombinerInputParameterfvNV = extern(System) void function(GLenum variable, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    fn_glGetFinalCombinerInputParameterfvNV glGetFinalCombinerInputParameterfvNV;
    alias fn_glGetFinalCombinerInputParameterivNV = extern(System) void function(GLenum variable, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_register_combiners")
    fn_glGetFinalCombinerInputParameterivNV glGetFinalCombinerInputParameterivNV;
    alias fn_glGetFirstPerfQueryIdINTEL = extern(System) void function(GLuint* queryId) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_performance_query")
    fn_glGetFirstPerfQueryIdINTEL glGetFirstPerfQueryIdINTEL;
    alias fn_glGetFixedv = extern(System) void function(GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glGetFixedv glGetFixedv;
    alias fn_glGetFixedvOES = extern(System) void function(GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glGetFixedvOES glGetFixedvOES;
    alias fn_glGetFloatIndexedvEXT = extern(System) void function(GLenum target, GLuint index, GLfloat* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetFloatIndexedvEXT glGetFloatIndexedvEXT;
    alias fn_glGetFloati_v = extern(System) void function(GLenum target, GLuint index, GLfloat* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_viewport_array")
    fn_glGetFloati_v glGetFloati_v;
    alias fn_glGetFloati_vEXT = extern(System) void function(GLenum pname, GLuint index, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetFloati_vEXT glGetFloati_vEXT;
    alias fn_glGetFloati_vNV = extern(System) void function(GLenum target, GLuint index, GLfloat* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_array")
    fn_glGetFloati_vNV glGetFloati_vNV;
    alias fn_glGetFloati_vOES = extern(System) void function(GLenum target, GLuint index, GLfloat* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_viewport_array")
    fn_glGetFloati_vOES glGetFloati_vOES;
    alias fn_glGetFloatv = extern(System) void function(GLenum pname, GLfloat* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glGetFloatv glGetFloatv;
    alias fn_glGetFogFuncSGIS = extern(System) void function(GLfloat* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_fog_function")
    fn_glGetFogFuncSGIS glGetFogFuncSGIS;
    alias fn_glGetFragDataIndexEXT = extern(System) GLint function(GLuint program, const( GLchar*) name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_blend_func_extended")
    fn_glGetFragDataIndexEXT glGetFragDataIndexEXT;
    alias fn_glGetFragDataLocationEXT = extern(System) GLint function(GLuint program, const( GLchar*) name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_gpu_shader4")
    fn_glGetFragDataLocationEXT glGetFragDataLocationEXT;
    alias fn_glGetFragmentLightfvSGIX = extern(System) void function(GLenum light, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    fn_glGetFragmentLightfvSGIX glGetFragmentLightfvSGIX;
    alias fn_glGetFragmentLightivSGIX = extern(System) void function(GLenum light, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    fn_glGetFragmentLightivSGIX glGetFragmentLightivSGIX;
    alias fn_glGetFragmentMaterialfvSGIX = extern(System) void function(GLenum face, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    fn_glGetFragmentMaterialfvSGIX glGetFragmentMaterialfvSGIX;
    alias fn_glGetFragmentMaterialivSGIX = extern(System) void function(GLenum face, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    fn_glGetFragmentMaterialivSGIX glGetFragmentMaterialivSGIX;
    alias fn_glGetFramebufferAttachmentParameterivEXT = extern(System) void function(GLenum target, GLenum attachment, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    fn_glGetFramebufferAttachmentParameterivEXT glGetFramebufferAttachmentParameterivEXT;
    alias fn_glGetFramebufferAttachmentParameterivOES = extern(System) void function(GLenum target, GLenum attachment, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    fn_glGetFramebufferAttachmentParameterivOES glGetFramebufferAttachmentParameterivOES;
    alias fn_glGetFramebufferParameterivEXT = extern(System) void function(GLuint framebuffer, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetFramebufferParameterivEXT glGetFramebufferParameterivEXT;
    alias fn_glGetFramebufferPixelLocalStorageSizeEXT = extern(System) GLsizei function(GLuint target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_shader_pixel_local_storage2")
    fn_glGetFramebufferPixelLocalStorageSizeEXT glGetFramebufferPixelLocalStorageSizeEXT;
    alias fn_glGetGraphicsResetStatusARB = extern(System) GLenum function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    fn_glGetGraphicsResetStatusARB glGetGraphicsResetStatusARB;
    alias fn_glGetGraphicsResetStatusEXT = extern(System) GLenum function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_robustness")
    fn_glGetGraphicsResetStatusEXT glGetGraphicsResetStatusEXT;
    alias fn_glGetGraphicsResetStatusKHR = extern(System) GLenum function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_robustness")
    fn_glGetGraphicsResetStatusKHR glGetGraphicsResetStatusKHR;
    alias fn_glGetHandleARB = extern(System) GLhandleARB function(GLenum pname) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glGetHandleARB glGetHandleARB;
    alias fn_glGetHistogramEXT = extern(System) void function(GLenum target, GLboolean reset, GLenum format, GLenum type, void* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_histogram")
    fn_glGetHistogramEXT glGetHistogramEXT;
    alias fn_glGetHistogramParameterfvEXT = extern(System) void function(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_histogram")
    fn_glGetHistogramParameterfvEXT glGetHistogramParameterfvEXT;
    alias fn_glGetHistogramParameterivEXT = extern(System) void function(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_histogram")
    fn_glGetHistogramParameterivEXT glGetHistogramParameterivEXT;
    alias fn_glGetHistogramParameterxvOES = extern(System) void function(GLenum target, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glGetHistogramParameterxvOES glGetHistogramParameterxvOES;
    alias fn_glGetImageHandleARB = extern(System) GLuint64 function(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    fn_glGetImageHandleARB glGetImageHandleARB;
    alias fn_glGetImageHandleNV = extern(System) GLuint64 function(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    fn_glGetImageHandleNV glGetImageHandleNV;
    alias fn_glGetImageTransformParameterfvHP = extern(System) void function(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_HP_image_transform")
    fn_glGetImageTransformParameterfvHP glGetImageTransformParameterfvHP;
    alias fn_glGetImageTransformParameterivHP = extern(System) void function(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_HP_image_transform")
    fn_glGetImageTransformParameterivHP glGetImageTransformParameterivHP;
    alias fn_glGetInfoLogARB = extern(System) void function(GLhandleARB obj, GLsizei maxLength, GLsizei* length, GLcharARB* infoLog) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glGetInfoLogARB glGetInfoLogARB;
    alias fn_glGetInstrumentsSGIX = extern(System) GLint function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_instruments")
    fn_glGetInstrumentsSGIX glGetInstrumentsSGIX;
    alias fn_glGetInteger64i_v = extern(System) void function(GLenum target, GLuint index, GLint64* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    fn_glGetInteger64i_v glGetInteger64i_v;
    alias fn_glGetInteger64v = extern(System) void function(GLenum pname, GLint64* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P2)
    @OpenGL_Extension("GL_ARB_sync")
    fn_glGetInteger64v glGetInteger64v;
    alias fn_glGetInteger64vAPPLE = extern(System) void function(GLenum pname, GLint64* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_sync")
    fn_glGetInteger64vAPPLE glGetInteger64vAPPLE;
    alias fn_glGetIntegerIndexedvEXT = extern(System) void function(GLenum target, GLuint index, GLint* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetIntegerIndexedvEXT glGetIntegerIndexedvEXT;
    alias fn_glGetIntegeri_v = extern(System) void function(GLenum target, GLuint index, GLint* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    @OpenGL_Extension("GL_ARB_uniform_buffer_object")
    fn_glGetIntegeri_v glGetIntegeri_v;
    alias fn_glGetIntegeri_vEXT = extern(System) void function(GLenum target, GLuint index, GLint* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_multiview_draw_buffers")
    fn_glGetIntegeri_vEXT glGetIntegeri_vEXT;
    alias fn_glGetIntegerui64i_vNV = extern(System) void function(GLenum value, GLuint index, GLuint64EXT* result) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_buffer_unified_memory")
    fn_glGetIntegerui64i_vNV glGetIntegerui64i_vNV;
    alias fn_glGetIntegerui64vNV = extern(System) void function(GLenum value, GLuint64EXT* result) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    fn_glGetIntegerui64vNV glGetIntegerui64vNV;
    alias fn_glGetIntegerv = extern(System) void function(GLenum pname, GLint* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glGetIntegerv glGetIntegerv;
    alias fn_glGetInternalformatSampleivNV = extern(System) void function(GLenum target, GLenum internalformat, GLsizei samples, GLenum pname, GLsizei bufSize, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_internalformat_sample_query")
    fn_glGetInternalformatSampleivNV glGetInternalformatSampleivNV;
    alias fn_glGetInvariantBooleanvEXT = extern(System) void function(GLuint id, GLenum value, GLboolean* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glGetInvariantBooleanvEXT glGetInvariantBooleanvEXT;
    alias fn_glGetInvariantFloatvEXT = extern(System) void function(GLuint id, GLenum value, GLfloat* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glGetInvariantFloatvEXT glGetInvariantFloatvEXT;
    alias fn_glGetInvariantIntegervEXT = extern(System) void function(GLuint id, GLenum value, GLint* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glGetInvariantIntegervEXT glGetInvariantIntegervEXT;
    alias fn_glGetLightxOES = extern(System) void function(GLenum light, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glGetLightxOES glGetLightxOES;
    alias fn_glGetLightxv = extern(System) void function(GLenum light, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glGetLightxv glGetLightxv;
    alias fn_glGetLightxvOES = extern(System) void function(GLenum light, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glGetLightxvOES glGetLightxvOES;
    alias fn_glGetListParameterfvSGIX = extern(System) void function(GLuint list, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_list_priority")
    fn_glGetListParameterfvSGIX glGetListParameterfvSGIX;
    alias fn_glGetListParameterivSGIX = extern(System) void function(GLuint list, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_list_priority")
    fn_glGetListParameterivSGIX glGetListParameterivSGIX;
    alias fn_glGetLocalConstantBooleanvEXT = extern(System) void function(GLuint id, GLenum value, GLboolean* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glGetLocalConstantBooleanvEXT glGetLocalConstantBooleanvEXT;
    alias fn_glGetLocalConstantFloatvEXT = extern(System) void function(GLuint id, GLenum value, GLfloat* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glGetLocalConstantFloatvEXT glGetLocalConstantFloatvEXT;
    alias fn_glGetLocalConstantIntegervEXT = extern(System) void function(GLuint id, GLenum value, GLint* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glGetLocalConstantIntegervEXT glGetLocalConstantIntegervEXT;
    alias fn_glGetMapAttribParameterfvNV = extern(System) void function(GLenum target, GLuint index, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_evaluators")
    fn_glGetMapAttribParameterfvNV glGetMapAttribParameterfvNV;
    alias fn_glGetMapAttribParameterivNV = extern(System) void function(GLenum target, GLuint index, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_evaluators")
    fn_glGetMapAttribParameterivNV glGetMapAttribParameterivNV;
    alias fn_glGetMapControlPointsNV = extern(System) void function(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, void* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_evaluators")
    fn_glGetMapControlPointsNV glGetMapControlPointsNV;
    alias fn_glGetMapParameterfvNV = extern(System) void function(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_evaluators")
    fn_glGetMapParameterfvNV glGetMapParameterfvNV;
    alias fn_glGetMapParameterivNV = extern(System) void function(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_evaluators")
    fn_glGetMapParameterivNV glGetMapParameterivNV;
    alias fn_glGetMapxvOES = extern(System) void function(GLenum target, GLenum query, GLfixed* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glGetMapxvOES glGetMapxvOES;
    alias fn_glGetMaterialxOES = extern(System) void function(GLenum face, GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glGetMaterialxOES glGetMaterialxOES;
    alias fn_glGetMaterialxv = extern(System) void function(GLenum face, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glGetMaterialxv glGetMaterialxv;
    alias fn_glGetMaterialxvOES = extern(System) void function(GLenum face, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glGetMaterialxvOES glGetMaterialxvOES;
    alias fn_glGetMinmaxEXT = extern(System) void function(GLenum target, GLboolean reset, GLenum format, GLenum type, void* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_histogram")
    fn_glGetMinmaxEXT glGetMinmaxEXT;
    alias fn_glGetMinmaxParameterfvEXT = extern(System) void function(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_histogram")
    fn_glGetMinmaxParameterfvEXT glGetMinmaxParameterfvEXT;
    alias fn_glGetMinmaxParameterivEXT = extern(System) void function(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_histogram")
    fn_glGetMinmaxParameterivEXT glGetMinmaxParameterivEXT;
    alias fn_glGetMultiTexEnvfvEXT = extern(System) void function(GLenum texunit, GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetMultiTexEnvfvEXT glGetMultiTexEnvfvEXT;
    alias fn_glGetMultiTexEnvivEXT = extern(System) void function(GLenum texunit, GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetMultiTexEnvivEXT glGetMultiTexEnvivEXT;
    alias fn_glGetMultiTexGendvEXT = extern(System) void function(GLenum texunit, GLenum coord, GLenum pname, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetMultiTexGendvEXT glGetMultiTexGendvEXT;
    alias fn_glGetMultiTexGenfvEXT = extern(System) void function(GLenum texunit, GLenum coord, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetMultiTexGenfvEXT glGetMultiTexGenfvEXT;
    alias fn_glGetMultiTexGenivEXT = extern(System) void function(GLenum texunit, GLenum coord, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetMultiTexGenivEXT glGetMultiTexGenivEXT;
    alias fn_glGetMultiTexImageEXT = extern(System) void function(GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetMultiTexImageEXT glGetMultiTexImageEXT;
    alias fn_glGetMultiTexLevelParameterfvEXT = extern(System) void function(GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetMultiTexLevelParameterfvEXT glGetMultiTexLevelParameterfvEXT;
    alias fn_glGetMultiTexLevelParameterivEXT = extern(System) void function(GLenum texunit, GLenum target, GLint level, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetMultiTexLevelParameterivEXT glGetMultiTexLevelParameterivEXT;
    alias fn_glGetMultiTexParameterIivEXT = extern(System) void function(GLenum texunit, GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetMultiTexParameterIivEXT glGetMultiTexParameterIivEXT;
    alias fn_glGetMultiTexParameterIuivEXT = extern(System) void function(GLenum texunit, GLenum target, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetMultiTexParameterIuivEXT glGetMultiTexParameterIuivEXT;
    alias fn_glGetMultiTexParameterfvEXT = extern(System) void function(GLenum texunit, GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetMultiTexParameterfvEXT glGetMultiTexParameterfvEXT;
    alias fn_glGetMultiTexParameterivEXT = extern(System) void function(GLenum texunit, GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetMultiTexParameterivEXT glGetMultiTexParameterivEXT;
    alias fn_glGetMultisamplefvNV = extern(System) void function(GLenum pname, GLuint index, GLfloat* val) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_explicit_multisample")
    fn_glGetMultisamplefvNV glGetMultisamplefvNV;
    alias fn_glGetNamedBufferParameterivEXT = extern(System) void function(GLuint buffer, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetNamedBufferParameterivEXT glGetNamedBufferParameterivEXT;
    alias fn_glGetNamedBufferParameterui64vNV = extern(System) void function(GLuint buffer, GLenum pname, GLuint64EXT* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    fn_glGetNamedBufferParameterui64vNV glGetNamedBufferParameterui64vNV;
    alias fn_glGetNamedBufferPointervEXT = extern(System) void function(GLuint buffer, GLenum pname, void** params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetNamedBufferPointervEXT glGetNamedBufferPointervEXT;
    alias fn_glGetNamedBufferSubDataEXT = extern(System) void function(GLuint buffer, GLintptr offset, GLsizeiptr size, void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetNamedBufferSubDataEXT glGetNamedBufferSubDataEXT;
    alias fn_glGetNamedFramebufferAttachmentParameterivEXT = extern(System) void function(GLuint framebuffer, GLenum attachment, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetNamedFramebufferAttachmentParameterivEXT glGetNamedFramebufferAttachmentParameterivEXT;
    alias fn_glGetNamedFramebufferParameterivEXT = extern(System) void function(GLuint framebuffer, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetNamedFramebufferParameterivEXT glGetNamedFramebufferParameterivEXT;
    alias fn_glGetNamedProgramLocalParameterIivEXT = extern(System) void function(GLuint program, GLenum target, GLuint index, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetNamedProgramLocalParameterIivEXT glGetNamedProgramLocalParameterIivEXT;
    alias fn_glGetNamedProgramLocalParameterIuivEXT = extern(System) void function(GLuint program, GLenum target, GLuint index, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetNamedProgramLocalParameterIuivEXT glGetNamedProgramLocalParameterIuivEXT;
    alias fn_glGetNamedProgramLocalParameterdvEXT = extern(System) void function(GLuint program, GLenum target, GLuint index, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetNamedProgramLocalParameterdvEXT glGetNamedProgramLocalParameterdvEXT;
    alias fn_glGetNamedProgramLocalParameterfvEXT = extern(System) void function(GLuint program, GLenum target, GLuint index, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetNamedProgramLocalParameterfvEXT glGetNamedProgramLocalParameterfvEXT;
    alias fn_glGetNamedProgramStringEXT = extern(System) void function(GLuint program, GLenum target, GLenum pname, void* string) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetNamedProgramStringEXT glGetNamedProgramStringEXT;
    alias fn_glGetNamedProgramivEXT = extern(System) void function(GLuint program, GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetNamedProgramivEXT glGetNamedProgramivEXT;
    alias fn_glGetNamedRenderbufferParameterivEXT = extern(System) void function(GLuint renderbuffer, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetNamedRenderbufferParameterivEXT glGetNamedRenderbufferParameterivEXT;
    alias fn_glGetNamedStringARB = extern(System) void function(GLint namelen, const( GLchar*) name, GLsizei bufSize, GLint* stringlen, GLchar* string) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shading_language_include")
    fn_glGetNamedStringARB glGetNamedStringARB;
    alias fn_glGetNamedStringivARB = extern(System) void function(GLint namelen, const( GLchar*) name, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shading_language_include")
    fn_glGetNamedStringivARB glGetNamedStringivARB;
    alias fn_glGetNextPerfQueryIdINTEL = extern(System) void function(GLuint queryId, GLuint* nextQueryId) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_performance_query")
    fn_glGetNextPerfQueryIdINTEL glGetNextPerfQueryIdINTEL;
    alias fn_glGetObjectBufferfvATI = extern(System) void function(GLuint buffer, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_array_object")
    fn_glGetObjectBufferfvATI glGetObjectBufferfvATI;
    alias fn_glGetObjectBufferivATI = extern(System) void function(GLuint buffer, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_array_object")
    fn_glGetObjectBufferivATI glGetObjectBufferivATI;
    alias fn_glGetObjectLabelEXT = extern(System) void function(GLenum type, GLuint object, GLsizei bufSize, GLsizei* length, GLchar* label) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_debug_label")
    fn_glGetObjectLabelEXT glGetObjectLabelEXT;
    alias fn_glGetObjectLabelKHR = extern(System) void function(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei* length, GLchar* label) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_debug")
    fn_glGetObjectLabelKHR glGetObjectLabelKHR;
    alias fn_glGetObjectParameterfvARB = extern(System) void function(GLhandleARB obj, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glGetObjectParameterfvARB glGetObjectParameterfvARB;
    alias fn_glGetObjectParameterivAPPLE = extern(System) void function(GLenum objectType, GLuint name, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_object_purgeable")
    fn_glGetObjectParameterivAPPLE glGetObjectParameterivAPPLE;
    alias fn_glGetObjectParameterivARB = extern(System) void function(GLhandleARB obj, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glGetObjectParameterivARB glGetObjectParameterivARB;
    alias fn_glGetObjectPtrLabelKHR = extern(System) void function(const( void*) ptr, GLsizei bufSize, GLsizei* length, GLchar* label) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_debug")
    fn_glGetObjectPtrLabelKHR glGetObjectPtrLabelKHR;
    alias fn_glGetOcclusionQueryivNV = extern(System) void function(GLuint id, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_occlusion_query")
    fn_glGetOcclusionQueryivNV glGetOcclusionQueryivNV;
    alias fn_glGetOcclusionQueryuivNV = extern(System) void function(GLuint id, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_occlusion_query")
    fn_glGetOcclusionQueryuivNV glGetOcclusionQueryuivNV;
    alias fn_glGetPathColorGenfvNV = extern(System) void function(GLenum color, GLenum pname, GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glGetPathColorGenfvNV glGetPathColorGenfvNV;
    alias fn_glGetPathColorGenivNV = extern(System) void function(GLenum color, GLenum pname, GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glGetPathColorGenivNV glGetPathColorGenivNV;
    alias fn_glGetPathCommandsNV = extern(System) void function(GLuint path, GLubyte* commands) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glGetPathCommandsNV glGetPathCommandsNV;
    alias fn_glGetPathCoordsNV = extern(System) void function(GLuint path, GLfloat* coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glGetPathCoordsNV glGetPathCoordsNV;
    alias fn_glGetPathDashArrayNV = extern(System) void function(GLuint path, GLfloat* dashArray) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glGetPathDashArrayNV glGetPathDashArrayNV;
    alias fn_glGetPathLengthNV = extern(System) GLfloat function(GLuint path, GLsizei startSegment, GLsizei numSegments) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glGetPathLengthNV glGetPathLengthNV;
    alias fn_glGetPathMetricRangeNV = extern(System) void function(GLbitfield metricQueryMask, GLuint firstPathName, GLsizei numPaths, GLsizei stride, GLfloat* metrics) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glGetPathMetricRangeNV glGetPathMetricRangeNV;
    alias fn_glGetPathMetricsNV = extern(System) void function(GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const( void*) paths, GLuint pathBase, GLsizei stride, GLfloat* metrics) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glGetPathMetricsNV glGetPathMetricsNV;
    alias fn_glGetPathParameterfvNV = extern(System) void function(GLuint path, GLenum pname, GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glGetPathParameterfvNV glGetPathParameterfvNV;
    alias fn_glGetPathParameterivNV = extern(System) void function(GLuint path, GLenum pname, GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glGetPathParameterivNV glGetPathParameterivNV;
    alias fn_glGetPathSpacingNV = extern(System) void function(GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const( void*) paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat* returnedSpacing) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glGetPathSpacingNV glGetPathSpacingNV;
    alias fn_glGetPathTexGenfvNV = extern(System) void function(GLenum texCoordSet, GLenum pname, GLfloat* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glGetPathTexGenfvNV glGetPathTexGenfvNV;
    alias fn_glGetPathTexGenivNV = extern(System) void function(GLenum texCoordSet, GLenum pname, GLint* value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glGetPathTexGenivNV glGetPathTexGenivNV;
    alias fn_glGetPerfCounterInfoINTEL = extern(System) void function(GLuint queryId, GLuint counterId, GLuint counterNameLength, GLchar* counterName, GLuint counterDescLength, GLchar* counterDesc, GLuint* counterOffset, GLuint* counterDataSize, GLuint* counterTypeEnum, GLuint* counterDataTypeEnum, GLuint64* rawCounterMaxValue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_performance_query")
    fn_glGetPerfCounterInfoINTEL glGetPerfCounterInfoINTEL;
    alias fn_glGetPerfMonitorCounterDataAMD = extern(System) void function(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint* data, GLint* bytesWritten) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_performance_monitor")
    fn_glGetPerfMonitorCounterDataAMD glGetPerfMonitorCounterDataAMD;
    alias fn_glGetPerfMonitorCounterInfoAMD = extern(System) void function(GLuint group, GLuint counter, GLenum pname, void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_performance_monitor")
    fn_glGetPerfMonitorCounterInfoAMD glGetPerfMonitorCounterInfoAMD;
    alias fn_glGetPerfMonitorCounterStringAMD = extern(System) void function(GLuint group, GLuint counter, GLsizei bufSize, GLsizei* length, GLchar* counterString) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_performance_monitor")
    fn_glGetPerfMonitorCounterStringAMD glGetPerfMonitorCounterStringAMD;
    alias fn_glGetPerfMonitorCountersAMD = extern(System) void function(GLuint group, GLint* numCounters, GLint* maxActiveCounters, GLsizei counterSize, GLuint* counters) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_performance_monitor")
    fn_glGetPerfMonitorCountersAMD glGetPerfMonitorCountersAMD;
    alias fn_glGetPerfMonitorGroupStringAMD = extern(System) void function(GLuint group, GLsizei bufSize, GLsizei* length, GLchar* groupString) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_performance_monitor")
    fn_glGetPerfMonitorGroupStringAMD glGetPerfMonitorGroupStringAMD;
    alias fn_glGetPerfMonitorGroupsAMD = extern(System) void function(GLint* numGroups, GLsizei groupsSize, GLuint* groups) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_performance_monitor")
    fn_glGetPerfMonitorGroupsAMD glGetPerfMonitorGroupsAMD;
    alias fn_glGetPerfQueryDataINTEL = extern(System) void function(GLuint queryHandle, GLuint flags, GLsizei dataSize, GLvoid* data, GLuint* bytesWritten) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_performance_query")
    fn_glGetPerfQueryDataINTEL glGetPerfQueryDataINTEL;
    alias fn_glGetPerfQueryIdByNameINTEL = extern(System) void function(GLchar* queryName, GLuint* queryId) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_performance_query")
    fn_glGetPerfQueryIdByNameINTEL glGetPerfQueryIdByNameINTEL;
    alias fn_glGetPerfQueryInfoINTEL = extern(System) void function(GLuint queryId, GLuint queryNameLength, GLchar* queryName, GLuint* dataSize, GLuint* noCounters, GLuint* noInstances, GLuint* capsMask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_performance_query")
    fn_glGetPerfQueryInfoINTEL glGetPerfQueryInfoINTEL;
    alias fn_glGetPixelMapxv = extern(System) void function(GLenum map, GLint size, GLfixed* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glGetPixelMapxv glGetPixelMapxv;
    alias fn_glGetPixelTexGenParameterfvSGIS = extern(System) void function(GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_pixel_texture")
    fn_glGetPixelTexGenParameterfvSGIS glGetPixelTexGenParameterfvSGIS;
    alias fn_glGetPixelTexGenParameterivSGIS = extern(System) void function(GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_pixel_texture")
    fn_glGetPixelTexGenParameterivSGIS glGetPixelTexGenParameterivSGIS;
    alias fn_glGetPixelTransformParameterfvEXT = extern(System) void function(GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_pixel_transform")
    fn_glGetPixelTransformParameterfvEXT glGetPixelTransformParameterfvEXT;
    alias fn_glGetPixelTransformParameterivEXT = extern(System) void function(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_pixel_transform")
    fn_glGetPixelTransformParameterivEXT glGetPixelTransformParameterivEXT;
    alias fn_glGetPointerIndexedvEXT = extern(System) void function(GLenum target, GLuint index, void** data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetPointerIndexedvEXT glGetPointerIndexedvEXT;
    alias fn_glGetPointeri_vEXT = extern(System) void function(GLenum pname, GLuint index, void** params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetPointeri_vEXT glGetPointeri_vEXT;
    alias fn_glGetPointervEXT = extern(System) void function(GLenum pname, void** params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_array")
    fn_glGetPointervEXT glGetPointervEXT;
    alias fn_glGetPointervKHR = extern(System) void function(GLenum pname, void** params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_debug")
    fn_glGetPointervKHR glGetPointervKHR;
    alias fn_glGetProgramBinaryOES = extern(System) void function(GLuint program, GLsizei bufSize, GLsizei* length, GLenum* binaryFormat, void* binary) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_get_program_binary")
    fn_glGetProgramBinaryOES glGetProgramBinaryOES;
    alias fn_glGetProgramEnvParameterIivNV = extern(System) void function(GLenum target, GLuint index, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    fn_glGetProgramEnvParameterIivNV glGetProgramEnvParameterIivNV;
    alias fn_glGetProgramEnvParameterIuivNV = extern(System) void function(GLenum target, GLuint index, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    fn_glGetProgramEnvParameterIuivNV glGetProgramEnvParameterIuivNV;
    alias fn_glGetProgramEnvParameterdvARB = extern(System) void function(GLenum target, GLuint index, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    fn_glGetProgramEnvParameterdvARB glGetProgramEnvParameterdvARB;
    alias fn_glGetProgramEnvParameterfvARB = extern(System) void function(GLenum target, GLuint index, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    fn_glGetProgramEnvParameterfvARB glGetProgramEnvParameterfvARB;
    alias fn_glGetProgramLocalParameterIivNV = extern(System) void function(GLenum target, GLuint index, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    fn_glGetProgramLocalParameterIivNV glGetProgramLocalParameterIivNV;
    alias fn_glGetProgramLocalParameterIuivNV = extern(System) void function(GLenum target, GLuint index, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    fn_glGetProgramLocalParameterIuivNV glGetProgramLocalParameterIuivNV;
    alias fn_glGetProgramLocalParameterdvARB = extern(System) void function(GLenum target, GLuint index, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    fn_glGetProgramLocalParameterdvARB glGetProgramLocalParameterdvARB;
    alias fn_glGetProgramLocalParameterfvARB = extern(System) void function(GLenum target, GLuint index, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    fn_glGetProgramLocalParameterfvARB glGetProgramLocalParameterfvARB;
    alias fn_glGetProgramNamedParameterdvNV = extern(System) void function(GLuint id, GLsizei len, const(GLubyte)* name, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fragment_program")
    fn_glGetProgramNamedParameterdvNV glGetProgramNamedParameterdvNV;
    alias fn_glGetProgramNamedParameterfvNV = extern(System) void function(GLuint id, GLsizei len, const(GLubyte)* name, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fragment_program")
    fn_glGetProgramNamedParameterfvNV glGetProgramNamedParameterfvNV;
    alias fn_glGetProgramParameterdvNV = extern(System) void function(GLenum target, GLuint index, GLenum pname, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glGetProgramParameterdvNV glGetProgramParameterdvNV;
    alias fn_glGetProgramParameterfvNV = extern(System) void function(GLenum target, GLuint index, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glGetProgramParameterfvNV glGetProgramParameterfvNV;
    alias fn_glGetProgramPipelineInfoLogEXT = extern(System) void function(GLuint pipeline, GLsizei bufSize, GLsizei* length, GLchar* infoLog) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    fn_glGetProgramPipelineInfoLogEXT glGetProgramPipelineInfoLogEXT;
    alias fn_glGetProgramPipelineivEXT = extern(System) void function(GLuint pipeline, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    fn_glGetProgramPipelineivEXT glGetProgramPipelineivEXT;
    alias fn_glGetProgramResourceLocationIndexEXT = extern(System) GLint function(GLuint program, GLenum programInterface, const( GLchar*) name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_blend_func_extended")
    fn_glGetProgramResourceLocationIndexEXT glGetProgramResourceLocationIndexEXT;
    alias fn_glGetProgramResourcefvNV = extern(System) void function(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const( GLenum*) props, GLsizei bufSize, GLsizei* length, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glGetProgramResourcefvNV glGetProgramResourcefvNV;
    alias fn_glGetProgramStringARB = extern(System) void function(GLenum target, GLenum pname, void* string) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    fn_glGetProgramStringARB glGetProgramStringARB;
    alias fn_glGetProgramStringNV = extern(System) void function(GLuint id, GLenum pname, GLubyte* program) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glGetProgramStringNV glGetProgramStringNV;
    alias fn_glGetProgramSubroutineParameteruivNV = extern(System) void function(GLenum target, GLuint index, GLuint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program5")
    fn_glGetProgramSubroutineParameteruivNV glGetProgramSubroutineParameteruivNV;
    alias fn_glGetProgramivARB = extern(System) void function(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    fn_glGetProgramivARB glGetProgramivARB;
    alias fn_glGetProgramivNV = extern(System) void function(GLuint id, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glGetProgramivNV glGetProgramivNV;
    alias fn_glGetQueryBufferObjecti64v = extern(System) void function(GLuint id, GLuint buffer, GLenum pname, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glGetQueryBufferObjecti64v glGetQueryBufferObjecti64v;
    alias fn_glGetQueryBufferObjectiv = extern(System) void function(GLuint id, GLuint buffer, GLenum pname, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glGetQueryBufferObjectiv glGetQueryBufferObjectiv;
    alias fn_glGetQueryBufferObjectui64v = extern(System) void function(GLuint id, GLuint buffer, GLenum pname, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glGetQueryBufferObjectui64v glGetQueryBufferObjectui64v;
    alias fn_glGetQueryBufferObjectuiv = extern(System) void function(GLuint id, GLuint buffer, GLenum pname, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glGetQueryBufferObjectuiv glGetQueryBufferObjectuiv;
    alias fn_glGetQueryObjecti64v = extern(System) void function(GLuint id, GLenum pname, GLint64* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_timer_query")
    fn_glGetQueryObjecti64v glGetQueryObjecti64v;
    alias fn_glGetQueryObjecti64vEXT = extern(System) void function(GLuint id, GLenum pname, GLint64* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_disjoint_timer_query")
    fn_glGetQueryObjecti64vEXT glGetQueryObjecti64vEXT;
    alias fn_glGetQueryObjectivARB = extern(System) void function(GLuint id, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_occlusion_query")
    fn_glGetQueryObjectivARB glGetQueryObjectivARB;
    alias fn_glGetQueryObjectivEXT = extern(System) void function(GLuint id, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_disjoint_timer_query")
    fn_glGetQueryObjectivEXT glGetQueryObjectivEXT;
    alias fn_glGetQueryObjectui64v = extern(System) void function(GLuint id, GLenum pname, GLuint64* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_timer_query")
    fn_glGetQueryObjectui64v glGetQueryObjectui64v;
    alias fn_glGetQueryObjectui64vEXT = extern(System) void function(GLuint id, GLenum pname, GLuint64* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_disjoint_timer_query")
    fn_glGetQueryObjectui64vEXT glGetQueryObjectui64vEXT;
    alias fn_glGetQueryObjectuiv = extern(System) void function(GLuint id, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P5)
    fn_glGetQueryObjectuiv glGetQueryObjectuiv;
    alias fn_glGetQueryObjectuivARB = extern(System) void function(GLuint id, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_occlusion_query")
    fn_glGetQueryObjectuivARB glGetQueryObjectuivARB;
    alias fn_glGetQueryObjectuivEXT = extern(System) void function(GLuint id, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_disjoint_timer_query")
    fn_glGetQueryObjectuivEXT glGetQueryObjectuivEXT;
    alias fn_glGetQueryivARB = extern(System) void function(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_occlusion_query")
    fn_glGetQueryivARB glGetQueryivARB;
    alias fn_glGetQueryivEXT = extern(System) void function(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_disjoint_timer_query")
    fn_glGetQueryivEXT glGetQueryivEXT;
    alias fn_glGetRenderbufferParameterivEXT = extern(System) void function(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    fn_glGetRenderbufferParameterivEXT glGetRenderbufferParameterivEXT;
    alias fn_glGetRenderbufferParameterivOES = extern(System) void function(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    fn_glGetRenderbufferParameterivOES glGetRenderbufferParameterivOES;
    alias fn_glGetSamplerParameterIiv = extern(System) void function(GLuint sampler, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    fn_glGetSamplerParameterIiv glGetSamplerParameterIiv;
    alias fn_glGetSamplerParameterIivEXT = extern(System) void function(GLuint sampler, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_border_clamp")
    fn_glGetSamplerParameterIivEXT glGetSamplerParameterIivEXT;
    alias fn_glGetSamplerParameterIivOES = extern(System) void function(GLuint sampler, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_border_clamp")
    fn_glGetSamplerParameterIivOES glGetSamplerParameterIivOES;
    alias fn_glGetSamplerParameterIuiv = extern(System) void function(GLuint sampler, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    fn_glGetSamplerParameterIuiv glGetSamplerParameterIuiv;
    alias fn_glGetSamplerParameterIuivEXT = extern(System) void function(GLuint sampler, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_border_clamp")
    fn_glGetSamplerParameterIuivEXT glGetSamplerParameterIuivEXT;
    alias fn_glGetSamplerParameterIuivOES = extern(System) void function(GLuint sampler, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_border_clamp")
    fn_glGetSamplerParameterIuivOES glGetSamplerParameterIuivOES;
    alias fn_glGetSamplerParameteriv = extern(System) void function(GLuint sampler, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    fn_glGetSamplerParameteriv glGetSamplerParameteriv;
    alias fn_glGetSeparableFilterEXT = extern(System) void function(GLenum target, GLenum format, GLenum type, void* row, void* column, void* span) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    fn_glGetSeparableFilterEXT glGetSeparableFilterEXT;
    alias fn_glGetShaderSourceARB = extern(System) void function(GLhandleARB obj, GLsizei maxLength, GLsizei* length, GLcharARB* source) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glGetShaderSourceARB glGetShaderSourceARB;
    alias fn_glGetSharpenTexFuncSGIS = extern(System) void function(GLenum target, GLfloat* points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_sharpen_texture")
    fn_glGetSharpenTexFuncSGIS glGetSharpenTexFuncSGIS;
    alias fn_glGetStageIndexNV = extern(System) GLushort function(GLenum shadertype) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    fn_glGetStageIndexNV glGetStageIndexNV;
    alias fn_glGetStringi = extern(System) const(GLubyte)* function(GLenum name, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glGetStringi glGetStringi;
    alias fn_glGetSyncivAPPLE = extern(System) void function(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei* length, GLint* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_sync")
    fn_glGetSyncivAPPLE glGetSyncivAPPLE;
    alias fn_glGetTexBumpParameterfvATI = extern(System) void function(GLenum pname, GLfloat* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_envmap_bumpmap")
    fn_glGetTexBumpParameterfvATI glGetTexBumpParameterfvATI;
    alias fn_glGetTexBumpParameterivATI = extern(System) void function(GLenum pname, GLint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_envmap_bumpmap")
    fn_glGetTexBumpParameterivATI glGetTexBumpParameterivATI;
    alias fn_glGetTexEnvxv = extern(System) void function(GLenum target, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glGetTexEnvxv glGetTexEnvxv;
    alias fn_glGetTexEnvxvOES = extern(System) void function(GLenum target, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glGetTexEnvxvOES glGetTexEnvxvOES;
    alias fn_glGetTexFilterFuncSGIS = extern(System) void function(GLenum target, GLenum filter, GLfloat* weights) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_texture_filter4")
    fn_glGetTexFilterFuncSGIS glGetTexFilterFuncSGIS;
    alias fn_glGetTexGenfvOES = extern(System) void function(GLenum coord, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_cube_map")
    fn_glGetTexGenfvOES glGetTexGenfvOES;
    alias fn_glGetTexGenivOES = extern(System) void function(GLenum coord, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_cube_map")
    fn_glGetTexGenivOES glGetTexGenivOES;
    alias fn_glGetTexGenxvOES = extern(System) void function(GLenum coord, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glGetTexGenxvOES glGetTexGenxvOES;
    alias fn_glGetTexLevelParameterxvOES = extern(System) void function(GLenum target, GLint level, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glGetTexLevelParameterxvOES glGetTexLevelParameterxvOES;
    alias fn_glGetTexParameterIivEXT = extern(System) void function(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_border_clamp")
    fn_glGetTexParameterIivEXT glGetTexParameterIivEXT;
    alias fn_glGetTexParameterIivOES = extern(System) void function(GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_border_clamp")
    fn_glGetTexParameterIivOES glGetTexParameterIivOES;
    alias fn_glGetTexParameterIuivEXT = extern(System) void function(GLenum target, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_border_clamp")
    fn_glGetTexParameterIuivEXT glGetTexParameterIuivEXT;
    alias fn_glGetTexParameterIuivOES = extern(System) void function(GLenum target, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_border_clamp")
    fn_glGetTexParameterIuivOES glGetTexParameterIuivOES;
    alias fn_glGetTexParameterPointervAPPLE = extern(System) void function(GLenum target, GLenum pname, void** params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_texture_range")
    fn_glGetTexParameterPointervAPPLE glGetTexParameterPointervAPPLE;
    alias fn_glGetTexParameterxv = extern(System) void function(GLenum target, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glGetTexParameterxv glGetTexParameterxv;
    alias fn_glGetTexParameterxvOES = extern(System) void function(GLenum target, GLenum pname, GLfixed* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glGetTexParameterxvOES glGetTexParameterxvOES;
    alias fn_glGetTextureHandleARB = extern(System) GLuint64 function(GLuint texture) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    fn_glGetTextureHandleARB glGetTextureHandleARB;
    alias fn_glGetTextureHandleIMG = extern(System) GLuint64 function(GLuint texture) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IMG_bindless_texture")
    fn_glGetTextureHandleIMG glGetTextureHandleIMG;
    alias fn_glGetTextureHandleNV = extern(System) GLuint64 function(GLuint texture) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    fn_glGetTextureHandleNV glGetTextureHandleNV;
    alias fn_glGetTextureImageEXT = extern(System) void function(GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, void* pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetTextureImageEXT glGetTextureImageEXT;
    alias fn_glGetTextureLevelParameterfvEXT = extern(System) void function(GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetTextureLevelParameterfvEXT glGetTextureLevelParameterfvEXT;
    alias fn_glGetTextureLevelParameterivEXT = extern(System) void function(GLuint texture, GLenum target, GLint level, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetTextureLevelParameterivEXT glGetTextureLevelParameterivEXT;
    alias fn_glGetTextureParameterIivEXT = extern(System) void function(GLuint texture, GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetTextureParameterIivEXT glGetTextureParameterIivEXT;
    alias fn_glGetTextureParameterIuivEXT = extern(System) void function(GLuint texture, GLenum target, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetTextureParameterIuivEXT glGetTextureParameterIuivEXT;
    alias fn_glGetTextureParameterfvEXT = extern(System) void function(GLuint texture, GLenum target, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetTextureParameterfvEXT glGetTextureParameterfvEXT;
    alias fn_glGetTextureParameterivEXT = extern(System) void function(GLuint texture, GLenum target, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetTextureParameterivEXT glGetTextureParameterivEXT;
    alias fn_glGetTextureSamplerHandleARB = extern(System) GLuint64 function(GLuint texture, GLuint sampler) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    fn_glGetTextureSamplerHandleARB glGetTextureSamplerHandleARB;
    alias fn_glGetTextureSamplerHandleIMG = extern(System) GLuint64 function(GLuint texture, GLuint sampler) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IMG_bindless_texture")
    fn_glGetTextureSamplerHandleIMG glGetTextureSamplerHandleIMG;
    alias fn_glGetTextureSamplerHandleNV = extern(System) GLuint64 function(GLuint texture, GLuint sampler) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    fn_glGetTextureSamplerHandleNV glGetTextureSamplerHandleNV;
    alias fn_glGetTrackMatrixivNV = extern(System) void function(GLenum target, GLuint address, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glGetTrackMatrixivNV glGetTrackMatrixivNV;
    alias fn_glGetTransformFeedbackVaryingEXT = extern(System) void function(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLsizei* size, GLenum* type, GLchar* name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_transform_feedback")
    fn_glGetTransformFeedbackVaryingEXT glGetTransformFeedbackVaryingEXT;
    alias fn_glGetTransformFeedbackVaryingNV = extern(System) void function(GLuint program, GLuint index, GLint* location) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback")
    fn_glGetTransformFeedbackVaryingNV glGetTransformFeedbackVaryingNV;
    alias fn_glGetTransformFeedbacki64_v = extern(System) void function(GLuint xfb, GLenum pname, GLuint index, GLint64* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glGetTransformFeedbacki64_v glGetTransformFeedbacki64_v;
    alias fn_glGetTransformFeedbacki_v = extern(System) void function(GLuint xfb, GLenum pname, GLuint index, GLint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glGetTransformFeedbacki_v glGetTransformFeedbacki_v;
    alias fn_glGetTranslatedShaderSourceANGLE = extern(System) void function(GLuint shader, GLsizei bufsize, GLsizei* length, GLchar* source) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ANGLE_translated_shader_source")
    fn_glGetTranslatedShaderSourceANGLE glGetTranslatedShaderSourceANGLE;
    alias fn_glGetUniformBufferSizeEXT = extern(System) GLint function(GLuint program, GLint location) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_bindable_uniform")
    fn_glGetUniformBufferSizeEXT glGetUniformBufferSizeEXT;
    alias fn_glGetUniformLocationARB = extern(System) GLint function(GLhandleARB programObj, const( GLcharARB*) name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glGetUniformLocationARB glGetUniformLocationARB;
    alias fn_glGetUniformOffsetEXT = extern(System) GLintptr function(GLuint program, GLint location) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_bindable_uniform")
    fn_glGetUniformOffsetEXT glGetUniformOffsetEXT;
    alias fn_glGetUniformfvARB = extern(System) void function(GLhandleARB programObj, GLint location, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glGetUniformfvARB glGetUniformfvARB;
    alias fn_glGetUniformi64vARB = extern(System) void function(GLuint program, GLint location, GLint64* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    fn_glGetUniformi64vARB glGetUniformi64vARB;
    alias fn_glGetUniformi64vNV = extern(System) void function(GLuint program, GLint location, GLint64EXT* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    fn_glGetUniformi64vNV glGetUniformi64vNV;
    alias fn_glGetUniformivARB = extern(System) void function(GLhandleARB programObj, GLint location, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glGetUniformivARB glGetUniformivARB;
    alias fn_glGetUniformui64vARB = extern(System) void function(GLuint program, GLint location, GLuint64* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    fn_glGetUniformui64vARB glGetUniformui64vARB;
    alias fn_glGetUniformui64vNV = extern(System) void function(GLuint program, GLint location, GLuint64EXT* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    fn_glGetUniformui64vNV glGetUniformui64vNV;
    alias fn_glGetUniformuivEXT = extern(System) void function(GLuint program, GLint location, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_gpu_shader4")
    fn_glGetUniformuivEXT glGetUniformuivEXT;
    alias fn_glGetVariantArrayObjectfvATI = extern(System) void function(GLuint id, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_array_object")
    fn_glGetVariantArrayObjectfvATI glGetVariantArrayObjectfvATI;
    alias fn_glGetVariantArrayObjectivATI = extern(System) void function(GLuint id, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_array_object")
    fn_glGetVariantArrayObjectivATI glGetVariantArrayObjectivATI;
    alias fn_glGetVariantBooleanvEXT = extern(System) void function(GLuint id, GLenum value, GLboolean* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glGetVariantBooleanvEXT glGetVariantBooleanvEXT;
    alias fn_glGetVariantFloatvEXT = extern(System) void function(GLuint id, GLenum value, GLfloat* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glGetVariantFloatvEXT glGetVariantFloatvEXT;
    alias fn_glGetVariantIntegervEXT = extern(System) void function(GLuint id, GLenum value, GLint* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glGetVariantIntegervEXT glGetVariantIntegervEXT;
    alias fn_glGetVariantPointervEXT = extern(System) void function(GLuint id, GLenum value, void** data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glGetVariantPointervEXT glGetVariantPointervEXT;
    alias fn_glGetVaryingLocationNV = extern(System) GLint function(GLuint program, const( GLchar*) name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback")
    fn_glGetVaryingLocationNV glGetVaryingLocationNV;
    alias fn_glGetVertexArrayIndexediv = extern(System) void function(GLuint vaobj, GLuint index, GLenum pname, GLint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glGetVertexArrayIndexediv glGetVertexArrayIndexediv;
    alias fn_glGetVertexArrayIntegeri_vEXT = extern(System) void function(GLuint vaobj, GLuint index, GLenum pname, GLint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetVertexArrayIntegeri_vEXT glGetVertexArrayIntegeri_vEXT;
    alias fn_glGetVertexArrayIntegervEXT = extern(System) void function(GLuint vaobj, GLenum pname, GLint* param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetVertexArrayIntegervEXT glGetVertexArrayIntegervEXT;
    alias fn_glGetVertexArrayPointeri_vEXT = extern(System) void function(GLuint vaobj, GLuint index, GLenum pname, void** param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetVertexArrayPointeri_vEXT glGetVertexArrayPointeri_vEXT;
    alias fn_glGetVertexArrayPointervEXT = extern(System) void function(GLuint vaobj, GLenum pname, void** param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glGetVertexArrayPointervEXT glGetVertexArrayPointervEXT;
    alias fn_glGetVertexAttribArrayObjectfvATI = extern(System) void function(GLuint index, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_attrib_array_object")
    fn_glGetVertexAttribArrayObjectfvATI glGetVertexAttribArrayObjectfvATI;
    alias fn_glGetVertexAttribArrayObjectivATI = extern(System) void function(GLuint index, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_attrib_array_object")
    fn_glGetVertexAttribArrayObjectivATI glGetVertexAttribArrayObjectivATI;
    alias fn_glGetVertexAttribIivEXT = extern(System) void function(GLuint index, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    fn_glGetVertexAttribIivEXT glGetVertexAttribIivEXT;
    alias fn_glGetVertexAttribIuivEXT = extern(System) void function(GLuint index, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    fn_glGetVertexAttribIuivEXT glGetVertexAttribIuivEXT;
    alias fn_glGetVertexAttribLdvEXT = extern(System) void function(GLuint index, GLenum pname, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_attrib_64bit")
    fn_glGetVertexAttribLdvEXT glGetVertexAttribLdvEXT;
    alias fn_glGetVertexAttribLi64vNV = extern(System) void function(GLuint index, GLenum pname, GLint64EXT* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    fn_glGetVertexAttribLi64vNV glGetVertexAttribLi64vNV;
    alias fn_glGetVertexAttribLui64vARB = extern(System) void function(GLuint index, GLenum pname, GLuint64EXT* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    fn_glGetVertexAttribLui64vARB glGetVertexAttribLui64vARB;
    alias fn_glGetVertexAttribLui64vNV = extern(System) void function(GLuint index, GLenum pname, GLuint64EXT* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    fn_glGetVertexAttribLui64vNV glGetVertexAttribLui64vNV;
    alias fn_glGetVertexAttribPointervARB = extern(System) void function(GLuint index, GLenum pname, void** pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glGetVertexAttribPointervARB glGetVertexAttribPointervARB;
    alias fn_glGetVertexAttribPointervNV = extern(System) void function(GLuint index, GLenum pname, void** pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glGetVertexAttribPointervNV glGetVertexAttribPointervNV;
    alias fn_glGetVertexAttribdvARB = extern(System) void function(GLuint index, GLenum pname, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glGetVertexAttribdvARB glGetVertexAttribdvARB;
    alias fn_glGetVertexAttribdvNV = extern(System) void function(GLuint index, GLenum pname, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glGetVertexAttribdvNV glGetVertexAttribdvNV;
    alias fn_glGetVertexAttribfvARB = extern(System) void function(GLuint index, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glGetVertexAttribfvARB glGetVertexAttribfvARB;
    alias fn_glGetVertexAttribfvNV = extern(System) void function(GLuint index, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glGetVertexAttribfvNV glGetVertexAttribfvNV;
    alias fn_glGetVertexAttribivARB = extern(System) void function(GLuint index, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glGetVertexAttribivARB glGetVertexAttribivARB;
    alias fn_glGetVertexAttribivNV = extern(System) void function(GLuint index, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glGetVertexAttribivNV glGetVertexAttribivNV;
    alias fn_glGetVideoCaptureStreamdvNV = extern(System) void function(GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_video_capture")
    fn_glGetVideoCaptureStreamdvNV glGetVideoCaptureStreamdvNV;
    alias fn_glGetVideoCaptureStreamfvNV = extern(System) void function(GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_video_capture")
    fn_glGetVideoCaptureStreamfvNV glGetVideoCaptureStreamfvNV;
    alias fn_glGetVideoCaptureStreamivNV = extern(System) void function(GLuint video_capture_slot, GLuint stream, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_video_capture")
    fn_glGetVideoCaptureStreamivNV glGetVideoCaptureStreamivNV;
    alias fn_glGetVideoCaptureivNV = extern(System) void function(GLuint video_capture_slot, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_video_capture")
    fn_glGetVideoCaptureivNV glGetVideoCaptureivNV;
    alias fn_glGetVideoi64vNV = extern(System) void function(GLuint video_slot, GLenum pname, GLint64EXT* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_present_video")
    fn_glGetVideoi64vNV glGetVideoi64vNV;
    alias fn_glGetVideoivNV = extern(System) void function(GLuint video_slot, GLenum pname, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_present_video")
    fn_glGetVideoivNV glGetVideoivNV;
    alias fn_glGetVideoui64vNV = extern(System) void function(GLuint video_slot, GLenum pname, GLuint64EXT* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_present_video")
    fn_glGetVideoui64vNV glGetVideoui64vNV;
    alias fn_glGetVideouivNV = extern(System) void function(GLuint video_slot, GLenum pname, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_present_video")
    fn_glGetVideouivNV glGetVideouivNV;
    alias fn_glGetnColorTable = extern(System) void function(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void* table) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    fn_glGetnColorTable glGetnColorTable;
    alias fn_glGetnColorTableARB = extern(System) void function(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void* table) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    fn_glGetnColorTableARB glGetnColorTableARB;
    alias fn_glGetnCompressedTexImageARB = extern(System) void function(GLenum target, GLint lod, GLsizei bufSize, void* img) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    fn_glGetnCompressedTexImageARB glGetnCompressedTexImageARB;
    alias fn_glGetnConvolutionFilter = extern(System) void function(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void* image) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    fn_glGetnConvolutionFilter glGetnConvolutionFilter;
    alias fn_glGetnConvolutionFilterARB = extern(System) void function(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void* image) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    fn_glGetnConvolutionFilterARB glGetnConvolutionFilterARB;
    alias fn_glGetnHistogram = extern(System) void function(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    fn_glGetnHistogram glGetnHistogram;
    alias fn_glGetnHistogramARB = extern(System) void function(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    fn_glGetnHistogramARB glGetnHistogramARB;
    alias fn_glGetnMapdv = extern(System) void function(GLenum target, GLenum query, GLsizei bufSize, GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    fn_glGetnMapdv glGetnMapdv;
    alias fn_glGetnMapdvARB = extern(System) void function(GLenum target, GLenum query, GLsizei bufSize, GLdouble* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    fn_glGetnMapdvARB glGetnMapdvARB;
    alias fn_glGetnMapfv = extern(System) void function(GLenum target, GLenum query, GLsizei bufSize, GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    fn_glGetnMapfv glGetnMapfv;
    alias fn_glGetnMapfvARB = extern(System) void function(GLenum target, GLenum query, GLsizei bufSize, GLfloat* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    fn_glGetnMapfvARB glGetnMapfvARB;
    alias fn_glGetnMapiv = extern(System) void function(GLenum target, GLenum query, GLsizei bufSize, GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    fn_glGetnMapiv glGetnMapiv;
    alias fn_glGetnMapivARB = extern(System) void function(GLenum target, GLenum query, GLsizei bufSize, GLint* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    fn_glGetnMapivARB glGetnMapivARB;
    alias fn_glGetnMinmax = extern(System) void function(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    fn_glGetnMinmax glGetnMinmax;
    alias fn_glGetnMinmaxARB = extern(System) void function(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    fn_glGetnMinmaxARB glGetnMinmaxARB;
    alias fn_glGetnPixelMapfv = extern(System) void function(GLenum map, GLsizei bufSize, GLfloat* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    fn_glGetnPixelMapfv glGetnPixelMapfv;
    alias fn_glGetnPixelMapfvARB = extern(System) void function(GLenum map, GLsizei bufSize, GLfloat* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    fn_glGetnPixelMapfvARB glGetnPixelMapfvARB;
    alias fn_glGetnPixelMapuiv = extern(System) void function(GLenum map, GLsizei bufSize, GLuint* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    fn_glGetnPixelMapuiv glGetnPixelMapuiv;
    alias fn_glGetnPixelMapuivARB = extern(System) void function(GLenum map, GLsizei bufSize, GLuint* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    fn_glGetnPixelMapuivARB glGetnPixelMapuivARB;
    alias fn_glGetnPixelMapusv = extern(System) void function(GLenum map, GLsizei bufSize, GLushort* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    fn_glGetnPixelMapusv glGetnPixelMapusv;
    alias fn_glGetnPixelMapusvARB = extern(System) void function(GLenum map, GLsizei bufSize, GLushort* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    fn_glGetnPixelMapusvARB glGetnPixelMapusvARB;
    alias fn_glGetnPolygonStipple = extern(System) void function(GLsizei bufSize, GLubyte* pattern) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    fn_glGetnPolygonStipple glGetnPolygonStipple;
    alias fn_glGetnPolygonStippleARB = extern(System) void function(GLsizei bufSize, GLubyte* pattern) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    fn_glGetnPolygonStippleARB glGetnPolygonStippleARB;
    alias fn_glGetnSeparableFilter = extern(System) void function(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void* row, GLsizei columnBufSize, void* column, void* span) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    fn_glGetnSeparableFilter glGetnSeparableFilter;
    alias fn_glGetnSeparableFilterARB = extern(System) void function(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void* row, GLsizei columnBufSize, void* column, void* span) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    fn_glGetnSeparableFilterARB glGetnSeparableFilterARB;
    alias fn_glGetnTexImageARB = extern(System) void function(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void* img) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    fn_glGetnTexImageARB glGetnTexImageARB;
    alias fn_glGetnUniformdvARB = extern(System) void function(GLuint program, GLint location, GLsizei bufSize, GLdouble* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    fn_glGetnUniformdvARB glGetnUniformdvARB;
    alias fn_glGetnUniformfvARB = extern(System) void function(GLuint program, GLint location, GLsizei bufSize, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    fn_glGetnUniformfvARB glGetnUniformfvARB;
    alias fn_glGetnUniformfvEXT = extern(System) void function(GLuint program, GLint location, GLsizei bufSize, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_robustness")
    fn_glGetnUniformfvEXT glGetnUniformfvEXT;
    alias fn_glGetnUniformfvKHR = extern(System) void function(GLuint program, GLint location, GLsizei bufSize, GLfloat* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_robustness")
    fn_glGetnUniformfvKHR glGetnUniformfvKHR;
    alias fn_glGetnUniformi64vARB = extern(System) void function(GLuint program, GLint location, GLsizei bufSize, GLint64* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    fn_glGetnUniformi64vARB glGetnUniformi64vARB;
    alias fn_glGetnUniformivARB = extern(System) void function(GLuint program, GLint location, GLsizei bufSize, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    fn_glGetnUniformivARB glGetnUniformivARB;
    alias fn_glGetnUniformivEXT = extern(System) void function(GLuint program, GLint location, GLsizei bufSize, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_robustness")
    fn_glGetnUniformivEXT glGetnUniformivEXT;
    alias fn_glGetnUniformivKHR = extern(System) void function(GLuint program, GLint location, GLsizei bufSize, GLint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_robustness")
    fn_glGetnUniformivKHR glGetnUniformivKHR;
    alias fn_glGetnUniformui64vARB = extern(System) void function(GLuint program, GLint location, GLsizei bufSize, GLuint64* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    fn_glGetnUniformui64vARB glGetnUniformui64vARB;
    alias fn_glGetnUniformuivARB = extern(System) void function(GLuint program, GLint location, GLsizei bufSize, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    fn_glGetnUniformuivARB glGetnUniformuivARB;
    alias fn_glGetnUniformuivKHR = extern(System) void function(GLuint program, GLint location, GLsizei bufSize, GLuint* params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_robustness")
    fn_glGetnUniformuivKHR glGetnUniformuivKHR;
    alias fn_glGlobalAlphaFactorbSUN = extern(System) void function(GLbyte factor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_global_alpha")
    fn_glGlobalAlphaFactorbSUN glGlobalAlphaFactorbSUN;
    alias fn_glGlobalAlphaFactordSUN = extern(System) void function(GLdouble factor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_global_alpha")
    fn_glGlobalAlphaFactordSUN glGlobalAlphaFactordSUN;
    alias fn_glGlobalAlphaFactorfSUN = extern(System) void function(GLfloat factor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_global_alpha")
    fn_glGlobalAlphaFactorfSUN glGlobalAlphaFactorfSUN;
    alias fn_glGlobalAlphaFactoriSUN = extern(System) void function(GLint factor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_global_alpha")
    fn_glGlobalAlphaFactoriSUN glGlobalAlphaFactoriSUN;
    alias fn_glGlobalAlphaFactorsSUN = extern(System) void function(GLshort factor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_global_alpha")
    fn_glGlobalAlphaFactorsSUN glGlobalAlphaFactorsSUN;
    alias fn_glGlobalAlphaFactorubSUN = extern(System) void function(GLubyte factor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_global_alpha")
    fn_glGlobalAlphaFactorubSUN glGlobalAlphaFactorubSUN;
    alias fn_glGlobalAlphaFactoruiSUN = extern(System) void function(GLuint factor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_global_alpha")
    fn_glGlobalAlphaFactoruiSUN glGlobalAlphaFactoruiSUN;
    alias fn_glGlobalAlphaFactorusSUN = extern(System) void function(GLushort factor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_global_alpha")
    fn_glGlobalAlphaFactorusSUN glGlobalAlphaFactorusSUN;
    alias fn_glHintPGI = extern(System) void function(GLenum target, GLint mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_PGI_misc_hints")
    fn_glHintPGI glHintPGI;
    alias fn_glHistogramEXT = extern(System) void function(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_histogram")
    fn_glHistogramEXT glHistogramEXT;
    alias fn_glIglooInterfaceSGIX = extern(System) void function(GLenum pname, const( void*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_igloo_interface")
    fn_glIglooInterfaceSGIX glIglooInterfaceSGIX;
    alias fn_glImageTransformParameterfHP = extern(System) void function(GLenum target, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_HP_image_transform")
    fn_glImageTransformParameterfHP glImageTransformParameterfHP;
    alias fn_glImageTransformParameterfvHP = extern(System) void function(GLenum target, GLenum pname, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_HP_image_transform")
    fn_glImageTransformParameterfvHP glImageTransformParameterfvHP;
    alias fn_glImageTransformParameteriHP = extern(System) void function(GLenum target, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_HP_image_transform")
    fn_glImageTransformParameteriHP glImageTransformParameteriHP;
    alias fn_glImageTransformParameterivHP = extern(System) void function(GLenum target, GLenum pname, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_HP_image_transform")
    fn_glImageTransformParameterivHP glImageTransformParameterivHP;
    alias fn_glImportSyncEXT = extern(System) GLsync function(GLenum external_sync_type, GLintptr external_sync, GLbitfield flags) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_x11_sync_object")
    fn_glImportSyncEXT glImportSyncEXT;
    alias fn_glIndexFormatNV = extern(System) void function(GLenum type, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_buffer_unified_memory")
    fn_glIndexFormatNV glIndexFormatNV;
    alias fn_glIndexFuncEXT = extern(System) void function(GLenum func, GLclampf ref_) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_index_func")
    fn_glIndexFuncEXT glIndexFuncEXT;
    alias fn_glIndexMaterialEXT = extern(System) void function(GLenum face, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_index_material")
    fn_glIndexMaterialEXT glIndexMaterialEXT;
    alias fn_glIndexPointerEXT = extern(System) void function(GLenum type, GLsizei stride, GLsizei count, const( void*) pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_array")
    fn_glIndexPointerEXT glIndexPointerEXT;
    alias fn_glIndexPointerListIBM = extern(System) void function(GLenum type, GLint stride, const( void**) pointer, GLint ptrstride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IBM_vertex_array_lists")
    fn_glIndexPointerListIBM glIndexPointerListIBM;
    alias fn_glIndexxOES = extern(System) void function(GLfixed component) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glIndexxOES glIndexxOES;
    alias fn_glIndexxvOES = extern(System) void function(const( GLfixed*) component) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glIndexxvOES glIndexxvOES;
    alias fn_glInsertComponentEXT = extern(System) void function(GLuint res, GLuint src, GLuint num) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glInsertComponentEXT glInsertComponentEXT;
    alias fn_glInsertEventMarkerEXT = extern(System) void function(GLsizei length, const( GLchar*) marker) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_debug_marker")
    fn_glInsertEventMarkerEXT glInsertEventMarkerEXT;
    alias fn_glInstrumentsBufferSGIX = extern(System) void function(GLsizei size, GLint* buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_instruments")
    fn_glInstrumentsBufferSGIX glInstrumentsBufferSGIX;
    alias fn_glInterpolatePathsNV = extern(System) void function(GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glInterpolatePathsNV glInterpolatePathsNV;
    alias fn_glIsAsyncMarkerSGIX = extern(System) GLboolean function(GLuint marker) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_async")
    fn_glIsAsyncMarkerSGIX glIsAsyncMarkerSGIX;
    alias fn_glIsBufferARB = extern(System) GLboolean function(GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_buffer_object")
    fn_glIsBufferARB glIsBufferARB;
    alias fn_glIsBufferResidentNV = extern(System) GLboolean function(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    fn_glIsBufferResidentNV glIsBufferResidentNV;
    alias fn_glIsCommandListNV = extern(System) GLboolean function(GLuint list) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    fn_glIsCommandListNV glIsCommandListNV;
    alias fn_glIsEnabledIndexedEXT = extern(System) GLboolean function(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glIsEnabledIndexedEXT glIsEnabledIndexedEXT;
    alias fn_glIsEnabledi = extern(System) GLboolean function(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glIsEnabledi glIsEnabledi;
    alias fn_glIsEnablediEXT = extern(System) GLboolean function(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_buffers_indexed")
    fn_glIsEnablediEXT glIsEnablediEXT;
    alias fn_glIsEnablediNV = extern(System) GLboolean function(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_array")
    fn_glIsEnablediNV glIsEnablediNV;
    alias fn_glIsEnablediOES = extern(System) GLboolean function(GLenum target, GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_buffers_indexed")
    fn_glIsEnablediOES glIsEnablediOES;
    alias fn_glIsFenceAPPLE = extern(System) GLboolean function(GLuint fence) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_fence")
    fn_glIsFenceAPPLE glIsFenceAPPLE;
    alias fn_glIsFenceNV = extern(System) GLboolean function(GLuint fence) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fence")
    fn_glIsFenceNV glIsFenceNV;
    alias fn_glIsFramebufferEXT = extern(System) GLboolean function(GLuint framebuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    fn_glIsFramebufferEXT glIsFramebufferEXT;
    alias fn_glIsFramebufferOES = extern(System) GLboolean function(GLuint framebuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    fn_glIsFramebufferOES glIsFramebufferOES;
    alias fn_glIsImageHandleResidentARB = extern(System) GLboolean function(GLuint64 handle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    fn_glIsImageHandleResidentARB glIsImageHandleResidentARB;
    alias fn_glIsImageHandleResidentNV = extern(System) GLboolean function(GLuint64 handle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    fn_glIsImageHandleResidentNV glIsImageHandleResidentNV;
    alias fn_glIsNameAMD = extern(System) GLboolean function(GLenum identifier, GLuint name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_name_gen_delete")
    fn_glIsNameAMD glIsNameAMD;
    alias fn_glIsNamedBufferResidentNV = extern(System) GLboolean function(GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    fn_glIsNamedBufferResidentNV glIsNamedBufferResidentNV;
    alias fn_glIsNamedStringARB = extern(System) GLboolean function(GLint namelen, const( GLchar*) name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shading_language_include")
    fn_glIsNamedStringARB glIsNamedStringARB;
    alias fn_glIsObjectBufferATI = extern(System) GLboolean function(GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_array_object")
    fn_glIsObjectBufferATI glIsObjectBufferATI;
    alias fn_glIsOcclusionQueryNV = extern(System) GLboolean function(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_occlusion_query")
    fn_glIsOcclusionQueryNV glIsOcclusionQueryNV;
    alias fn_glIsPathNV = extern(System) GLboolean function(GLuint path) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glIsPathNV glIsPathNV;
    alias fn_glIsPointInFillPathNV = extern(System) GLboolean function(GLuint path, GLuint mask, GLfloat x, GLfloat y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glIsPointInFillPathNV glIsPointInFillPathNV;
    alias fn_glIsPointInStrokePathNV = extern(System) GLboolean function(GLuint path, GLfloat x, GLfloat y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glIsPointInStrokePathNV glIsPointInStrokePathNV;
    alias fn_glIsProgramARB = extern(System) GLboolean function(GLuint program) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    fn_glIsProgramARB glIsProgramARB;
    alias fn_glIsProgramNV = extern(System) GLboolean function(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glIsProgramNV glIsProgramNV;
    alias fn_glIsProgramPipelineEXT = extern(System) GLboolean function(GLuint pipeline) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    fn_glIsProgramPipelineEXT glIsProgramPipelineEXT;
    alias fn_glIsQueryARB = extern(System) GLboolean function(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_occlusion_query")
    fn_glIsQueryARB glIsQueryARB;
    alias fn_glIsQueryEXT = extern(System) GLboolean function(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_disjoint_timer_query")
    fn_glIsQueryEXT glIsQueryEXT;
    alias fn_glIsRenderbufferEXT = extern(System) GLboolean function(GLuint renderbuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    fn_glIsRenderbufferEXT glIsRenderbufferEXT;
    alias fn_glIsRenderbufferOES = extern(System) GLboolean function(GLuint renderbuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    fn_glIsRenderbufferOES glIsRenderbufferOES;
    alias fn_glIsStateNV = extern(System) GLboolean function(GLuint state) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    fn_glIsStateNV glIsStateNV;
    alias fn_glIsSyncAPPLE = extern(System) GLboolean function(GLsync sync) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_sync")
    fn_glIsSyncAPPLE glIsSyncAPPLE;
    alias fn_glIsTextureEXT = extern(System) GLboolean function(GLuint texture) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_object")
    fn_glIsTextureEXT glIsTextureEXT;
    alias fn_glIsTextureHandleResidentARB = extern(System) GLboolean function(GLuint64 handle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    fn_glIsTextureHandleResidentARB glIsTextureHandleResidentARB;
    alias fn_glIsTextureHandleResidentNV = extern(System) GLboolean function(GLuint64 handle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    fn_glIsTextureHandleResidentNV glIsTextureHandleResidentNV;
    alias fn_glIsTransformFeedbackNV = extern(System) GLboolean function(GLuint id) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback2")
    fn_glIsTransformFeedbackNV glIsTransformFeedbackNV;
    alias fn_glIsVariantEnabledEXT = extern(System) GLboolean function(GLuint id, GLenum cap) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glIsVariantEnabledEXT glIsVariantEnabledEXT;
    alias fn_glIsVertexArrayAPPLE = extern(System) GLboolean function(GLuint array) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_array_object")
    fn_glIsVertexArrayAPPLE glIsVertexArrayAPPLE;
    alias fn_glIsVertexArrayOES = extern(System) GLboolean function(GLuint array) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_vertex_array_object")
    fn_glIsVertexArrayOES glIsVertexArrayOES;
    alias fn_glIsVertexAttribEnabledAPPLE = extern(System) GLboolean function(GLuint index, GLenum pname) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_program_evaluators")
    fn_glIsVertexAttribEnabledAPPLE glIsVertexAttribEnabledAPPLE;
    alias fn_glLabelObjectEXT = extern(System) void function(GLenum type, GLuint object, GLsizei length, const( GLchar*) label) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_debug_label")
    fn_glLabelObjectEXT glLabelObjectEXT;
    alias fn_glLightEnviSGIX = extern(System) void function(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_fragment_lighting")
    fn_glLightEnviSGIX glLightEnviSGIX;
    alias fn_glLightModelx = extern(System) void function(GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glLightModelx glLightModelx;
    alias fn_glLightModelxOES = extern(System) void function(GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glLightModelxOES glLightModelxOES;
    alias fn_glLightModelxv = extern(System) void function(GLenum pname, const( GLfixed*) param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glLightModelxv glLightModelxv;
    alias fn_glLightModelxvOES = extern(System) void function(GLenum pname, const( GLfixed*) param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glLightModelxvOES glLightModelxvOES;
    alias fn_glLightx = extern(System) void function(GLenum light, GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glLightx glLightx;
    alias fn_glLightxOES = extern(System) void function(GLenum light, GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glLightxOES glLightxOES;
    alias fn_glLightxv = extern(System) void function(GLenum light, GLenum pname, const( GLfixed*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glLightxv glLightxv;
    alias fn_glLightxvOES = extern(System) void function(GLenum light, GLenum pname, const( GLfixed*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glLightxvOES glLightxvOES;
    alias fn_glLineWidthx = extern(System) void function(GLfixed width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glLineWidthx glLineWidthx;
    alias fn_glLineWidthxOES = extern(System) void function(GLfixed width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glLineWidthxOES glLineWidthxOES;
    alias fn_glLinkProgramARB = extern(System) void function(GLhandleARB programObj) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glLinkProgramARB glLinkProgramARB;
    alias fn_glListDrawCommandsStatesClientNV = extern(System) void function(GLuint list, GLuint segment, const( void**) indirects, const( GLsizei*) sizes, const( GLuint*) states, const( GLuint*) fbos, GLuint count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    fn_glListDrawCommandsStatesClientNV glListDrawCommandsStatesClientNV;
    alias fn_glListParameterfSGIX = extern(System) void function(GLuint list, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_list_priority")
    fn_glListParameterfSGIX glListParameterfSGIX;
    alias fn_glListParameterfvSGIX = extern(System) void function(GLuint list, GLenum pname, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_list_priority")
    fn_glListParameterfvSGIX glListParameterfvSGIX;
    alias fn_glListParameteriSGIX = extern(System) void function(GLuint list, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_list_priority")
    fn_glListParameteriSGIX glListParameteriSGIX;
    alias fn_glListParameterivSGIX = extern(System) void function(GLuint list, GLenum pname, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_list_priority")
    fn_glListParameterivSGIX glListParameterivSGIX;
    alias fn_glLoadIdentityDeformationMapSGIX = extern(System) void function(GLbitfield mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_polynomial_ffd")
    fn_glLoadIdentityDeformationMapSGIX glLoadIdentityDeformationMapSGIX;
    alias fn_glLoadMatrixx = extern(System) void function(const( GLfixed*) m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glLoadMatrixx glLoadMatrixx;
    alias fn_glLoadMatrixxOES = extern(System) void function(const( GLfixed*) m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glLoadMatrixxOES glLoadMatrixxOES;
    alias fn_glLoadPaletteFromModelViewMatrixOES = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_matrix_palette")
    fn_glLoadPaletteFromModelViewMatrixOES glLoadPaletteFromModelViewMatrixOES;
    alias fn_glLoadProgramNV = extern(System) void function(GLenum target, GLuint id, GLsizei len, const(GLubyte)* program) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glLoadProgramNV glLoadProgramNV;
    alias fn_glLoadTransposeMatrixdARB = extern(System) void function(const( GLdouble*) m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_transpose_matrix")
    fn_glLoadTransposeMatrixdARB glLoadTransposeMatrixdARB;
    alias fn_glLoadTransposeMatrixfARB = extern(System) void function(const( GLfloat*) m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_transpose_matrix")
    fn_glLoadTransposeMatrixfARB glLoadTransposeMatrixfARB;
    alias fn_glLoadTransposeMatrixxOES = extern(System) void function(const( GLfixed*) m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glLoadTransposeMatrixxOES glLoadTransposeMatrixxOES;
    alias fn_glLockArraysEXT = extern(System) void function(GLint first, GLsizei count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_compiled_vertex_array")
    fn_glLockArraysEXT glLockArraysEXT;
    alias fn_glMakeBufferNonResidentNV = extern(System) void function(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    fn_glMakeBufferNonResidentNV glMakeBufferNonResidentNV;
    alias fn_glMakeBufferResidentNV = extern(System) void function(GLenum target, GLenum access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    fn_glMakeBufferResidentNV glMakeBufferResidentNV;
    alias fn_glMakeImageHandleNonResidentARB = extern(System) void function(GLuint64 handle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    fn_glMakeImageHandleNonResidentARB glMakeImageHandleNonResidentARB;
    alias fn_glMakeImageHandleNonResidentNV = extern(System) void function(GLuint64 handle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    fn_glMakeImageHandleNonResidentNV glMakeImageHandleNonResidentNV;
    alias fn_glMakeImageHandleResidentARB = extern(System) void function(GLuint64 handle, GLenum access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    fn_glMakeImageHandleResidentARB glMakeImageHandleResidentARB;
    alias fn_glMakeImageHandleResidentNV = extern(System) void function(GLuint64 handle, GLenum access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    fn_glMakeImageHandleResidentNV glMakeImageHandleResidentNV;
    alias fn_glMakeNamedBufferNonResidentNV = extern(System) void function(GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    fn_glMakeNamedBufferNonResidentNV glMakeNamedBufferNonResidentNV;
    alias fn_glMakeNamedBufferResidentNV = extern(System) void function(GLuint buffer, GLenum access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    fn_glMakeNamedBufferResidentNV glMakeNamedBufferResidentNV;
    alias fn_glMakeTextureHandleNonResidentARB = extern(System) void function(GLuint64 handle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    fn_glMakeTextureHandleNonResidentARB glMakeTextureHandleNonResidentARB;
    alias fn_glMakeTextureHandleNonResidentNV = extern(System) void function(GLuint64 handle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    fn_glMakeTextureHandleNonResidentNV glMakeTextureHandleNonResidentNV;
    alias fn_glMakeTextureHandleResidentARB = extern(System) void function(GLuint64 handle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    fn_glMakeTextureHandleResidentARB glMakeTextureHandleResidentARB;
    alias fn_glMakeTextureHandleResidentNV = extern(System) void function(GLuint64 handle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    fn_glMakeTextureHandleResidentNV glMakeTextureHandleResidentNV;
    alias fn_glMap1xOES = extern(System) void function(GLenum target, GLfixed u1, GLfixed u2, GLint stride, GLint order, GLfixed points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glMap1xOES glMap1xOES;
    alias fn_glMap2xOES = extern(System) void function(GLenum target, GLfixed u1, GLfixed u2, GLint ustride, GLint uorder, GLfixed v1, GLfixed v2, GLint vstride, GLint vorder, GLfixed points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glMap2xOES glMap2xOES;
    alias fn_glMapBufferARB = extern(System) void* function(GLenum target, GLenum access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_buffer_object")
    fn_glMapBufferARB glMapBufferARB;
    alias fn_glMapBufferOES = extern(System) void* function(GLenum target, GLenum access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_mapbuffer")
    fn_glMapBufferOES glMapBufferOES;
    alias fn_glMapBufferRangeEXT = extern(System) void* function(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_map_buffer_range")
    fn_glMapBufferRangeEXT glMapBufferRangeEXT;
    alias fn_glMapControlPointsNV = extern(System) void function(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const( void*) points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_evaluators")
    fn_glMapControlPointsNV glMapControlPointsNV;
    alias fn_glMapGrid1xOES = extern(System) void function(GLint n, GLfixed u1, GLfixed u2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glMapGrid1xOES glMapGrid1xOES;
    alias fn_glMapGrid2xOES = extern(System) void function(GLint n, GLfixed u1, GLfixed u2, GLfixed v1, GLfixed v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glMapGrid2xOES glMapGrid2xOES;
    alias fn_glMapNamedBufferEXT = extern(System) void* function(GLuint buffer, GLenum access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMapNamedBufferEXT glMapNamedBufferEXT;
    alias fn_glMapNamedBufferRangeEXT = extern(System) void* function(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMapNamedBufferRangeEXT glMapNamedBufferRangeEXT;
    alias fn_glMapObjectBufferATI = extern(System) void* function(GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_map_object_buffer")
    fn_glMapObjectBufferATI glMapObjectBufferATI;
    alias fn_glMapParameterfvNV = extern(System) void function(GLenum target, GLenum pname, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_evaluators")
    fn_glMapParameterfvNV glMapParameterfvNV;
    alias fn_glMapParameterivNV = extern(System) void function(GLenum target, GLenum pname, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_evaluators")
    fn_glMapParameterivNV glMapParameterivNV;
    alias fn_glMapTexture2DINTEL = extern(System) void* function(GLuint texture, GLint level, GLbitfield access, GLint* stride, GLenum* layout) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_map_texture")
    fn_glMapTexture2DINTEL glMapTexture2DINTEL;
    alias fn_glMapVertexAttrib1dAPPLE = extern(System) void function(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const( GLdouble*) points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_program_evaluators")
    fn_glMapVertexAttrib1dAPPLE glMapVertexAttrib1dAPPLE;
    alias fn_glMapVertexAttrib1fAPPLE = extern(System) void function(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const( GLfloat*) points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_program_evaluators")
    fn_glMapVertexAttrib1fAPPLE glMapVertexAttrib1fAPPLE;
    alias fn_glMapVertexAttrib2dAPPLE = extern(System) void function(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const( GLdouble*) points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_program_evaluators")
    fn_glMapVertexAttrib2dAPPLE glMapVertexAttrib2dAPPLE;
    alias fn_glMapVertexAttrib2fAPPLE = extern(System) void function(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const( GLfloat*) points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_program_evaluators")
    fn_glMapVertexAttrib2fAPPLE glMapVertexAttrib2fAPPLE;
    alias fn_glMaterialx = extern(System) void function(GLenum face, GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glMaterialx glMaterialx;
    alias fn_glMaterialxOES = extern(System) void function(GLenum face, GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glMaterialxOES glMaterialxOES;
    alias fn_glMaterialxv = extern(System) void function(GLenum face, GLenum pname, const( GLfixed*) param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glMaterialxv glMaterialxv;
    alias fn_glMaterialxvOES = extern(System) void function(GLenum face, GLenum pname, const( GLfixed*) param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glMaterialxvOES glMaterialxvOES;
    alias fn_glMatrixFrustumEXT = extern(System) void function(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMatrixFrustumEXT glMatrixFrustumEXT;
    alias fn_glMatrixIndexPointerARB = extern(System) void function(GLint size, GLenum type, GLsizei stride, const( void*) pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_matrix_palette")
    fn_glMatrixIndexPointerARB glMatrixIndexPointerARB;
    alias fn_glMatrixIndexPointerOES = extern(System) void function(GLint size, GLenum type, GLsizei stride, const( void*) pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_matrix_palette")
    fn_glMatrixIndexPointerOES glMatrixIndexPointerOES;
    alias fn_glMatrixIndexubvARB = extern(System) void function(GLint size, const(GLubyte)* indices) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_matrix_palette")
    fn_glMatrixIndexubvARB glMatrixIndexubvARB;
    alias fn_glMatrixIndexuivARB = extern(System) void function(GLint size, const( GLuint*) indices) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_matrix_palette")
    fn_glMatrixIndexuivARB glMatrixIndexuivARB;
    alias fn_glMatrixIndexusvARB = extern(System) void function(GLint size, const( GLushort*) indices) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_matrix_palette")
    fn_glMatrixIndexusvARB glMatrixIndexusvARB;
    alias fn_glMatrixLoad3x2fNV = extern(System) void function(GLenum matrixMode, const( GLfloat*) m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glMatrixLoad3x2fNV glMatrixLoad3x2fNV;
    alias fn_glMatrixLoad3x3fNV = extern(System) void function(GLenum matrixMode, const( GLfloat*) m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glMatrixLoad3x3fNV glMatrixLoad3x3fNV;
    alias fn_glMatrixLoadIdentityEXT = extern(System) void function(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMatrixLoadIdentityEXT glMatrixLoadIdentityEXT;
    alias fn_glMatrixLoadTranspose3x3fNV = extern(System) void function(GLenum matrixMode, const( GLfloat*) m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glMatrixLoadTranspose3x3fNV glMatrixLoadTranspose3x3fNV;
    alias fn_glMatrixLoadTransposedEXT = extern(System) void function(GLenum mode, const( GLdouble*) m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMatrixLoadTransposedEXT glMatrixLoadTransposedEXT;
    alias fn_glMatrixLoadTransposefEXT = extern(System) void function(GLenum mode, const( GLfloat*) m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMatrixLoadTransposefEXT glMatrixLoadTransposefEXT;
    alias fn_glMatrixLoaddEXT = extern(System) void function(GLenum mode, const( GLdouble*) m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMatrixLoaddEXT glMatrixLoaddEXT;
    alias fn_glMatrixLoadfEXT = extern(System) void function(GLenum mode, const( GLfloat*) m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMatrixLoadfEXT glMatrixLoadfEXT;
    alias fn_glMatrixMult3x2fNV = extern(System) void function(GLenum matrixMode, const( GLfloat*) m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glMatrixMult3x2fNV glMatrixMult3x2fNV;
    alias fn_glMatrixMult3x3fNV = extern(System) void function(GLenum matrixMode, const( GLfloat*) m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glMatrixMult3x3fNV glMatrixMult3x3fNV;
    alias fn_glMatrixMultTranspose3x3fNV = extern(System) void function(GLenum matrixMode, const( GLfloat*) m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glMatrixMultTranspose3x3fNV glMatrixMultTranspose3x3fNV;
    alias fn_glMatrixMultTransposedEXT = extern(System) void function(GLenum mode, const( GLdouble*) m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMatrixMultTransposedEXT glMatrixMultTransposedEXT;
    alias fn_glMatrixMultTransposefEXT = extern(System) void function(GLenum mode, const( GLfloat*) m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMatrixMultTransposefEXT glMatrixMultTransposefEXT;
    alias fn_glMatrixMultdEXT = extern(System) void function(GLenum mode, const( GLdouble*) m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMatrixMultdEXT glMatrixMultdEXT;
    alias fn_glMatrixMultfEXT = extern(System) void function(GLenum mode, const( GLfloat*) m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMatrixMultfEXT glMatrixMultfEXT;
    alias fn_glMatrixOrthoEXT = extern(System) void function(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMatrixOrthoEXT glMatrixOrthoEXT;
    alias fn_glMatrixPopEXT = extern(System) void function(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMatrixPopEXT glMatrixPopEXT;
    alias fn_glMatrixPushEXT = extern(System) void function(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMatrixPushEXT glMatrixPushEXT;
    alias fn_glMatrixRotatedEXT = extern(System) void function(GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMatrixRotatedEXT glMatrixRotatedEXT;
    alias fn_glMatrixRotatefEXT = extern(System) void function(GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMatrixRotatefEXT glMatrixRotatefEXT;
    alias fn_glMatrixScaledEXT = extern(System) void function(GLenum mode, GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMatrixScaledEXT glMatrixScaledEXT;
    alias fn_glMatrixScalefEXT = extern(System) void function(GLenum mode, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMatrixScalefEXT glMatrixScalefEXT;
    alias fn_glMatrixTranslatedEXT = extern(System) void function(GLenum mode, GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMatrixTranslatedEXT glMatrixTranslatedEXT;
    alias fn_glMatrixTranslatefEXT = extern(System) void function(GLenum mode, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMatrixTranslatefEXT glMatrixTranslatefEXT;
    alias fn_glMaxShaderCompilerThreadsARB = extern(System) void function(GLuint count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_parallel_shader_compile")
    fn_glMaxShaderCompilerThreadsARB glMaxShaderCompilerThreadsARB;
    alias fn_glMemoryBarrierEXT = extern(System) void function(GLbitfield barriers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_shader_image_load_store")
    fn_glMemoryBarrierEXT glMemoryBarrierEXT;
    alias fn_glMinSampleShadingARB = extern(System) void function(GLfloat value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_sample_shading")
    fn_glMinSampleShadingARB glMinSampleShadingARB;
    alias fn_glMinSampleShadingOES = extern(System) void function(GLfloat value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_sample_shading")
    fn_glMinSampleShadingOES glMinSampleShadingOES;
    alias fn_glMinmaxEXT = extern(System) void function(GLenum target, GLenum internalformat, GLboolean sink) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_histogram")
    fn_glMinmaxEXT glMinmaxEXT;
    alias fn_glMultMatrixx = extern(System) void function(const( GLfixed*) m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glMultMatrixx glMultMatrixx;
    alias fn_glMultMatrixxOES = extern(System) void function(const( GLfixed*) m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glMultMatrixxOES glMultMatrixxOES;
    alias fn_glMultTransposeMatrixdARB = extern(System) void function(const( GLdouble*) m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_transpose_matrix")
    fn_glMultTransposeMatrixdARB glMultTransposeMatrixdARB;
    alias fn_glMultTransposeMatrixfARB = extern(System) void function(const( GLfloat*) m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_transpose_matrix")
    fn_glMultTransposeMatrixfARB glMultTransposeMatrixfARB;
    alias fn_glMultTransposeMatrixxOES = extern(System) void function(const( GLfixed*) m) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glMultTransposeMatrixxOES glMultTransposeMatrixxOES;
    alias fn_glMultiDrawArraysEXT = extern(System) void function(GLenum mode, const( GLint*) first, const( GLsizei*) count, GLsizei primcount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_multi_draw_arrays")
    fn_glMultiDrawArraysEXT glMultiDrawArraysEXT;
    alias fn_glMultiDrawArraysIndirectAMD = extern(System) void function(GLenum mode, const( void*) indirect, GLsizei primcount, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_multi_draw_indirect")
    fn_glMultiDrawArraysIndirectAMD glMultiDrawArraysIndirectAMD;
    alias fn_glMultiDrawArraysIndirectBindlessCountNV = extern(System) void function(GLenum mode, const( void*) indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_multi_draw_indirect_count")
    fn_glMultiDrawArraysIndirectBindlessCountNV glMultiDrawArraysIndirectBindlessCountNV;
    alias fn_glMultiDrawArraysIndirectBindlessNV = extern(System) void function(GLenum mode, const( void*) indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_multi_draw_indirect")
    fn_glMultiDrawArraysIndirectBindlessNV glMultiDrawArraysIndirectBindlessNV;
    alias fn_glMultiDrawArraysIndirectCountARB = extern(System) void function(GLenum mode, GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_indirect_parameters")
    fn_glMultiDrawArraysIndirectCountARB glMultiDrawArraysIndirectCountARB;
    alias fn_glMultiDrawArraysIndirectEXT = extern(System) void function(GLenum mode, const( void*) indirect, GLsizei drawcount, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_multi_draw_indirect")
    fn_glMultiDrawArraysIndirectEXT glMultiDrawArraysIndirectEXT;
    alias fn_glMultiDrawElementArrayAPPLE = extern(System) void function(GLenum mode, const( GLint*) first, const( GLsizei*) count, GLsizei primcount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_element_array")
    fn_glMultiDrawElementArrayAPPLE glMultiDrawElementArrayAPPLE;
    alias fn_glMultiDrawElementsBaseVertexEXT = extern(System) void function(GLenum mode, const( GLsizei*) count, GLenum type, const(const(GLvoid*)*) indices, GLsizei primcount, const( GLint*) basevertex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_draw_elements_base_vertex")
    fn_glMultiDrawElementsBaseVertexEXT glMultiDrawElementsBaseVertexEXT;
    alias fn_glMultiDrawElementsBaseVertexOES = extern(System) void function(GLenum mode, const( GLsizei*) count, GLenum type, const(const(GLvoid*)*) indices, GLsizei primcount, const( GLint*) basevertex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_draw_elements_base_vertex")
    fn_glMultiDrawElementsBaseVertexOES glMultiDrawElementsBaseVertexOES;
    alias fn_glMultiDrawElementsEXT = extern(System) void function(GLenum mode, const( GLsizei*) count, GLenum type, const(const(GLvoid*)*) indices, GLsizei primcount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_multi_draw_arrays")
    fn_glMultiDrawElementsEXT glMultiDrawElementsEXT;
    alias fn_glMultiDrawElementsIndirectAMD = extern(System) void function(GLenum mode, GLenum type, const( void*) indirect, GLsizei primcount, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_multi_draw_indirect")
    fn_glMultiDrawElementsIndirectAMD glMultiDrawElementsIndirectAMD;
    alias fn_glMultiDrawElementsIndirectBindlessCountNV = extern(System) void function(GLenum mode, GLenum type, const( void*) indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_multi_draw_indirect_count")
    fn_glMultiDrawElementsIndirectBindlessCountNV glMultiDrawElementsIndirectBindlessCountNV;
    alias fn_glMultiDrawElementsIndirectBindlessNV = extern(System) void function(GLenum mode, GLenum type, const( void*) indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_multi_draw_indirect")
    fn_glMultiDrawElementsIndirectBindlessNV glMultiDrawElementsIndirectBindlessNV;
    alias fn_glMultiDrawElementsIndirectCountARB = extern(System) void function(GLenum mode, GLenum type, GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_indirect_parameters")
    fn_glMultiDrawElementsIndirectCountARB glMultiDrawElementsIndirectCountARB;
    alias fn_glMultiDrawElementsIndirectEXT = extern(System) void function(GLenum mode, GLenum type, const( void*) indirect, GLsizei drawcount, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_multi_draw_indirect")
    fn_glMultiDrawElementsIndirectEXT glMultiDrawElementsIndirectEXT;
    alias fn_glMultiDrawRangeElementArrayAPPLE = extern(System) void function(GLenum mode, GLuint start, GLuint end, const( GLint*) first, const( GLsizei*) count, GLsizei primcount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_element_array")
    fn_glMultiDrawRangeElementArrayAPPLE glMultiDrawRangeElementArrayAPPLE;
    alias fn_glMultiModeDrawArraysIBM = extern(System) void function(const( GLenum*) mode, const( GLint*) first, const( GLsizei*) count, GLsizei primcount, GLint modestride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IBM_multimode_draw_arrays")
    fn_glMultiModeDrawArraysIBM glMultiModeDrawArraysIBM;
    alias fn_glMultiModeDrawElementsIBM = extern(System) void function(const( GLenum*) mode, const( GLsizei*) count, GLenum type, const(const(GLvoid*)*) indices, GLsizei primcount, GLint modestride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IBM_multimode_draw_arrays")
    fn_glMultiModeDrawElementsIBM glMultiModeDrawElementsIBM;
    alias fn_glMultiTexBufferEXT = extern(System) void function(GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMultiTexBufferEXT glMultiTexBufferEXT;
    alias fn_glMultiTexCoord1bOES = extern(System) void function(GLenum texture, GLbyte s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    fn_glMultiTexCoord1bOES glMultiTexCoord1bOES;
    alias fn_glMultiTexCoord1bvOES = extern(System) void function(GLenum texture, const( GLbyte*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    fn_glMultiTexCoord1bvOES glMultiTexCoord1bvOES;
    alias fn_glMultiTexCoord1dARB = extern(System) void function(GLenum target, GLdouble s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    fn_glMultiTexCoord1dARB glMultiTexCoord1dARB;
    alias fn_glMultiTexCoord1dvARB = extern(System) void function(GLenum target, const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    fn_glMultiTexCoord1dvARB glMultiTexCoord1dvARB;
    alias fn_glMultiTexCoord1fARB = extern(System) void function(GLenum target, GLfloat s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    fn_glMultiTexCoord1fARB glMultiTexCoord1fARB;
    alias fn_glMultiTexCoord1fvARB = extern(System) void function(GLenum target, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    fn_glMultiTexCoord1fvARB glMultiTexCoord1fvARB;
    alias fn_glMultiTexCoord1hNV = extern(System) void function(GLenum target, GLhalfNV s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glMultiTexCoord1hNV glMultiTexCoord1hNV;
    alias fn_glMultiTexCoord1hvNV = extern(System) void function(GLenum target, const( GLhalfNV*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glMultiTexCoord1hvNV glMultiTexCoord1hvNV;
    alias fn_glMultiTexCoord1iARB = extern(System) void function(GLenum target, GLint s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    fn_glMultiTexCoord1iARB glMultiTexCoord1iARB;
    alias fn_glMultiTexCoord1ivARB = extern(System) void function(GLenum target, const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    fn_glMultiTexCoord1ivARB glMultiTexCoord1ivARB;
    alias fn_glMultiTexCoord1sARB = extern(System) void function(GLenum target, GLshort s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    fn_glMultiTexCoord1sARB glMultiTexCoord1sARB;
    alias fn_glMultiTexCoord1svARB = extern(System) void function(GLenum target, const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    fn_glMultiTexCoord1svARB glMultiTexCoord1svARB;
    alias fn_glMultiTexCoord1xOES = extern(System) void function(GLenum texture, GLfixed s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glMultiTexCoord1xOES glMultiTexCoord1xOES;
    alias fn_glMultiTexCoord1xvOES = extern(System) void function(GLenum texture, const( GLfixed*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glMultiTexCoord1xvOES glMultiTexCoord1xvOES;
    alias fn_glMultiTexCoord2bOES = extern(System) void function(GLenum texture, GLbyte s, GLbyte t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    fn_glMultiTexCoord2bOES glMultiTexCoord2bOES;
    alias fn_glMultiTexCoord2bvOES = extern(System) void function(GLenum texture, const( GLbyte*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    fn_glMultiTexCoord2bvOES glMultiTexCoord2bvOES;
    alias fn_glMultiTexCoord2dARB = extern(System) void function(GLenum target, GLdouble s, GLdouble t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    fn_glMultiTexCoord2dARB glMultiTexCoord2dARB;
    alias fn_glMultiTexCoord2dvARB = extern(System) void function(GLenum target, const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    fn_glMultiTexCoord2dvARB glMultiTexCoord2dvARB;
    alias fn_glMultiTexCoord2fARB = extern(System) void function(GLenum target, GLfloat s, GLfloat t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    fn_glMultiTexCoord2fARB glMultiTexCoord2fARB;
    alias fn_glMultiTexCoord2fvARB = extern(System) void function(GLenum target, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    fn_glMultiTexCoord2fvARB glMultiTexCoord2fvARB;
    alias fn_glMultiTexCoord2hNV = extern(System) void function(GLenum target, GLhalfNV s, GLhalfNV t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glMultiTexCoord2hNV glMultiTexCoord2hNV;
    alias fn_glMultiTexCoord2hvNV = extern(System) void function(GLenum target, const( GLhalfNV*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glMultiTexCoord2hvNV glMultiTexCoord2hvNV;
    alias fn_glMultiTexCoord2iARB = extern(System) void function(GLenum target, GLint s, GLint t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    fn_glMultiTexCoord2iARB glMultiTexCoord2iARB;
    alias fn_glMultiTexCoord2ivARB = extern(System) void function(GLenum target, const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    fn_glMultiTexCoord2ivARB glMultiTexCoord2ivARB;
    alias fn_glMultiTexCoord2sARB = extern(System) void function(GLenum target, GLshort s, GLshort t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    fn_glMultiTexCoord2sARB glMultiTexCoord2sARB;
    alias fn_glMultiTexCoord2svARB = extern(System) void function(GLenum target, const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    fn_glMultiTexCoord2svARB glMultiTexCoord2svARB;
    alias fn_glMultiTexCoord2xOES = extern(System) void function(GLenum texture, GLfixed s, GLfixed t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glMultiTexCoord2xOES glMultiTexCoord2xOES;
    alias fn_glMultiTexCoord2xvOES = extern(System) void function(GLenum texture, const( GLfixed*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glMultiTexCoord2xvOES glMultiTexCoord2xvOES;
    alias fn_glMultiTexCoord3bOES = extern(System) void function(GLenum texture, GLbyte s, GLbyte t, GLbyte r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    fn_glMultiTexCoord3bOES glMultiTexCoord3bOES;
    alias fn_glMultiTexCoord3bvOES = extern(System) void function(GLenum texture, const( GLbyte*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    fn_glMultiTexCoord3bvOES glMultiTexCoord3bvOES;
    alias fn_glMultiTexCoord3dARB = extern(System) void function(GLenum target, GLdouble s, GLdouble t, GLdouble r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    fn_glMultiTexCoord3dARB glMultiTexCoord3dARB;
    alias fn_glMultiTexCoord3dvARB = extern(System) void function(GLenum target, const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    fn_glMultiTexCoord3dvARB glMultiTexCoord3dvARB;
    alias fn_glMultiTexCoord3fARB = extern(System) void function(GLenum target, GLfloat s, GLfloat t, GLfloat r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    fn_glMultiTexCoord3fARB glMultiTexCoord3fARB;
    alias fn_glMultiTexCoord3fvARB = extern(System) void function(GLenum target, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    fn_glMultiTexCoord3fvARB glMultiTexCoord3fvARB;
    alias fn_glMultiTexCoord3hNV = extern(System) void function(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glMultiTexCoord3hNV glMultiTexCoord3hNV;
    alias fn_glMultiTexCoord3hvNV = extern(System) void function(GLenum target, const( GLhalfNV*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glMultiTexCoord3hvNV glMultiTexCoord3hvNV;
    alias fn_glMultiTexCoord3iARB = extern(System) void function(GLenum target, GLint s, GLint t, GLint r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    fn_glMultiTexCoord3iARB glMultiTexCoord3iARB;
    alias fn_glMultiTexCoord3ivARB = extern(System) void function(GLenum target, const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    fn_glMultiTexCoord3ivARB glMultiTexCoord3ivARB;
    alias fn_glMultiTexCoord3sARB = extern(System) void function(GLenum target, GLshort s, GLshort t, GLshort r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    fn_glMultiTexCoord3sARB glMultiTexCoord3sARB;
    alias fn_glMultiTexCoord3svARB = extern(System) void function(GLenum target, const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    fn_glMultiTexCoord3svARB glMultiTexCoord3svARB;
    alias fn_glMultiTexCoord3xOES = extern(System) void function(GLenum texture, GLfixed s, GLfixed t, GLfixed r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glMultiTexCoord3xOES glMultiTexCoord3xOES;
    alias fn_glMultiTexCoord3xvOES = extern(System) void function(GLenum texture, const( GLfixed*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glMultiTexCoord3xvOES glMultiTexCoord3xvOES;
    alias fn_glMultiTexCoord4bOES = extern(System) void function(GLenum texture, GLbyte s, GLbyte t, GLbyte r, GLbyte q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    fn_glMultiTexCoord4bOES glMultiTexCoord4bOES;
    alias fn_glMultiTexCoord4bvOES = extern(System) void function(GLenum texture, const( GLbyte*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    fn_glMultiTexCoord4bvOES glMultiTexCoord4bvOES;
    alias fn_glMultiTexCoord4dARB = extern(System) void function(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    fn_glMultiTexCoord4dARB glMultiTexCoord4dARB;
    alias fn_glMultiTexCoord4dvARB = extern(System) void function(GLenum target, const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    fn_glMultiTexCoord4dvARB glMultiTexCoord4dvARB;
    alias fn_glMultiTexCoord4fARB = extern(System) void function(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    fn_glMultiTexCoord4fARB glMultiTexCoord4fARB;
    alias fn_glMultiTexCoord4fvARB = extern(System) void function(GLenum target, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    fn_glMultiTexCoord4fvARB glMultiTexCoord4fvARB;
    alias fn_glMultiTexCoord4hNV = extern(System) void function(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glMultiTexCoord4hNV glMultiTexCoord4hNV;
    alias fn_glMultiTexCoord4hvNV = extern(System) void function(GLenum target, const( GLhalfNV*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glMultiTexCoord4hvNV glMultiTexCoord4hvNV;
    alias fn_glMultiTexCoord4iARB = extern(System) void function(GLenum target, GLint s, GLint t, GLint r, GLint q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    fn_glMultiTexCoord4iARB glMultiTexCoord4iARB;
    alias fn_glMultiTexCoord4ivARB = extern(System) void function(GLenum target, const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    fn_glMultiTexCoord4ivARB glMultiTexCoord4ivARB;
    alias fn_glMultiTexCoord4sARB = extern(System) void function(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    fn_glMultiTexCoord4sARB glMultiTexCoord4sARB;
    alias fn_glMultiTexCoord4svARB = extern(System) void function(GLenum target, const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multitexture")
    fn_glMultiTexCoord4svARB glMultiTexCoord4svARB;
    alias fn_glMultiTexCoord4x = extern(System) void function(GLenum texture, GLfixed s, GLfixed t, GLfixed r, GLfixed q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glMultiTexCoord4x glMultiTexCoord4x;
    alias fn_glMultiTexCoord4xOES = extern(System) void function(GLenum texture, GLfixed s, GLfixed t, GLfixed r, GLfixed q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glMultiTexCoord4xOES glMultiTexCoord4xOES;
    alias fn_glMultiTexCoord4xvOES = extern(System) void function(GLenum texture, const( GLfixed*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glMultiTexCoord4xvOES glMultiTexCoord4xvOES;
    alias fn_glMultiTexCoordP1ui = extern(System) void function(GLenum texture, GLenum type, GLuint coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glMultiTexCoordP1ui glMultiTexCoordP1ui;
    alias fn_glMultiTexCoordP1uiv = extern(System) void function(GLenum texture, GLenum type, const( GLuint*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glMultiTexCoordP1uiv glMultiTexCoordP1uiv;
    alias fn_glMultiTexCoordP2ui = extern(System) void function(GLenum texture, GLenum type, GLuint coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glMultiTexCoordP2ui glMultiTexCoordP2ui;
    alias fn_glMultiTexCoordP2uiv = extern(System) void function(GLenum texture, GLenum type, const( GLuint*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glMultiTexCoordP2uiv glMultiTexCoordP2uiv;
    alias fn_glMultiTexCoordP3ui = extern(System) void function(GLenum texture, GLenum type, GLuint coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glMultiTexCoordP3ui glMultiTexCoordP3ui;
    alias fn_glMultiTexCoordP3uiv = extern(System) void function(GLenum texture, GLenum type, const( GLuint*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glMultiTexCoordP3uiv glMultiTexCoordP3uiv;
    alias fn_glMultiTexCoordP4ui = extern(System) void function(GLenum texture, GLenum type, GLuint coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glMultiTexCoordP4ui glMultiTexCoordP4ui;
    alias fn_glMultiTexCoordP4uiv = extern(System) void function(GLenum texture, GLenum type, const( GLuint*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glMultiTexCoordP4uiv glMultiTexCoordP4uiv;
    alias fn_glMultiTexCoordPointerEXT = extern(System) void function(GLenum texunit, GLint size, GLenum type, GLsizei stride, const( void*) pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMultiTexCoordPointerEXT glMultiTexCoordPointerEXT;
    alias fn_glMultiTexEnvfEXT = extern(System) void function(GLenum texunit, GLenum target, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMultiTexEnvfEXT glMultiTexEnvfEXT;
    alias fn_glMultiTexEnvfvEXT = extern(System) void function(GLenum texunit, GLenum target, GLenum pname, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMultiTexEnvfvEXT glMultiTexEnvfvEXT;
    alias fn_glMultiTexEnviEXT = extern(System) void function(GLenum texunit, GLenum target, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMultiTexEnviEXT glMultiTexEnviEXT;
    alias fn_glMultiTexEnvivEXT = extern(System) void function(GLenum texunit, GLenum target, GLenum pname, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMultiTexEnvivEXT glMultiTexEnvivEXT;
    alias fn_glMultiTexGendEXT = extern(System) void function(GLenum texunit, GLenum coord, GLenum pname, GLdouble param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMultiTexGendEXT glMultiTexGendEXT;
    alias fn_glMultiTexGendvEXT = extern(System) void function(GLenum texunit, GLenum coord, GLenum pname, const( GLdouble*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMultiTexGendvEXT glMultiTexGendvEXT;
    alias fn_glMultiTexGenfEXT = extern(System) void function(GLenum texunit, GLenum coord, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMultiTexGenfEXT glMultiTexGenfEXT;
    alias fn_glMultiTexGenfvEXT = extern(System) void function(GLenum texunit, GLenum coord, GLenum pname, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMultiTexGenfvEXT glMultiTexGenfvEXT;
    alias fn_glMultiTexGeniEXT = extern(System) void function(GLenum texunit, GLenum coord, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMultiTexGeniEXT glMultiTexGeniEXT;
    alias fn_glMultiTexGenivEXT = extern(System) void function(GLenum texunit, GLenum coord, GLenum pname, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMultiTexGenivEXT glMultiTexGenivEXT;
    alias fn_glMultiTexImage1DEXT = extern(System) void function(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const( void*) pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMultiTexImage1DEXT glMultiTexImage1DEXT;
    alias fn_glMultiTexImage2DEXT = extern(System) void function(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const( void*) pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMultiTexImage2DEXT glMultiTexImage2DEXT;
    alias fn_glMultiTexImage3DEXT = extern(System) void function(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const( void*) pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMultiTexImage3DEXT glMultiTexImage3DEXT;
    alias fn_glMultiTexParameterIivEXT = extern(System) void function(GLenum texunit, GLenum target, GLenum pname, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMultiTexParameterIivEXT glMultiTexParameterIivEXT;
    alias fn_glMultiTexParameterIuivEXT = extern(System) void function(GLenum texunit, GLenum target, GLenum pname, const( GLuint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMultiTexParameterIuivEXT glMultiTexParameterIuivEXT;
    alias fn_glMultiTexParameterfEXT = extern(System) void function(GLenum texunit, GLenum target, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMultiTexParameterfEXT glMultiTexParameterfEXT;
    alias fn_glMultiTexParameterfvEXT = extern(System) void function(GLenum texunit, GLenum target, GLenum pname, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMultiTexParameterfvEXT glMultiTexParameterfvEXT;
    alias fn_glMultiTexParameteriEXT = extern(System) void function(GLenum texunit, GLenum target, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMultiTexParameteriEXT glMultiTexParameteriEXT;
    alias fn_glMultiTexParameterivEXT = extern(System) void function(GLenum texunit, GLenum target, GLenum pname, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMultiTexParameterivEXT glMultiTexParameterivEXT;
    alias fn_glMultiTexRenderbufferEXT = extern(System) void function(GLenum texunit, GLenum target, GLuint renderbuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMultiTexRenderbufferEXT glMultiTexRenderbufferEXT;
    alias fn_glMultiTexSubImage1DEXT = extern(System) void function(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const( void*) pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMultiTexSubImage1DEXT glMultiTexSubImage1DEXT;
    alias fn_glMultiTexSubImage2DEXT = extern(System) void function(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const( void*) pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMultiTexSubImage2DEXT glMultiTexSubImage2DEXT;
    alias fn_glMultiTexSubImage3DEXT = extern(System) void function(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const( void*) pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glMultiTexSubImage3DEXT glMultiTexSubImage3DEXT;
    alias fn_glNamedBufferDataEXT = extern(System) void function(GLuint buffer, GLsizeiptr size, const( void*) data, GLenum usage) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glNamedBufferDataEXT glNamedBufferDataEXT;
    alias fn_glNamedBufferPageCommitmentARB = extern(System) void function(GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_sparse_buffer")
    fn_glNamedBufferPageCommitmentARB glNamedBufferPageCommitmentARB;
    alias fn_glNamedBufferPageCommitmentEXT = extern(System) void function(GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_sparse_buffer")
    fn_glNamedBufferPageCommitmentEXT glNamedBufferPageCommitmentEXT;
    alias fn_glNamedBufferStorageEXT = extern(System) void function(GLuint buffer, GLsizeiptr size, const( void*) data, GLbitfield flags) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glNamedBufferStorageEXT glNamedBufferStorageEXT;
    alias fn_glNamedBufferSubDataEXT = extern(System) void function(GLuint buffer, GLintptr offset, GLsizeiptr size, const( void*) data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glNamedBufferSubDataEXT glNamedBufferSubDataEXT;
    alias fn_glNamedCopyBufferSubDataEXT = extern(System) void function(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glNamedCopyBufferSubDataEXT glNamedCopyBufferSubDataEXT;
    alias fn_glNamedFramebufferParameteriEXT = extern(System) void function(GLuint framebuffer, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glNamedFramebufferParameteriEXT glNamedFramebufferParameteriEXT;
    alias fn_glNamedFramebufferRenderbufferEXT = extern(System) void function(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glNamedFramebufferRenderbufferEXT glNamedFramebufferRenderbufferEXT;
    alias fn_glNamedFramebufferSampleLocationsfvARB = extern(System) void function(GLuint framebuffer, GLuint start, GLsizei count, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_sample_locations")
    fn_glNamedFramebufferSampleLocationsfvARB glNamedFramebufferSampleLocationsfvARB;
    alias fn_glNamedFramebufferSampleLocationsfvNV = extern(System) void function(GLuint framebuffer, GLuint start, GLsizei count, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_sample_locations")
    fn_glNamedFramebufferSampleLocationsfvNV glNamedFramebufferSampleLocationsfvNV;
    alias fn_glNamedFramebufferTexture1DEXT = extern(System) void function(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glNamedFramebufferTexture1DEXT glNamedFramebufferTexture1DEXT;
    alias fn_glNamedFramebufferTexture2DEXT = extern(System) void function(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glNamedFramebufferTexture2DEXT glNamedFramebufferTexture2DEXT;
    alias fn_glNamedFramebufferTexture3DEXT = extern(System) void function(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glNamedFramebufferTexture3DEXT glNamedFramebufferTexture3DEXT;
    alias fn_glNamedFramebufferTextureEXT = extern(System) void function(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glNamedFramebufferTextureEXT glNamedFramebufferTextureEXT;
    alias fn_glNamedFramebufferTextureFaceEXT = extern(System) void function(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glNamedFramebufferTextureFaceEXT glNamedFramebufferTextureFaceEXT;
    alias fn_glNamedFramebufferTextureLayerEXT = extern(System) void function(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glNamedFramebufferTextureLayerEXT glNamedFramebufferTextureLayerEXT;
    alias fn_glNamedProgramLocalParameter4dEXT = extern(System) void function(GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glNamedProgramLocalParameter4dEXT glNamedProgramLocalParameter4dEXT;
    alias fn_glNamedProgramLocalParameter4dvEXT = extern(System) void function(GLuint program, GLenum target, GLuint index, const( GLdouble*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glNamedProgramLocalParameter4dvEXT glNamedProgramLocalParameter4dvEXT;
    alias fn_glNamedProgramLocalParameter4fEXT = extern(System) void function(GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glNamedProgramLocalParameter4fEXT glNamedProgramLocalParameter4fEXT;
    alias fn_glNamedProgramLocalParameter4fvEXT = extern(System) void function(GLuint program, GLenum target, GLuint index, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glNamedProgramLocalParameter4fvEXT glNamedProgramLocalParameter4fvEXT;
    alias fn_glNamedProgramLocalParameterI4iEXT = extern(System) void function(GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glNamedProgramLocalParameterI4iEXT glNamedProgramLocalParameterI4iEXT;
    alias fn_glNamedProgramLocalParameterI4ivEXT = extern(System) void function(GLuint program, GLenum target, GLuint index, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glNamedProgramLocalParameterI4ivEXT glNamedProgramLocalParameterI4ivEXT;
    alias fn_glNamedProgramLocalParameterI4uiEXT = extern(System) void function(GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glNamedProgramLocalParameterI4uiEXT glNamedProgramLocalParameterI4uiEXT;
    alias fn_glNamedProgramLocalParameterI4uivEXT = extern(System) void function(GLuint program, GLenum target, GLuint index, const( GLuint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glNamedProgramLocalParameterI4uivEXT glNamedProgramLocalParameterI4uivEXT;
    alias fn_glNamedProgramLocalParameters4fvEXT = extern(System) void function(GLuint program, GLenum target, GLuint index, GLsizei count, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glNamedProgramLocalParameters4fvEXT glNamedProgramLocalParameters4fvEXT;
    alias fn_glNamedProgramLocalParametersI4ivEXT = extern(System) void function(GLuint program, GLenum target, GLuint index, GLsizei count, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glNamedProgramLocalParametersI4ivEXT glNamedProgramLocalParametersI4ivEXT;
    alias fn_glNamedProgramLocalParametersI4uivEXT = extern(System) void function(GLuint program, GLenum target, GLuint index, GLsizei count, const( GLuint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glNamedProgramLocalParametersI4uivEXT glNamedProgramLocalParametersI4uivEXT;
    alias fn_glNamedProgramStringEXT = extern(System) void function(GLuint program, GLenum target, GLenum format, GLsizei len, const( void*) string) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glNamedProgramStringEXT glNamedProgramStringEXT;
    alias fn_glNamedRenderbufferStorageEXT = extern(System) void function(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glNamedRenderbufferStorageEXT glNamedRenderbufferStorageEXT;
    alias fn_glNamedRenderbufferStorageMultisampleCoverageEXT = extern(System) void function(GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glNamedRenderbufferStorageMultisampleCoverageEXT glNamedRenderbufferStorageMultisampleCoverageEXT;
    alias fn_glNamedRenderbufferStorageMultisampleEXT = extern(System) void function(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glNamedRenderbufferStorageMultisampleEXT glNamedRenderbufferStorageMultisampleEXT;
    alias fn_glNamedStringARB = extern(System) void function(GLenum type, GLint namelen, const( GLchar*) name, GLint stringlen, const( GLchar*) string) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shading_language_include")
    fn_glNamedStringARB glNamedStringARB;
    alias fn_glNewObjectBufferATI = extern(System) GLuint function(GLsizei size, const( void*) pointer, GLenum usage) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_array_object")
    fn_glNewObjectBufferATI glNewObjectBufferATI;
    alias fn_glNormal3fVertex3fSUN = extern(System) void function(GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glNormal3fVertex3fSUN glNormal3fVertex3fSUN;
    alias fn_glNormal3fVertex3fvSUN = extern(System) void function(const( GLfloat*) n, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glNormal3fVertex3fvSUN glNormal3fVertex3fvSUN;
    alias fn_glNormal3hNV = extern(System) void function(GLhalfNV nx, GLhalfNV ny, GLhalfNV nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glNormal3hNV glNormal3hNV;
    alias fn_glNormal3hvNV = extern(System) void function(const( GLhalfNV*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glNormal3hvNV glNormal3hvNV;
    alias fn_glNormal3x = extern(System) void function(GLfixed nx, GLfixed ny, GLfixed nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glNormal3x glNormal3x;
    alias fn_glNormal3xOES = extern(System) void function(GLfixed nx, GLfixed ny, GLfixed nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glNormal3xOES glNormal3xOES;
    alias fn_glNormal3xvOES = extern(System) void function(const( GLfixed*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glNormal3xvOES glNormal3xvOES;
    alias fn_glNormalFormatNV = extern(System) void function(GLenum type, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_buffer_unified_memory")
    fn_glNormalFormatNV glNormalFormatNV;
    alias fn_glNormalP3ui = extern(System) void function(GLenum type, GLuint coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glNormalP3ui glNormalP3ui;
    alias fn_glNormalP3uiv = extern(System) void function(GLenum type, const( GLuint*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glNormalP3uiv glNormalP3uiv;
    alias fn_glNormalPointerEXT = extern(System) void function(GLenum type, GLsizei stride, GLsizei count, const( void*) pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_array")
    fn_glNormalPointerEXT glNormalPointerEXT;
    alias fn_glNormalPointerListIBM = extern(System) void function(GLenum type, GLint stride, const( void**) pointer, GLint ptrstride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IBM_vertex_array_lists")
    fn_glNormalPointerListIBM glNormalPointerListIBM;
    alias fn_glNormalPointervINTEL = extern(System) void function(GLenum type, const( void**) pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_parallel_arrays")
    fn_glNormalPointervINTEL glNormalPointervINTEL;
    alias fn_glNormalStream3bATI = extern(System) void function(GLenum stream, GLbyte nx, GLbyte ny, GLbyte nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glNormalStream3bATI glNormalStream3bATI;
    alias fn_glNormalStream3bvATI = extern(System) void function(GLenum stream, const( GLbyte*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glNormalStream3bvATI glNormalStream3bvATI;
    alias fn_glNormalStream3dATI = extern(System) void function(GLenum stream, GLdouble nx, GLdouble ny, GLdouble nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glNormalStream3dATI glNormalStream3dATI;
    alias fn_glNormalStream3dvATI = extern(System) void function(GLenum stream, const( GLdouble*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glNormalStream3dvATI glNormalStream3dvATI;
    alias fn_glNormalStream3fATI = extern(System) void function(GLenum stream, GLfloat nx, GLfloat ny, GLfloat nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glNormalStream3fATI glNormalStream3fATI;
    alias fn_glNormalStream3fvATI = extern(System) void function(GLenum stream, const( GLfloat*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glNormalStream3fvATI glNormalStream3fvATI;
    alias fn_glNormalStream3iATI = extern(System) void function(GLenum stream, GLint nx, GLint ny, GLint nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glNormalStream3iATI glNormalStream3iATI;
    alias fn_glNormalStream3ivATI = extern(System) void function(GLenum stream, const( GLint*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glNormalStream3ivATI glNormalStream3ivATI;
    alias fn_glNormalStream3sATI = extern(System) void function(GLenum stream, GLshort nx, GLshort ny, GLshort nz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glNormalStream3sATI glNormalStream3sATI;
    alias fn_glNormalStream3svATI = extern(System) void function(GLenum stream, const( GLshort*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glNormalStream3svATI glNormalStream3svATI;
    alias fn_glObjectLabelKHR = extern(System) void function(GLenum identifier, GLuint name, GLsizei length, const( GLchar*) label) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_debug")
    fn_glObjectLabelKHR glObjectLabelKHR;
    alias fn_glObjectPtrLabelKHR = extern(System) void function(const( void*) ptr, GLsizei length, const( GLchar*) label) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_debug")
    fn_glObjectPtrLabelKHR glObjectPtrLabelKHR;
    alias fn_glObjectPurgeableAPPLE = extern(System) GLenum function(GLenum objectType, GLuint name, GLenum option) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_object_purgeable")
    fn_glObjectPurgeableAPPLE glObjectPurgeableAPPLE;
    alias fn_glObjectUnpurgeableAPPLE = extern(System) GLenum function(GLenum objectType, GLuint name, GLenum option) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_object_purgeable")
    fn_glObjectUnpurgeableAPPLE glObjectUnpurgeableAPPLE;
    alias fn_glOrthof = extern(System) void function(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glOrthof glOrthof;
    alias fn_glOrthofOES = extern(System) void function(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_single_precision")
    fn_glOrthofOES glOrthofOES;
    alias fn_glOrthox = extern(System) void function(GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glOrthox glOrthox;
    alias fn_glOrthoxOES = extern(System) void function(GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glOrthoxOES glOrthoxOES;
    alias fn_glPNTrianglesfATI = extern(System) void function(GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_pn_triangles")
    fn_glPNTrianglesfATI glPNTrianglesfATI;
    alias fn_glPNTrianglesiATI = extern(System) void function(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_pn_triangles")
    fn_glPNTrianglesiATI glPNTrianglesiATI;
    alias fn_glPassTexCoordATI = extern(System) void function(GLuint dst, GLuint coord, GLenum swizzle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    fn_glPassTexCoordATI glPassTexCoordATI;
    alias fn_glPassThroughxOES = extern(System) void function(GLfixed token) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glPassThroughxOES glPassThroughxOES;
    alias fn_glPatchParameterfv = extern(System) void function(GLenum pname, const( GLfloat*) values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_tessellation_shader")
    fn_glPatchParameterfv glPatchParameterfv;
    alias fn_glPatchParameteriEXT = extern(System) void function(GLenum pname, GLint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_tessellation_shader")
    fn_glPatchParameteriEXT glPatchParameteriEXT;
    alias fn_glPatchParameteriOES = extern(System) void function(GLenum pname, GLint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_tessellation_shader")
    fn_glPatchParameteriOES glPatchParameteriOES;
    alias fn_glPathColorGenNV = extern(System) void function(GLenum color, GLenum genMode, GLenum colorFormat, const( GLfloat*) coeffs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glPathColorGenNV glPathColorGenNV;
    alias fn_glPathCommandsNV = extern(System) void function(GLuint path, GLsizei numCommands, const(GLubyte)* commands, GLsizei numCoords, GLenum coordType, const( void*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glPathCommandsNV glPathCommandsNV;
    alias fn_glPathCoordsNV = extern(System) void function(GLuint path, GLsizei numCoords, GLenum coordType, const( void*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glPathCoordsNV glPathCoordsNV;
    alias fn_glPathCoverDepthFuncNV = extern(System) void function(GLenum func) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glPathCoverDepthFuncNV glPathCoverDepthFuncNV;
    alias fn_glPathDashArrayNV = extern(System) void function(GLuint path, GLsizei dashCount, const( GLfloat*) dashArray) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glPathDashArrayNV glPathDashArrayNV;
    alias fn_glPathFogGenNV = extern(System) void function(GLenum genMode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glPathFogGenNV glPathFogGenNV;
    alias fn_glPathGlyphIndexArrayNV = extern(System) GLenum function(GLuint firstPathName, GLenum fontTarget, const( void*) fontName, GLbitfield fontStyle, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glPathGlyphIndexArrayNV glPathGlyphIndexArrayNV;
    alias fn_glPathGlyphIndexRangeNV = extern(System) GLenum function(GLenum fontTarget, const( void*) fontName, GLbitfield fontStyle, GLuint pathParameterTemplate, GLfloat emScale, GLuint baseAndCount) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glPathGlyphIndexRangeNV glPathGlyphIndexRangeNV;
    alias fn_glPathGlyphRangeNV = extern(System) void function(GLuint firstPathName, GLenum fontTarget, const( void*) fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glPathGlyphRangeNV glPathGlyphRangeNV;
    alias fn_glPathGlyphsNV = extern(System) void function(GLuint firstPathName, GLenum fontTarget, const( void*) fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const( void*) charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glPathGlyphsNV glPathGlyphsNV;
    alias fn_glPathMemoryGlyphIndexArrayNV = extern(System) GLenum function(GLuint firstPathName, GLenum fontTarget, GLsizeiptr fontSize, const( void*) fontData, GLsizei faceIndex, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glPathMemoryGlyphIndexArrayNV glPathMemoryGlyphIndexArrayNV;
    alias fn_glPathParameterfNV = extern(System) void function(GLuint path, GLenum pname, GLfloat value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glPathParameterfNV glPathParameterfNV;
    alias fn_glPathParameterfvNV = extern(System) void function(GLuint path, GLenum pname, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glPathParameterfvNV glPathParameterfvNV;
    alias fn_glPathParameteriNV = extern(System) void function(GLuint path, GLenum pname, GLint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glPathParameteriNV glPathParameteriNV;
    alias fn_glPathParameterivNV = extern(System) void function(GLuint path, GLenum pname, const( GLint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glPathParameterivNV glPathParameterivNV;
    alias fn_glPathStencilDepthOffsetNV = extern(System) void function(GLfloat factor, GLfloat units) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glPathStencilDepthOffsetNV glPathStencilDepthOffsetNV;
    alias fn_glPathStencilFuncNV = extern(System) void function(GLenum func, GLint ref_, GLuint mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glPathStencilFuncNV glPathStencilFuncNV;
    alias fn_glPathStringNV = extern(System) void function(GLuint path, GLenum format, GLsizei length, const( void*) pathString) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glPathStringNV glPathStringNV;
    alias fn_glPathSubCommandsNV = extern(System) void function(GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const(GLubyte)* commands, GLsizei numCoords, GLenum coordType, const( void*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glPathSubCommandsNV glPathSubCommandsNV;
    alias fn_glPathSubCoordsNV = extern(System) void function(GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const( void*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glPathSubCoordsNV glPathSubCoordsNV;
    alias fn_glPathTexGenNV = extern(System) void function(GLenum texCoordSet, GLenum genMode, GLint components, const( GLfloat*) coeffs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glPathTexGenNV glPathTexGenNV;
    alias fn_glPauseTransformFeedbackNV = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback2")
    fn_glPauseTransformFeedbackNV glPauseTransformFeedbackNV;
    alias fn_glPixelDataRangeNV = extern(System) void function(GLenum target, GLsizei length, const( void*) pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_pixel_data_range")
    fn_glPixelDataRangeNV glPixelDataRangeNV;
    alias fn_glPixelMapx = extern(System) void function(GLenum map, GLint size, const( GLfixed*) values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glPixelMapx glPixelMapx;
    alias fn_glPixelStorei = extern(System) void function(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glPixelStorei glPixelStorei;
    alias fn_glPixelStorex = extern(System) void function(GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glPixelStorex glPixelStorex;
    alias fn_glPixelTexGenParameterfSGIS = extern(System) void function(GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_pixel_texture")
    fn_glPixelTexGenParameterfSGIS glPixelTexGenParameterfSGIS;
    alias fn_glPixelTexGenParameterfvSGIS = extern(System) void function(GLenum pname, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_pixel_texture")
    fn_glPixelTexGenParameterfvSGIS glPixelTexGenParameterfvSGIS;
    alias fn_glPixelTexGenParameteriSGIS = extern(System) void function(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_pixel_texture")
    fn_glPixelTexGenParameteriSGIS glPixelTexGenParameteriSGIS;
    alias fn_glPixelTexGenParameterivSGIS = extern(System) void function(GLenum pname, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_pixel_texture")
    fn_glPixelTexGenParameterivSGIS glPixelTexGenParameterivSGIS;
    alias fn_glPixelTexGenSGIX = extern(System) void function(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_pixel_texture")
    fn_glPixelTexGenSGIX glPixelTexGenSGIX;
    alias fn_glPixelTransferxOES = extern(System) void function(GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glPixelTransferxOES glPixelTransferxOES;
    alias fn_glPixelTransformParameterfEXT = extern(System) void function(GLenum target, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_pixel_transform")
    fn_glPixelTransformParameterfEXT glPixelTransformParameterfEXT;
    alias fn_glPixelTransformParameterfvEXT = extern(System) void function(GLenum target, GLenum pname, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_pixel_transform")
    fn_glPixelTransformParameterfvEXT glPixelTransformParameterfvEXT;
    alias fn_glPixelTransformParameteriEXT = extern(System) void function(GLenum target, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_pixel_transform")
    fn_glPixelTransformParameteriEXT glPixelTransformParameteriEXT;
    alias fn_glPixelTransformParameterivEXT = extern(System) void function(GLenum target, GLenum pname, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_pixel_transform")
    fn_glPixelTransformParameterivEXT glPixelTransformParameterivEXT;
    alias fn_glPixelZoomxOES = extern(System) void function(GLfixed xfactor, GLfixed yfactor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glPixelZoomxOES glPixelZoomxOES;
    alias fn_glPointAlongPathNV = extern(System) GLboolean function(GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat* x, GLfloat* y, GLfloat* tangentX, GLfloat* tangentY) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glPointAlongPathNV glPointAlongPathNV;
    alias fn_glPointParameterfARB = extern(System) void function(GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_point_parameters")
    fn_glPointParameterfARB glPointParameterfARB;
    alias fn_glPointParameterfEXT = extern(System) void function(GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_point_parameters")
    fn_glPointParameterfEXT glPointParameterfEXT;
    alias fn_glPointParameterfSGIS = extern(System) void function(GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_point_parameters")
    fn_glPointParameterfSGIS glPointParameterfSGIS;
    alias fn_glPointParameterfv = extern(System) void function(GLenum pname, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glPointParameterfv glPointParameterfv;
    alias fn_glPointParameterfvARB = extern(System) void function(GLenum pname, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_point_parameters")
    fn_glPointParameterfvARB glPointParameterfvARB;
    alias fn_glPointParameterfvEXT = extern(System) void function(GLenum pname, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_point_parameters")
    fn_glPointParameterfvEXT glPointParameterfvEXT;
    alias fn_glPointParameterfvSGIS = extern(System) void function(GLenum pname, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_point_parameters")
    fn_glPointParameterfvSGIS glPointParameterfvSGIS;
    alias fn_glPointParameteri = extern(System) void function(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glPointParameteri glPointParameteri;
    alias fn_glPointParameteriNV = extern(System) void function(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_point_sprite")
    fn_glPointParameteriNV glPointParameteriNV;
    alias fn_glPointParameteriv = extern(System) void function(GLenum pname, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P4)
    fn_glPointParameteriv glPointParameteriv;
    alias fn_glPointParameterivNV = extern(System) void function(GLenum pname, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_point_sprite")
    fn_glPointParameterivNV glPointParameterivNV;
    alias fn_glPointParameterx = extern(System) void function(GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glPointParameterx glPointParameterx;
    alias fn_glPointParameterxOES = extern(System) void function(GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glPointParameterxOES glPointParameterxOES;
    alias fn_glPointParameterxv = extern(System) void function(GLenum pname, const( GLfixed*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glPointParameterxv glPointParameterxv;
    alias fn_glPointParameterxvOES = extern(System) void function(GLenum pname, const( GLfixed*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glPointParameterxvOES glPointParameterxvOES;
    alias fn_glPointSizePointerOES = extern(System) void function(GLenum type, GLsizei stride, const( void*) pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_point_size_array")
    fn_glPointSizePointerOES glPointSizePointerOES;
    alias fn_glPointSizex = extern(System) void function(GLfixed size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glPointSizex glPointSizex;
    alias fn_glPointSizexOES = extern(System) void function(GLfixed size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glPointSizexOES glPointSizexOES;
    alias fn_glPollAsyncSGIX = extern(System) GLint function(GLuint* markerp) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_async")
    fn_glPollAsyncSGIX glPollAsyncSGIX;
    alias fn_glPollInstrumentsSGIX = extern(System) GLint function(GLint* marker_p) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_instruments")
    fn_glPollInstrumentsSGIX glPollInstrumentsSGIX;
    alias fn_glPolygonModeNV = extern(System) void function(GLenum face, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_polygon_mode")
    fn_glPolygonModeNV glPolygonModeNV;
    alias fn_glPolygonOffsetClampEXT = extern(System) void function(GLfloat factor, GLfloat units, GLfloat clamp) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_polygon_offset_clamp")
    fn_glPolygonOffsetClampEXT glPolygonOffsetClampEXT;
    alias fn_glPolygonOffsetEXT = extern(System) void function(GLfloat factor, GLfloat bias) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_polygon_offset")
    fn_glPolygonOffsetEXT glPolygonOffsetEXT;
    alias fn_glPolygonOffsetx = extern(System) void function(GLfixed factor, GLfixed units) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glPolygonOffsetx glPolygonOffsetx;
    alias fn_glPolygonOffsetxOES = extern(System) void function(GLfixed factor, GLfixed units) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glPolygonOffsetxOES glPolygonOffsetxOES;
    alias fn_glPopDebugGroupKHR = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_debug")
    fn_glPopDebugGroupKHR glPopDebugGroupKHR;
    alias fn_glPopGroupMarkerEXT = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_debug_marker")
    fn_glPopGroupMarkerEXT glPopGroupMarkerEXT;
    alias fn_glPresentFrameDualFillNV = extern(System) void function(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_present_video")
    fn_glPresentFrameDualFillNV glPresentFrameDualFillNV;
    alias fn_glPresentFrameKeyedNV = extern(System) void function(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_present_video")
    fn_glPresentFrameKeyedNV glPresentFrameKeyedNV;
    alias fn_glPrimitiveBoundingBox = extern(System) void function(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glPrimitiveBoundingBox glPrimitiveBoundingBox;
    alias fn_glPrimitiveBoundingBoxARB = extern(System) void function(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_ES3_2_compatibility")
    fn_glPrimitiveBoundingBoxARB glPrimitiveBoundingBoxARB;
    alias fn_glPrimitiveBoundingBoxEXT = extern(System) void function(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_primitive_bounding_box")
    fn_glPrimitiveBoundingBoxEXT glPrimitiveBoundingBoxEXT;
    alias fn_glPrimitiveBoundingBoxOES = extern(System) void function(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_primitive_bounding_box")
    fn_glPrimitiveBoundingBoxOES glPrimitiveBoundingBoxOES;
    alias fn_glPrimitiveRestartIndexNV = extern(System) void function(GLuint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_primitive_restart")
    fn_glPrimitiveRestartIndexNV glPrimitiveRestartIndexNV;
    alias fn_glPrimitiveRestartNV = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_primitive_restart")
    fn_glPrimitiveRestartNV glPrimitiveRestartNV;
    alias fn_glPrioritizeTexturesEXT = extern(System) void function(GLsizei n, const( GLuint*) textures, const( GLclampf*) priorities) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_object")
    fn_glPrioritizeTexturesEXT glPrioritizeTexturesEXT;
    alias fn_glPrioritizeTexturesxOES = extern(System) void function(GLsizei n, const( GLuint*) textures, const( GLfixed*) priorities) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glPrioritizeTexturesxOES glPrioritizeTexturesxOES;
    alias fn_glProgramBinaryOES = extern(System) void function(GLuint program, GLenum binaryFormat, const( void*) binary, GLint length) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_get_program_binary")
    fn_glProgramBinaryOES glProgramBinaryOES;
    alias fn_glProgramBufferParametersIivNV = extern(System) void function(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_parameter_buffer_object")
    fn_glProgramBufferParametersIivNV glProgramBufferParametersIivNV;
    alias fn_glProgramBufferParametersIuivNV = extern(System) void function(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const( GLuint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_parameter_buffer_object")
    fn_glProgramBufferParametersIuivNV glProgramBufferParametersIuivNV;
    alias fn_glProgramBufferParametersfvNV = extern(System) void function(GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_parameter_buffer_object")
    fn_glProgramBufferParametersfvNV glProgramBufferParametersfvNV;
    alias fn_glProgramEnvParameter4dARB = extern(System) void function(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    fn_glProgramEnvParameter4dARB glProgramEnvParameter4dARB;
    alias fn_glProgramEnvParameter4dvARB = extern(System) void function(GLenum target, GLuint index, const( GLdouble*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    fn_glProgramEnvParameter4dvARB glProgramEnvParameter4dvARB;
    alias fn_glProgramEnvParameter4fARB = extern(System) void function(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    fn_glProgramEnvParameter4fARB glProgramEnvParameter4fARB;
    alias fn_glProgramEnvParameter4fvARB = extern(System) void function(GLenum target, GLuint index, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    fn_glProgramEnvParameter4fvARB glProgramEnvParameter4fvARB;
    alias fn_glProgramEnvParameterI4iNV = extern(System) void function(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    fn_glProgramEnvParameterI4iNV glProgramEnvParameterI4iNV;
    alias fn_glProgramEnvParameterI4ivNV = extern(System) void function(GLenum target, GLuint index, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    fn_glProgramEnvParameterI4ivNV glProgramEnvParameterI4ivNV;
    alias fn_glProgramEnvParameterI4uiNV = extern(System) void function(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    fn_glProgramEnvParameterI4uiNV glProgramEnvParameterI4uiNV;
    alias fn_glProgramEnvParameterI4uivNV = extern(System) void function(GLenum target, GLuint index, const( GLuint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    fn_glProgramEnvParameterI4uivNV glProgramEnvParameterI4uivNV;
    alias fn_glProgramEnvParameters4fvEXT = extern(System) void function(GLenum target, GLuint index, GLsizei count, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_gpu_program_parameters")
    fn_glProgramEnvParameters4fvEXT glProgramEnvParameters4fvEXT;
    alias fn_glProgramEnvParametersI4ivNV = extern(System) void function(GLenum target, GLuint index, GLsizei count, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    fn_glProgramEnvParametersI4ivNV glProgramEnvParametersI4ivNV;
    alias fn_glProgramEnvParametersI4uivNV = extern(System) void function(GLenum target, GLuint index, GLsizei count, const( GLuint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    fn_glProgramEnvParametersI4uivNV glProgramEnvParametersI4uivNV;
    alias fn_glProgramLocalParameter4dARB = extern(System) void function(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    fn_glProgramLocalParameter4dARB glProgramLocalParameter4dARB;
    alias fn_glProgramLocalParameter4dvARB = extern(System) void function(GLenum target, GLuint index, const( GLdouble*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    fn_glProgramLocalParameter4dvARB glProgramLocalParameter4dvARB;
    alias fn_glProgramLocalParameter4fARB = extern(System) void function(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    fn_glProgramLocalParameter4fARB glProgramLocalParameter4fARB;
    alias fn_glProgramLocalParameter4fvARB = extern(System) void function(GLenum target, GLuint index, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    fn_glProgramLocalParameter4fvARB glProgramLocalParameter4fvARB;
    alias fn_glProgramLocalParameterI4iNV = extern(System) void function(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    fn_glProgramLocalParameterI4iNV glProgramLocalParameterI4iNV;
    alias fn_glProgramLocalParameterI4ivNV = extern(System) void function(GLenum target, GLuint index, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    fn_glProgramLocalParameterI4ivNV glProgramLocalParameterI4ivNV;
    alias fn_glProgramLocalParameterI4uiNV = extern(System) void function(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    fn_glProgramLocalParameterI4uiNV glProgramLocalParameterI4uiNV;
    alias fn_glProgramLocalParameterI4uivNV = extern(System) void function(GLenum target, GLuint index, const( GLuint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    fn_glProgramLocalParameterI4uivNV glProgramLocalParameterI4uivNV;
    alias fn_glProgramLocalParameters4fvEXT = extern(System) void function(GLenum target, GLuint index, GLsizei count, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_gpu_program_parameters")
    fn_glProgramLocalParameters4fvEXT glProgramLocalParameters4fvEXT;
    alias fn_glProgramLocalParametersI4ivNV = extern(System) void function(GLenum target, GLuint index, GLsizei count, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    fn_glProgramLocalParametersI4ivNV glProgramLocalParametersI4ivNV;
    alias fn_glProgramLocalParametersI4uivNV = extern(System) void function(GLenum target, GLuint index, GLsizei count, const( GLuint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program4")
    fn_glProgramLocalParametersI4uivNV glProgramLocalParametersI4uivNV;
    alias fn_glProgramNamedParameter4dNV = extern(System) void function(GLuint id, GLsizei len, const(GLubyte)* name, GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fragment_program")
    fn_glProgramNamedParameter4dNV glProgramNamedParameter4dNV;
    alias fn_glProgramNamedParameter4dvNV = extern(System) void function(GLuint id, GLsizei len, const(GLubyte)* name, const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fragment_program")
    fn_glProgramNamedParameter4dvNV glProgramNamedParameter4dvNV;
    alias fn_glProgramNamedParameter4fNV = extern(System) void function(GLuint id, GLsizei len, const(GLubyte)* name, GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fragment_program")
    fn_glProgramNamedParameter4fNV glProgramNamedParameter4fNV;
    alias fn_glProgramNamedParameter4fvNV = extern(System) void function(GLuint id, GLsizei len, const(GLubyte)* name, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fragment_program")
    fn_glProgramNamedParameter4fvNV glProgramNamedParameter4fvNV;
    alias fn_glProgramParameter4dNV = extern(System) void function(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glProgramParameter4dNV glProgramParameter4dNV;
    alias fn_glProgramParameter4dvNV = extern(System) void function(GLenum target, GLuint index, const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glProgramParameter4dvNV glProgramParameter4dvNV;
    alias fn_glProgramParameter4fNV = extern(System) void function(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glProgramParameter4fNV glProgramParameter4fNV;
    alias fn_glProgramParameter4fvNV = extern(System) void function(GLenum target, GLuint index, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glProgramParameter4fvNV glProgramParameter4fvNV;
    alias fn_glProgramParameteriARB = extern(System) void function(GLuint program, GLenum pname, GLint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_geometry_shader4")
    fn_glProgramParameteriARB glProgramParameteriARB;
    alias fn_glProgramParameteriEXT = extern(System) void function(GLuint program, GLenum pname, GLint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_geometry_shader4")
    fn_glProgramParameteriEXT glProgramParameteriEXT;
    alias fn_glProgramParameters4dvNV = extern(System) void function(GLenum target, GLuint index, GLsizei count, const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glProgramParameters4dvNV glProgramParameters4dvNV;
    alias fn_glProgramParameters4fvNV = extern(System) void function(GLenum target, GLuint index, GLsizei count, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glProgramParameters4fvNV glProgramParameters4fvNV;
    alias fn_glProgramPathFragmentInputGenNV = extern(System) void function(GLuint program, GLint location, GLenum genMode, GLint components, const( GLfloat*) coeffs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glProgramPathFragmentInputGenNV glProgramPathFragmentInputGenNV;
    alias fn_glProgramStringARB = extern(System) void function(GLenum target, GLenum format, GLsizei len, const( void*) string) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_fragment_program")
    fn_glProgramStringARB glProgramStringARB;
    alias fn_glProgramSubroutineParametersuivNV = extern(System) void function(GLenum target, GLsizei count, const( GLuint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_gpu_program5")
    fn_glProgramSubroutineParametersuivNV glProgramSubroutineParametersuivNV;
    alias fn_glProgramUniform1d = extern(System) void function(GLuint program, GLint location, GLdouble v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniform1d glProgramUniform1d;
    alias fn_glProgramUniform1dEXT = extern(System) void function(GLuint program, GLint location, GLdouble x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniform1dEXT glProgramUniform1dEXT;
    alias fn_glProgramUniform1dv = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniform1dv glProgramUniform1dv;
    alias fn_glProgramUniform1dvEXT = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniform1dvEXT glProgramUniform1dvEXT;
    alias fn_glProgramUniform1fEXT = extern(System) void function(GLuint program, GLint location, GLfloat v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniform1fEXT glProgramUniform1fEXT;
    alias fn_glProgramUniform1fvEXT = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniform1fvEXT glProgramUniform1fvEXT;
    alias fn_glProgramUniform1i64ARB = extern(System) void function(GLuint program, GLint location, GLint64 x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    fn_glProgramUniform1i64ARB glProgramUniform1i64ARB;
    alias fn_glProgramUniform1i64NV = extern(System) void function(GLuint program, GLint location, GLint64EXT x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    fn_glProgramUniform1i64NV glProgramUniform1i64NV;
    alias fn_glProgramUniform1i64vARB = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLint64*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    fn_glProgramUniform1i64vARB glProgramUniform1i64vARB;
    alias fn_glProgramUniform1i64vNV = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLint64EXT*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    fn_glProgramUniform1i64vNV glProgramUniform1i64vNV;
    alias fn_glProgramUniform1iEXT = extern(System) void function(GLuint program, GLint location, GLint v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniform1iEXT glProgramUniform1iEXT;
    alias fn_glProgramUniform1ivEXT = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniform1ivEXT glProgramUniform1ivEXT;
    alias fn_glProgramUniform1ui64ARB = extern(System) void function(GLuint program, GLint location, GLuint64 x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    fn_glProgramUniform1ui64ARB glProgramUniform1ui64ARB;
    alias fn_glProgramUniform1ui64NV = extern(System) void function(GLuint program, GLint location, GLuint64EXT x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    fn_glProgramUniform1ui64NV glProgramUniform1ui64NV;
    alias fn_glProgramUniform1ui64vARB = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLuint64*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    fn_glProgramUniform1ui64vARB glProgramUniform1ui64vARB;
    alias fn_glProgramUniform1ui64vNV = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLuint64EXT*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    fn_glProgramUniform1ui64vNV glProgramUniform1ui64vNV;
    alias fn_glProgramUniform1uiEXT = extern(System) void function(GLuint program, GLint location, GLuint v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniform1uiEXT glProgramUniform1uiEXT;
    alias fn_glProgramUniform1uivEXT = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLuint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniform1uivEXT glProgramUniform1uivEXT;
    alias fn_glProgramUniform2d = extern(System) void function(GLuint program, GLint location, GLdouble v0, GLdouble v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniform2d glProgramUniform2d;
    alias fn_glProgramUniform2dEXT = extern(System) void function(GLuint program, GLint location, GLdouble x, GLdouble y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniform2dEXT glProgramUniform2dEXT;
    alias fn_glProgramUniform2dv = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniform2dv glProgramUniform2dv;
    alias fn_glProgramUniform2dvEXT = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniform2dvEXT glProgramUniform2dvEXT;
    alias fn_glProgramUniform2fEXT = extern(System) void function(GLuint program, GLint location, GLfloat v0, GLfloat v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniform2fEXT glProgramUniform2fEXT;
    alias fn_glProgramUniform2fvEXT = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniform2fvEXT glProgramUniform2fvEXT;
    alias fn_glProgramUniform2i64ARB = extern(System) void function(GLuint program, GLint location, GLint64 x, GLint64 y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    fn_glProgramUniform2i64ARB glProgramUniform2i64ARB;
    alias fn_glProgramUniform2i64NV = extern(System) void function(GLuint program, GLint location, GLint64EXT x, GLint64EXT y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    fn_glProgramUniform2i64NV glProgramUniform2i64NV;
    alias fn_glProgramUniform2i64vARB = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLint64*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    fn_glProgramUniform2i64vARB glProgramUniform2i64vARB;
    alias fn_glProgramUniform2i64vNV = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLint64EXT*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    fn_glProgramUniform2i64vNV glProgramUniform2i64vNV;
    alias fn_glProgramUniform2iEXT = extern(System) void function(GLuint program, GLint location, GLint v0, GLint v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniform2iEXT glProgramUniform2iEXT;
    alias fn_glProgramUniform2ivEXT = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniform2ivEXT glProgramUniform2ivEXT;
    alias fn_glProgramUniform2ui64ARB = extern(System) void function(GLuint program, GLint location, GLuint64 x, GLuint64 y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    fn_glProgramUniform2ui64ARB glProgramUniform2ui64ARB;
    alias fn_glProgramUniform2ui64NV = extern(System) void function(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    fn_glProgramUniform2ui64NV glProgramUniform2ui64NV;
    alias fn_glProgramUniform2ui64vARB = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLuint64*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    fn_glProgramUniform2ui64vARB glProgramUniform2ui64vARB;
    alias fn_glProgramUniform2ui64vNV = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLuint64EXT*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    fn_glProgramUniform2ui64vNV glProgramUniform2ui64vNV;
    alias fn_glProgramUniform2uiEXT = extern(System) void function(GLuint program, GLint location, GLuint v0, GLuint v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniform2uiEXT glProgramUniform2uiEXT;
    alias fn_glProgramUniform2uivEXT = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLuint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniform2uivEXT glProgramUniform2uivEXT;
    alias fn_glProgramUniform3d = extern(System) void function(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniform3d glProgramUniform3d;
    alias fn_glProgramUniform3dEXT = extern(System) void function(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniform3dEXT glProgramUniform3dEXT;
    alias fn_glProgramUniform3dv = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniform3dv glProgramUniform3dv;
    alias fn_glProgramUniform3dvEXT = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniform3dvEXT glProgramUniform3dvEXT;
    alias fn_glProgramUniform3fEXT = extern(System) void function(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniform3fEXT glProgramUniform3fEXT;
    alias fn_glProgramUniform3fvEXT = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniform3fvEXT glProgramUniform3fvEXT;
    alias fn_glProgramUniform3i64ARB = extern(System) void function(GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    fn_glProgramUniform3i64ARB glProgramUniform3i64ARB;
    alias fn_glProgramUniform3i64NV = extern(System) void function(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    fn_glProgramUniform3i64NV glProgramUniform3i64NV;
    alias fn_glProgramUniform3i64vARB = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLint64*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    fn_glProgramUniform3i64vARB glProgramUniform3i64vARB;
    alias fn_glProgramUniform3i64vNV = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLint64EXT*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    fn_glProgramUniform3i64vNV glProgramUniform3i64vNV;
    alias fn_glProgramUniform3iEXT = extern(System) void function(GLuint program, GLint location, GLint v0, GLint v1, GLint v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniform3iEXT glProgramUniform3iEXT;
    alias fn_glProgramUniform3ivEXT = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniform3ivEXT glProgramUniform3ivEXT;
    alias fn_glProgramUniform3ui64ARB = extern(System) void function(GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    fn_glProgramUniform3ui64ARB glProgramUniform3ui64ARB;
    alias fn_glProgramUniform3ui64NV = extern(System) void function(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    fn_glProgramUniform3ui64NV glProgramUniform3ui64NV;
    alias fn_glProgramUniform3ui64vARB = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLuint64*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    fn_glProgramUniform3ui64vARB glProgramUniform3ui64vARB;
    alias fn_glProgramUniform3ui64vNV = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLuint64EXT*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    fn_glProgramUniform3ui64vNV glProgramUniform3ui64vNV;
    alias fn_glProgramUniform3uiEXT = extern(System) void function(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniform3uiEXT glProgramUniform3uiEXT;
    alias fn_glProgramUniform3uivEXT = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLuint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniform3uivEXT glProgramUniform3uivEXT;
    alias fn_glProgramUniform4d = extern(System) void function(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniform4d glProgramUniform4d;
    alias fn_glProgramUniform4dEXT = extern(System) void function(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniform4dEXT glProgramUniform4dEXT;
    alias fn_glProgramUniform4dv = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniform4dv glProgramUniform4dv;
    alias fn_glProgramUniform4dvEXT = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniform4dvEXT glProgramUniform4dvEXT;
    alias fn_glProgramUniform4fEXT = extern(System) void function(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniform4fEXT glProgramUniform4fEXT;
    alias fn_glProgramUniform4fvEXT = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniform4fvEXT glProgramUniform4fvEXT;
    alias fn_glProgramUniform4i64ARB = extern(System) void function(GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    fn_glProgramUniform4i64ARB glProgramUniform4i64ARB;
    alias fn_glProgramUniform4i64NV = extern(System) void function(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    fn_glProgramUniform4i64NV glProgramUniform4i64NV;
    alias fn_glProgramUniform4i64vARB = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLint64*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    fn_glProgramUniform4i64vARB glProgramUniform4i64vARB;
    alias fn_glProgramUniform4i64vNV = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLint64EXT*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    fn_glProgramUniform4i64vNV glProgramUniform4i64vNV;
    alias fn_glProgramUniform4iEXT = extern(System) void function(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniform4iEXT glProgramUniform4iEXT;
    alias fn_glProgramUniform4ivEXT = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniform4ivEXT glProgramUniform4ivEXT;
    alias fn_glProgramUniform4ui64ARB = extern(System) void function(GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    fn_glProgramUniform4ui64ARB glProgramUniform4ui64ARB;
    alias fn_glProgramUniform4ui64NV = extern(System) void function(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    fn_glProgramUniform4ui64NV glProgramUniform4ui64NV;
    alias fn_glProgramUniform4ui64vARB = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLuint64*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    fn_glProgramUniform4ui64vARB glProgramUniform4ui64vARB;
    alias fn_glProgramUniform4ui64vNV = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLuint64EXT*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    fn_glProgramUniform4ui64vNV glProgramUniform4ui64vNV;
    alias fn_glProgramUniform4uiEXT = extern(System) void function(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniform4uiEXT glProgramUniform4uiEXT;
    alias fn_glProgramUniform4uivEXT = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLuint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniform4uivEXT glProgramUniform4uivEXT;
    alias fn_glProgramUniformHandleui64ARB = extern(System) void function(GLuint program, GLint location, GLuint64 value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    fn_glProgramUniformHandleui64ARB glProgramUniformHandleui64ARB;
    alias fn_glProgramUniformHandleui64IMG = extern(System) void function(GLuint program, GLint location, GLuint64 value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IMG_bindless_texture")
    fn_glProgramUniformHandleui64IMG glProgramUniformHandleui64IMG;
    alias fn_glProgramUniformHandleui64NV = extern(System) void function(GLuint program, GLint location, GLuint64 value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    fn_glProgramUniformHandleui64NV glProgramUniformHandleui64NV;
    alias fn_glProgramUniformHandleui64vARB = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLuint64*) values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    fn_glProgramUniformHandleui64vARB glProgramUniformHandleui64vARB;
    alias fn_glProgramUniformHandleui64vIMG = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLuint64*) values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IMG_bindless_texture")
    fn_glProgramUniformHandleui64vIMG glProgramUniformHandleui64vIMG;
    alias fn_glProgramUniformHandleui64vNV = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLuint64*) values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    fn_glProgramUniformHandleui64vNV glProgramUniformHandleui64vNV;
    alias fn_glProgramUniformMatrix2dv = extern(System) void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniformMatrix2dv glProgramUniformMatrix2dv;
    alias fn_glProgramUniformMatrix2dvEXT = extern(System) void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniformMatrix2dvEXT glProgramUniformMatrix2dvEXT;
    alias fn_glProgramUniformMatrix2fvEXT = extern(System) void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniformMatrix2fvEXT glProgramUniformMatrix2fvEXT;
    alias fn_glProgramUniformMatrix2x3dv = extern(System) void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniformMatrix2x3dv glProgramUniformMatrix2x3dv;
    alias fn_glProgramUniformMatrix2x3dvEXT = extern(System) void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniformMatrix2x3dvEXT glProgramUniformMatrix2x3dvEXT;
    alias fn_glProgramUniformMatrix2x3fvEXT = extern(System) void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniformMatrix2x3fvEXT glProgramUniformMatrix2x3fvEXT;
    alias fn_glProgramUniformMatrix2x4dv = extern(System) void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniformMatrix2x4dv glProgramUniformMatrix2x4dv;
    alias fn_glProgramUniformMatrix2x4dvEXT = extern(System) void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniformMatrix2x4dvEXT glProgramUniformMatrix2x4dvEXT;
    alias fn_glProgramUniformMatrix2x4fvEXT = extern(System) void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniformMatrix2x4fvEXT glProgramUniformMatrix2x4fvEXT;
    alias fn_glProgramUniformMatrix3dv = extern(System) void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniformMatrix3dv glProgramUniformMatrix3dv;
    alias fn_glProgramUniformMatrix3dvEXT = extern(System) void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniformMatrix3dvEXT glProgramUniformMatrix3dvEXT;
    alias fn_glProgramUniformMatrix3fvEXT = extern(System) void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniformMatrix3fvEXT glProgramUniformMatrix3fvEXT;
    alias fn_glProgramUniformMatrix3x2dv = extern(System) void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniformMatrix3x2dv glProgramUniformMatrix3x2dv;
    alias fn_glProgramUniformMatrix3x2dvEXT = extern(System) void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniformMatrix3x2dvEXT glProgramUniformMatrix3x2dvEXT;
    alias fn_glProgramUniformMatrix3x2fvEXT = extern(System) void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniformMatrix3x2fvEXT glProgramUniformMatrix3x2fvEXT;
    alias fn_glProgramUniformMatrix3x4dv = extern(System) void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniformMatrix3x4dv glProgramUniformMatrix3x4dv;
    alias fn_glProgramUniformMatrix3x4dvEXT = extern(System) void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniformMatrix3x4dvEXT glProgramUniformMatrix3x4dvEXT;
    alias fn_glProgramUniformMatrix3x4fvEXT = extern(System) void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniformMatrix3x4fvEXT glProgramUniformMatrix3x4fvEXT;
    alias fn_glProgramUniformMatrix4dv = extern(System) void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniformMatrix4dv glProgramUniformMatrix4dv;
    alias fn_glProgramUniformMatrix4dvEXT = extern(System) void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniformMatrix4dvEXT glProgramUniformMatrix4dvEXT;
    alias fn_glProgramUniformMatrix4fvEXT = extern(System) void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniformMatrix4fvEXT glProgramUniformMatrix4fvEXT;
    alias fn_glProgramUniformMatrix4x2dv = extern(System) void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniformMatrix4x2dv glProgramUniformMatrix4x2dv;
    alias fn_glProgramUniformMatrix4x2dvEXT = extern(System) void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniformMatrix4x2dvEXT glProgramUniformMatrix4x2dvEXT;
    alias fn_glProgramUniformMatrix4x2fvEXT = extern(System) void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniformMatrix4x2fvEXT glProgramUniformMatrix4x2fvEXT;
    alias fn_glProgramUniformMatrix4x3dv = extern(System) void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_separate_shader_objects")
    fn_glProgramUniformMatrix4x3dv glProgramUniformMatrix4x3dv;
    alias fn_glProgramUniformMatrix4x3dvEXT = extern(System) void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniformMatrix4x3dvEXT glProgramUniformMatrix4x3dvEXT;
    alias fn_glProgramUniformMatrix4x3fvEXT = extern(System) void function(GLuint program, GLint location, GLsizei count, GLboolean transpose, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glProgramUniformMatrix4x3fvEXT glProgramUniformMatrix4x3fvEXT;
    alias fn_glProgramUniformui64NV = extern(System) void function(GLuint program, GLint location, GLuint64EXT value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    fn_glProgramUniformui64NV glProgramUniformui64NV;
    alias fn_glProgramUniformui64vNV = extern(System) void function(GLuint program, GLint location, GLsizei count, const( GLuint64EXT*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    fn_glProgramUniformui64vNV glProgramUniformui64vNV;
    alias fn_glProgramVertexLimitNV = extern(System) void function(GLenum target, GLint limit) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_geometry_program4")
    fn_glProgramVertexLimitNV glProgramVertexLimitNV;
    alias fn_glProvokingVertexEXT = extern(System) void function(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_provoking_vertex")
    fn_glProvokingVertexEXT glProvokingVertexEXT;
    alias fn_glPushClientAttribDefaultEXT = extern(System) void function(GLbitfield mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glPushClientAttribDefaultEXT glPushClientAttribDefaultEXT;
    alias fn_glPushDebugGroupKHR = extern(System) void function(GLenum source, GLuint id, GLsizei length, const( GLchar*) message) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_debug")
    fn_glPushDebugGroupKHR glPushDebugGroupKHR;
    alias fn_glPushGroupMarkerEXT = extern(System) void function(GLsizei length, const( GLchar*) marker) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_debug_marker")
    fn_glPushGroupMarkerEXT glPushGroupMarkerEXT;
    alias fn_glQueryCounterEXT = extern(System) void function(GLuint id, GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_disjoint_timer_query")
    fn_glQueryCounterEXT glQueryCounterEXT;
    alias fn_glQueryMatrixxOES = extern(System) GLbitfield function(GLfixed* mantissa, GLint* exponent) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_query_matrix")
    fn_glQueryMatrixxOES glQueryMatrixxOES;
    alias fn_glQueryObjectParameteruiAMD = extern(System) void function(GLenum target, GLuint id, GLenum pname, GLuint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_occlusion_query_event")
    fn_glQueryObjectParameteruiAMD glQueryObjectParameteruiAMD;
    alias fn_glRasterPos2xOES = extern(System) void function(GLfixed x, GLfixed y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glRasterPos2xOES glRasterPos2xOES;
    alias fn_glRasterPos2xvOES = extern(System) void function(const( GLfixed*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glRasterPos2xvOES glRasterPos2xvOES;
    alias fn_glRasterPos3xOES = extern(System) void function(GLfixed x, GLfixed y, GLfixed z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glRasterPos3xOES glRasterPos3xOES;
    alias fn_glRasterPos3xvOES = extern(System) void function(const( GLfixed*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glRasterPos3xvOES glRasterPos3xvOES;
    alias fn_glRasterPos4xOES = extern(System) void function(GLfixed x, GLfixed y, GLfixed z, GLfixed w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glRasterPos4xOES glRasterPos4xOES;
    alias fn_glRasterPos4xvOES = extern(System) void function(const( GLfixed*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glRasterPos4xvOES glRasterPos4xvOES;
    alias fn_glRasterSamplesEXT = extern(System) void function(GLuint samples, GLboolean fixedsamplelocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_raster_multisample")
    fn_glRasterSamplesEXT glRasterSamplesEXT;
    alias fn_glReadBufferIndexedEXT = extern(System) void function(GLenum src, GLint index) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_multiview_draw_buffers")
    fn_glReadBufferIndexedEXT glReadBufferIndexedEXT;
    alias fn_glReadBufferNV = extern(System) void function(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_read_buffer")
    fn_glReadBufferNV glReadBufferNV;
    alias fn_glReadInstrumentsSGIX = extern(System) void function(GLint marker) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_instruments")
    fn_glReadInstrumentsSGIX glReadInstrumentsSGIX;
    alias fn_glReadnPixelsARB = extern(System) void function(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_robustness")
    fn_glReadnPixelsARB glReadnPixelsARB;
    alias fn_glReadnPixelsEXT = extern(System) void function(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_robustness")
    fn_glReadnPixelsEXT glReadnPixelsEXT;
    alias fn_glReadnPixelsKHR = extern(System) void function(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void* data) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_KHR_robustness")
    fn_glReadnPixelsKHR glReadnPixelsKHR;
    alias fn_glRectxOES = extern(System) void function(GLfixed x1, GLfixed y1, GLfixed x2, GLfixed y2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glRectxOES glRectxOES;
    alias fn_glRectxvOES = extern(System) void function(const( GLfixed*) v1, const( GLfixed*) v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glRectxvOES glRectxvOES;
    alias fn_glReferencePlaneSGIX = extern(System) void function(const( GLdouble*) equation) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_reference_plane")
    fn_glReferencePlaneSGIX glReferencePlaneSGIX;
    alias fn_glRenderbufferStorageEXT = extern(System) void function(GLenum target, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_object")
    fn_glRenderbufferStorageEXT glRenderbufferStorageEXT;
    alias fn_glRenderbufferStorageMultisampleANGLE = extern(System) void function(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ANGLE_framebuffer_multisample")
    fn_glRenderbufferStorageMultisampleANGLE glRenderbufferStorageMultisampleANGLE;
    alias fn_glRenderbufferStorageMultisampleAPPLE = extern(System) void function(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_framebuffer_multisample")
    fn_glRenderbufferStorageMultisampleAPPLE glRenderbufferStorageMultisampleAPPLE;
    alias fn_glRenderbufferStorageMultisampleCoverageNV = extern(System) void function(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_framebuffer_multisample_coverage")
    fn_glRenderbufferStorageMultisampleCoverageNV glRenderbufferStorageMultisampleCoverageNV;
    alias fn_glRenderbufferStorageMultisampleEXT = extern(System) void function(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_framebuffer_multisample")
    fn_glRenderbufferStorageMultisampleEXT glRenderbufferStorageMultisampleEXT;
    alias fn_glRenderbufferStorageMultisampleIMG = extern(System) void function(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IMG_multisampled_render_to_texture")
    fn_glRenderbufferStorageMultisampleIMG glRenderbufferStorageMultisampleIMG;
    alias fn_glRenderbufferStorageMultisampleNV = extern(System) void function(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_framebuffer_multisample")
    fn_glRenderbufferStorageMultisampleNV glRenderbufferStorageMultisampleNV;
    alias fn_glRenderbufferStorageOES = extern(System) void function(GLenum target, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_framebuffer_object")
    fn_glRenderbufferStorageOES glRenderbufferStorageOES;
    alias fn_glReplacementCodePointerSUN = extern(System) void function(GLenum type, GLsizei stride, const( void**) pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_triangle_list")
    fn_glReplacementCodePointerSUN glReplacementCodePointerSUN;
    alias fn_glReplacementCodeubSUN = extern(System) void function(GLubyte code) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_triangle_list")
    fn_glReplacementCodeubSUN glReplacementCodeubSUN;
    alias fn_glReplacementCodeubvSUN = extern(System) void function(const(GLubyte)* code) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_triangle_list")
    fn_glReplacementCodeubvSUN glReplacementCodeubvSUN;
    alias fn_glReplacementCodeuiColor3fVertex3fSUN = extern(System) void function(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glReplacementCodeuiColor3fVertex3fSUN glReplacementCodeuiColor3fVertex3fSUN;
    alias fn_glReplacementCodeuiColor3fVertex3fvSUN = extern(System) void function(const( GLuint*) rc, const( GLfloat*) c, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glReplacementCodeuiColor3fVertex3fvSUN glReplacementCodeuiColor3fVertex3fvSUN;
    alias fn_glReplacementCodeuiColor4fNormal3fVertex3fSUN = extern(System) void function(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glReplacementCodeuiColor4fNormal3fVertex3fSUN glReplacementCodeuiColor4fNormal3fVertex3fSUN;
    alias fn_glReplacementCodeuiColor4fNormal3fVertex3fvSUN = extern(System) void function(const( GLuint*) rc, const( GLfloat*) c, const( GLfloat*) n, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glReplacementCodeuiColor4fNormal3fVertex3fvSUN glReplacementCodeuiColor4fNormal3fVertex3fvSUN;
    alias fn_glReplacementCodeuiColor4ubVertex3fSUN = extern(System) void function(GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glReplacementCodeuiColor4ubVertex3fSUN glReplacementCodeuiColor4ubVertex3fSUN;
    alias fn_glReplacementCodeuiColor4ubVertex3fvSUN = extern(System) void function(const( GLuint*) rc, const(GLubyte)* c, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glReplacementCodeuiColor4ubVertex3fvSUN glReplacementCodeuiColor4ubVertex3fvSUN;
    alias fn_glReplacementCodeuiNormal3fVertex3fSUN = extern(System) void function(GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glReplacementCodeuiNormal3fVertex3fSUN glReplacementCodeuiNormal3fVertex3fSUN;
    alias fn_glReplacementCodeuiNormal3fVertex3fvSUN = extern(System) void function(const( GLuint*) rc, const( GLfloat*) n, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glReplacementCodeuiNormal3fVertex3fvSUN glReplacementCodeuiNormal3fVertex3fvSUN;
    alias fn_glReplacementCodeuiSUN = extern(System) void function(GLuint code) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_triangle_list")
    fn_glReplacementCodeuiSUN glReplacementCodeuiSUN;
    alias fn_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN = extern(System) void function(GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN;
    alias fn_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN = extern(System) void function(const( GLuint*) rc, const( GLfloat*) tc, const( GLfloat*) c, const( GLfloat*) n, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN;
    alias fn_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN = extern(System) void function(GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN;
    alias fn_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN = extern(System) void function(const( GLuint*) rc, const( GLfloat*) tc, const( GLfloat*) n, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN;
    alias fn_glReplacementCodeuiTexCoord2fVertex3fSUN = extern(System) void function(GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glReplacementCodeuiTexCoord2fVertex3fSUN glReplacementCodeuiTexCoord2fVertex3fSUN;
    alias fn_glReplacementCodeuiTexCoord2fVertex3fvSUN = extern(System) void function(const( GLuint*) rc, const( GLfloat*) tc, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glReplacementCodeuiTexCoord2fVertex3fvSUN glReplacementCodeuiTexCoord2fVertex3fvSUN;
    alias fn_glReplacementCodeuiVertex3fSUN = extern(System) void function(GLuint rc, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glReplacementCodeuiVertex3fSUN glReplacementCodeuiVertex3fSUN;
    alias fn_glReplacementCodeuiVertex3fvSUN = extern(System) void function(const( GLuint*) rc, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glReplacementCodeuiVertex3fvSUN glReplacementCodeuiVertex3fvSUN;
    alias fn_glReplacementCodeuivSUN = extern(System) void function(const( GLuint*) code) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_triangle_list")
    fn_glReplacementCodeuivSUN glReplacementCodeuivSUN;
    alias fn_glReplacementCodeusSUN = extern(System) void function(GLushort code) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_triangle_list")
    fn_glReplacementCodeusSUN glReplacementCodeusSUN;
    alias fn_glReplacementCodeusvSUN = extern(System) void function(const( GLushort*) code) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_triangle_list")
    fn_glReplacementCodeusvSUN glReplacementCodeusvSUN;
    alias fn_glRequestResidentProgramsNV = extern(System) void function(GLsizei n, const( GLuint*) programs) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glRequestResidentProgramsNV glRequestResidentProgramsNV;
    alias fn_glResetHistogramEXT = extern(System) void function(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_histogram")
    fn_glResetHistogramEXT glResetHistogramEXT;
    alias fn_glResetMinmaxEXT = extern(System) void function(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_histogram")
    fn_glResetMinmaxEXT glResetMinmaxEXT;
    alias fn_glResizeBuffersMESA = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_resize_buffers")
    fn_glResizeBuffersMESA glResizeBuffersMESA;
    alias fn_glResolveDepthValuesNV = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_sample_locations")
    fn_glResolveDepthValuesNV glResolveDepthValuesNV;
    alias fn_glResolveMultisampleFramebufferAPPLE = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_framebuffer_multisample")
    fn_glResolveMultisampleFramebufferAPPLE glResolveMultisampleFramebufferAPPLE;
    alias fn_glResumeTransformFeedbackNV = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback2")
    fn_glResumeTransformFeedbackNV glResumeTransformFeedbackNV;
    alias fn_glRotatex = extern(System) void function(GLfixed angle, GLfixed x, GLfixed y, GLfixed z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glRotatex glRotatex;
    alias fn_glRotatexOES = extern(System) void function(GLfixed angle, GLfixed x, GLfixed y, GLfixed z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glRotatexOES glRotatexOES;
    alias fn_glSampleCoverageARB = extern(System) void function(GLfloat value, GLboolean invert) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_multisample")
    fn_glSampleCoverageARB glSampleCoverageARB;
    alias fn_glSampleCoveragex = extern(System) void function(GLclampx value, GLboolean invert) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glSampleCoveragex glSampleCoveragex;
    alias fn_glSampleCoveragexOES = extern(System) void function(GLclampx value, GLboolean invert) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glSampleCoveragexOES glSampleCoveragexOES;
    alias fn_glSampleMapATI = extern(System) void function(GLuint dst, GLuint interp, GLenum swizzle) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    fn_glSampleMapATI glSampleMapATI;
    alias fn_glSampleMaskEXT = extern(System) void function(GLclampf value, GLboolean invert) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_multisample")
    fn_glSampleMaskEXT glSampleMaskEXT;
    alias fn_glSampleMaskIndexedNV = extern(System) void function(GLuint index, GLbitfield mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_explicit_multisample")
    fn_glSampleMaskIndexedNV glSampleMaskIndexedNV;
    alias fn_glSampleMaskSGIS = extern(System) void function(GLclampf value, GLboolean invert) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_multisample")
    fn_glSampleMaskSGIS glSampleMaskSGIS;
    alias fn_glSamplePatternEXT = extern(System) void function(GLenum pattern) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_multisample")
    fn_glSamplePatternEXT glSamplePatternEXT;
    alias fn_glSamplePatternSGIS = extern(System) void function(GLenum pattern) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_multisample")
    fn_glSamplePatternSGIS glSamplePatternSGIS;
    alias fn_glSamplerParameterIiv = extern(System) void function(GLuint sampler, GLenum pname, const( GLint*) param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    fn_glSamplerParameterIiv glSamplerParameterIiv;
    alias fn_glSamplerParameterIivEXT = extern(System) void function(GLuint sampler, GLenum pname, const( GLint*) param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_border_clamp")
    fn_glSamplerParameterIivEXT glSamplerParameterIivEXT;
    alias fn_glSamplerParameterIivOES = extern(System) void function(GLuint sampler, GLenum pname, const( GLint*) param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_border_clamp")
    fn_glSamplerParameterIivOES glSamplerParameterIivOES;
    alias fn_glSamplerParameterIuiv = extern(System) void function(GLuint sampler, GLenum pname, const( GLuint*) param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    fn_glSamplerParameterIuiv glSamplerParameterIuiv;
    alias fn_glSamplerParameterIuivEXT = extern(System) void function(GLuint sampler, GLenum pname, const( GLuint*) param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_border_clamp")
    fn_glSamplerParameterIuivEXT glSamplerParameterIuivEXT;
    alias fn_glSamplerParameterIuivOES = extern(System) void function(GLuint sampler, GLenum pname, const( GLuint*) param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_border_clamp")
    fn_glSamplerParameterIuivOES glSamplerParameterIuivOES;
    alias fn_glSamplerParameterfv = extern(System) void function(GLuint sampler, GLenum pname, const( GLfloat*) param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    fn_glSamplerParameterfv glSamplerParameterfv;
    alias fn_glSamplerParameteri = extern(System) void function(GLuint sampler, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    fn_glSamplerParameteri glSamplerParameteri;
    alias fn_glSamplerParameteriv = extern(System) void function(GLuint sampler, GLenum pname, const( GLint*) param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_sampler_objects")
    fn_glSamplerParameteriv glSamplerParameteriv;
    alias fn_glScalex = extern(System) void function(GLfixed x, GLfixed y, GLfixed z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glScalex glScalex;
    alias fn_glScalexOES = extern(System) void function(GLfixed x, GLfixed y, GLfixed z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glScalexOES glScalexOES;
    alias fn_glScissorArrayvNV = extern(System) void function(GLuint first, GLsizei count, const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_array")
    fn_glScissorArrayvNV glScissorArrayvNV;
    alias fn_glScissorArrayvOES = extern(System) void function(GLuint first, GLsizei count, const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_viewport_array")
    fn_glScissorArrayvOES glScissorArrayvOES;
    alias fn_glScissorIndexedNV = extern(System) void function(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_array")
    fn_glScissorIndexedNV glScissorIndexedNV;
    alias fn_glScissorIndexedOES = extern(System) void function(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_viewport_array")
    fn_glScissorIndexedOES glScissorIndexedOES;
    alias fn_glScissorIndexedvNV = extern(System) void function(GLuint index, const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_array")
    fn_glScissorIndexedvNV glScissorIndexedvNV;
    alias fn_glScissorIndexedvOES = extern(System) void function(GLuint index, const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_viewport_array")
    fn_glScissorIndexedvOES glScissorIndexedvOES;
    alias fn_glSecondaryColor3bEXT = extern(System) void function(GLbyte red, GLbyte green, GLbyte blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    fn_glSecondaryColor3bEXT glSecondaryColor3bEXT;
    alias fn_glSecondaryColor3bvEXT = extern(System) void function(const( GLbyte*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    fn_glSecondaryColor3bvEXT glSecondaryColor3bvEXT;
    alias fn_glSecondaryColor3dEXT = extern(System) void function(GLdouble red, GLdouble green, GLdouble blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    fn_glSecondaryColor3dEXT glSecondaryColor3dEXT;
    alias fn_glSecondaryColor3dvEXT = extern(System) void function(const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    fn_glSecondaryColor3dvEXT glSecondaryColor3dvEXT;
    alias fn_glSecondaryColor3fEXT = extern(System) void function(GLfloat red, GLfloat green, GLfloat blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    fn_glSecondaryColor3fEXT glSecondaryColor3fEXT;
    alias fn_glSecondaryColor3fvEXT = extern(System) void function(const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    fn_glSecondaryColor3fvEXT glSecondaryColor3fvEXT;
    alias fn_glSecondaryColor3hNV = extern(System) void function(GLhalfNV red, GLhalfNV green, GLhalfNV blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glSecondaryColor3hNV glSecondaryColor3hNV;
    alias fn_glSecondaryColor3hvNV = extern(System) void function(const( GLhalfNV*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glSecondaryColor3hvNV glSecondaryColor3hvNV;
    alias fn_glSecondaryColor3iEXT = extern(System) void function(GLint red, GLint green, GLint blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    fn_glSecondaryColor3iEXT glSecondaryColor3iEXT;
    alias fn_glSecondaryColor3ivEXT = extern(System) void function(const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    fn_glSecondaryColor3ivEXT glSecondaryColor3ivEXT;
    alias fn_glSecondaryColor3sEXT = extern(System) void function(GLshort red, GLshort green, GLshort blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    fn_glSecondaryColor3sEXT glSecondaryColor3sEXT;
    alias fn_glSecondaryColor3svEXT = extern(System) void function(const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    fn_glSecondaryColor3svEXT glSecondaryColor3svEXT;
    alias fn_glSecondaryColor3ubEXT = extern(System) void function(GLubyte red, GLubyte green, GLubyte blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    fn_glSecondaryColor3ubEXT glSecondaryColor3ubEXT;
    alias fn_glSecondaryColor3ubvEXT = extern(System) void function(const(GLubyte)* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    fn_glSecondaryColor3ubvEXT glSecondaryColor3ubvEXT;
    alias fn_glSecondaryColor3uiEXT = extern(System) void function(GLuint red, GLuint green, GLuint blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    fn_glSecondaryColor3uiEXT glSecondaryColor3uiEXT;
    alias fn_glSecondaryColor3uivEXT = extern(System) void function(const( GLuint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    fn_glSecondaryColor3uivEXT glSecondaryColor3uivEXT;
    alias fn_glSecondaryColor3usEXT = extern(System) void function(GLushort red, GLushort green, GLushort blue) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    fn_glSecondaryColor3usEXT glSecondaryColor3usEXT;
    alias fn_glSecondaryColor3usvEXT = extern(System) void function(const( GLushort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    fn_glSecondaryColor3usvEXT glSecondaryColor3usvEXT;
    alias fn_glSecondaryColorFormatNV = extern(System) void function(GLint size, GLenum type, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_buffer_unified_memory")
    fn_glSecondaryColorFormatNV glSecondaryColorFormatNV;
    alias fn_glSecondaryColorP3ui = extern(System) void function(GLenum type, GLuint color) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glSecondaryColorP3ui glSecondaryColorP3ui;
    alias fn_glSecondaryColorP3uiv = extern(System) void function(GLenum type, const( GLuint*) color) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glSecondaryColorP3uiv glSecondaryColorP3uiv;
    alias fn_glSecondaryColorPointerEXT = extern(System) void function(GLint size, GLenum type, GLsizei stride, const( void*) pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_secondary_color")
    fn_glSecondaryColorPointerEXT glSecondaryColorPointerEXT;
    alias fn_glSecondaryColorPointerListIBM = extern(System) void function(GLint size, GLenum type, GLint stride, const( void**) pointer, GLint ptrstride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IBM_vertex_array_lists")
    fn_glSecondaryColorPointerListIBM glSecondaryColorPointerListIBM;
    alias fn_glSelectPerfMonitorCountersAMD = extern(System) void function(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint* counterList) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_performance_monitor")
    fn_glSelectPerfMonitorCountersAMD glSelectPerfMonitorCountersAMD;
    alias fn_glSeparableFilter2DEXT = extern(System) void function(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const( void*) row, const( void*) column) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_convolution")
    fn_glSeparableFilter2DEXT glSeparableFilter2DEXT;
    alias fn_glSetFenceAPPLE = extern(System) void function(GLuint fence) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_fence")
    fn_glSetFenceAPPLE glSetFenceAPPLE;
    alias fn_glSetFenceNV = extern(System) void function(GLuint fence, GLenum condition) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fence")
    fn_glSetFenceNV glSetFenceNV;
    alias fn_glSetFragmentShaderConstantATI = extern(System) void function(GLuint dst, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_fragment_shader")
    fn_glSetFragmentShaderConstantATI glSetFragmentShaderConstantATI;
    alias fn_glSetInvariantEXT = extern(System) void function(GLuint id, GLenum type, const( void*) addr) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glSetInvariantEXT glSetInvariantEXT;
    alias fn_glSetLocalConstantEXT = extern(System) void function(GLuint id, GLenum type, const( void*) addr) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glSetLocalConstantEXT glSetLocalConstantEXT;
    alias fn_glSetMultisamplefvAMD = extern(System) void function(GLenum pname, GLuint index, const( GLfloat*) val) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_sample_positions")
    fn_glSetMultisamplefvAMD glSetMultisamplefvAMD;
    alias fn_glShaderOp1EXT = extern(System) void function(GLenum op, GLuint res, GLuint arg1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glShaderOp1EXT glShaderOp1EXT;
    alias fn_glShaderOp2EXT = extern(System) void function(GLenum op, GLuint res, GLuint arg1, GLuint arg2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glShaderOp2EXT glShaderOp2EXT;
    alias fn_glShaderOp3EXT = extern(System) void function(GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glShaderOp3EXT glShaderOp3EXT;
    alias fn_glShaderSourceARB = extern(System) void function(GLhandleARB shaderObj, GLsizei count, const( GLcharARB**) string, const( GLint*) length) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glShaderSourceARB glShaderSourceARB;
    alias fn_glSharpenTexFuncSGIS = extern(System) void function(GLenum target, GLsizei n, const( GLfloat*) points) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_sharpen_texture")
    fn_glSharpenTexFuncSGIS glSharpenTexFuncSGIS;
    alias fn_glSpriteParameterfSGIX = extern(System) void function(GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_sprite")
    fn_glSpriteParameterfSGIX glSpriteParameterfSGIX;
    alias fn_glSpriteParameterfvSGIX = extern(System) void function(GLenum pname, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_sprite")
    fn_glSpriteParameterfvSGIX glSpriteParameterfvSGIX;
    alias fn_glSpriteParameteriSGIX = extern(System) void function(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_sprite")
    fn_glSpriteParameteriSGIX glSpriteParameteriSGIX;
    alias fn_glSpriteParameterivSGIX = extern(System) void function(GLenum pname, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_sprite")
    fn_glSpriteParameterivSGIX glSpriteParameterivSGIX;
    alias fn_glStartInstrumentsSGIX = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_instruments")
    fn_glStartInstrumentsSGIX glStartInstrumentsSGIX;
    alias fn_glStartTilingQCOM = extern(System) void function(GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_QCOM_tiled_rendering")
    fn_glStartTilingQCOM glStartTilingQCOM;
    alias fn_glStateCaptureNV = extern(System) void function(GLuint state, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_command_list")
    fn_glStateCaptureNV glStateCaptureNV;
    alias fn_glStencilClearTagEXT = extern(System) void function(GLsizei stencilTagBits, GLuint stencilClearTag) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_stencil_clear_tag")
    fn_glStencilClearTagEXT glStencilClearTagEXT;
    alias fn_glStencilFillPathInstancedNV = extern(System) void function(GLsizei numPaths, GLenum pathNameType, const( void*) paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const( GLfloat*) transformValues) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glStencilFillPathInstancedNV glStencilFillPathInstancedNV;
    alias fn_glStencilFillPathNV = extern(System) void function(GLuint path, GLenum fillMode, GLuint mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glStencilFillPathNV glStencilFillPathNV;
    alias fn_glStencilFuncSeparateATI = extern(System) void function(GLenum frontfunc, GLenum backfunc, GLint ref_, GLuint mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_separate_stencil")
    fn_glStencilFuncSeparateATI glStencilFuncSeparateATI;
    alias fn_glStencilOpSeparateATI = extern(System) void function(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_separate_stencil")
    fn_glStencilOpSeparateATI glStencilOpSeparateATI;
    alias fn_glStencilOpValueAMD = extern(System) void function(GLenum face, GLuint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_stencil_operation_extended")
    fn_glStencilOpValueAMD glStencilOpValueAMD;
    alias fn_glStencilStrokePathInstancedNV = extern(System) void function(GLsizei numPaths, GLenum pathNameType, const( void*) paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const( GLfloat*) transformValues) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glStencilStrokePathInstancedNV glStencilStrokePathInstancedNV;
    alias fn_glStencilStrokePathNV = extern(System) void function(GLuint path, GLint reference, GLuint mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glStencilStrokePathNV glStencilStrokePathNV;
    alias fn_glStencilThenCoverFillPathInstancedNV = extern(System) void function(GLsizei numPaths, GLenum pathNameType, const( void*) paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum coverMode, GLenum transformType, const( GLfloat*) transformValues) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glStencilThenCoverFillPathInstancedNV glStencilThenCoverFillPathInstancedNV;
    alias fn_glStencilThenCoverFillPathNV = extern(System) void function(GLuint path, GLenum fillMode, GLuint mask, GLenum coverMode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glStencilThenCoverFillPathNV glStencilThenCoverFillPathNV;
    alias fn_glStencilThenCoverStrokePathInstancedNV = extern(System) void function(GLsizei numPaths, GLenum pathNameType, const( void*) paths, GLuint pathBase, GLint reference, GLuint mask, GLenum coverMode, GLenum transformType, const( GLfloat*) transformValues) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glStencilThenCoverStrokePathInstancedNV glStencilThenCoverStrokePathInstancedNV;
    alias fn_glStencilThenCoverStrokePathNV = extern(System) void function(GLuint path, GLint reference, GLuint mask, GLenum coverMode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glStencilThenCoverStrokePathNV glStencilThenCoverStrokePathNV;
    alias fn_glStopInstrumentsSGIX = extern(System) void function(GLint marker) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_instruments")
    fn_glStopInstrumentsSGIX glStopInstrumentsSGIX;
    alias fn_glStringMarkerGREMEDY = extern(System) void function(GLsizei len, const( void*) string) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_GREMEDY_string_marker")
    fn_glStringMarkerGREMEDY glStringMarkerGREMEDY;
    alias fn_glSubpixelPrecisionBiasNV = extern(System) void function(GLuint xbits, GLuint ybits) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_conservative_raster")
    fn_glSubpixelPrecisionBiasNV glSubpixelPrecisionBiasNV;
    alias fn_glSwizzleEXT = extern(System) void function(GLuint res, GLuint in_, GLenum outX, GLenum outY, GLenum outZ, GLenum outW) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glSwizzleEXT glSwizzleEXT;
    alias fn_glSyncTextureINTEL = extern(System) void function(GLuint texture) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_map_texture")
    fn_glSyncTextureINTEL glSyncTextureINTEL;
    alias fn_glTagSampleBufferSGIX = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIX_tag_sample_buffer")
    fn_glTagSampleBufferSGIX glTagSampleBufferSGIX;
    alias fn_glTangent3bEXT = extern(System) void function(GLbyte tx, GLbyte ty, GLbyte tz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    fn_glTangent3bEXT glTangent3bEXT;
    alias fn_glTangent3bvEXT = extern(System) void function(const( GLbyte*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    fn_glTangent3bvEXT glTangent3bvEXT;
    alias fn_glTangent3dEXT = extern(System) void function(GLdouble tx, GLdouble ty, GLdouble tz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    fn_glTangent3dEXT glTangent3dEXT;
    alias fn_glTangent3dvEXT = extern(System) void function(const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    fn_glTangent3dvEXT glTangent3dvEXT;
    alias fn_glTangent3fEXT = extern(System) void function(GLfloat tx, GLfloat ty, GLfloat tz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    fn_glTangent3fEXT glTangent3fEXT;
    alias fn_glTangent3fvEXT = extern(System) void function(const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    fn_glTangent3fvEXT glTangent3fvEXT;
    alias fn_glTangent3iEXT = extern(System) void function(GLint tx, GLint ty, GLint tz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    fn_glTangent3iEXT glTangent3iEXT;
    alias fn_glTangent3ivEXT = extern(System) void function(const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    fn_glTangent3ivEXT glTangent3ivEXT;
    alias fn_glTangent3sEXT = extern(System) void function(GLshort tx, GLshort ty, GLshort tz) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    fn_glTangent3sEXT glTangent3sEXT;
    alias fn_glTangent3svEXT = extern(System) void function(const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    fn_glTangent3svEXT glTangent3svEXT;
    alias fn_glTangentPointerEXT = extern(System) void function(GLenum type, GLsizei stride, const( void*) pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_coordinate_frame")
    fn_glTangentPointerEXT glTangentPointerEXT;
    alias fn_glTbufferMask3DFX = extern(System) void function(GLuint mask) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_3DFX_tbuffer")
    fn_glTbufferMask3DFX glTbufferMask3DFX;
    alias fn_glTessellationFactorAMD = extern(System) void function(GLfloat factor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_vertex_shader_tessellator")
    fn_glTessellationFactorAMD glTessellationFactorAMD;
    alias fn_glTessellationModeAMD = extern(System) void function(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_vertex_shader_tessellator")
    fn_glTessellationModeAMD glTessellationModeAMD;
    alias fn_glTestFenceAPPLE = extern(System) GLboolean function(GLuint fence) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_fence")
    fn_glTestFenceAPPLE glTestFenceAPPLE;
    alias fn_glTestFenceNV = extern(System) GLboolean function(GLuint fence) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_fence")
    fn_glTestFenceNV glTestFenceNV;
    alias fn_glTestObjectAPPLE = extern(System) GLboolean function(GLenum object, GLuint name) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_fence")
    fn_glTestObjectAPPLE glTestObjectAPPLE;
    alias fn_glTexBufferARB = extern(System) void function(GLenum target, GLenum internalformat, GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_texture_buffer_object")
    fn_glTexBufferARB glTexBufferARB;
    alias fn_glTexBufferEXT = extern(System) void function(GLenum target, GLenum internalformat, GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_buffer")
    fn_glTexBufferEXT glTexBufferEXT;
    alias fn_glTexBufferOES = extern(System) void function(GLenum target, GLenum internalformat, GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_buffer")
    fn_glTexBufferOES glTexBufferOES;
    alias fn_glTexBufferRangeEXT = extern(System) void function(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_buffer")
    fn_glTexBufferRangeEXT glTexBufferRangeEXT;
    alias fn_glTexBufferRangeOES = extern(System) void function(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_buffer")
    fn_glTexBufferRangeOES glTexBufferRangeOES;
    alias fn_glTexBumpParameterfvATI = extern(System) void function(GLenum pname, const( GLfloat*) param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_envmap_bumpmap")
    fn_glTexBumpParameterfvATI glTexBumpParameterfvATI;
    alias fn_glTexBumpParameterivATI = extern(System) void function(GLenum pname, const( GLint*) param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_envmap_bumpmap")
    fn_glTexBumpParameterivATI glTexBumpParameterivATI;
    alias fn_glTexCoord1bOES = extern(System) void function(GLbyte s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    fn_glTexCoord1bOES glTexCoord1bOES;
    alias fn_glTexCoord1bvOES = extern(System) void function(const( GLbyte*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    fn_glTexCoord1bvOES glTexCoord1bvOES;
    alias fn_glTexCoord1hNV = extern(System) void function(GLhalfNV s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glTexCoord1hNV glTexCoord1hNV;
    alias fn_glTexCoord1hvNV = extern(System) void function(const( GLhalfNV*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glTexCoord1hvNV glTexCoord1hvNV;
    alias fn_glTexCoord1xOES = extern(System) void function(GLfixed s) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glTexCoord1xOES glTexCoord1xOES;
    alias fn_glTexCoord1xvOES = extern(System) void function(const( GLfixed*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glTexCoord1xvOES glTexCoord1xvOES;
    alias fn_glTexCoord2bOES = extern(System) void function(GLbyte s, GLbyte t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    fn_glTexCoord2bOES glTexCoord2bOES;
    alias fn_glTexCoord2bvOES = extern(System) void function(const( GLbyte*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    fn_glTexCoord2bvOES glTexCoord2bvOES;
    alias fn_glTexCoord2fColor3fVertex3fSUN = extern(System) void function(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glTexCoord2fColor3fVertex3fSUN glTexCoord2fColor3fVertex3fSUN;
    alias fn_glTexCoord2fColor3fVertex3fvSUN = extern(System) void function(const( GLfloat*) tc, const( GLfloat*) c, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glTexCoord2fColor3fVertex3fvSUN glTexCoord2fColor3fVertex3fvSUN;
    alias fn_glTexCoord2fColor4fNormal3fVertex3fSUN = extern(System) void function(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glTexCoord2fColor4fNormal3fVertex3fSUN glTexCoord2fColor4fNormal3fVertex3fSUN;
    alias fn_glTexCoord2fColor4fNormal3fVertex3fvSUN = extern(System) void function(const( GLfloat*) tc, const( GLfloat*) c, const( GLfloat*) n, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glTexCoord2fColor4fNormal3fVertex3fvSUN glTexCoord2fColor4fNormal3fVertex3fvSUN;
    alias fn_glTexCoord2fColor4ubVertex3fSUN = extern(System) void function(GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glTexCoord2fColor4ubVertex3fSUN glTexCoord2fColor4ubVertex3fSUN;
    alias fn_glTexCoord2fColor4ubVertex3fvSUN = extern(System) void function(const( GLfloat*) tc, const(GLubyte)* c, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glTexCoord2fColor4ubVertex3fvSUN glTexCoord2fColor4ubVertex3fvSUN;
    alias fn_glTexCoord2fNormal3fVertex3fSUN = extern(System) void function(GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glTexCoord2fNormal3fVertex3fSUN glTexCoord2fNormal3fVertex3fSUN;
    alias fn_glTexCoord2fNormal3fVertex3fvSUN = extern(System) void function(const( GLfloat*) tc, const( GLfloat*) n, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glTexCoord2fNormal3fVertex3fvSUN glTexCoord2fNormal3fVertex3fvSUN;
    alias fn_glTexCoord2fVertex3fSUN = extern(System) void function(GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glTexCoord2fVertex3fSUN glTexCoord2fVertex3fSUN;
    alias fn_glTexCoord2fVertex3fvSUN = extern(System) void function(const( GLfloat*) tc, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glTexCoord2fVertex3fvSUN glTexCoord2fVertex3fvSUN;
    alias fn_glTexCoord2hNV = extern(System) void function(GLhalfNV s, GLhalfNV t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glTexCoord2hNV glTexCoord2hNV;
    alias fn_glTexCoord2hvNV = extern(System) void function(const( GLhalfNV*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glTexCoord2hvNV glTexCoord2hvNV;
    alias fn_glTexCoord2xOES = extern(System) void function(GLfixed s, GLfixed t) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glTexCoord2xOES glTexCoord2xOES;
    alias fn_glTexCoord2xvOES = extern(System) void function(const( GLfixed*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glTexCoord2xvOES glTexCoord2xvOES;
    alias fn_glTexCoord3bOES = extern(System) void function(GLbyte s, GLbyte t, GLbyte r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    fn_glTexCoord3bOES glTexCoord3bOES;
    alias fn_glTexCoord3bvOES = extern(System) void function(const( GLbyte*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    fn_glTexCoord3bvOES glTexCoord3bvOES;
    alias fn_glTexCoord3hNV = extern(System) void function(GLhalfNV s, GLhalfNV t, GLhalfNV r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glTexCoord3hNV glTexCoord3hNV;
    alias fn_glTexCoord3hvNV = extern(System) void function(const( GLhalfNV*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glTexCoord3hvNV glTexCoord3hvNV;
    alias fn_glTexCoord3xOES = extern(System) void function(GLfixed s, GLfixed t, GLfixed r) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glTexCoord3xOES glTexCoord3xOES;
    alias fn_glTexCoord3xvOES = extern(System) void function(const( GLfixed*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glTexCoord3xvOES glTexCoord3xvOES;
    alias fn_glTexCoord4bOES = extern(System) void function(GLbyte s, GLbyte t, GLbyte r, GLbyte q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    fn_glTexCoord4bOES glTexCoord4bOES;
    alias fn_glTexCoord4bvOES = extern(System) void function(const( GLbyte*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    fn_glTexCoord4bvOES glTexCoord4bvOES;
    alias fn_glTexCoord4fColor4fNormal3fVertex4fSUN = extern(System) void function(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glTexCoord4fColor4fNormal3fVertex4fSUN glTexCoord4fColor4fNormal3fVertex4fSUN;
    alias fn_glTexCoord4fColor4fNormal3fVertex4fvSUN = extern(System) void function(const( GLfloat*) tc, const( GLfloat*) c, const( GLfloat*) n, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glTexCoord4fColor4fNormal3fVertex4fvSUN glTexCoord4fColor4fNormal3fVertex4fvSUN;
    alias fn_glTexCoord4fVertex4fSUN = extern(System) void function(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glTexCoord4fVertex4fSUN glTexCoord4fVertex4fSUN;
    alias fn_glTexCoord4fVertex4fvSUN = extern(System) void function(const( GLfloat*) tc, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SUN_vertex")
    fn_glTexCoord4fVertex4fvSUN glTexCoord4fVertex4fvSUN;
    alias fn_glTexCoord4hNV = extern(System) void function(GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glTexCoord4hNV glTexCoord4hNV;
    alias fn_glTexCoord4hvNV = extern(System) void function(const( GLhalfNV*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glTexCoord4hvNV glTexCoord4hvNV;
    alias fn_glTexCoord4xOES = extern(System) void function(GLfixed s, GLfixed t, GLfixed r, GLfixed q) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glTexCoord4xOES glTexCoord4xOES;
    alias fn_glTexCoord4xvOES = extern(System) void function(const( GLfixed*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glTexCoord4xvOES glTexCoord4xvOES;
    alias fn_glTexCoordFormatNV = extern(System) void function(GLint size, GLenum type, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_buffer_unified_memory")
    fn_glTexCoordFormatNV glTexCoordFormatNV;
    alias fn_glTexCoordP1ui = extern(System) void function(GLenum type, GLuint coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glTexCoordP1ui glTexCoordP1ui;
    alias fn_glTexCoordP1uiv = extern(System) void function(GLenum type, const( GLuint*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glTexCoordP1uiv glTexCoordP1uiv;
    alias fn_glTexCoordP2ui = extern(System) void function(GLenum type, GLuint coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glTexCoordP2ui glTexCoordP2ui;
    alias fn_glTexCoordP2uiv = extern(System) void function(GLenum type, const( GLuint*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glTexCoordP2uiv glTexCoordP2uiv;
    alias fn_glTexCoordP3ui = extern(System) void function(GLenum type, GLuint coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glTexCoordP3ui glTexCoordP3ui;
    alias fn_glTexCoordP3uiv = extern(System) void function(GLenum type, const( GLuint*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glTexCoordP3uiv glTexCoordP3uiv;
    alias fn_glTexCoordP4ui = extern(System) void function(GLenum type, GLuint coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glTexCoordP4ui glTexCoordP4ui;
    alias fn_glTexCoordP4uiv = extern(System) void function(GLenum type, const( GLuint*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glTexCoordP4uiv glTexCoordP4uiv;
    alias fn_glTexCoordPointerEXT = extern(System) void function(GLint size, GLenum type, GLsizei stride, GLsizei count, const( void*) pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_array")
    fn_glTexCoordPointerEXT glTexCoordPointerEXT;
    alias fn_glTexCoordPointerListIBM = extern(System) void function(GLint size, GLenum type, GLint stride, const( void**) pointer, GLint ptrstride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IBM_vertex_array_lists")
    fn_glTexCoordPointerListIBM glTexCoordPointerListIBM;
    alias fn_glTexCoordPointervINTEL = extern(System) void function(GLint size, GLenum type, const( void**) pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_parallel_arrays")
    fn_glTexCoordPointervINTEL glTexCoordPointervINTEL;
    alias fn_glTexEnvx = extern(System) void function(GLenum target, GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glTexEnvx glTexEnvx;
    alias fn_glTexEnvxOES = extern(System) void function(GLenum target, GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glTexEnvxOES glTexEnvxOES;
    alias fn_glTexEnvxv = extern(System) void function(GLenum target, GLenum pname, const( GLfixed*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glTexEnvxv glTexEnvxv;
    alias fn_glTexEnvxvOES = extern(System) void function(GLenum target, GLenum pname, const( GLfixed*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glTexEnvxvOES glTexEnvxvOES;
    alias fn_glTexFilterFuncSGIS = extern(System) void function(GLenum target, GLenum filter, GLsizei n, const( GLfloat*) weights) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_texture_filter4")
    fn_glTexFilterFuncSGIS glTexFilterFuncSGIS;
    alias fn_glTexGenfOES = extern(System) void function(GLenum coord, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_cube_map")
    fn_glTexGenfOES glTexGenfOES;
    alias fn_glTexGenfvOES = extern(System) void function(GLenum coord, GLenum pname, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_cube_map")
    fn_glTexGenfvOES glTexGenfvOES;
    alias fn_glTexGeniOES = extern(System) void function(GLenum coord, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_cube_map")
    fn_glTexGeniOES glTexGeniOES;
    alias fn_glTexGenivOES = extern(System) void function(GLenum coord, GLenum pname, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_cube_map")
    fn_glTexGenivOES glTexGenivOES;
    alias fn_glTexGenxOES = extern(System) void function(GLenum coord, GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glTexGenxOES glTexGenxOES;
    alias fn_glTexGenxvOES = extern(System) void function(GLenum coord, GLenum pname, const( GLfixed*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glTexGenxvOES glTexGenxvOES;
    alias fn_glTexImage2DMultisampleCoverageNV = extern(System) void function(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_texture_multisample")
    fn_glTexImage2DMultisampleCoverageNV glTexImage2DMultisampleCoverageNV;
    alias fn_glTexImage3DEXT = extern(System) void function(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const( void*) pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture3D")
    fn_glTexImage3DEXT glTexImage3DEXT;
    alias fn_glTexImage3DMultisampleCoverageNV = extern(System) void function(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_texture_multisample")
    fn_glTexImage3DMultisampleCoverageNV glTexImage3DMultisampleCoverageNV;
    alias fn_glTexImage3DOES = extern(System) void function(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const( void*) pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_3D")
    fn_glTexImage3DOES glTexImage3DOES;
    alias fn_glTexImage4DSGIS = extern(System) void function(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const( void*) pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_texture4D")
    fn_glTexImage4DSGIS glTexImage4DSGIS;
    alias fn_glTexPageCommitmentARB = extern(System) void function(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_sparse_texture")
    fn_glTexPageCommitmentARB glTexPageCommitmentARB;
    alias fn_glTexPageCommitmentEXT = extern(System) void function(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_sparse_texture")
    fn_glTexPageCommitmentEXT glTexPageCommitmentEXT;
    alias fn_glTexParameterIiv = extern(System) void function(GLenum target, GLenum pname, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glTexParameterIiv glTexParameterIiv;
    alias fn_glTexParameterIivEXT = extern(System) void function(GLenum target, GLenum pname, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_border_clamp")
    fn_glTexParameterIivEXT glTexParameterIivEXT;
    alias fn_glTexParameterIivOES = extern(System) void function(GLenum target, GLenum pname, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_border_clamp")
    fn_glTexParameterIivOES glTexParameterIivOES;
    alias fn_glTexParameterIuiv = extern(System) void function(GLenum target, GLenum pname, const( GLuint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P0)
    fn_glTexParameterIuiv glTexParameterIuiv;
    alias fn_glTexParameterIuivEXT = extern(System) void function(GLenum target, GLenum pname, const( GLuint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_border_clamp")
    fn_glTexParameterIuivEXT glTexParameterIuivEXT;
    alias fn_glTexParameterIuivOES = extern(System) void function(GLenum target, GLenum pname, const( GLuint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_border_clamp")
    fn_glTexParameterIuivOES glTexParameterIuivOES;
    alias fn_glTexParameterfv = extern(System) void function(GLenum target, GLenum pname, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexParameterfv glTexParameterfv;
    alias fn_glTexParameteriv = extern(System) void function(GLenum target, GLenum pname, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V1P0)
    fn_glTexParameteriv glTexParameteriv;
    alias fn_glTexParameterx = extern(System) void function(GLenum target, GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glTexParameterx glTexParameterx;
    alias fn_glTexParameterxOES = extern(System) void function(GLenum target, GLenum pname, GLfixed param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glTexParameterxOES glTexParameterxOES;
    alias fn_glTexParameterxv = extern(System) void function(GLenum target, GLenum pname, const( GLfixed*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glTexParameterxv glTexParameterxv;
    alias fn_glTexParameterxvOES = extern(System) void function(GLenum target, GLenum pname, const( GLfixed*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glTexParameterxvOES glTexParameterxvOES;
    alias fn_glTexRenderbufferNV = extern(System) void function(GLenum target, GLuint renderbuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_explicit_multisample")
    fn_glTexRenderbufferNV glTexRenderbufferNV;
    alias fn_glTexStorage1DEXT = extern(System) void function(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_storage")
    fn_glTexStorage1DEXT glTexStorage1DEXT;
    alias fn_glTexStorage2DEXT = extern(System) void function(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_storage")
    fn_glTexStorage2DEXT glTexStorage2DEXT;
    alias fn_glTexStorage3DEXT = extern(System) void function(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_storage")
    fn_glTexStorage3DEXT glTexStorage3DEXT;
    alias fn_glTexStorage3DMultisampleOES = extern(System) void function(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_storage_multisample_2d_array")
    fn_glTexStorage3DMultisampleOES glTexStorage3DMultisampleOES;
    alias fn_glTexStorageSparseAMD = extern(System) void function(GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_sparse_texture")
    fn_glTexStorageSparseAMD glTexStorageSparseAMD;
    alias fn_glTexSubImage1DEXT = extern(System) void function(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const( void*) pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_subtexture")
    fn_glTexSubImage1DEXT glTexSubImage1DEXT;
    alias fn_glTexSubImage2DEXT = extern(System) void function(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const( void*) pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_subtexture")
    fn_glTexSubImage2DEXT glTexSubImage2DEXT;
    alias fn_glTexSubImage3DEXT = extern(System) void function(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const( void*) pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture3D")
    fn_glTexSubImage3DEXT glTexSubImage3DEXT;
    alias fn_glTexSubImage3DOES = extern(System) void function(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const( void*) pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_3D")
    fn_glTexSubImage3DOES glTexSubImage3DOES;
    alias fn_glTexSubImage4DSGIS = extern(System) void function(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const( void*) pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_texture4D")
    fn_glTexSubImage4DSGIS glTexSubImage4DSGIS;
    alias fn_glTextureBarrierNV = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_texture_barrier")
    fn_glTextureBarrierNV glTextureBarrierNV;
    alias fn_glTextureBufferEXT = extern(System) void function(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glTextureBufferEXT glTextureBufferEXT;
    alias fn_glTextureBufferRangeEXT = extern(System) void function(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glTextureBufferRangeEXT glTextureBufferRangeEXT;
    alias fn_glTextureColorMaskSGIS = extern(System) void function(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_SGIS_texture_color_mask")
    fn_glTextureColorMaskSGIS glTextureColorMaskSGIS;
    alias fn_glTextureImage1DEXT = extern(System) void function(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const( void*) pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glTextureImage1DEXT glTextureImage1DEXT;
    alias fn_glTextureImage2DEXT = extern(System) void function(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const( void*) pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glTextureImage2DEXT glTextureImage2DEXT;
    alias fn_glTextureImage2DMultisampleCoverageNV = extern(System) void function(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_texture_multisample")
    fn_glTextureImage2DMultisampleCoverageNV glTextureImage2DMultisampleCoverageNV;
    alias fn_glTextureImage2DMultisampleNV = extern(System) void function(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_texture_multisample")
    fn_glTextureImage2DMultisampleNV glTextureImage2DMultisampleNV;
    alias fn_glTextureImage3DEXT = extern(System) void function(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const( void*) pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glTextureImage3DEXT glTextureImage3DEXT;
    alias fn_glTextureImage3DMultisampleCoverageNV = extern(System) void function(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_texture_multisample")
    fn_glTextureImage3DMultisampleCoverageNV glTextureImage3DMultisampleCoverageNV;
    alias fn_glTextureImage3DMultisampleNV = extern(System) void function(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_texture_multisample")
    fn_glTextureImage3DMultisampleNV glTextureImage3DMultisampleNV;
    alias fn_glTextureLightEXT = extern(System) void function(GLenum pname) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_light_texture")
    fn_glTextureLightEXT glTextureLightEXT;
    alias fn_glTextureMaterialEXT = extern(System) void function(GLenum face, GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_light_texture")
    fn_glTextureMaterialEXT glTextureMaterialEXT;
    alias fn_glTextureNormalEXT = extern(System) void function(GLenum mode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_perturb_normal")
    fn_glTextureNormalEXT glTextureNormalEXT;
    alias fn_glTexturePageCommitmentEXT = extern(System) void function(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glTexturePageCommitmentEXT glTexturePageCommitmentEXT;
    alias fn_glTextureParameterIiv = extern(System) void function(GLuint texture, GLenum pname, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glTextureParameterIiv glTextureParameterIiv;
    alias fn_glTextureParameterIivEXT = extern(System) void function(GLuint texture, GLenum target, GLenum pname, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glTextureParameterIivEXT glTextureParameterIivEXT;
    alias fn_glTextureParameterIuiv = extern(System) void function(GLuint texture, GLenum pname, const( GLuint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glTextureParameterIuiv glTextureParameterIuiv;
    alias fn_glTextureParameterIuivEXT = extern(System) void function(GLuint texture, GLenum target, GLenum pname, const( GLuint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glTextureParameterIuivEXT glTextureParameterIuivEXT;
    alias fn_glTextureParameterf = extern(System) void function(GLuint texture, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glTextureParameterf glTextureParameterf;
    alias fn_glTextureParameterfEXT = extern(System) void function(GLuint texture, GLenum target, GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glTextureParameterfEXT glTextureParameterfEXT;
    alias fn_glTextureParameterfv = extern(System) void function(GLuint texture, GLenum pname, const( GLfloat*) param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glTextureParameterfv glTextureParameterfv;
    alias fn_glTextureParameterfvEXT = extern(System) void function(GLuint texture, GLenum target, GLenum pname, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glTextureParameterfvEXT glTextureParameterfvEXT;
    alias fn_glTextureParameteri = extern(System) void function(GLuint texture, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glTextureParameteri glTextureParameteri;
    alias fn_glTextureParameteriEXT = extern(System) void function(GLuint texture, GLenum target, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glTextureParameteriEXT glTextureParameteriEXT;
    alias fn_glTextureParameteriv = extern(System) void function(GLuint texture, GLenum pname, const( GLint*) param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P5)
    @OpenGL_Extension("GL_ARB_direct_state_access")
    fn_glTextureParameteriv glTextureParameteriv;
    alias fn_glTextureParameterivEXT = extern(System) void function(GLuint texture, GLenum target, GLenum pname, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glTextureParameterivEXT glTextureParameterivEXT;
    alias fn_glTextureRangeAPPLE = extern(System) void function(GLenum target, GLsizei length, const( void*) pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_texture_range")
    fn_glTextureRangeAPPLE glTextureRangeAPPLE;
    alias fn_glTextureRenderbufferEXT = extern(System) void function(GLuint texture, GLenum target, GLuint renderbuffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glTextureRenderbufferEXT glTextureRenderbufferEXT;
    alias fn_glTextureStorage1DEXT = extern(System) void function(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glTextureStorage1DEXT glTextureStorage1DEXT;
    alias fn_glTextureStorage2DEXT = extern(System) void function(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glTextureStorage2DEXT glTextureStorage2DEXT;
    alias fn_glTextureStorage2DMultisampleEXT = extern(System) void function(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glTextureStorage2DMultisampleEXT glTextureStorage2DMultisampleEXT;
    alias fn_glTextureStorage3DEXT = extern(System) void function(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glTextureStorage3DEXT glTextureStorage3DEXT;
    alias fn_glTextureStorage3DMultisampleEXT = extern(System) void function(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glTextureStorage3DMultisampleEXT glTextureStorage3DMultisampleEXT;
    alias fn_glTextureStorageSparseAMD = extern(System) void function(GLuint texture, GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_sparse_texture")
    fn_glTextureStorageSparseAMD glTextureStorageSparseAMD;
    alias fn_glTextureSubImage1DEXT = extern(System) void function(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const( void*) pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glTextureSubImage1DEXT glTextureSubImage1DEXT;
    alias fn_glTextureSubImage2DEXT = extern(System) void function(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const( void*) pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glTextureSubImage2DEXT glTextureSubImage2DEXT;
    alias fn_glTextureSubImage3DEXT = extern(System) void function(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const( void*) pixels) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glTextureSubImage3DEXT glTextureSubImage3DEXT;
    alias fn_glTextureViewEXT = extern(System) void function(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_texture_view")
    fn_glTextureViewEXT glTextureViewEXT;
    alias fn_glTextureViewOES = extern(System) void function(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_texture_view")
    fn_glTextureViewOES glTextureViewOES;
    alias fn_glTrackMatrixNV = extern(System) void function(GLenum target, GLuint address, GLenum matrix, GLenum transform) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glTrackMatrixNV glTrackMatrixNV;
    alias fn_glTransformFeedbackAttribsNV = extern(System) void function(GLsizei count, const( GLint*) attribs, GLenum bufferMode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback")
    fn_glTransformFeedbackAttribsNV glTransformFeedbackAttribsNV;
    alias fn_glTransformFeedbackStreamAttribsNV = extern(System) void function(GLsizei count, const( GLint*) attribs, GLsizei nbuffers, const( GLint*) bufstreams, GLenum bufferMode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback")
    fn_glTransformFeedbackStreamAttribsNV glTransformFeedbackStreamAttribsNV;
    alias fn_glTransformFeedbackVaryingsEXT = extern(System) void function(GLuint program, GLsizei count, const(const(GLvoid*)*) varyings, GLenum bufferMode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_transform_feedback")
    fn_glTransformFeedbackVaryingsEXT glTransformFeedbackVaryingsEXT;
    alias fn_glTransformFeedbackVaryingsNV = extern(System) void function(GLuint program, GLsizei count, const( GLint*) locations, GLenum bufferMode) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_transform_feedback")
    fn_glTransformFeedbackVaryingsNV glTransformFeedbackVaryingsNV;
    alias fn_glTransformPathNV = extern(System) void function(GLuint resultPath, GLuint srcPath, GLenum transformType, const( GLfloat*) transformValues) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glTransformPathNV glTransformPathNV;
    alias fn_glTranslatex = extern(System) void function(GLfixed x, GLfixed y, GLfixed z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    fn_glTranslatex glTranslatex;
    alias fn_glTranslatexOES = extern(System) void function(GLfixed x, GLfixed y, GLfixed z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glTranslatexOES glTranslatexOES;
    alias fn_glUniform1d = extern(System) void function(GLint location, GLdouble x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    fn_glUniform1d glUniform1d;
    alias fn_glUniform1dv = extern(System) void function(GLint location, GLsizei count, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    fn_glUniform1dv glUniform1dv;
    alias fn_glUniform1fARB = extern(System) void function(GLint location, GLfloat v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glUniform1fARB glUniform1fARB;
    alias fn_glUniform1fvARB = extern(System) void function(GLint location, GLsizei count, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glUniform1fvARB glUniform1fvARB;
    alias fn_glUniform1i64ARB = extern(System) void function(GLint location, GLint64 x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    fn_glUniform1i64ARB glUniform1i64ARB;
    alias fn_glUniform1i64NV = extern(System) void function(GLint location, GLint64EXT x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    fn_glUniform1i64NV glUniform1i64NV;
    alias fn_glUniform1i64vARB = extern(System) void function(GLint location, GLsizei count, const( GLint64*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    fn_glUniform1i64vARB glUniform1i64vARB;
    alias fn_glUniform1i64vNV = extern(System) void function(GLint location, GLsizei count, const( GLint64EXT*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    fn_glUniform1i64vNV glUniform1i64vNV;
    alias fn_glUniform1iARB = extern(System) void function(GLint location, GLint v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glUniform1iARB glUniform1iARB;
    alias fn_glUniform1ivARB = extern(System) void function(GLint location, GLsizei count, const( GLint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glUniform1ivARB glUniform1ivARB;
    alias fn_glUniform1ui64ARB = extern(System) void function(GLint location, GLuint64 x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    fn_glUniform1ui64ARB glUniform1ui64ARB;
    alias fn_glUniform1ui64NV = extern(System) void function(GLint location, GLuint64EXT x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    fn_glUniform1ui64NV glUniform1ui64NV;
    alias fn_glUniform1ui64vARB = extern(System) void function(GLint location, GLsizei count, const( GLuint64*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    fn_glUniform1ui64vARB glUniform1ui64vARB;
    alias fn_glUniform1ui64vNV = extern(System) void function(GLint location, GLsizei count, const( GLuint64EXT*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    fn_glUniform1ui64vNV glUniform1ui64vNV;
    alias fn_glUniform1uiEXT = extern(System) void function(GLint location, GLuint v0) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_gpu_shader4")
    fn_glUniform1uiEXT glUniform1uiEXT;
    alias fn_glUniform1uivEXT = extern(System) void function(GLint location, GLsizei count, const( GLuint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_gpu_shader4")
    fn_glUniform1uivEXT glUniform1uivEXT;
    alias fn_glUniform2d = extern(System) void function(GLint location, GLdouble x, GLdouble y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    fn_glUniform2d glUniform2d;
    alias fn_glUniform2dv = extern(System) void function(GLint location, GLsizei count, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    fn_glUniform2dv glUniform2dv;
    alias fn_glUniform2fARB = extern(System) void function(GLint location, GLfloat v0, GLfloat v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glUniform2fARB glUniform2fARB;
    alias fn_glUniform2fvARB = extern(System) void function(GLint location, GLsizei count, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glUniform2fvARB glUniform2fvARB;
    alias fn_glUniform2i64ARB = extern(System) void function(GLint location, GLint64 x, GLint64 y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    fn_glUniform2i64ARB glUniform2i64ARB;
    alias fn_glUniform2i64NV = extern(System) void function(GLint location, GLint64EXT x, GLint64EXT y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    fn_glUniform2i64NV glUniform2i64NV;
    alias fn_glUniform2i64vARB = extern(System) void function(GLint location, GLsizei count, const( GLint64*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    fn_glUniform2i64vARB glUniform2i64vARB;
    alias fn_glUniform2i64vNV = extern(System) void function(GLint location, GLsizei count, const( GLint64EXT*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    fn_glUniform2i64vNV glUniform2i64vNV;
    alias fn_glUniform2iARB = extern(System) void function(GLint location, GLint v0, GLint v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glUniform2iARB glUniform2iARB;
    alias fn_glUniform2ivARB = extern(System) void function(GLint location, GLsizei count, const( GLint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glUniform2ivARB glUniform2ivARB;
    alias fn_glUniform2ui64ARB = extern(System) void function(GLint location, GLuint64 x, GLuint64 y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    fn_glUniform2ui64ARB glUniform2ui64ARB;
    alias fn_glUniform2ui64NV = extern(System) void function(GLint location, GLuint64EXT x, GLuint64EXT y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    fn_glUniform2ui64NV glUniform2ui64NV;
    alias fn_glUniform2ui64vARB = extern(System) void function(GLint location, GLsizei count, const( GLuint64*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    fn_glUniform2ui64vARB glUniform2ui64vARB;
    alias fn_glUniform2ui64vNV = extern(System) void function(GLint location, GLsizei count, const( GLuint64EXT*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    fn_glUniform2ui64vNV glUniform2ui64vNV;
    alias fn_glUniform2uiEXT = extern(System) void function(GLint location, GLuint v0, GLuint v1) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_gpu_shader4")
    fn_glUniform2uiEXT glUniform2uiEXT;
    alias fn_glUniform2uivEXT = extern(System) void function(GLint location, GLsizei count, const( GLuint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_gpu_shader4")
    fn_glUniform2uivEXT glUniform2uivEXT;
    alias fn_glUniform3d = extern(System) void function(GLint location, GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    fn_glUniform3d glUniform3d;
    alias fn_glUniform3dv = extern(System) void function(GLint location, GLsizei count, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    fn_glUniform3dv glUniform3dv;
    alias fn_glUniform3fARB = extern(System) void function(GLint location, GLfloat v0, GLfloat v1, GLfloat v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glUniform3fARB glUniform3fARB;
    alias fn_glUniform3fvARB = extern(System) void function(GLint location, GLsizei count, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glUniform3fvARB glUniform3fvARB;
    alias fn_glUniform3i64ARB = extern(System) void function(GLint location, GLint64 x, GLint64 y, GLint64 z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    fn_glUniform3i64ARB glUniform3i64ARB;
    alias fn_glUniform3i64NV = extern(System) void function(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    fn_glUniform3i64NV glUniform3i64NV;
    alias fn_glUniform3i64vARB = extern(System) void function(GLint location, GLsizei count, const( GLint64*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    fn_glUniform3i64vARB glUniform3i64vARB;
    alias fn_glUniform3i64vNV = extern(System) void function(GLint location, GLsizei count, const( GLint64EXT*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    fn_glUniform3i64vNV glUniform3i64vNV;
    alias fn_glUniform3iARB = extern(System) void function(GLint location, GLint v0, GLint v1, GLint v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glUniform3iARB glUniform3iARB;
    alias fn_glUniform3ivARB = extern(System) void function(GLint location, GLsizei count, const( GLint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glUniform3ivARB glUniform3ivARB;
    alias fn_glUniform3ui64ARB = extern(System) void function(GLint location, GLuint64 x, GLuint64 y, GLuint64 z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    fn_glUniform3ui64ARB glUniform3ui64ARB;
    alias fn_glUniform3ui64NV = extern(System) void function(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    fn_glUniform3ui64NV glUniform3ui64NV;
    alias fn_glUniform3ui64vARB = extern(System) void function(GLint location, GLsizei count, const( GLuint64*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    fn_glUniform3ui64vARB glUniform3ui64vARB;
    alias fn_glUniform3ui64vNV = extern(System) void function(GLint location, GLsizei count, const( GLuint64EXT*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    fn_glUniform3ui64vNV glUniform3ui64vNV;
    alias fn_glUniform3uiEXT = extern(System) void function(GLint location, GLuint v0, GLuint v1, GLuint v2) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_gpu_shader4")
    fn_glUniform3uiEXT glUniform3uiEXT;
    alias fn_glUniform3uivEXT = extern(System) void function(GLint location, GLsizei count, const( GLuint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_gpu_shader4")
    fn_glUniform3uivEXT glUniform3uivEXT;
    alias fn_glUniform4d = extern(System) void function(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    fn_glUniform4d glUniform4d;
    alias fn_glUniform4dv = extern(System) void function(GLint location, GLsizei count, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    fn_glUniform4dv glUniform4dv;
    alias fn_glUniform4fARB = extern(System) void function(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glUniform4fARB glUniform4fARB;
    alias fn_glUniform4fvARB = extern(System) void function(GLint location, GLsizei count, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glUniform4fvARB glUniform4fvARB;
    alias fn_glUniform4i64ARB = extern(System) void function(GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    fn_glUniform4i64ARB glUniform4i64ARB;
    alias fn_glUniform4i64NV = extern(System) void function(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    fn_glUniform4i64NV glUniform4i64NV;
    alias fn_glUniform4i64vARB = extern(System) void function(GLint location, GLsizei count, const( GLint64*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    fn_glUniform4i64vARB glUniform4i64vARB;
    alias fn_glUniform4i64vNV = extern(System) void function(GLint location, GLsizei count, const( GLint64EXT*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    fn_glUniform4i64vNV glUniform4i64vNV;
    alias fn_glUniform4iARB = extern(System) void function(GLint location, GLint v0, GLint v1, GLint v2, GLint v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glUniform4iARB glUniform4iARB;
    alias fn_glUniform4ivARB = extern(System) void function(GLint location, GLsizei count, const( GLint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glUniform4ivARB glUniform4ivARB;
    alias fn_glUniform4ui64ARB = extern(System) void function(GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    fn_glUniform4ui64ARB glUniform4ui64ARB;
    alias fn_glUniform4ui64NV = extern(System) void function(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    fn_glUniform4ui64NV glUniform4ui64NV;
    alias fn_glUniform4ui64vARB = extern(System) void function(GLint location, GLsizei count, const( GLuint64*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_gpu_shader_int64")
    fn_glUniform4ui64vARB glUniform4ui64vARB;
    alias fn_glUniform4ui64vNV = extern(System) void function(GLint location, GLsizei count, const( GLuint64EXT*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_gpu_shader_int64")
    fn_glUniform4ui64vNV glUniform4ui64vNV;
    alias fn_glUniform4uiEXT = extern(System) void function(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_gpu_shader4")
    fn_glUniform4uiEXT glUniform4uiEXT;
    alias fn_glUniform4uivEXT = extern(System) void function(GLint location, GLsizei count, const( GLuint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_gpu_shader4")
    fn_glUniform4uivEXT glUniform4uivEXT;
    alias fn_glUniformBufferEXT = extern(System) void function(GLuint program, GLint location, GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_bindable_uniform")
    fn_glUniformBufferEXT glUniformBufferEXT;
    alias fn_glUniformHandleui64ARB = extern(System) void function(GLint location, GLuint64 value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    fn_glUniformHandleui64ARB glUniformHandleui64ARB;
    alias fn_glUniformHandleui64IMG = extern(System) void function(GLint location, GLuint64 value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IMG_bindless_texture")
    fn_glUniformHandleui64IMG glUniformHandleui64IMG;
    alias fn_glUniformHandleui64NV = extern(System) void function(GLint location, GLuint64 value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    fn_glUniformHandleui64NV glUniformHandleui64NV;
    alias fn_glUniformHandleui64vARB = extern(System) void function(GLint location, GLsizei count, const( GLuint64*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    fn_glUniformHandleui64vARB glUniformHandleui64vARB;
    alias fn_glUniformHandleui64vIMG = extern(System) void function(GLint location, GLsizei count, const( GLuint64*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IMG_bindless_texture")
    fn_glUniformHandleui64vIMG glUniformHandleui64vIMG;
    alias fn_glUniformHandleui64vNV = extern(System) void function(GLint location, GLsizei count, const( GLuint64*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_bindless_texture")
    fn_glUniformHandleui64vNV glUniformHandleui64vNV;
    alias fn_glUniformMatrix2dv = extern(System) void function(GLint location, GLsizei count, GLboolean transpose, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    fn_glUniformMatrix2dv glUniformMatrix2dv;
    alias fn_glUniformMatrix2fvARB = extern(System) void function(GLint location, GLsizei count, GLboolean transpose, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glUniformMatrix2fvARB glUniformMatrix2fvARB;
    alias fn_glUniformMatrix2x3dv = extern(System) void function(GLint location, GLsizei count, GLboolean transpose, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    fn_glUniformMatrix2x3dv glUniformMatrix2x3dv;
    alias fn_glUniformMatrix2x3fvNV = extern(System) void function(GLint location, GLsizei count, GLboolean transpose, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_non_square_matrices")
    fn_glUniformMatrix2x3fvNV glUniformMatrix2x3fvNV;
    alias fn_glUniformMatrix2x4dv = extern(System) void function(GLint location, GLsizei count, GLboolean transpose, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    fn_glUniformMatrix2x4dv glUniformMatrix2x4dv;
    alias fn_glUniformMatrix2x4fvNV = extern(System) void function(GLint location, GLsizei count, GLboolean transpose, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_non_square_matrices")
    fn_glUniformMatrix2x4fvNV glUniformMatrix2x4fvNV;
    alias fn_glUniformMatrix3dv = extern(System) void function(GLint location, GLsizei count, GLboolean transpose, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    fn_glUniformMatrix3dv glUniformMatrix3dv;
    alias fn_glUniformMatrix3fvARB = extern(System) void function(GLint location, GLsizei count, GLboolean transpose, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glUniformMatrix3fvARB glUniformMatrix3fvARB;
    alias fn_glUniformMatrix3x2dv = extern(System) void function(GLint location, GLsizei count, GLboolean transpose, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    fn_glUniformMatrix3x2dv glUniformMatrix3x2dv;
    alias fn_glUniformMatrix3x2fvNV = extern(System) void function(GLint location, GLsizei count, GLboolean transpose, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_non_square_matrices")
    fn_glUniformMatrix3x2fvNV glUniformMatrix3x2fvNV;
    alias fn_glUniformMatrix3x4dv = extern(System) void function(GLint location, GLsizei count, GLboolean transpose, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    fn_glUniformMatrix3x4dv glUniformMatrix3x4dv;
    alias fn_glUniformMatrix3x4fvNV = extern(System) void function(GLint location, GLsizei count, GLboolean transpose, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_non_square_matrices")
    fn_glUniformMatrix3x4fvNV glUniformMatrix3x4fvNV;
    alias fn_glUniformMatrix4dv = extern(System) void function(GLint location, GLsizei count, GLboolean transpose, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    fn_glUniformMatrix4dv glUniformMatrix4dv;
    alias fn_glUniformMatrix4fvARB = extern(System) void function(GLint location, GLsizei count, GLboolean transpose, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glUniformMatrix4fvARB glUniformMatrix4fvARB;
    alias fn_glUniformMatrix4x2dv = extern(System) void function(GLint location, GLsizei count, GLboolean transpose, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    fn_glUniformMatrix4x2dv glUniformMatrix4x2dv;
    alias fn_glUniformMatrix4x2fvNV = extern(System) void function(GLint location, GLsizei count, GLboolean transpose, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_non_square_matrices")
    fn_glUniformMatrix4x2fvNV glUniformMatrix4x2fvNV;
    alias fn_glUniformMatrix4x3dv = extern(System) void function(GLint location, GLsizei count, GLboolean transpose, const( GLdouble*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P0)
    @OpenGL_Extension("GL_ARB_gpu_shader_fp64")
    fn_glUniformMatrix4x3dv glUniformMatrix4x3dv;
    alias fn_glUniformMatrix4x3fvNV = extern(System) void function(GLint location, GLsizei count, GLboolean transpose, const( GLfloat*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_non_square_matrices")
    fn_glUniformMatrix4x3fvNV glUniformMatrix4x3fvNV;
    alias fn_glUniformui64NV = extern(System) void function(GLint location, GLuint64EXT value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    fn_glUniformui64NV glUniformui64NV;
    alias fn_glUniformui64vNV = extern(System) void function(GLint location, GLsizei count, const( GLuint64EXT*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_shader_buffer_load")
    fn_glUniformui64vNV glUniformui64vNV;
    alias fn_glUnlockArraysEXT = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_compiled_vertex_array")
    fn_glUnlockArraysEXT glUnlockArraysEXT;
    alias fn_glUnmapBufferARB = extern(System) GLboolean function(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_buffer_object")
    fn_glUnmapBufferARB glUnmapBufferARB;
    alias fn_glUnmapBufferOES = extern(System) GLboolean function(GLenum target) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_mapbuffer")
    fn_glUnmapBufferOES glUnmapBufferOES;
    alias fn_glUnmapNamedBufferEXT = extern(System) GLboolean function(GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glUnmapNamedBufferEXT glUnmapNamedBufferEXT;
    alias fn_glUnmapObjectBufferATI = extern(System) void function(GLuint buffer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_map_object_buffer")
    fn_glUnmapObjectBufferATI glUnmapObjectBufferATI;
    alias fn_glUnmapTexture2DINTEL = extern(System) void function(GLuint texture, GLint level) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_map_texture")
    fn_glUnmapTexture2DINTEL glUnmapTexture2DINTEL;
    alias fn_glUpdateObjectBufferATI = extern(System) void function(GLuint buffer, GLuint offset, GLsizei size, const( void*) pointer, GLenum preserve) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_array_object")
    fn_glUpdateObjectBufferATI glUpdateObjectBufferATI;
    alias fn_glUseProgramObjectARB = extern(System) void function(GLhandleARB programObj) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glUseProgramObjectARB glUseProgramObjectARB;
    alias fn_glUseProgramStagesEXT = extern(System) void function(GLuint pipeline, GLbitfield stages, GLuint program) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    fn_glUseProgramStagesEXT glUseProgramStagesEXT;
    alias fn_glUseShaderProgramEXT = extern(System) void function(GLenum type, GLuint program) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    fn_glUseShaderProgramEXT glUseShaderProgramEXT;
    alias fn_glVDPAUFiniNV = extern(System) void function() @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vdpau_interop")
    fn_glVDPAUFiniNV glVDPAUFiniNV;
    alias fn_glVDPAUGetSurfaceivNV = extern(System) void function(GLvdpauSurfaceNV surface, GLenum pname, GLsizei bufSize, GLsizei* length, GLint* values) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vdpau_interop")
    fn_glVDPAUGetSurfaceivNV glVDPAUGetSurfaceivNV;
    alias fn_glVDPAUInitNV = extern(System) void function(const( void*) vdpDevice, const( void*) getProcAddress) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vdpau_interop")
    fn_glVDPAUInitNV glVDPAUInitNV;
    alias fn_glVDPAUIsSurfaceNV = extern(System) GLboolean function(GLvdpauSurfaceNV surface) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vdpau_interop")
    fn_glVDPAUIsSurfaceNV glVDPAUIsSurfaceNV;
    alias fn_glVDPAUMapSurfacesNV = extern(System) void function(GLsizei numSurfaces, const( GLvdpauSurfaceNV*) surfaces) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vdpau_interop")
    fn_glVDPAUMapSurfacesNV glVDPAUMapSurfacesNV;
    alias fn_glVDPAURegisterOutputSurfaceNV = extern(System) GLvdpauSurfaceNV function(const( void*) vdpSurface, GLenum target, GLsizei numTextureNames, const( GLuint*) textureNames) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vdpau_interop")
    fn_glVDPAURegisterOutputSurfaceNV glVDPAURegisterOutputSurfaceNV;
    alias fn_glVDPAURegisterVideoSurfaceNV = extern(System) GLvdpauSurfaceNV function(const( void*) vdpSurface, GLenum target, GLsizei numTextureNames, const( GLuint*) textureNames) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vdpau_interop")
    fn_glVDPAURegisterVideoSurfaceNV glVDPAURegisterVideoSurfaceNV;
    alias fn_glVDPAUSurfaceAccessNV = extern(System) void function(GLvdpauSurfaceNV surface, GLenum access) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vdpau_interop")
    fn_glVDPAUSurfaceAccessNV glVDPAUSurfaceAccessNV;
    alias fn_glVDPAUUnmapSurfacesNV = extern(System) void function(GLsizei numSurface, const( GLvdpauSurfaceNV*) surfaces) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vdpau_interop")
    fn_glVDPAUUnmapSurfacesNV glVDPAUUnmapSurfacesNV;
    alias fn_glVDPAUUnregisterSurfaceNV = extern(System) void function(GLvdpauSurfaceNV surface) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vdpau_interop")
    fn_glVDPAUUnregisterSurfaceNV glVDPAUUnregisterSurfaceNV;
    alias fn_glValidateProgramARB = extern(System) void function(GLhandleARB programObj) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_shader_objects")
    fn_glValidateProgramARB glValidateProgramARB;
    alias fn_glValidateProgramPipelineEXT = extern(System) void function(GLuint pipeline) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_separate_shader_objects")
    fn_glValidateProgramPipelineEXT glValidateProgramPipelineEXT;
    alias fn_glVariantArrayObjectATI = extern(System) void function(GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_array_object")
    fn_glVariantArrayObjectATI glVariantArrayObjectATI;
    alias fn_glVariantPointerEXT = extern(System) void function(GLuint id, GLenum type, GLuint stride, const( void*) addr) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glVariantPointerEXT glVariantPointerEXT;
    alias fn_glVariantbvEXT = extern(System) void function(GLuint id, const( GLbyte*) addr) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glVariantbvEXT glVariantbvEXT;
    alias fn_glVariantdvEXT = extern(System) void function(GLuint id, const( GLdouble*) addr) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glVariantdvEXT glVariantdvEXT;
    alias fn_glVariantfvEXT = extern(System) void function(GLuint id, const( GLfloat*) addr) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glVariantfvEXT glVariantfvEXT;
    alias fn_glVariantivEXT = extern(System) void function(GLuint id, const( GLint*) addr) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glVariantivEXT glVariantivEXT;
    alias fn_glVariantsvEXT = extern(System) void function(GLuint id, const( GLshort*) addr) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glVariantsvEXT glVariantsvEXT;
    alias fn_glVariantubvEXT = extern(System) void function(GLuint id, const(GLubyte)* addr) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glVariantubvEXT glVariantubvEXT;
    alias fn_glVariantuivEXT = extern(System) void function(GLuint id, const( GLuint*) addr) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glVariantuivEXT glVariantuivEXT;
    alias fn_glVariantusvEXT = extern(System) void function(GLuint id, const( GLushort*) addr) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glVariantusvEXT glVariantusvEXT;
    alias fn_glVertex2bOES = extern(System) void function(GLbyte x, GLbyte y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    fn_glVertex2bOES glVertex2bOES;
    alias fn_glVertex2bvOES = extern(System) void function(const( GLbyte*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    fn_glVertex2bvOES glVertex2bvOES;
    alias fn_glVertex2hNV = extern(System) void function(GLhalfNV x, GLhalfNV y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glVertex2hNV glVertex2hNV;
    alias fn_glVertex2hvNV = extern(System) void function(const( GLhalfNV*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glVertex2hvNV glVertex2hvNV;
    alias fn_glVertex2xOES = extern(System) void function(GLfixed x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glVertex2xOES glVertex2xOES;
    alias fn_glVertex2xvOES = extern(System) void function(const( GLfixed*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glVertex2xvOES glVertex2xvOES;
    alias fn_glVertex3bOES = extern(System) void function(GLbyte x, GLbyte y, GLbyte z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    fn_glVertex3bOES glVertex3bOES;
    alias fn_glVertex3bvOES = extern(System) void function(const( GLbyte*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    fn_glVertex3bvOES glVertex3bvOES;
    alias fn_glVertex3hNV = extern(System) void function(GLhalfNV x, GLhalfNV y, GLhalfNV z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glVertex3hNV glVertex3hNV;
    alias fn_glVertex3hvNV = extern(System) void function(const( GLhalfNV*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glVertex3hvNV glVertex3hvNV;
    alias fn_glVertex3xOES = extern(System) void function(GLfixed x, GLfixed y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glVertex3xOES glVertex3xOES;
    alias fn_glVertex3xvOES = extern(System) void function(const( GLfixed*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glVertex3xvOES glVertex3xvOES;
    alias fn_glVertex4bOES = extern(System) void function(GLbyte x, GLbyte y, GLbyte z, GLbyte w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    fn_glVertex4bOES glVertex4bOES;
    alias fn_glVertex4bvOES = extern(System) void function(const( GLbyte*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_byte_coordinates")
    fn_glVertex4bvOES glVertex4bvOES;
    alias fn_glVertex4hNV = extern(System) void function(GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glVertex4hNV glVertex4hNV;
    alias fn_glVertex4hvNV = extern(System) void function(const( GLhalfNV*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glVertex4hvNV glVertex4hvNV;
    alias fn_glVertex4xOES = extern(System) void function(GLfixed x, GLfixed y, GLfixed z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glVertex4xOES glVertex4xOES;
    alias fn_glVertex4xvOES = extern(System) void function(const( GLfixed*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_fixed_point")
    fn_glVertex4xvOES glVertex4xvOES;
    alias fn_glVertexArrayBindVertexBufferEXT = extern(System) void function(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glVertexArrayBindVertexBufferEXT glVertexArrayBindVertexBufferEXT;
    alias fn_glVertexArrayColorOffsetEXT = extern(System) void function(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glVertexArrayColorOffsetEXT glVertexArrayColorOffsetEXT;
    alias fn_glVertexArrayEdgeFlagOffsetEXT = extern(System) void function(GLuint vaobj, GLuint buffer, GLsizei stride, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glVertexArrayEdgeFlagOffsetEXT glVertexArrayEdgeFlagOffsetEXT;
    alias fn_glVertexArrayFogCoordOffsetEXT = extern(System) void function(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glVertexArrayFogCoordOffsetEXT glVertexArrayFogCoordOffsetEXT;
    alias fn_glVertexArrayIndexOffsetEXT = extern(System) void function(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glVertexArrayIndexOffsetEXT glVertexArrayIndexOffsetEXT;
    alias fn_glVertexArrayMultiTexCoordOffsetEXT = extern(System) void function(GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glVertexArrayMultiTexCoordOffsetEXT glVertexArrayMultiTexCoordOffsetEXT;
    alias fn_glVertexArrayNormalOffsetEXT = extern(System) void function(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glVertexArrayNormalOffsetEXT glVertexArrayNormalOffsetEXT;
    alias fn_glVertexArrayParameteriAPPLE = extern(System) void function(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_array_range")
    fn_glVertexArrayParameteriAPPLE glVertexArrayParameteriAPPLE;
    alias fn_glVertexArrayRangeAPPLE = extern(System) void function(GLsizei length, void* pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_vertex_array_range")
    fn_glVertexArrayRangeAPPLE glVertexArrayRangeAPPLE;
    alias fn_glVertexArrayRangeNV = extern(System) void function(GLsizei length, const( void*) pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_array_range")
    fn_glVertexArrayRangeNV glVertexArrayRangeNV;
    alias fn_glVertexArraySecondaryColorOffsetEXT = extern(System) void function(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glVertexArraySecondaryColorOffsetEXT glVertexArraySecondaryColorOffsetEXT;
    alias fn_glVertexArrayTexCoordOffsetEXT = extern(System) void function(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glVertexArrayTexCoordOffsetEXT glVertexArrayTexCoordOffsetEXT;
    alias fn_glVertexArrayVertexAttribBindingEXT = extern(System) void function(GLuint vaobj, GLuint attribindex, GLuint bindingindex) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glVertexArrayVertexAttribBindingEXT glVertexArrayVertexAttribBindingEXT;
    alias fn_glVertexArrayVertexAttribDivisorEXT = extern(System) void function(GLuint vaobj, GLuint index, GLuint divisor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glVertexArrayVertexAttribDivisorEXT glVertexArrayVertexAttribDivisorEXT;
    alias fn_glVertexArrayVertexAttribFormatEXT = extern(System) void function(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glVertexArrayVertexAttribFormatEXT glVertexArrayVertexAttribFormatEXT;
    alias fn_glVertexArrayVertexAttribIFormatEXT = extern(System) void function(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glVertexArrayVertexAttribIFormatEXT glVertexArrayVertexAttribIFormatEXT;
    alias fn_glVertexArrayVertexAttribIOffsetEXT = extern(System) void function(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glVertexArrayVertexAttribIOffsetEXT glVertexArrayVertexAttribIOffsetEXT;
    alias fn_glVertexArrayVertexAttribLFormatEXT = extern(System) void function(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glVertexArrayVertexAttribLFormatEXT glVertexArrayVertexAttribLFormatEXT;
    alias fn_glVertexArrayVertexAttribLOffsetEXT = extern(System) void function(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glVertexArrayVertexAttribLOffsetEXT glVertexArrayVertexAttribLOffsetEXT;
    alias fn_glVertexArrayVertexAttribOffsetEXT = extern(System) void function(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glVertexArrayVertexAttribOffsetEXT glVertexArrayVertexAttribOffsetEXT;
    alias fn_glVertexArrayVertexBindingDivisorEXT = extern(System) void function(GLuint vaobj, GLuint bindingindex, GLuint divisor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glVertexArrayVertexBindingDivisorEXT glVertexArrayVertexBindingDivisorEXT;
    alias fn_glVertexArrayVertexOffsetEXT = extern(System) void function(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_direct_state_access")
    fn_glVertexArrayVertexOffsetEXT glVertexArrayVertexOffsetEXT;
    alias fn_glVertexAttrib1dARB = extern(System) void function(GLuint index, GLdouble x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glVertexAttrib1dARB glVertexAttrib1dARB;
    alias fn_glVertexAttrib1dNV = extern(System) void function(GLuint index, GLdouble x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttrib1dNV glVertexAttrib1dNV;
    alias fn_glVertexAttrib1dvARB = extern(System) void function(GLuint index, const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glVertexAttrib1dvARB glVertexAttrib1dvARB;
    alias fn_glVertexAttrib1dvNV = extern(System) void function(GLuint index, const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttrib1dvNV glVertexAttrib1dvNV;
    alias fn_glVertexAttrib1fARB = extern(System) void function(GLuint index, GLfloat x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glVertexAttrib1fARB glVertexAttrib1fARB;
    alias fn_glVertexAttrib1fNV = extern(System) void function(GLuint index, GLfloat x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttrib1fNV glVertexAttrib1fNV;
    alias fn_glVertexAttrib1fvARB = extern(System) void function(GLuint index, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glVertexAttrib1fvARB glVertexAttrib1fvARB;
    alias fn_glVertexAttrib1fvNV = extern(System) void function(GLuint index, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttrib1fvNV glVertexAttrib1fvNV;
    alias fn_glVertexAttrib1hNV = extern(System) void function(GLuint index, GLhalfNV x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glVertexAttrib1hNV glVertexAttrib1hNV;
    alias fn_glVertexAttrib1hvNV = extern(System) void function(GLuint index, const( GLhalfNV*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glVertexAttrib1hvNV glVertexAttrib1hvNV;
    alias fn_glVertexAttrib1sARB = extern(System) void function(GLuint index, GLshort x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glVertexAttrib1sARB glVertexAttrib1sARB;
    alias fn_glVertexAttrib1sNV = extern(System) void function(GLuint index, GLshort x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttrib1sNV glVertexAttrib1sNV;
    alias fn_glVertexAttrib1svARB = extern(System) void function(GLuint index, const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glVertexAttrib1svARB glVertexAttrib1svARB;
    alias fn_glVertexAttrib1svNV = extern(System) void function(GLuint index, const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttrib1svNV glVertexAttrib1svNV;
    alias fn_glVertexAttrib2dARB = extern(System) void function(GLuint index, GLdouble x, GLdouble y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glVertexAttrib2dARB glVertexAttrib2dARB;
    alias fn_glVertexAttrib2dNV = extern(System) void function(GLuint index, GLdouble x, GLdouble y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttrib2dNV glVertexAttrib2dNV;
    alias fn_glVertexAttrib2dvARB = extern(System) void function(GLuint index, const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glVertexAttrib2dvARB glVertexAttrib2dvARB;
    alias fn_glVertexAttrib2dvNV = extern(System) void function(GLuint index, const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttrib2dvNV glVertexAttrib2dvNV;
    alias fn_glVertexAttrib2fARB = extern(System) void function(GLuint index, GLfloat x, GLfloat y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glVertexAttrib2fARB glVertexAttrib2fARB;
    alias fn_glVertexAttrib2fNV = extern(System) void function(GLuint index, GLfloat x, GLfloat y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttrib2fNV glVertexAttrib2fNV;
    alias fn_glVertexAttrib2fvARB = extern(System) void function(GLuint index, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glVertexAttrib2fvARB glVertexAttrib2fvARB;
    alias fn_glVertexAttrib2fvNV = extern(System) void function(GLuint index, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttrib2fvNV glVertexAttrib2fvNV;
    alias fn_glVertexAttrib2hNV = extern(System) void function(GLuint index, GLhalfNV x, GLhalfNV y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glVertexAttrib2hNV glVertexAttrib2hNV;
    alias fn_glVertexAttrib2hvNV = extern(System) void function(GLuint index, const( GLhalfNV*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glVertexAttrib2hvNV glVertexAttrib2hvNV;
    alias fn_glVertexAttrib2sARB = extern(System) void function(GLuint index, GLshort x, GLshort y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glVertexAttrib2sARB glVertexAttrib2sARB;
    alias fn_glVertexAttrib2sNV = extern(System) void function(GLuint index, GLshort x, GLshort y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttrib2sNV glVertexAttrib2sNV;
    alias fn_glVertexAttrib2svARB = extern(System) void function(GLuint index, const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glVertexAttrib2svARB glVertexAttrib2svARB;
    alias fn_glVertexAttrib2svNV = extern(System) void function(GLuint index, const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttrib2svNV glVertexAttrib2svNV;
    alias fn_glVertexAttrib3dARB = extern(System) void function(GLuint index, GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glVertexAttrib3dARB glVertexAttrib3dARB;
    alias fn_glVertexAttrib3dNV = extern(System) void function(GLuint index, GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttrib3dNV glVertexAttrib3dNV;
    alias fn_glVertexAttrib3dvARB = extern(System) void function(GLuint index, const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glVertexAttrib3dvARB glVertexAttrib3dvARB;
    alias fn_glVertexAttrib3dvNV = extern(System) void function(GLuint index, const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttrib3dvNV glVertexAttrib3dvNV;
    alias fn_glVertexAttrib3fARB = extern(System) void function(GLuint index, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glVertexAttrib3fARB glVertexAttrib3fARB;
    alias fn_glVertexAttrib3fNV = extern(System) void function(GLuint index, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttrib3fNV glVertexAttrib3fNV;
    alias fn_glVertexAttrib3fvARB = extern(System) void function(GLuint index, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glVertexAttrib3fvARB glVertexAttrib3fvARB;
    alias fn_glVertexAttrib3fvNV = extern(System) void function(GLuint index, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttrib3fvNV glVertexAttrib3fvNV;
    alias fn_glVertexAttrib3hNV = extern(System) void function(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glVertexAttrib3hNV glVertexAttrib3hNV;
    alias fn_glVertexAttrib3hvNV = extern(System) void function(GLuint index, const( GLhalfNV*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glVertexAttrib3hvNV glVertexAttrib3hvNV;
    alias fn_glVertexAttrib3sARB = extern(System) void function(GLuint index, GLshort x, GLshort y, GLshort z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glVertexAttrib3sARB glVertexAttrib3sARB;
    alias fn_glVertexAttrib3sNV = extern(System) void function(GLuint index, GLshort x, GLshort y, GLshort z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttrib3sNV glVertexAttrib3sNV;
    alias fn_glVertexAttrib3svARB = extern(System) void function(GLuint index, const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glVertexAttrib3svARB glVertexAttrib3svARB;
    alias fn_glVertexAttrib3svNV = extern(System) void function(GLuint index, const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttrib3svNV glVertexAttrib3svNV;
    alias fn_glVertexAttrib4NbvARB = extern(System) void function(GLuint index, const( GLbyte*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glVertexAttrib4NbvARB glVertexAttrib4NbvARB;
    alias fn_glVertexAttrib4NivARB = extern(System) void function(GLuint index, const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glVertexAttrib4NivARB glVertexAttrib4NivARB;
    alias fn_glVertexAttrib4NsvARB = extern(System) void function(GLuint index, const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glVertexAttrib4NsvARB glVertexAttrib4NsvARB;
    alias fn_glVertexAttrib4NubARB = extern(System) void function(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glVertexAttrib4NubARB glVertexAttrib4NubARB;
    alias fn_glVertexAttrib4NubvARB = extern(System) void function(GLuint index, const(GLubyte)* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glVertexAttrib4NubvARB glVertexAttrib4NubvARB;
    alias fn_glVertexAttrib4NuivARB = extern(System) void function(GLuint index, const( GLuint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glVertexAttrib4NuivARB glVertexAttrib4NuivARB;
    alias fn_glVertexAttrib4NusvARB = extern(System) void function(GLuint index, const( GLushort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glVertexAttrib4NusvARB glVertexAttrib4NusvARB;
    alias fn_glVertexAttrib4bvARB = extern(System) void function(GLuint index, const( GLbyte*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glVertexAttrib4bvARB glVertexAttrib4bvARB;
    alias fn_glVertexAttrib4dARB = extern(System) void function(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glVertexAttrib4dARB glVertexAttrib4dARB;
    alias fn_glVertexAttrib4dNV = extern(System) void function(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttrib4dNV glVertexAttrib4dNV;
    alias fn_glVertexAttrib4dvARB = extern(System) void function(GLuint index, const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glVertexAttrib4dvARB glVertexAttrib4dvARB;
    alias fn_glVertexAttrib4dvNV = extern(System) void function(GLuint index, const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttrib4dvNV glVertexAttrib4dvNV;
    alias fn_glVertexAttrib4fARB = extern(System) void function(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glVertexAttrib4fARB glVertexAttrib4fARB;
    alias fn_glVertexAttrib4fNV = extern(System) void function(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttrib4fNV glVertexAttrib4fNV;
    alias fn_glVertexAttrib4fvARB = extern(System) void function(GLuint index, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glVertexAttrib4fvARB glVertexAttrib4fvARB;
    alias fn_glVertexAttrib4fvNV = extern(System) void function(GLuint index, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttrib4fvNV glVertexAttrib4fvNV;
    alias fn_glVertexAttrib4hNV = extern(System) void function(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glVertexAttrib4hNV glVertexAttrib4hNV;
    alias fn_glVertexAttrib4hvNV = extern(System) void function(GLuint index, const( GLhalfNV*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glVertexAttrib4hvNV glVertexAttrib4hvNV;
    alias fn_glVertexAttrib4ivARB = extern(System) void function(GLuint index, const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glVertexAttrib4ivARB glVertexAttrib4ivARB;
    alias fn_glVertexAttrib4sARB = extern(System) void function(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glVertexAttrib4sARB glVertexAttrib4sARB;
    alias fn_glVertexAttrib4sNV = extern(System) void function(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttrib4sNV glVertexAttrib4sNV;
    alias fn_glVertexAttrib4svARB = extern(System) void function(GLuint index, const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glVertexAttrib4svARB glVertexAttrib4svARB;
    alias fn_glVertexAttrib4svNV = extern(System) void function(GLuint index, const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttrib4svNV glVertexAttrib4svNV;
    alias fn_glVertexAttrib4ubNV = extern(System) void function(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttrib4ubNV glVertexAttrib4ubNV;
    alias fn_glVertexAttrib4ubvARB = extern(System) void function(GLuint index, const(GLubyte)* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glVertexAttrib4ubvARB glVertexAttrib4ubvARB;
    alias fn_glVertexAttrib4ubvNV = extern(System) void function(GLuint index, const(GLubyte)* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttrib4ubvNV glVertexAttrib4ubvNV;
    alias fn_glVertexAttrib4uivARB = extern(System) void function(GLuint index, const( GLuint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glVertexAttrib4uivARB glVertexAttrib4uivARB;
    alias fn_glVertexAttrib4usvARB = extern(System) void function(GLuint index, const( GLushort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glVertexAttrib4usvARB glVertexAttrib4usvARB;
    alias fn_glVertexAttribArrayObjectATI = extern(System) void function(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_attrib_array_object")
    fn_glVertexAttribArrayObjectATI glVertexAttribArrayObjectATI;
    alias fn_glVertexAttribDivisorANGLE = extern(System) void function(GLuint index, GLuint divisor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ANGLE_instanced_arrays")
    fn_glVertexAttribDivisorANGLE glVertexAttribDivisorANGLE;
    alias fn_glVertexAttribDivisorARB = extern(System) void function(GLuint index, GLuint divisor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_instanced_arrays")
    fn_glVertexAttribDivisorARB glVertexAttribDivisorARB;
    alias fn_glVertexAttribDivisorEXT = extern(System) void function(GLuint index, GLuint divisor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_instanced_arrays")
    fn_glVertexAttribDivisorEXT glVertexAttribDivisorEXT;
    alias fn_glVertexAttribDivisorNV = extern(System) void function(GLuint index, GLuint divisor) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_instanced_arrays")
    fn_glVertexAttribDivisorNV glVertexAttribDivisorNV;
    alias fn_glVertexAttribFormatNV = extern(System) void function(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_buffer_unified_memory")
    fn_glVertexAttribFormatNV glVertexAttribFormatNV;
    alias fn_glVertexAttribI1iEXT = extern(System) void function(GLuint index, GLint x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    fn_glVertexAttribI1iEXT glVertexAttribI1iEXT;
    alias fn_glVertexAttribI1ivEXT = extern(System) void function(GLuint index, const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    fn_glVertexAttribI1ivEXT glVertexAttribI1ivEXT;
    alias fn_glVertexAttribI1uiEXT = extern(System) void function(GLuint index, GLuint x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    fn_glVertexAttribI1uiEXT glVertexAttribI1uiEXT;
    alias fn_glVertexAttribI1uivEXT = extern(System) void function(GLuint index, const( GLuint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    fn_glVertexAttribI1uivEXT glVertexAttribI1uivEXT;
    alias fn_glVertexAttribI2iEXT = extern(System) void function(GLuint index, GLint x, GLint y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    fn_glVertexAttribI2iEXT glVertexAttribI2iEXT;
    alias fn_glVertexAttribI2ivEXT = extern(System) void function(GLuint index, const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    fn_glVertexAttribI2ivEXT glVertexAttribI2ivEXT;
    alias fn_glVertexAttribI2uiEXT = extern(System) void function(GLuint index, GLuint x, GLuint y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    fn_glVertexAttribI2uiEXT glVertexAttribI2uiEXT;
    alias fn_glVertexAttribI2uivEXT = extern(System) void function(GLuint index, const( GLuint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    fn_glVertexAttribI2uivEXT glVertexAttribI2uivEXT;
    alias fn_glVertexAttribI3iEXT = extern(System) void function(GLuint index, GLint x, GLint y, GLint z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    fn_glVertexAttribI3iEXT glVertexAttribI3iEXT;
    alias fn_glVertexAttribI3ivEXT = extern(System) void function(GLuint index, const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    fn_glVertexAttribI3ivEXT glVertexAttribI3ivEXT;
    alias fn_glVertexAttribI3uiEXT = extern(System) void function(GLuint index, GLuint x, GLuint y, GLuint z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    fn_glVertexAttribI3uiEXT glVertexAttribI3uiEXT;
    alias fn_glVertexAttribI3uivEXT = extern(System) void function(GLuint index, const( GLuint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    fn_glVertexAttribI3uivEXT glVertexAttribI3uivEXT;
    alias fn_glVertexAttribI4bvEXT = extern(System) void function(GLuint index, const( GLbyte*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    fn_glVertexAttribI4bvEXT glVertexAttribI4bvEXT;
    alias fn_glVertexAttribI4iEXT = extern(System) void function(GLuint index, GLint x, GLint y, GLint z, GLint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    fn_glVertexAttribI4iEXT glVertexAttribI4iEXT;
    alias fn_glVertexAttribI4ivEXT = extern(System) void function(GLuint index, const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    fn_glVertexAttribI4ivEXT glVertexAttribI4ivEXT;
    alias fn_glVertexAttribI4svEXT = extern(System) void function(GLuint index, const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    fn_glVertexAttribI4svEXT glVertexAttribI4svEXT;
    alias fn_glVertexAttribI4ubvEXT = extern(System) void function(GLuint index, const(GLubyte)* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    fn_glVertexAttribI4ubvEXT glVertexAttribI4ubvEXT;
    alias fn_glVertexAttribI4uiEXT = extern(System) void function(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    fn_glVertexAttribI4uiEXT glVertexAttribI4uiEXT;
    alias fn_glVertexAttribI4uivEXT = extern(System) void function(GLuint index, const( GLuint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    fn_glVertexAttribI4uivEXT glVertexAttribI4uivEXT;
    alias fn_glVertexAttribI4usvEXT = extern(System) void function(GLuint index, const( GLushort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    fn_glVertexAttribI4usvEXT glVertexAttribI4usvEXT;
    alias fn_glVertexAttribIFormatNV = extern(System) void function(GLuint index, GLint size, GLenum type, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_buffer_unified_memory")
    fn_glVertexAttribIFormatNV glVertexAttribIFormatNV;
    alias fn_glVertexAttribIPointerEXT = extern(System) void function(GLuint index, GLint size, GLenum type, GLsizei stride, const( void*) pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program4")
    fn_glVertexAttribIPointerEXT glVertexAttribIPointerEXT;
    alias fn_glVertexAttribL1dEXT = extern(System) void function(GLuint index, GLdouble x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_attrib_64bit")
    fn_glVertexAttribL1dEXT glVertexAttribL1dEXT;
    alias fn_glVertexAttribL1dvEXT = extern(System) void function(GLuint index, const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_attrib_64bit")
    fn_glVertexAttribL1dvEXT glVertexAttribL1dvEXT;
    alias fn_glVertexAttribL1i64NV = extern(System) void function(GLuint index, GLint64EXT x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    fn_glVertexAttribL1i64NV glVertexAttribL1i64NV;
    alias fn_glVertexAttribL1i64vNV = extern(System) void function(GLuint index, const( GLint64EXT*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    fn_glVertexAttribL1i64vNV glVertexAttribL1i64vNV;
    alias fn_glVertexAttribL1ui64ARB = extern(System) void function(GLuint index, GLuint64EXT x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    fn_glVertexAttribL1ui64ARB glVertexAttribL1ui64ARB;
    alias fn_glVertexAttribL1ui64NV = extern(System) void function(GLuint index, GLuint64EXT x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    fn_glVertexAttribL1ui64NV glVertexAttribL1ui64NV;
    alias fn_glVertexAttribL1ui64vARB = extern(System) void function(GLuint index, const( GLuint64EXT*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_bindless_texture")
    fn_glVertexAttribL1ui64vARB glVertexAttribL1ui64vARB;
    alias fn_glVertexAttribL1ui64vNV = extern(System) void function(GLuint index, const( GLuint64EXT*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    fn_glVertexAttribL1ui64vNV glVertexAttribL1ui64vNV;
    alias fn_glVertexAttribL2dEXT = extern(System) void function(GLuint index, GLdouble x, GLdouble y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_attrib_64bit")
    fn_glVertexAttribL2dEXT glVertexAttribL2dEXT;
    alias fn_glVertexAttribL2dvEXT = extern(System) void function(GLuint index, const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_attrib_64bit")
    fn_glVertexAttribL2dvEXT glVertexAttribL2dvEXT;
    alias fn_glVertexAttribL2i64NV = extern(System) void function(GLuint index, GLint64EXT x, GLint64EXT y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    fn_glVertexAttribL2i64NV glVertexAttribL2i64NV;
    alias fn_glVertexAttribL2i64vNV = extern(System) void function(GLuint index, const( GLint64EXT*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    fn_glVertexAttribL2i64vNV glVertexAttribL2i64vNV;
    alias fn_glVertexAttribL2ui64NV = extern(System) void function(GLuint index, GLuint64EXT x, GLuint64EXT y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    fn_glVertexAttribL2ui64NV glVertexAttribL2ui64NV;
    alias fn_glVertexAttribL2ui64vNV = extern(System) void function(GLuint index, const( GLuint64EXT*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    fn_glVertexAttribL2ui64vNV glVertexAttribL2ui64vNV;
    alias fn_glVertexAttribL3dEXT = extern(System) void function(GLuint index, GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_attrib_64bit")
    fn_glVertexAttribL3dEXT glVertexAttribL3dEXT;
    alias fn_glVertexAttribL3dvEXT = extern(System) void function(GLuint index, const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_attrib_64bit")
    fn_glVertexAttribL3dvEXT glVertexAttribL3dvEXT;
    alias fn_glVertexAttribL3i64NV = extern(System) void function(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    fn_glVertexAttribL3i64NV glVertexAttribL3i64NV;
    alias fn_glVertexAttribL3i64vNV = extern(System) void function(GLuint index, const( GLint64EXT*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    fn_glVertexAttribL3i64vNV glVertexAttribL3i64vNV;
    alias fn_glVertexAttribL3ui64NV = extern(System) void function(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    fn_glVertexAttribL3ui64NV glVertexAttribL3ui64NV;
    alias fn_glVertexAttribL3ui64vNV = extern(System) void function(GLuint index, const( GLuint64EXT*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    fn_glVertexAttribL3ui64vNV glVertexAttribL3ui64vNV;
    alias fn_glVertexAttribL4dEXT = extern(System) void function(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_attrib_64bit")
    fn_glVertexAttribL4dEXT glVertexAttribL4dEXT;
    alias fn_glVertexAttribL4dvEXT = extern(System) void function(GLuint index, const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_attrib_64bit")
    fn_glVertexAttribL4dvEXT glVertexAttribL4dvEXT;
    alias fn_glVertexAttribL4i64NV = extern(System) void function(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    fn_glVertexAttribL4i64NV glVertexAttribL4i64NV;
    alias fn_glVertexAttribL4i64vNV = extern(System) void function(GLuint index, const( GLint64EXT*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    fn_glVertexAttribL4i64vNV glVertexAttribL4i64vNV;
    alias fn_glVertexAttribL4ui64NV = extern(System) void function(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    fn_glVertexAttribL4ui64NV glVertexAttribL4ui64NV;
    alias fn_glVertexAttribL4ui64vNV = extern(System) void function(GLuint index, const( GLuint64EXT*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    fn_glVertexAttribL4ui64vNV glVertexAttribL4ui64vNV;
    alias fn_glVertexAttribLFormatNV = extern(System) void function(GLuint index, GLint size, GLenum type, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_attrib_integer_64bit")
    fn_glVertexAttribLFormatNV glVertexAttribLFormatNV;
    alias fn_glVertexAttribLPointerEXT = extern(System) void function(GLuint index, GLint size, GLenum type, GLsizei stride, const( void*) pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_attrib_64bit")
    fn_glVertexAttribLPointerEXT glVertexAttribLPointerEXT;
    alias fn_glVertexAttribP1uiv = extern(System) void function(GLuint index, GLenum type, GLboolean normalized, const( GLuint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glVertexAttribP1uiv glVertexAttribP1uiv;
    alias fn_glVertexAttribP2uiv = extern(System) void function(GLuint index, GLenum type, GLboolean normalized, const( GLuint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glVertexAttribP2uiv glVertexAttribP2uiv;
    alias fn_glVertexAttribP3uiv = extern(System) void function(GLuint index, GLenum type, GLboolean normalized, const( GLuint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glVertexAttribP3uiv glVertexAttribP3uiv;
    alias fn_glVertexAttribP4uiv = extern(System) void function(GLuint index, GLenum type, GLboolean normalized, const( GLuint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glVertexAttribP4uiv glVertexAttribP4uiv;
    alias fn_glVertexAttribParameteriAMD = extern(System) void function(GLuint index, GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_AMD_interleaved_elements")
    fn_glVertexAttribParameteriAMD glVertexAttribParameteriAMD;
    alias fn_glVertexAttribPointerARB = extern(System) void function(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const( void*) pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_program")
    fn_glVertexAttribPointerARB glVertexAttribPointerARB;
    alias fn_glVertexAttribPointerNV = extern(System) void function(GLuint index, GLint fsize, GLenum type, GLsizei stride, const( void*) pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttribPointerNV glVertexAttribPointerNV;
    alias fn_glVertexAttribs1dvNV = extern(System) void function(GLuint index, GLsizei count, const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttribs1dvNV glVertexAttribs1dvNV;
    alias fn_glVertexAttribs1fvNV = extern(System) void function(GLuint index, GLsizei count, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttribs1fvNV glVertexAttribs1fvNV;
    alias fn_glVertexAttribs1hvNV = extern(System) void function(GLuint index, GLsizei n, const( GLhalfNV*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glVertexAttribs1hvNV glVertexAttribs1hvNV;
    alias fn_glVertexAttribs1svNV = extern(System) void function(GLuint index, GLsizei count, const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttribs1svNV glVertexAttribs1svNV;
    alias fn_glVertexAttribs2dvNV = extern(System) void function(GLuint index, GLsizei count, const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttribs2dvNV glVertexAttribs2dvNV;
    alias fn_glVertexAttribs2fvNV = extern(System) void function(GLuint index, GLsizei count, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttribs2fvNV glVertexAttribs2fvNV;
    alias fn_glVertexAttribs2hvNV = extern(System) void function(GLuint index, GLsizei n, const( GLhalfNV*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glVertexAttribs2hvNV glVertexAttribs2hvNV;
    alias fn_glVertexAttribs2svNV = extern(System) void function(GLuint index, GLsizei count, const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttribs2svNV glVertexAttribs2svNV;
    alias fn_glVertexAttribs3dvNV = extern(System) void function(GLuint index, GLsizei count, const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttribs3dvNV glVertexAttribs3dvNV;
    alias fn_glVertexAttribs3fvNV = extern(System) void function(GLuint index, GLsizei count, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttribs3fvNV glVertexAttribs3fvNV;
    alias fn_glVertexAttribs3hvNV = extern(System) void function(GLuint index, GLsizei n, const( GLhalfNV*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glVertexAttribs3hvNV glVertexAttribs3hvNV;
    alias fn_glVertexAttribs3svNV = extern(System) void function(GLuint index, GLsizei count, const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttribs3svNV glVertexAttribs3svNV;
    alias fn_glVertexAttribs4dvNV = extern(System) void function(GLuint index, GLsizei count, const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttribs4dvNV glVertexAttribs4dvNV;
    alias fn_glVertexAttribs4fvNV = extern(System) void function(GLuint index, GLsizei count, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttribs4fvNV glVertexAttribs4fvNV;
    alias fn_glVertexAttribs4hvNV = extern(System) void function(GLuint index, GLsizei n, const( GLhalfNV*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glVertexAttribs4hvNV glVertexAttribs4hvNV;
    alias fn_glVertexAttribs4svNV = extern(System) void function(GLuint index, GLsizei count, const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttribs4svNV glVertexAttribs4svNV;
    alias fn_glVertexAttribs4ubvNV = extern(System) void function(GLuint index, GLsizei count, const(GLubyte)* v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_program")
    fn_glVertexAttribs4ubvNV glVertexAttribs4ubvNV;
    alias fn_glVertexBlendARB = extern(System) void function(GLint count) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_blend")
    fn_glVertexBlendARB glVertexBlendARB;
    alias fn_glVertexBlendEnvfATI = extern(System) void function(GLenum pname, GLfloat param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glVertexBlendEnvfATI glVertexBlendEnvfATI;
    alias fn_glVertexBlendEnviATI = extern(System) void function(GLenum pname, GLint param) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glVertexBlendEnviATI glVertexBlendEnviATI;
    alias fn_glVertexFormatNV = extern(System) void function(GLint size, GLenum type, GLsizei stride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_vertex_buffer_unified_memory")
    fn_glVertexFormatNV glVertexFormatNV;
    alias fn_glVertexP2ui = extern(System) void function(GLenum type, GLuint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glVertexP2ui glVertexP2ui;
    alias fn_glVertexP2uiv = extern(System) void function(GLenum type, const( GLuint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glVertexP2uiv glVertexP2uiv;
    alias fn_glVertexP3ui = extern(System) void function(GLenum type, GLuint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glVertexP3ui glVertexP3ui;
    alias fn_glVertexP3uiv = extern(System) void function(GLenum type, const( GLuint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glVertexP3uiv glVertexP3uiv;
    alias fn_glVertexP4ui = extern(System) void function(GLenum type, GLuint value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glVertexP4ui glVertexP4ui;
    alias fn_glVertexP4uiv = extern(System) void function(GLenum type, const( GLuint*) value) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V3P3)
    @OpenGL_Extension("GL_ARB_vertex_type_2_10_10_10_rev")
    fn_glVertexP4uiv glVertexP4uiv;
    alias fn_glVertexPointerEXT = extern(System) void function(GLint size, GLenum type, GLsizei stride, GLsizei count, const( void*) pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_array")
    fn_glVertexPointerEXT glVertexPointerEXT;
    alias fn_glVertexPointerListIBM = extern(System) void function(GLint size, GLenum type, GLint stride, const( void**) pointer, GLint ptrstride) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_IBM_vertex_array_lists")
    fn_glVertexPointerListIBM glVertexPointerListIBM;
    alias fn_glVertexPointervINTEL = extern(System) void function(GLint size, GLenum type, const( void**) pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_INTEL_parallel_arrays")
    fn_glVertexPointervINTEL glVertexPointervINTEL;
    alias fn_glVertexStream1dATI = extern(System) void function(GLenum stream, GLdouble x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glVertexStream1dATI glVertexStream1dATI;
    alias fn_glVertexStream1dvATI = extern(System) void function(GLenum stream, const( GLdouble*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glVertexStream1dvATI glVertexStream1dvATI;
    alias fn_glVertexStream1fATI = extern(System) void function(GLenum stream, GLfloat x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glVertexStream1fATI glVertexStream1fATI;
    alias fn_glVertexStream1fvATI = extern(System) void function(GLenum stream, const( GLfloat*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glVertexStream1fvATI glVertexStream1fvATI;
    alias fn_glVertexStream1iATI = extern(System) void function(GLenum stream, GLint x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glVertexStream1iATI glVertexStream1iATI;
    alias fn_glVertexStream1ivATI = extern(System) void function(GLenum stream, const( GLint*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glVertexStream1ivATI glVertexStream1ivATI;
    alias fn_glVertexStream1sATI = extern(System) void function(GLenum stream, GLshort x) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glVertexStream1sATI glVertexStream1sATI;
    alias fn_glVertexStream1svATI = extern(System) void function(GLenum stream, const( GLshort*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glVertexStream1svATI glVertexStream1svATI;
    alias fn_glVertexStream2dATI = extern(System) void function(GLenum stream, GLdouble x, GLdouble y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glVertexStream2dATI glVertexStream2dATI;
    alias fn_glVertexStream2dvATI = extern(System) void function(GLenum stream, const( GLdouble*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glVertexStream2dvATI glVertexStream2dvATI;
    alias fn_glVertexStream2fATI = extern(System) void function(GLenum stream, GLfloat x, GLfloat y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glVertexStream2fATI glVertexStream2fATI;
    alias fn_glVertexStream2fvATI = extern(System) void function(GLenum stream, const( GLfloat*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glVertexStream2fvATI glVertexStream2fvATI;
    alias fn_glVertexStream2iATI = extern(System) void function(GLenum stream, GLint x, GLint y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glVertexStream2iATI glVertexStream2iATI;
    alias fn_glVertexStream2ivATI = extern(System) void function(GLenum stream, const( GLint*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glVertexStream2ivATI glVertexStream2ivATI;
    alias fn_glVertexStream2sATI = extern(System) void function(GLenum stream, GLshort x, GLshort y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glVertexStream2sATI glVertexStream2sATI;
    alias fn_glVertexStream2svATI = extern(System) void function(GLenum stream, const( GLshort*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glVertexStream2svATI glVertexStream2svATI;
    alias fn_glVertexStream3dATI = extern(System) void function(GLenum stream, GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glVertexStream3dATI glVertexStream3dATI;
    alias fn_glVertexStream3dvATI = extern(System) void function(GLenum stream, const( GLdouble*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glVertexStream3dvATI glVertexStream3dvATI;
    alias fn_glVertexStream3fATI = extern(System) void function(GLenum stream, GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glVertexStream3fATI glVertexStream3fATI;
    alias fn_glVertexStream3fvATI = extern(System) void function(GLenum stream, const( GLfloat*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glVertexStream3fvATI glVertexStream3fvATI;
    alias fn_glVertexStream3iATI = extern(System) void function(GLenum stream, GLint x, GLint y, GLint z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glVertexStream3iATI glVertexStream3iATI;
    alias fn_glVertexStream3ivATI = extern(System) void function(GLenum stream, const( GLint*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glVertexStream3ivATI glVertexStream3ivATI;
    alias fn_glVertexStream3sATI = extern(System) void function(GLenum stream, GLshort x, GLshort y, GLshort z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glVertexStream3sATI glVertexStream3sATI;
    alias fn_glVertexStream3svATI = extern(System) void function(GLenum stream, const( GLshort*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glVertexStream3svATI glVertexStream3svATI;
    alias fn_glVertexStream4dATI = extern(System) void function(GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glVertexStream4dATI glVertexStream4dATI;
    alias fn_glVertexStream4dvATI = extern(System) void function(GLenum stream, const( GLdouble*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glVertexStream4dvATI glVertexStream4dvATI;
    alias fn_glVertexStream4fATI = extern(System) void function(GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glVertexStream4fATI glVertexStream4fATI;
    alias fn_glVertexStream4fvATI = extern(System) void function(GLenum stream, const( GLfloat*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glVertexStream4fvATI glVertexStream4fvATI;
    alias fn_glVertexStream4iATI = extern(System) void function(GLenum stream, GLint x, GLint y, GLint z, GLint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glVertexStream4iATI glVertexStream4iATI;
    alias fn_glVertexStream4ivATI = extern(System) void function(GLenum stream, const( GLint*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glVertexStream4ivATI glVertexStream4ivATI;
    alias fn_glVertexStream4sATI = extern(System) void function(GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glVertexStream4sATI glVertexStream4sATI;
    alias fn_glVertexStream4svATI = extern(System) void function(GLenum stream, const( GLshort*) coords) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ATI_vertex_streams")
    fn_glVertexStream4svATI glVertexStream4svATI;
    alias fn_glVertexWeightPointerEXT = extern(System) void function(GLint size, GLenum type, GLsizei stride, const( void*) pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_weighting")
    fn_glVertexWeightPointerEXT glVertexWeightPointerEXT;
    alias fn_glVertexWeightfEXT = extern(System) void function(GLfloat weight) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_weighting")
    fn_glVertexWeightfEXT glVertexWeightfEXT;
    alias fn_glVertexWeightfvEXT = extern(System) void function(const( GLfloat*) weight) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_weighting")
    fn_glVertexWeightfvEXT glVertexWeightfvEXT;
    alias fn_glVertexWeighthNV = extern(System) void function(GLhalfNV weight) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glVertexWeighthNV glVertexWeighthNV;
    alias fn_glVertexWeighthvNV = extern(System) void function(const( GLhalfNV*) weight) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_half_float")
    fn_glVertexWeighthvNV glVertexWeighthvNV;
    alias fn_glVideoCaptureNV = extern(System) GLenum function(GLuint video_capture_slot, GLuint* sequence_num, GLuint64EXT* capture_time) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_video_capture")
    fn_glVideoCaptureNV glVideoCaptureNV;
    alias fn_glVideoCaptureStreamParameterdvNV = extern(System) void function(GLuint video_capture_slot, GLuint stream, GLenum pname, const( GLdouble*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_video_capture")
    fn_glVideoCaptureStreamParameterdvNV glVideoCaptureStreamParameterdvNV;
    alias fn_glVideoCaptureStreamParameterfvNV = extern(System) void function(GLuint video_capture_slot, GLuint stream, GLenum pname, const( GLfloat*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_video_capture")
    fn_glVideoCaptureStreamParameterfvNV glVideoCaptureStreamParameterfvNV;
    alias fn_glVideoCaptureStreamParameterivNV = extern(System) void function(GLuint video_capture_slot, GLuint stream, GLenum pname, const( GLint*) params) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_video_capture")
    fn_glVideoCaptureStreamParameterivNV glVideoCaptureStreamParameterivNV;
    alias fn_glViewportArrayvNV = extern(System) void function(GLuint first, GLsizei count, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_array")
    fn_glViewportArrayvNV glViewportArrayvNV;
    alias fn_glViewportArrayvOES = extern(System) void function(GLuint first, GLsizei count, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_viewport_array")
    fn_glViewportArrayvOES glViewportArrayvOES;
    alias fn_glViewportIndexedfOES = extern(System) void function(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_viewport_array")
    fn_glViewportIndexedfOES glViewportIndexedfOES;
    alias fn_glViewportIndexedfNV = extern(System) void function(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_array")
    fn_glViewportIndexedfNV glViewportIndexedfNV;
    alias fn_glViewportIndexedfv = extern(System) void function(GLuint index, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.V4P1)
    @OpenGL_Extension("GL_ARB_viewport_array")
    fn_glViewportIndexedfv glViewportIndexedfv;
    alias fn_glViewportIndexedfvOES = extern(System) void function(GLuint index, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_viewport_array")
    fn_glViewportIndexedfvOES glViewportIndexedfvOES;
    alias fn_glViewportIndexedfvNV = extern(System) void function(GLuint index, const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_array")
    fn_glViewportIndexedfvNV glViewportIndexedfvNV;
    alias fn_glViewportPositionWScaleNV = extern(System) void function(GLuint index, GLfloat xcoeff, GLfloat ycoeff) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_clip_space_w_scaling")
    fn_glViewportPositionWScaleNV glViewportPositionWScaleNV;
    alias fn_glViewportSwizzleNV = extern(System) void function(GLuint index, GLenum swizzlex, GLenum swizzley, GLenum swizzlez, GLenum swizzlew) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_viewport_swizzle")
    fn_glViewportSwizzleNV glViewportSwizzleNV;
    alias fn_glWaitSyncAPPLE = extern(System) void function(GLsync sync, GLbitfield flags, GLuint64 timeout) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_APPLE_sync")
    fn_glWaitSyncAPPLE glWaitSyncAPPLE;
    alias fn_glWeightPathsNV = extern(System) void function(GLuint resultPath, GLsizei numPaths, const( GLuint*) paths, const( GLfloat*) weights) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_NV_path_rendering")
    fn_glWeightPathsNV glWeightPathsNV;
    alias fn_glWeightPointerARB = extern(System) void function(GLint size, GLenum type, GLsizei stride, const( void*) pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_blend")
    fn_glWeightPointerARB glWeightPointerARB;
    alias fn_glWeightPointerOES = extern(System) void function(GLint size, GLenum type, GLsizei stride, const( void*) pointer) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_OES_matrix_palette")
    fn_glWeightPointerOES glWeightPointerOES;
    alias fn_glWeightbvARB = extern(System) void function(GLint size, const( GLbyte*) weights) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_blend")
    fn_glWeightbvARB glWeightbvARB;
    alias fn_glWeightdvARB = extern(System) void function(GLint size, const( GLdouble*) weights) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_blend")
    fn_glWeightdvARB glWeightdvARB;
    alias fn_glWeightfvARB = extern(System) void function(GLint size, const( GLfloat*) weights) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_blend")
    fn_glWeightfvARB glWeightfvARB;
    alias fn_glWeightivARB = extern(System) void function(GLint size, const( GLint*) weights) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_blend")
    fn_glWeightivARB glWeightivARB;
    alias fn_glWeightsvARB = extern(System) void function(GLint size, const( GLshort*) weights) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_blend")
    fn_glWeightsvARB glWeightsvARB;
    alias fn_glWeightubvARB = extern(System) void function(GLint size, const(GLubyte)* weights) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_blend")
    fn_glWeightubvARB glWeightubvARB;
    alias fn_glWeightuivARB = extern(System) void function(GLint size, const( GLuint*) weights) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_blend")
    fn_glWeightuivARB glWeightuivARB;
    alias fn_glWeightusvARB = extern(System) void function(GLint size, const( GLushort*) weights) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_vertex_blend")
    fn_glWeightusvARB glWeightusvARB;
    alias fn_glWindowPos2dARB = extern(System) void function(GLdouble x, GLdouble y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    fn_glWindowPos2dARB glWindowPos2dARB;
    alias fn_glWindowPos2dMESA = extern(System) void function(GLdouble x, GLdouble y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    fn_glWindowPos2dMESA glWindowPos2dMESA;
    alias fn_glWindowPos2dvARB = extern(System) void function(const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    fn_glWindowPos2dvARB glWindowPos2dvARB;
    alias fn_glWindowPos2dvMESA = extern(System) void function(const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    fn_glWindowPos2dvMESA glWindowPos2dvMESA;
    alias fn_glWindowPos2fARB = extern(System) void function(GLfloat x, GLfloat y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    fn_glWindowPos2fARB glWindowPos2fARB;
    alias fn_glWindowPos2fMESA = extern(System) void function(GLfloat x, GLfloat y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    fn_glWindowPos2fMESA glWindowPos2fMESA;
    alias fn_glWindowPos2fvARB = extern(System) void function(const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    fn_glWindowPos2fvARB glWindowPos2fvARB;
    alias fn_glWindowPos2fvMESA = extern(System) void function(const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    fn_glWindowPos2fvMESA glWindowPos2fvMESA;
    alias fn_glWindowPos2iARB = extern(System) void function(GLint x, GLint y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    fn_glWindowPos2iARB glWindowPos2iARB;
    alias fn_glWindowPos2iMESA = extern(System) void function(GLint x, GLint y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    fn_glWindowPos2iMESA glWindowPos2iMESA;
    alias fn_glWindowPos2ivARB = extern(System) void function(const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    fn_glWindowPos2ivARB glWindowPos2ivARB;
    alias fn_glWindowPos2ivMESA = extern(System) void function(const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    fn_glWindowPos2ivMESA glWindowPos2ivMESA;
    alias fn_glWindowPos2sARB = extern(System) void function(GLshort x, GLshort y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    fn_glWindowPos2sARB glWindowPos2sARB;
    alias fn_glWindowPos2sMESA = extern(System) void function(GLshort x, GLshort y) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    fn_glWindowPos2sMESA glWindowPos2sMESA;
    alias fn_glWindowPos2svARB = extern(System) void function(const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    fn_glWindowPos2svARB glWindowPos2svARB;
    alias fn_glWindowPos2svMESA = extern(System) void function(const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    fn_glWindowPos2svMESA glWindowPos2svMESA;
    alias fn_glWindowPos3dARB = extern(System) void function(GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    fn_glWindowPos3dARB glWindowPos3dARB;
    alias fn_glWindowPos3dMESA = extern(System) void function(GLdouble x, GLdouble y, GLdouble z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    fn_glWindowPos3dMESA glWindowPos3dMESA;
    alias fn_glWindowPos3dvARB = extern(System) void function(const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    fn_glWindowPos3dvARB glWindowPos3dvARB;
    alias fn_glWindowPos3dvMESA = extern(System) void function(const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    fn_glWindowPos3dvMESA glWindowPos3dvMESA;
    alias fn_glWindowPos3fARB = extern(System) void function(GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    fn_glWindowPos3fARB glWindowPos3fARB;
    alias fn_glWindowPos3fMESA = extern(System) void function(GLfloat x, GLfloat y, GLfloat z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    fn_glWindowPos3fMESA glWindowPos3fMESA;
    alias fn_glWindowPos3fvARB = extern(System) void function(const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    fn_glWindowPos3fvARB glWindowPos3fvARB;
    alias fn_glWindowPos3fvMESA = extern(System) void function(const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    fn_glWindowPos3fvMESA glWindowPos3fvMESA;
    alias fn_glWindowPos3iARB = extern(System) void function(GLint x, GLint y, GLint z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    fn_glWindowPos3iARB glWindowPos3iARB;
    alias fn_glWindowPos3iMESA = extern(System) void function(GLint x, GLint y, GLint z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    fn_glWindowPos3iMESA glWindowPos3iMESA;
    alias fn_glWindowPos3ivARB = extern(System) void function(const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    fn_glWindowPos3ivARB glWindowPos3ivARB;
    alias fn_glWindowPos3ivMESA = extern(System) void function(const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    fn_glWindowPos3ivMESA glWindowPos3ivMESA;
    alias fn_glWindowPos3sARB = extern(System) void function(GLshort x, GLshort y, GLshort z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    fn_glWindowPos3sARB glWindowPos3sARB;
    alias fn_glWindowPos3sMESA = extern(System) void function(GLshort x, GLshort y, GLshort z) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    fn_glWindowPos3sMESA glWindowPos3sMESA;
    alias fn_glWindowPos3svARB = extern(System) void function(const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_ARB_window_pos")
    fn_glWindowPos3svARB glWindowPos3svARB;
    alias fn_glWindowPos3svMESA = extern(System) void function(const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    fn_glWindowPos3svMESA glWindowPos3svMESA;
    alias fn_glWindowPos4dMESA = extern(System) void function(GLdouble x, GLdouble y, GLdouble z, GLdouble w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    fn_glWindowPos4dMESA glWindowPos4dMESA;
    alias fn_glWindowPos4dvMESA = extern(System) void function(const( GLdouble*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    fn_glWindowPos4dvMESA glWindowPos4dvMESA;
    alias fn_glWindowPos4fMESA = extern(System) void function(GLfloat x, GLfloat y, GLfloat z, GLfloat w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    fn_glWindowPos4fMESA glWindowPos4fMESA;
    alias fn_glWindowPos4fvMESA = extern(System) void function(const( GLfloat*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    fn_glWindowPos4fvMESA glWindowPos4fvMESA;
    alias fn_glWindowPos4iMESA = extern(System) void function(GLint x, GLint y, GLint z, GLint w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    fn_glWindowPos4iMESA glWindowPos4iMESA;
    alias fn_glWindowPos4ivMESA = extern(System) void function(const( GLint*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    fn_glWindowPos4ivMESA glWindowPos4ivMESA;
    alias fn_glWindowPos4sMESA = extern(System) void function(GLshort x, GLshort y, GLshort z, GLshort w) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    fn_glWindowPos4sMESA glWindowPos4sMESA;
    alias fn_glWindowPos4svMESA = extern(System) void function(const( GLshort*) v) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_MESA_window_pos")
    fn_glWindowPos4svMESA glWindowPos4svMESA;
    alias fn_glWindowRectanglesEXT = extern(System) void function(GLenum mode, GLsizei count, const( GLint*) box) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_window_rectangles")
    fn_glWindowRectanglesEXT glWindowRectanglesEXT;
    alias fn_glWriteMaskEXT = extern(System) void function(GLuint res, GLuint in_, GLenum outX, GLenum outY, GLenum outZ, GLenum outW) @system @nogc nothrow;
    /// Ditto
    @OpenGL_Version(OGLIntroducedIn.Unknown)
    @OpenGL_Extension("GL_EXT_vertex_shader")
    fn_glWriteMaskEXT glWriteMaskEXT;
}
